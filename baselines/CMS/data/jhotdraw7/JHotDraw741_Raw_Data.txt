58, close, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 177, 208
6
/**
  * Skips remaining data and closes the stream.
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
28
   public void close()
    throws IOException
   {
    try {
     int bufferLength = this.buffer.length();
     for (;;) {
      String str = "";
      char ch;
      if (this.bufferIndex >= bufferLength) {
         str = XMLUtil.read(this.reader, '&');
         ch = str.charAt(0);
      } else {
         ch = this.buffer.charAt(this.bufferIndex);
         this.bufferIndex++;
         continue; // don't interprete chars in the buffer
      }
      if (ch == '<') {
         this.reader.unread(ch);
         break;
      }
      if ((ch == '&') && (str.length() > 1)) {
         if (str.charAt(1) != '#') {
          XMLUtil.processEntity(str, this.reader, this.resolver);
         }
      }
     }
    } catch (XMLParseException e) {
     throw new IOException(e.getMessage());
###
59, ContentReader, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 78, 85
7
/**
  * Creates the reader.
  *
  * @param reader the encapsulated reader
  * @param resolver the entity resolver
  * @param buffer data that has already been read from <code>reader</code>
  */
8
   ContentReader(IXMLReader     reader,
         IXMLEntityResolver resolver,
         String       buffer)
   {
    this.reader = reader;
    this.resolver = resolver;
    this.buffer = buffer;
    this.bufferIndex = 0;
###
60, read, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 114, 166
12
/**
  * Reads a block of data.
  *
  * @param outputBuffer where to put the read data
  * @param offset first position in buffer to put the data
  * @param size maximum number of chars to read
  *
  * @return the number of chars read, or -1 if at EOF
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
45
   public int read(char[] outputBuffer,
           int  offset,
           int  size)
    throws IOException
   {
    try {
     int charsRead = 0;
     int bufferLength = this.buffer.length();
     if ((offset + size) > outputBuffer.length) {
      size = outputBuffer.length - offset;
     }
     while (charsRead < size) {
      String str = "";
      char ch;
      if (this.bufferIndex >= bufferLength) {
         str = XMLUtil.read(this.reader, '&');
         ch = str.charAt(0);
      } else {
         ch = this.buffer.charAt(this.bufferIndex);
         this.bufferIndex++;
         outputBuffer[charsRead] = ch;
         charsRead++;
         continue; // don't interprete chars in the buffer
      }
      if (ch == '<') {
         this.reader.unread(ch);
         break;
      }
      if ((ch == '&') && (str.length() > 1)) {
         if (str.charAt(1) == '#') {
          ch = XMLUtil.processCharLiteral(str);
         } else {
          XMLUtil.processEntity(str, this.reader, this.resolver);
          continue;
         }
      }
      outputBuffer[charsRead] = ch;
      charsRead++;
     }
     if (charsRead == 0) {
      charsRead = -1;
     }
     return charsRead;
    } catch (XMLParseException e) {
     throw new IOException(e.getMessage());
###
61, finalize, ContentReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java, 92, 98
3
/**
  * Cleans up the object when it's destroyed.
  */
7
   protected void finalize()
    throws Throwable
   {
    this.reader = null;
    this.resolver = null;
    this.buffer = null;
    super.finalize();
###
62, finalize, PIReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java, 74, 78
3
/**
  * Cleans up the object when it's destroyed.
  */
5
   protected void finalize()
    throws Throwable
   {
    this.reader = null;
    super.finalize();
###
63, read, PIReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java, 94, 131
12
/**
  * Reads a block of data.
  *
  * @param buffer where to put the read data
  * @param offset first position in buffer to put the data
  * @param size maximum number of chars to read
  *
  * @return the number of chars read, or -1 if at EOF
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
29
   public int read(char[] buffer,
           int  offset,
           int  size)
    throws IOException
   {
    if (this.atEndOfData) {
     return -1;
    }
    int charsRead = 0;
    if ((offset + size) > buffer.length) {
     size = buffer.length - offset;
    }
    while (charsRead < size) {
     char ch = this.reader.read();
     if (ch == '?') {
      char ch2 = this.reader.read();
      if (ch2 == '>') {
         this.atEndOfData = true;
         break;
      }
      this.reader.unread(ch2);
     }
     buffer[charsRead] = ch;
     charsRead++;
    }
    if (charsRead == 0) {
     charsRead = -1;
    }
    return charsRead;
###
64, PIReader, PIReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java, 64, 67
5
/**
  * Creates the reader.
  *
  * @param reader the encapsulated reader
  */
4
   PIReader(IXMLReader reader)
   {
    this.reader = reader;
    this.atEndOfData = false;
###
77, getParameterEntityResolver, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 115, 117
5
/**
  * Returns the parameter entity resolver.
  *
  * @return the entity resolver.
  */
3
   public IXMLEntityResolver getParameterEntityResolver()
   {
    return this.parameterEntityResolver;
###
78, attributeAdded, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 608, 616
8
/**
  * Indicates that an attribute has been added to the current element.
  *
  * @param key    the name of the attribute.
  * @param value    the value of the attribute.
  * @param systemId   the system ID of the XML data of the element.
  * @param lineNr   the line number in the XML data of the element.
  */
8
   public void attributeAdded(String key,
                String value,
                String systemId,
                int  lineNr)
   {
    Properties props = (Properties) this.currentElements.peek();
    if (props.containsKey(key)) {
     props.remove(key);
###
79, processElement, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 184, 217
9
/**
  * Processes an element in the DTD.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
27
   protected void processElement(IXMLReader     reader,
                 IXMLEntityResolver entityResolver)
    throws Exception
   {
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    if (ch != '!') {
     XMLUtil.skipTag(reader);
     return;
    }
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    switch (ch) {
     case '-':
      XMLUtil.skipComment(reader);
      break;
     case '[':
      this.processConditionalSection(reader, entityResolver);
      break;
     case 'E':
      this.processEntity(reader, entityResolver);
      break;
     case 'A':
      this.processAttList(reader, entityResolver);
      break;
     default:
      XMLUtil.skipTag(reader);
###
80, NonValidator, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 76, 80
3
/**
  * Creates the &quot;validator&quot;.
  */
5
   public NonValidator()
   {
    this.attributeDefaultValues = new Hashtable();
    this.currentElements = new Stack();
    this.parameterEntityResolver = new XMLEntityResolver();
###
81, processEntity, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 460, 530
9
/**
  * Processes an ENTITY element.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
61
   protected void processEntity(IXMLReader     reader,
                IXMLEntityResolver entityResolver)
    throws Exception
   {
    if (! XMLUtil.checkLiteral(reader, "NTITY")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    char ch = XMLUtil.readChar(reader, '\0');
    if (ch == '%') {
     XMLUtil.skipWhitespace(reader, null);
     entityResolver = this.parameterEntityResolver;
    } else {
     reader.unread(ch);
    }
    String key = XMLUtil.scanIdentifier(reader);
    XMLUtil.skipWhitespace(reader, null);
    ch = XMLUtil.readChar(reader, '%');
    String systemID = null;
    String publicID = null;
    switch (ch) {
     case 'P':
      if (! XMLUtil.checkLiteral(reader, "UBLIC")) {
         XMLUtil.skipTag(reader);
         return;
      }
      XMLUtil.skipWhitespace(reader, null);
      publicID = XMLUtil.scanString(reader, '%',
                      this.parameterEntityResolver);
      XMLUtil.skipWhitespace(reader, null);
      systemID = XMLUtil.scanString(reader, '%',
                      this.parameterEntityResolver);
      XMLUtil.skipWhitespace(reader, null);
      XMLUtil.readChar(reader, '%');
      break;
     case 'S':
      if (! XMLUtil.checkLiteral(reader, "YSTEM")) {
         XMLUtil.skipTag(reader);
         return;
      }
      XMLUtil.skipWhitespace(reader, null);
      systemID = XMLUtil.scanString(reader, '%',
                      this.parameterEntityResolver);
      XMLUtil.skipWhitespace(reader, null);
      XMLUtil.readChar(reader, '%');
      break;
     case '"':
     case '\'':
      reader.unread(ch);
      String value = XMLUtil.scanString(reader, '%',
                        this.parameterEntityResolver);
      entityResolver.addInternalEntity(key, value);
      XMLUtil.skipWhitespace(reader, null);
      XMLUtil.readChar(reader, '%');
      break;
     default:
      XMLUtil.skipTag(reader);
    }
    if (systemID != null) {
     entityResolver.addExternalEntity(key, publicID, systemID);
###
83, parseDTD, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 133, 170
12
/**
  * Parses the DTD. The validator object is responsible for reading the
  * full DTD.
  *
  * @param publicID     the public ID, which may be null.
  * @param reader     the reader to read the DTD from.
  * @param entityResolver the entity resolver.
  * @param external     true if the DTD is external.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
33
   public void parseDTD(String       publicID,
            IXMLReader     reader,
            IXMLEntityResolver entityResolver,
            boolean      external)
    throws Exception
   {
    XMLUtil.skipWhitespace(reader, null);
    int origLevel = reader.getStreamLevel();
    for (;;) {
     String str = XMLUtil.read(reader, '%');
     char ch = str.charAt(0);
     if (ch == '%') {
      XMLUtil.processEntity(str, reader,
                  this.parameterEntityResolver);
      continue;
     } else if (ch == '<') {
      this.processElement(reader, entityResolver);
     } else if (ch == ']') {
      return; // end internal DTD
     } else {
      XMLUtil.errorInvalidInput(reader.getSystemID(),
                    reader.getLineNr(),
                    str);
     }
     do {
      ch = reader.read();
      if (external && (reader.getStreamLevel() < origLevel)) {
         reader.unread(ch);
         return; // end external DTD
      }
     } while ((ch == ' ') || (ch == '\t') || (ch == '\n')
          || (ch == '\r'));
     reader.unread(ch);
###
84, elementStarted, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 542, 555
7
/**
  * Indicates that an element has been started.
  *
  * @param name     the name of the element.
  * @param systemId   the system ID of the XML data of the element.
  * @param lineNr   the line number in the XML data of the element.
  */
12
   public void elementStarted(String name,
                String systemId,
                int  lineNr)
   {
    Properties attribs
     = (Properties) this.attributeDefaultValues.get(name);
    if (attribs == null) {
     attribs = new Properties();
    } else {
     attribs = (Properties) attribs.clone();
    }
    this.currentElements.push(attribs);
###
85, elementAttributesProcessed, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 585, 595
14
/**
  * This method is called when the attributes of an XML element have been
  * processed.
  * If there are attributes with a default value which have not been
  * specified yet, they have to be put into <I>extraAttributes</I>.
  *
  * @param name      the name of the element.
  * @param extraAttributes where to put extra attributes.
  * @param systemId    the system ID of the XML data of the element.
  * @param lineNr      the line number in the XML data of the element.
  */
 --------------
// nothing to do
 --------------
10
   public void elementAttributesProcessed(String   name,
                      Properties extraAttributes,
                      String   systemId,
                      int    lineNr)
   {
    Properties props = (Properties) this.currentElements.pop();
    Enumeration enm = props.keys();
    while (enm.hasMoreElements()) {
     String key = (String) enm.nextElement();
     extraAttributes.put(key, props.get(key));
###
86, processIgnoreSection, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 303, 323
9
/**
  * Processes an ignore section.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
17
   protected void processIgnoreSection(IXMLReader     reader,
                     IXMLEntityResolver entityResolver)
    throws Exception
   {
    if (! XMLUtil.checkLiteral(reader, "NORE")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    if (ch != '[') {
     XMLUtil.skipTag(reader);
     return;
    }
    Reader subreader = new CDATAReader(reader);
    subreader.close();
###
87, processConditionalSection, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 231, 290
9
/**
  * Processes a conditional section.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
45
   protected void processConditionalSection(IXMLReader     reader,
                      IXMLEntityResolver entityResolver)
    throws Exception
   {
    XMLUtil.skipWhitespace(reader, null);
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    if (ch != 'I') {
     XMLUtil.skipTag(reader);
     return;
    }
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    switch (ch) {
     case 'G':
      this.processIgnoreSection(reader, entityResolver);
      return;
     case 'N':
      break;
     default:
      XMLUtil.skipTag(reader);
      return;
    }
    if (! XMLUtil.checkLiteral(reader, "CLUDE")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    if (ch != '[') {
     XMLUtil.skipTag(reader);
     return;
    }
    Reader subreader = new CDATAReader(reader);
    StringBuffer buf = new StringBuffer(1024);
    for (;;) {
     int ch2 = subreader.read();
     if (ch2 < 0) {
      break;
     }
     buf.append((char) ch2);
    }
    subreader.close();
    reader.startNewStream(new StringReader(buf.toString()));
###
88, setParameterEntityResolver, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 104, 106
5
/**
  * Sets the parameter entity resolver.
  *
  * @param resolver the entity resolver.
  */
3
   public void setParameterEntityResolver(IXMLEntityResolver resolver)
   {
    this.parameterEntityResolver = resolver;
###
89, processAttList, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 336, 446
9
/**
  * Processes an ATTLIST element.
  *
  * @param reader     the reader to read data from.
  * @param entityResolver the entity resolver.
  *
  * @throws java.lang.Exception
  *   If something went wrong.
  */
100
   protected void processAttList(IXMLReader     reader,
                 IXMLEntityResolver entityResolver)
    throws Exception
   {
    if (! XMLUtil.checkLiteral(reader,  "TTLIST")) {
     XMLUtil.skipTag(reader);
     return;
    }
    XMLUtil.skipWhitespace(reader, null);
    String str = XMLUtil.read(reader, '%');
    char ch = str.charAt(0);
    while (ch == '%') {
     XMLUtil.processEntity(str, reader,
                 this.parameterEntityResolver);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
    }
    reader.unread(ch);
    String elementName = XMLUtil.scanIdentifier(reader);
    XMLUtil.skipWhitespace(reader, null);
    
    str = XMLUtil.read(reader, '%');
    ch = str.charAt(0);
    while (ch == '%') {
     XMLUtil.processEntity(str, reader,
                 this.parameterEntityResolver);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
    }
    Properties props = new Properties();
    while (ch != '>') {
     reader.unread(ch);
     String attName = XMLUtil.scanIdentifier(reader);
     XMLUtil.skipWhitespace(reader, null);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
     while (ch == '%') {
       XMLUtil.processEntity(str, reader,
                   this.parameterEntityResolver);
       str = XMLUtil.read(reader, '%');
       ch = str.charAt(0);
     }
     if (ch == '(') {
       while (ch != ')') {
         str = XMLUtil.read(reader, '%');
         ch = str.charAt(0);
         while (ch == '%') {
           XMLUtil.processEntity(str, reader,
                       this.parameterEntityResolver);
           str = XMLUtil.read(reader, '%');
           ch = str.charAt(0);
         }
       }
     } else {
      reader.unread(ch);
      XMLUtil.scanIdentifier(reader);
     }
     XMLUtil.skipWhitespace(reader, null);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
     while (ch == '%') {
       XMLUtil.processEntity(str, reader,
                   this.parameterEntityResolver);
       str = XMLUtil.read(reader, '%');
       ch = str.charAt(0);
     }
     
     if (ch == '#') {
      str = XMLUtil.scanIdentifier(reader);
      XMLUtil.skipWhitespace(reader, null);
      if (! str.equals("FIXED")) {
         XMLUtil.skipWhitespace(reader, null);
         str = XMLUtil.read(reader, '%');
         ch = str.charAt(0);
         while (ch == '%') {
          XMLUtil.processEntity(str, reader,
                    this.parameterEntityResolver);
          str = XMLUtil.read(reader, '%');
          ch = str.charAt(0);
         }
         continue;
      }
     } else {
      reader.unread(ch);
     }
     String value = XMLUtil.scanString(reader, '%',
                       this.parameterEntityResolver);
     props.put(attName, value);
     XMLUtil.skipWhitespace(reader, null);
     str = XMLUtil.read(reader, '%');
     ch = str.charAt(0);
     while (ch == '%') {
      XMLUtil.processEntity(str, reader,
                  this.parameterEntityResolver);
      str = XMLUtil.read(reader, '%');
      ch = str.charAt(0);
     }
    }
    if (! props.isEmpty()) {
     this.attributeDefaultValues.put(elementName, props);
###
90, finalize, NonValidator, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java, 87, 95
3
/**
  * Cleans up the object when it's destroyed.
  */
9
   protected void finalize()
    throws Throwable
   {
    this.parameterEntityResolver = null;
    this.attributeDefaultValues.clear();
    this.attributeDefaultValues = null;
    this.currentElements.clear();
    this.currentElements = null;
    super.finalize();
###
149, CDATAReader, CDATAReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java, 70, 74
5
/**
  * Creates the reader.
  *
  * @param reader the encapsulated reader
  */
5
   CDATAReader(IXMLReader reader)
   {
    this.reader = reader;
    this.savedChar = 0;
    this.atEndOfData = false;
###
150, finalize, CDATAReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java, 81, 85
3
/**
  * Cleans up the object when it's destroyed.
  */
5
   protected void finalize()
    throws Throwable
   {
    this.reader = null;
    super.finalize();
###
151, read, CDATAReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java, 101, 150
12
/**
  * Reads a block of data.
  *
  * @param buffer where to put the read data
  * @param offset first position in buffer to put the data
  * @param size maximum number of chars to read
  *
  * @return the number of chars read, or -1 if at EOF
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
41
   public int read(char[] buffer,
           int  offset,
           int  size)
    throws IOException
   {
    int charsRead = 0;
    if (this.atEndOfData) {
     return -1;
    }
    if ((offset + size) > buffer.length) {
     size = buffer.length - offset;
    }
    while (charsRead < size) {
     char ch = this.savedChar;
     if (ch == 0) {
      ch = this.reader.read();
     } else {
      this.savedChar = 0;
     }
     if (ch == ']') {
      char ch2 = this.reader.read();
      
      if (ch2 == ']') {
         char ch3 = this.reader.read();
         if (ch3 == '>') {
          this.atEndOfData = true;
          break;
         }
         this.savedChar = ch2;
         this.reader.unread(ch3);
      } else {
         this.reader.unread(ch2);
      }
     }
     buffer[charsRead] = ch;
     charsRead++;
    }
    if (charsRead == 0) {
     charsRead = -1;
    }
    return charsRead;
###
215, getElementName, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 165, 167
4
/**
  * Returns the name of the element in which the validation is violated.
  * If there is no current element, null is returned.
  */
3
   public String getElementName()
   {
    return this.elementName;
###
216, getAttributeName, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 175, 177
4
/**
  * Returns the name of the attribute in which the validation is violated.
  * If there is no current attribute, null is returned.
  */
3
   public String getAttributeName()
   {
    return this.attributeName;
###
217, XMLValidationException, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 127, 144
12
/**
  * Creates a new exception.
  *
  * @param errorType    the type of validity error
  * @param systemID     the system ID from where the data came
  * @param lineNr     the line number in the XML data where the
  *             exception occurred.
  * @param elementName  the name of the offending element
  * @param attributeName  the name of the offending attribute
  * @param attributeValue the value of the offending attribute
  * @param msg      the message of the exception.
  */
18
   public XMLValidationException(int  errorType,
                 String systemID,
                 int  lineNr,
                 String elementName,
                 String attributeName,
                 String attributeValue,
                 String msg)
   {
    super(systemID, lineNr, null,
      msg + ((elementName == null) ? "" : (", element=" + elementName))
      + ((attributeName == null) ? ""
                     : (", attribute=" + attributeName))
      + ((attributeValue == null) ? ""
                     : (", value='" + attributeValue + "'")),
      false);
    this.elementName = elementName;
    this.attributeName = attributeName;
    this.attributeValue = attributeValue;
###
218, finalize, XMLValidationException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java, 151, 157
3
/**
  * Cleans up the object when it's destroyed.
  */
7
   protected void finalize()
    throws Throwable
   {
    this.elementName = null;
    this.attributeName = null;
    this.attributeValue = null;
    super.finalize();
###
219, errorClosingTagNotEmpty, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 552, 557
7
/**
  * Throws an XMLParseException to indicate that extra data is encountered
  * in a closing tag.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  */
6
   static void errorClosingTagNotEmpty(String systemID,
                     int  lineNr)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Closing tag must be empty");
###
221, errorUnexpectedPCData, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 722, 733
8
/**
  * Throws an XMLValidationException to indicate that a #PCDATA element was
  * unexpected.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  */
12
   static void errorUnexpectedPCData(String systemID,
                   int  lineNr,
                   String parentElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
            XMLValidationException.UNEXPECTED_PCDATA,
            systemID, lineNr,
            /*elementName*/ null,
            /*attributeName*/ null,
            /*attributeValue*/ null,
            "Unexpected #PCDATA in element " + parentElementName);
###
223, errorUnexpectedCDATA, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 496, 501
7
/**
  * Throws an XMLParseException to indicate that a CDATA section is
  * unexpected at this point.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  */
6
   static void errorUnexpectedCDATA(String systemID,
                  int  lineNr)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "No CDATA section is expected here");
###
225, errorInvalidAttributeValue, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 674, 687
10
/**
  * Throws an XMLValidationException to indicate that an attribute has an
  * invalid value.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param elementName  the name of the element
  * @param attributeName  the name of the attribute
  * @param attributeValue the value of that attribute
  */
14
   static void errorInvalidAttributeValue(String systemID,
                      int  lineNr,
                      String elementName,
                      String attributeName,
                      String attributeValue)
    throws XMLValidationException
   {
    throw new XMLValidationException(
               XMLValidationException.ATTRIBUTE_WITH_INVALID_VALUE,
               systemID, lineNr,
               elementName,
               attributeName,
               attributeValue,
               "Invalid value for attribute " + attributeName);
###
227, errorUnexpectedAttribute, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 647, 660
9
/**
  * Throws an XMLValidationException to indicate that an attribute is
  * unexpected.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param elementName  the name of the element
  * @param attributeName  the name of the unexpected attribute
  */
14
   static void errorUnexpectedAttribute(String systemID,
                    int  lineNr,
                    String elementName,
                    String attributeName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
           XMLValidationException.UNEXPECTED_ATTRIBUTE,
           systemID, lineNr,
           elementName,
           attributeName,
           /*attributeValue*/ null,
           "Element " + elementName + " did not expect an attribute "
           + "named " + attributeName);
###
230, scanPublicID, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 128, 140
11
/**
  * Scans a public ID.
  *
  * @param publicID     will contain the public ID
  * @param reader     the reader
  *
  * @return the system ID
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
12
   static String scanPublicID(StringBuffer publicID,
                IXMLReader   reader)
    throws IOException,
       XMLParseException
   {
    if (! XMLUtil.checkLiteral(reader, "UBLIC")) {
     return null;
    }
    XMLUtil.skipWhitespace(reader, null);
    publicID.append(XMLUtil.scanString(reader, '\0', null));
    XMLUtil.skipWhitespace(reader, null);
    return XMLUtil.scanString(reader, '\0', null);
###
231, errorWrongClosingTag, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 532, 541
9
/**
  * Throws an XMLParseException to indicate that the closing tag of an
  * element does not match the opening tag.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param expectedName the name of the opening tag
  * @param wrongName  the name of the closing tag
  */
10
   static void errorWrongClosingTag(String systemID,
                  int  lineNr,
                  String   expectedName,
                  String   wrongName)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Closing tag does not match opening tag: `"
                  + wrongName + "' != `" + expectedName
                  + "'");
###
232, readChar, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 391, 405
7
/**
  * Reads a character from the reader disallowing entities.
  *
  * @param reader     the reader
  * @param entityChar   the escape character (&amp; or %) used to indicate
  *             an entity
  */
13
   static char readChar(IXMLReader reader,
            char     entityChar)
    throws IOException,
       XMLParseException
   {
    String str = XMLUtil.read(reader, entityChar);
    char ch = str.charAt(0);
    if (ch == entityChar) {
     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),
                     reader.getLineNr(),
                     str);
    }
    return ch;
###
233, updateApplicationEnabled, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 91, 94
4
/**
   * Updates the enabled state of this action depending on the new enabled
   * state of the application.
   */
4
  protected void updateApplicationEnabled() {
    firePropertyChange("enabled",
        Boolean.valueOf(!isEnabled()),
        Boolean.valueOf(isEnabled()));
###
234, checkLiteral, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 419, 430
10
/**
  * Returns true if the data starts with <I>literal</I>.
  * Enough chars are read to determine this result.
  *
  * @param reader     the reader
  * @param literal    the literal to check
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
11
   static boolean checkLiteral(IXMLReader     reader,
                 String       literal)
    throws IOException,
       XMLParseException
   {
    for (int i = 0; i < literal.length(); i++) {
     if (reader.read() != literal.charAt(i)) {
      return false;
     }
    }
    return true;
###
235, isEnabled, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 105, 107
8
/**
   * Returns true if the action is enabled.
   * The enabled state of the action depends on the state that has been set
   * using setEnabled() and on the enabled state of the application.
   *
   * @return true if the action is enabled, false otherwise
   * @see Action#isEnabled
   */
3
  @Override
  public boolean isEnabled() {
    return app != null && app.isEnabled() && enabled;
###
236, installApplicationListeners, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 58, 62
3
/*
   * Installs listeners on the application object.
   */
5
  protected void installApplicationListeners(Application app) {
    if (applicationListener == null) {
      applicationListener = createApplicationListener();
    }
    app.addPropertyChangeListener(new WeakPropertyChangeListener(applicationListener));
###
237, scanString, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 209, 256
10
/**
  * Retrieves a delimited string from the data.
  *
  * @param reader        the reader
  * @param entityChar      the escape character (&amp; or %)
  * @param entityResolver    the entity resolver
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
44
   static String scanString(IXMLReader     reader,
              char         entityChar,
              IXMLEntityResolver entityResolver)
    throws IOException,
       XMLParseException
   {
    StringBuffer result = new StringBuffer();
    int startingLevel = reader.getStreamLevel();
    char delim = reader.read();
    if ((delim != '\'') && (delim != '"')) {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "delimited string");
    }
    for (;;) {
     String str = XMLUtil.read(reader, entityChar);
     char ch = str.charAt(0);
     if (ch == entityChar) {
      if (str.charAt(1) == '#') {
         result.append(XMLUtil.processCharLiteral(str));
      } else {
         XMLUtil.processEntity(str, reader, entityResolver);
      }
     } else if (ch == '&') {
      reader.unread(ch);
      str = XMLUtil.read(reader, '&');
      if (str.charAt(1) == '#') {
         result.append(XMLUtil.processCharLiteral(str));
      } else {
         result.append(str);
      }
     } else if (reader.getStreamLevel() == startingLevel) {
      if (ch == delim) {
         break;
      } else if ((ch == 9) || (ch == 10) || (ch == 13)) {
         result.append(' ');
      } else {
         result.append(ch);
      }
     } else {
      result.append(ch);
     }
    }
    return result.toString();
###
238, uninstallApplicationListeners, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 68, 69
3
/**
   * Installs listeners on the application object.
   */
2
  protected void uninstallApplicationListeners(Application app) {
    app.removePropertyChangeListener(applicationListener);
###
239, AbstractApplicationAction, AbstractApplicationAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java, 49, 52
1
/** Creates a new instance. */
4
  public AbstractApplicationAction(Application app) {
    this.app = app;
    installApplicationListeners(app);
    updateApplicationEnabled();
###
240, errorMissingAttribute, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 621, 634
9
/**
  * Throws an XMLValidationException to indicate that an attribute is
  * missing.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param elementName  the name of the element
  * @param attributeName  the name of the missing attribute
  */
14
   static void errorMissingAttribute(String systemID,
                   int  lineNr,
                   String elementName,
                   String attributeName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
           XMLValidationException.MISSING_ATTRIBUTE,
           systemID, lineNr,
           elementName,
           attributeName,
           /*attributeValue*/ null,
           "Element " + elementName + " expects an attribute named "
           + attributeName);
###
241, scanSystemID, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 154, 163
10
/**
  * Scans a system ID.
  *
  * @param reader     the reader
  *
  * @return the system ID
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
9
   static String scanSystemID(IXMLReader reader)
    throws IOException,
      XMLParseException
   {
    if (! XMLUtil.checkLiteral(reader, "YSTEM")) {
     return null;
    }
    XMLUtil.skipWhitespace(reader, null);
    return XMLUtil.scanString(reader, '\0', null);
###
242, skipComment, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 55, 81
9
/**
  * Skips the remainder of a comment.
  * It is assumed that &lt;!- is already read.
  *
  * @param reader the reader
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
23
   static void skipComment(IXMLReader reader)
    throws IOException,
       XMLParseException
   {
    if (reader.read() != '-') {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "<!--");
    }
    
    int dashesRead = 0;
    for (;;) {
     char ch = reader.read();
     switch (ch) {
      case '-':
         dashesRead++;
         break;
      case '>':
         if (dashesRead == 2) {
          return;
         }
      default:
         dashesRead = 0;
###
243, read, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 364, 380
12
/**
  * Reads a character from the reader.
  *
  * @param reader     the reader
  * @param entityChar   the escape character (&amp; or %) used to indicate
  *             an entity
  *
  * @return the character, or an entity expression (like e.g. &amp;lt;)
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
15
   static String read(IXMLReader     reader,
            char         entityChar)
    throws IOException,
       XMLParseException
   {
    char ch = reader.read();
    StringBuffer buf = new StringBuffer();
    buf.append(ch);
    if (ch == entityChar) {
     while (ch != ';') {
      ch = reader.read();
      buf.append(ch);
     }
    }
    return buf.toString();
###
244, errorInvalidEntity, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 460, 466
8
/**
  * Throws an XMLParseException to indicate that an entity could not be
  * resolved.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param entity  the name of the entity
  */
7
   static void errorInvalidEntity(String systemID,
                  int  lineNr,
                  String   entity)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Invalid entity: `&" + entity + ";'");
###
245, errorUnexpectedElement, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 595, 608
9
/**
  * Throws an XMLValidationException to indicate that an element is
  * unexpected.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  * @param unexpectedElementName the name of the unexpected element
  */
14
   static void errorUnexpectedElement(String systemID,
                    int  lineNr,
                    String parentElementName,
                    String unexpectedElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
                XMLValidationException.UNEXPECTED_ELEMENT,
                systemID, lineNr,
                unexpectedElementName,
                /*attributeName*/ null,
                /*attributeValue*/ null,
                "Unexpected " + unexpectedElementName + " in a "
                + parentElementName);
###
246, errorInvalidInput, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 513, 519
8
/**
  * Throws an XMLParseException to indicate that a string is not expected
  * at this point.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param unexpectedString the string that is unexpected
  */
7
   static void errorInvalidInput(String systemID,
                 int  lineNr,
                 String   unexpectedString)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Invalid input: " + unexpectedString);
###
247, errorMissingPCData, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 699, 710
8
/**
  * Throws an XMLValidationException to indicate that a #PCDATA element was
  * missing.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  */
12
   static void errorMissingPCData(String systemID,
                  int  lineNr,
                  String parentElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
               XMLValidationException.MISSING_PCDATA,
               systemID, lineNr,
               /*elementName*/ null,
               /*attributeName*/ null,
               /*attributeValue*/ null,
               "Missing #PCDATA in element " + parentElementName);
###
248, errorExpectedInput, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 442, 448
8
/**
  * Throws an XMLParseException to indicate that an expected string is not
  * encountered.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param expectedString the string that is expected
  */
7
   static void errorExpectedInput(String systemID,
                  int  lineNr,
                  String expectedString)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "Expected: " + expectedString);
###
249, errorMissingElement, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 569, 582
8
/**
  * Throws an XMLValidationException to indicate that an element is missing.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param parentElementName the name of the parent element
  * @param missingElementName the name of the missing element
  */
14
   static void errorMissingElement(String systemID,
                   int  lineNr,
                   String parentElementName,
                   String missingElementName)
    throws XMLValidationException
   {
    throw new XMLValidationException(
                XMLValidationException.MISSING_ELEMENT,
                systemID, lineNr,
                missingElementName,
                /*attributeName*/ null,
                /*attributeValue*/ null,
                "Element " + parentElementName
                + " expects to have a " + missingElementName);
###
250, errorUnexpectedEntity, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 478, 485
8
/**
  * Throws an XMLParseException to indicate that an entity reference is
  * unexpected at this point.
  *
  * @param systemID     the system ID of the data source
  * @param lineNr     the line number in the data source
  * @param entity  the name of the entity
  */
8
   static void errorUnexpectedEntity(String systemID,
                   int  lineNr,
                   String entity)
    throws XMLParseException
   {
    throw new XMLParseException(systemID, lineNr,
                  "No entity reference is expected here ("
                  + entity + ")");
###
251, AbstractSaveUnsavedChangesAction, AbstractSaveUnsavedChangesAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractSaveUnsavedChangesAction.java, 52, 53
1
/** Creates a new instance. */
2
  public AbstractSaveUnsavedChangesAction(Application app, View view) {
    super(app, view);
###
252, processEntity, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 270, 286
10
/**
  * Processes an entity.
  *
  * @param entity     the entity
  * @param reader     the reader
  * @param entityResolver the entity resolver
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
15
   static void processEntity(String       entity,
               IXMLReader     reader,
               IXMLEntityResolver entityResolver)
    throws IOException,
       XMLParseException
   {
    entity = entity.substring(1, entity.length() - 1);
    Reader entityReader = entityResolver.getEntity(reader, entity);
    if (entityReader == null) {
     XMLUtil.errorInvalidEntity(reader.getSystemID(),
                  reader.getLineNr(),
                  entity);
    }
    boolean externalEntity = entityResolver.isExternalEntity(entity);
    reader.startNewStream(entityReader, !externalEntity);
###
253, scanIdentifier, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 175, 195
8
/**
  * Retrieves an identifier from the data.
  *
  * @param reader     the reader
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
18
   static String scanIdentifier(IXMLReader reader)
    throws IOException,
       XMLParseException
   {
    StringBuffer result = new StringBuffer();
    for (;;) {
     char ch = reader.read();
     if ((ch == '_') || (ch == ':') || (ch == '-') || (ch == '.')
       || ((ch >= 'a') && (ch <= 'z'))
       || ((ch >= 'A') && (ch <= 'Z'))
       || ((ch >= '0') && (ch <= '9')) || (ch > '\u007E')) {
      result.append(ch);
     } else {
      reader.unread(ch);
      break;
     }
    }
    return result.toString();
###
254, skipWhitespace, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 322, 348
10
/**
  * Skips whitespace from the reader.
  *
  * @param reader     the reader
  * @param buffer     where to put the whitespace; null if the
  *             whitespace does not have to be stored.
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
23
   static void skipWhitespace(IXMLReader   reader,
                StringBuffer buffer)
    throws IOException
   {
    char ch;
    if (buffer == null) {
     do {
      ch = reader.read();
     } while ((ch == ' ') || (ch == '\t') || (ch == '\n'));
    } else {
     for (;;) {
      ch = reader.read();
      if ((ch != ' ') && (ch != '\t') && (ch != '\n')) {
         break;
      }
      if (ch == '\n') {
         buffer.append('\n');
      } else {
         buffer.append(' ');
      }
     }
    }
    reader.unread(ch);
###
255, skipTag, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 95, 111
8
/**
  * Skips the remainder of the current XML tag.
  *
  * @param reader     the reader
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
14
   static void skipTag(IXMLReader reader)
    throws IOException,
       XMLParseException
   {
    int level = 1;
    while (level > 0) {
     char ch = reader.read();
     switch (ch) {
      case '<':
         ++level;
         break;
      case '>':
         --level;
         break;
###
256, processCharLiteral, XMLUtil, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java, 298, 307
8
/**
  * Processes a character literal.
  *
  * @param entity     the entity
  *
  * @throws java.io.IOException
  *    if an error occurred reading the data
  */
10
   static char processCharLiteral(String entity)
    throws IOException,
       XMLParseException
   {
    if (entity.charAt(2) == 'x') {
     entity = entity.substring(3, entity.length() - 1);
     return (char) Integer.parseInt(entity, 16);
    } else {
     entity = entity.substring(2, entity.length() - 1);
     return (char) Integer.parseInt(entity, 10);
###
260, setViewClassName, AbstractApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java, 79, 82
3
/**
   * Use this method for best application startup performance.
   */
4
  public void setViewClassName(String newValue) {
    String oldValue = viewClassName;
    viewClassName = newValue;
    firePropertyChange(VIEW_CLASS_NAME_PROPERTY, oldValue, newValue);
###
263, createImportChooser, AbstractApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java, 166, 168
1
/** Returns createOpenChooser. */
3
  @Override
  public URIChooser createImportChooser(Application a, View v) {
    return createOpenChooser(a,v);
###
264, setViewClass, AbstractApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java, 88, 91
3
/**
   * Use this method only, if setViewClassName() does not suit you.
   */
4
  public void setViewClass(Class newValue) {
    Class oldValue = viewClass;
    viewClass = newValue;
    firePropertyChange(VIEW_CLASS_PROPERTY, oldValue, newValue);
###
266, XMLParseException, XMLParseException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLParseException.java, 48, 50
5
/**
  * Creates a new exception.
  *
  * @param msg the message of the exception.
  */
3
   public XMLParseException(String msg)
   {
    super(msg);
###
268, createMenuBar, OSXApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java, 300, 371
3
/**
   * Creates a menu bar.
   */
68
  protected JMenuBar createMenuBar(View v) {
    JMenuBar mb = new JMenuBar();
    // Get menus from application model
    JMenu fileMenu = null;
    JMenu editMenu = null;
    JMenu helpMenu = null;
    JMenu viewMenu = null;
    JMenu windowMenu = null;
    String fileMenuText = labels.getString("file.text");
    String editMenuText = labels.getString("edit.text");
    String viewMenuText = labels.getString("view.text");
    String windowMenuText = labels.getString("window.text");
    String helpMenuText = labels.getString("help.text");
    for (JMenu mm : getModel().createMenus(this, v)) {
      String text = mm.getText();
      if (text == null) {
        mm.setText("-null-");
      } else if (text.equals(fileMenuText)) {
        fileMenu = mm;
        continue;
      } else if (text.equals(editMenuText)) {
        editMenu = mm;
        continue;
      } else if (text.equals(viewMenuText)) {
        viewMenu = mm;
        continue;
      } else if (text.equals(windowMenuText)) {
        windowMenu = mm;
        continue;
      } else if (text.equals(helpMenuText)) {
        helpMenu = mm;
        continue;
      }
      mb.add(mm);
    }
    // Create missing standard menus
    if (fileMenu == null) {
      fileMenu = createFileMenu(v);
    }
    if (editMenu == null) {
      editMenu = createEditMenu(v);
    }
    if (viewMenu == null) {
      viewMenu = createViewMenu(v);
    }
    if (windowMenu == null) {
      windowMenu = createWindowMenu(v);
    }
    if (helpMenu == null) {
      helpMenu = createHelpMenu(v);
    }
    // Insert standard menus into menu bar
    if (fileMenu != null) {
      mb.add(fileMenu, 0);
    }
    if (editMenu != null) {
      mb.add(editMenu, Math.min(1, mb.getComponentCount()));
    }
    if (viewMenu != null) {
      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));
    }
    if (windowMenu != null) {
      mb.add(windowMenu);
    }
    if (helpMenu != null) {
      mb.add(helpMenu);
    }
    return mb;
###
270, addDisposable, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 238, 242
6
/**
   * Adds a disposable object, which will be disposed when the specified view
   * is disposed.
   *
   * @param disposable
   */
5
  public void addDisposable(Disposable disposable) {
    if (disposables == null) {
      disposables = new LinkedList<Disposable>();
    }
    disposables.add(disposable);
###
271, initComponents, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 152, 154
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    setLayout(new java.awt.BorderLayout());
###
272, updateViewTitle, OSXApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java, 267, 283
6
/**
   * Updates the title of a view and displays it in the given frame.
   * 
   * @param v The view.
   * @param f The frame.
   */
16
  protected void updateViewTitle(View v, JFrame f) {
    String title;
    URI uri = v.getURI();
    if (uri == null) {
      title = labels.getString("unnamedFile");
    } else {
      title = URIUtil.getName(uri);
    }
    v.setTitle(labels.getFormatted("frame.title", title, getName(), v.getMultipleOpenId()));
    f.setTitle(v.getTitle());
    // Adds a proxy icon for the file to the title bar
    // See http://developer.apple.com/technotes/tn2007/tn2196.html#WINDOW_DOCUMENTFILE
    if (uri != null && uri.getScheme() != null && uri.getScheme().equals("file")) {
      f.getRootPane().putClientProperty("Window.documentFile", new File(uri));
    } else {
      f.getRootPane().putClientProperty("Window.documentFile", null);
###
273, hasUnsavedChanges, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 176, 177
4
/**
   * Returns true, if the view has unsaved changes.
   * This is a bound property.
   */
2
  public boolean hasUnsavedChanges() {
    return hasUnsavedChanges;
###
277, getComponent, OSXApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java, 557, 571
2
/** Returns the Frame which holds the frameless JMenuBar.
   */
15
  public Component getComponent() {
    if (invisibleFrame == null) {
      invisibleFrame = new JFrame();
      invisibleFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
      invisibleFrame.setUndecorated(true);
      // Move it way off screen
      invisibleFrame.setLocation(10000, 10000);
      // make the frame transparent and shadowless
      // see https://developer.apple.com/mac/library/technotes/tn2007/tn2196.html
      invisibleFrame.getRootPane().putClientProperty("Window.alpha", 0f);
      invisibleFrame.getRootPane().putClientProperty("Window.shadow", false);
      // make it visible, so the menu bar will show
      invisibleFrame.setVisible(true);
    }
    return invisibleFrame;
###
278, addExternalEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 102, 107
7
/**
  * Adds an external entity.
  *
  * @param name the name of the entity.
  * @param publicID the public ID of the entity, which may be null.
  * @param systemID the system ID of the entity.
  */
6
   public void addExternalEntity(String name,
                 String publicID,
                 String systemID)
   {
    if (! this.entities.containsKey(name)) {
     this.entities.put(name, new String[] { publicID, systemID } );
###
279, execute, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 191, 195
5
/**
   * Executes the specified runnable on the worker thread of the view.
   * Execution is perfomred sequentially in the same sequence as the
   * runnables have been passed to this method.
   */
5
  public void execute(Runnable worker) {
    if (executor == null) {
      executor = Executors.newSingleThreadExecutor();
    }
    executor.execute(worker);
###
280, isExternalEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 142, 145
5
/**
  * Returns true if an entity is external.
  *
  * @param name the name of the entity.
  */
4
   public boolean isExternalEntity(String name)
   {
    Object obj = this.entities.get(name);
    return ! (obj instanceof java.lang.String);
###
281, dispose, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 111, 125
4
/**
   * Gets rid of all the resources of the view.
   * No other methods should be invoked on the view afterwards.
   */
13
      @SuppressWarnings("unchecked")
  public void dispose() {
    if (executor != null) {
      executor.shutdown();
      executor = null;
    }
    if (disposables != null) {
      for (Disposable d : (LinkedList<Disposable>)disposables.clone()) {
        d.dispose();
      }
      disposables = null;
    }
    removeAll();
###
283, addInternalEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 86, 90
6
/**
  * Adds an internal entity.
  *
  * @param name the name of the entity.
  * @param value the value of the entity.
  */
5
   public void addInternalEntity(String name,
                 String value)
   {
    if (! this.entities.containsKey(name)) {
     this.entities.put(name, value);
###
284, AbstractView, AbstractView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java, 78, 79
3
/**
   * Creates a new instance.
   */
2
  public AbstractView() {
    preferences = PreferencesUtil.userNodeForPackage(getClass());
###
286, XMLEntityResolver, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 57, 64
3
/**
  * Initializes the resolver.
  */
8
   public XMLEntityResolver()
   {
    this.entities = new Hashtable();
    this.entities.put("amp", "&#38;");
    this.entities.put("quot", "&#34;");
    this.entities.put("apos", "&#39;");
    this.entities.put("lt", "&#60;");
    this.entities.put("gt", "&#62;");
###
287, getEntity, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 120, 132
8
/**
  * Returns a Java reader containing the value of an entity.
  *
  * @param xmlReader the current XML reader
  * @param name the name of the entity.
  *
  * @return the reader, or null if the entity could not be resolved.
  */
12
   public Reader getEntity(IXMLReader xmlReader,
               String   name)
    throws XMLParseException
   {
    Object obj = this.entities.get(name);
    if (obj == null) {
     return null;
    } else if (obj instanceof java.lang.String) {
     return new StringReader((String)obj);
    } else {
     String[] id = (String[]) obj;
     return this.openExternalEntity(xmlReader, id[0], id[1]);
###
288, finalize, XMLEntityResolver, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java, 71, 76
3
/**
  * Cleans up the object when it's destroyed.
  */
6
   protected void finalize()
    throws Throwable
   {
    this.entities.clear();
    this.entities = null;
    super.finalize();
###
289, XMLWriter, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 79, 81
5
/**
  * Creates a new XML writer.
  *
  * @param stream where to write the output to.
  */
3
   public XMLWriter(OutputStream stream)
   {
    this.writer = new PrintWriter(stream);
###
291, write, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 148, 261
8
/**
  * Writes an XML element.
  *
  * @param xml the non-null XML element to write.
  * @param prettyPrint if spaces need to be inserted to make the output more
  *          readable
  * @param indent how many spaces to indent the element.
  */
95
   public void write(IXMLElement xml,
           boolean   prettyPrint,
           int     indent,
           boolean   collapseEmptyElements)
    throws IOException
   {
    if (prettyPrint) {
     for (int i = 0; i < indent; i++) {
      this.writer.print(' ');
     }
    }
    if (xml.getName() == null) {
     if (xml.getContent() != null) {
      if (prettyPrint) {
         this.writeEncoded(xml.getContent().trim());
         writer.println();
      } else {
         this.writeEncoded(xml.getContent());
      }
     }
    } else {
     this.writer.print('<');
     this.writer.print(xml.getFullName());
     Vector nsprefixes = new Vector();
     if (xml.getNamespace() != null) {
      if (xml.getName().equals(xml.getFullName())) {
         this.writer.print(" xmlns=\"" + xml.getNamespace() + '"');
      } else {
         String prefix = xml.getFullName();
         prefix = prefix.substring(0, prefix.indexOf(':'));
         nsprefixes.addElement(prefix);
         this.writer.print(" xmlns:" + prefix);
         this.writer.print("=\"" + xml.getNamespace() + "\"");
      }
     }
     Iterator enm = xml.iterateAttributeNames();
     while (enm.hasNext()) {
      String key = (String) enm.next();
      int index = key.indexOf(':');
      if (index >= 0) {
         String namespace = xml.getAttributeNamespace(key);
         if (namespace != null) {
          String prefix = key.substring(0, index);
          if (! nsprefixes.contains(prefix)) {
           this.writer.print(" xmlns:" + prefix);
           this.writer.print("=\"" + namespace + '"');
           nsprefixes.addElement(prefix);
          }
         }
      }
     }
     enm = xml.iterateAttributeNames();
     while (enm.hasNext()) {
      String key = (String) enm.next();
      String value = xml.getAttribute(key, null);
      this.writer.print(" " + key + "=\"");
      this.writeEncoded(value);
      this.writer.print('"');
     }
     if ((xml.getContent() != null)
       && (xml.getContent().length() > 0)) {
      writer.print('>');
      this.writeEncoded(xml.getContent());
      writer.print("</" + xml.getFullName() + '>');
      if (prettyPrint) {
         writer.println();
      }
     } else if (xml.hasChildren() || (! collapseEmptyElements)) {
      writer.print('>');
      if (prettyPrint) {
         writer.println();
      }
      enm = xml.iterateChildren();
      while (enm.hasNext()) {
         IXMLElement child = (IXMLElement) enm.next();
         this.write(child, prettyPrint, indent + 4,
              collapseEmptyElements);
      }
      if (prettyPrint) {
         for (int i = 0; i < indent; i++) {
          this.writer.print(' ');
         }
      }
      this.writer.print("</" + xml.getFullName() + ">");
      if (prettyPrint) {
         writer.println();
      }
     } else {
      this.writer.print("/>");
      if (prettyPrint) {
         writer.println();
      }
     }
    }
    this.writer.flush();
###
292, write, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 101, 104
5
/**
  * Writes an XML element.
  *
  * @param xml the non-null XML element to write.
  */
4
   public void write(IXMLElement xml)
    throws IOException
   {
    this.write(xml, false, 0, true);
###
295, XMLWriter, XMLWriter, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java, 64, 69
5
/**
  * Creates a new XML writer.
  *
  * @param writer where to write the output to.
  */
6
   public XMLWriter(Writer writer)
   {
    if (writer instanceof PrintWriter) {
     this.writer = (PrintWriter) writer;
    } else {
     this.writer = new PrintWriter(writer);
###
297, createMenuBar, MDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/MDIApplication.java, 384, 455
3
/**
   * Creates a menu bar.
   */
68
  protected JMenuBar createMenuBar(View v) {
    JMenuBar mb = new JMenuBar();
    // Get menus from application model
    JMenu fileMenu = null;
    JMenu editMenu = null;
    JMenu helpMenu = null;
    JMenu viewMenu = null;
    JMenu windowMenu = null;
    String fileMenuText = labels.getString("file.text");
    String editMenuText = labels.getString("edit.text");
    String viewMenuText = labels.getString("view.text");
    String windowMenuText = labels.getString("window.text");
    String helpMenuText = labels.getString("help.text");
    for (JMenu mm : getModel().createMenus(this, v)) {
      String text = mm.getText();
      if (text == null) {
        mm.setText("-null-");
      } else if (text.equals(fileMenuText)) {
        fileMenu = mm;
        continue;
      } else if (text.equals(editMenuText)) {
        editMenu = mm;
        continue;
      } else if (text.equals(viewMenuText)) {
        viewMenu = mm;
        continue;
      } else if (text.equals(windowMenuText)) {
        windowMenu = mm;
        continue;
      } else if (text.equals(helpMenuText)) {
        helpMenu = mm;
        continue;
      }
      mb.add(mm);
    }
    // Create missing standard menus
    if (fileMenu == null) {
      fileMenu = createFileMenu(v);
    }
    if (editMenu == null) {
      editMenu = createEditMenu(v);
    }
    if (viewMenu == null) {
      viewMenu = createViewMenu(v);
    }
    if (windowMenu == null) {
      windowMenu = createWindowMenu(v);
    }
    if (helpMenu == null) {
      helpMenu = createHelpMenu(v);
    }
    // Insert standard menus into menu bar
    if (fileMenu != null) {
      mb.add(fileMenu, 0);
    }
    if (editMenu != null) {
      mb.add(editMenu, Math.min(1, mb.getComponentCount()));
    }
    if (viewMenu != null) {
      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));
    }
    if (windowMenu != null) {
      mb.add(windowMenu);
    }
    if (helpMenu != null) {
      mb.add(helpMenu);
    }
    return mb;
###
298, wrapDesktopPane, MDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/MDIApplication.java, 365, 378
3
/**
   * Returns the wrapped desktop pane.
   */
14
  protected Component wrapDesktopPane(Component c, LinkedList<Action> toolBarActions) {
    if (getModel() != null) {
      int id = 0;
      for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, null))) {
        id++;
        JPanel panel = new JPanel(new BorderLayout());
        panel.add(tb, BorderLayout.NORTH);
        panel.add(c, BorderLayout.CENTER);
        c = panel;
        PreferencesUtil.installToolBarPrefsHandler(prefs, "toolbar." + id, tb);
        toolBarActions.addFirst(new ToggleToolBarAction(tb, tb.getName()));
      }
    }
    return c;
###
299, getNamespace, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 312, 313
6
/**
   * Returns the namespace of the element.
   *
   * @return the namespace, or null if no namespace is associated with the
   *     element.
   */
2
  public String getNamespace() {
    return this.namespace;
###
300, getChildren, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 464, 465
5
/**
   * Returns a vector containing all the child iterator.
   *
   * @return the vector.
   */
2
  public ArrayList getChildren() {
    return this.children;
###
301, maybeAddSeparator, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 306, 307
2
/** Adds a separator to the supplied menu. The separator will only
  be added, if additional items are added using addAction. */
2
  protected void maybeAddSeparator(JMenu m) {
    m.putClientProperty("needsSeparator", Boolean.TRUE);
###
302, addAction, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 275, 276
1
/** Adds the specified action as a menu item to the supplied menu. */
2
  protected void addAction(JMenu m, View view, String actionID) {
    addAction(m, getAction(view, actionID));
###
304, setActiveView, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 138, 147
6
/**
   * Sets the active view. Calls deactivate on the previously
   * active view, and then calls activate on the given view.
   * 
   * @param newValue Active view, can be null.
   */
10
  public void setActiveView(View newValue) {
    View oldValue = activeView;
    if (activeView != null) {
      activeView.deactivate();
    }
    activeView = newValue;
    if (activeView != null) {
      activeView.activate();
    }
    firePropertyChange(ACTIVE_VIEW_PROPERTY, oldValue, newValue);
###
305, hasChildren, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 444, 445
5
/**
   * Returns whether the element has children.
   *
   * @return true if the element has children.
   */
2
  public boolean hasChildren() {
    return (! this.children.isEmpty());
###
306, getAttributeType, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 828, 834
8
/**
   * Returns the type of an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI, which may be null.
   *
   * @return the type, or null if the attribute does not exist.
   */
7
  public String getAttributeType(String name,
      String namespace) {
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      return null;
    } else {
      return attr.getType();
###
307, AbstractSelectionAction, AbstractSelectionAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractSelectionAction.java, 49, 66
5
/** Creates a new instance which acts on the specified component.
   *
   * @param target The target of the action. Specify null for the currently
   * focused component.
   */
16
  public AbstractSelectionAction(JComponent target) {
    this.target = target;
    if (target != null) {
      // Register with a weak reference on the JComponent.
      propertyHandler = new PropertyChangeListener() {
        @Override
        public void propertyChange(PropertyChangeEvent evt) {
          String n = evt.getPropertyName();
          if (n.equals("enabled")) {
            updateEnabled();
          } else if (n.equals(EditableComponent.SELECTION_EMPTY_PROPERTY)) {
            updateEnabled();
          }
        }
      };
      target.addPropertyChangeListener(new WeakPropertyChangeListener(propertyHandler));
###
308, addChild, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 354, 368
5
/**
   * Adds a child element.
   *
   * @param child the non-null child to add.
   */
15
  public void addChild(IXMLElement child) {
    if (child == null) {
      throw new IllegalArgumentException("child must not be null");
    }
    if ((child.getName() == null) && (! this.children.isEmpty())) {
      IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);
      
      if (lastChild.getName() == null) {
        lastChild.setContent(lastChild.getContent()
        + child.getContent());
        return;
      }
    }
    ((XMLElement)child).parent = this;
    this.children.add(child);
###
310, getFirstChildNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 513, 530
8
/**
   * Searches a child element.
   *
   * @param name    the name of the child to search for.
   * @param namespace the namespace, which may be null.
   *
   * @return the child element, or null if no such child was found.
   */
18
  public IXMLElement getFirstChildNamed(String name,
      String namespace) {
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String str = child.getName();
      boolean found = (str != null) && (str.equals(name));
      str = child.getNamespace();
      if (str == null) {
        found &= (name == null);
      } else {
        found &= str.equals(namespace);
      }
      if (found) {
        return child;
      }
    }
    return null;
###
311, addAction, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 280, 289
1
/** Adds the specified action as a menu item to the supplied menu. */
10
  protected void addAction(JMenu m, Action a) {
    if (a != null) {
      if (m.getClientProperty("needsSeparator") == Boolean.TRUE) {
        m.addSeparator();
        m.putClientProperty("needsSeparator", null);
      }
      JMenuItem mi;
      mi = m.add(a);
      mi.setIcon(null);
      mi.setToolTipText(null);
###
312, getActiveView, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 155, 156
5
/**
   * Gets the active view.
   * 
   * @return The active view can be null.
   */
2
  public View getActiveView() {
    return activeView;
###
313, removeChildAtIndex, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 414, 415
5
/**
   * Removes the child located at a certain index.
   *
   * @param index the index of the child, where the first child has index 0.
   */
2
  public void removeChildAtIndex(int index) {
    this.children.remove(index);
###
314, setActionMap, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 536, 537
3
/**
   * Sets the application-wide action map.
   */
2
  public void setActionMap(ActionMap m) {
    actionMap = m;
###
315, getFullName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 291, 292
6
/**
   * Returns the full name (i.e. the name including an eventual namespace
   * prefix) of the element.
   *
   * @return the name, or null if the element only contains #PCDATA.
   */
2
  public String getFullName() {
    return this.fullName;
###
316, getParent, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 280, 281
4
/**
   * Returns the parent element. This method returns null for the root
   * element.
   */
2
  public IXMLElement getParent() {
    return this.parent;
###
319, setAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 845, 852
6
/**
   * Sets an attribute.
   *
   * @param name the non-null full name of the attribute.
   * @param value the non-null value of the attribute.
   */
8
  public void setAttribute(String name,
      String value) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      attr = new XMLAttribute(name, name, null, value, "CDATA");
      this.attributes.add(attr);
    } else {
      attr.setValue(value);
###
320, addMenuItem, AbstractApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 294, 300
1
/** Adds the specified action as a menu item to the supplied menu. */
7
  protected void addMenuItem(JMenu m, JMenuItem mi) {
    if (mi != null) {
      if (m.getClientProperty("needsSeparator") == Boolean.TRUE) {
        m.addSeparator();
        m.putClientProperty("needsSeparator", null);
      }
      m.add(mi);
###
321, equals, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1053, 1057
5
/**
   * Returns true if the element equals another element.
   *
   * @param rawElement the element to compare to
   */
5
  public boolean equals(Object rawElement) {
    try {
      return this.equalsXMLElement((IXMLElement) rawElement);
    } catch (ClassCastException e) {
      return false;
###
322, getName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 301, 302
5
/**
   * Returns the name of the element.
   *
   * @return the name, or null if the element only contains #PCDATA.
   */
2
  public String getName() {
    return this.name;
###
324, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 725, 728
8
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null full name of the attribute.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
4
  public int getAttribute(String name,
      int  defaultValue) {
    String value = this.getAttribute(name, Integer.toString(defaultValue));
    return Integer.parseInt(value);
###
326, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 135, 136
5
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   */
2
  public XMLElement(String fullName) {
    this(fullName, null, null, NO_LINE);
###
329, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 125, 126
3
/**
   * Creates an empty element to be used for #PCDATA content.
   */
2
  public XMLElement() {
    this(null, null, null, NO_LINE);
###
331, getContent, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1032, 1033
8
/**
   * Return the #PCDATA content of the element. If the element has a
   * combination of #PCDATA content and child iterator, the #PCDATA
   * sections can be retrieved as unnamed child objects. In this case,
   * this method returns null.
   *
   * @return the content.
   */
2
  public String getContent() {
    return this.content;
###
333, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 224, 227
7
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   * @param systemID the system ID of the XML data where the element starts.
   * @param lineNr   the line in the XML data where the element starts.
   */
4
  public IXMLElement createElement(String fullName,
      String systemID,
      int  lineNr) {
    return new XMLElement(fullName, systemID, lineNr);
###
337, updateOpenRecentMenu, OpenRecentMenuHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java, 393, 428
3
/**
     * Updates the "File &gt; Open Recent" menu.
     */
33
    protected void updateOpenRecentMenu() {
      if (openRecentMenu.getItemCount() > 0) {
        JMenuItem clearRecentFilesItem = (JMenuItem) openRecentMenu.getItem(
            openRecentMenu.getItemCount() - 1);
        openRecentMenu.remove(openRecentMenu.getItemCount() - 1);
        // Dispose the actions and the menu items that are currently in the menu
        for (Action action : openRecentActions) {
          if (action instanceof Disposable) {
            ((Disposable) action).dispose();
          }
        }
        openRecentActions.clear();
        openRecentMenu.removeAll();
        // Create new actions and add them to the menu
        if (getAction(view, LoadFileAction.ID) != null || //
            getAction(view, LoadDirectoryAction.ID) != null) {
          for (URI f : getRecentURIs()) {
            LoadRecentFileAction action = new LoadRecentFileAction(AbstractApplication.this, view, f);
            openRecentMenu.add(action);
            openRecentActions.add(action);
          }
        } else {
          for (URI f : getRecentURIs()) {
            OpenRecentFileAction action = new OpenRecentFileAction(AbstractApplication.this, f);
            openRecentMenu.add(action);
            openRecentActions.add(action);
          }
        }
        if (getRecentURIs().size() > 0) {
          openRecentMenu.addSeparator();
        }
        // Add a separator and the clear recent files item.
        openRecentMenu.add(clearRecentFilesItem);
###
338, getAttributesInNamespace, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 980, 995
7
/**
   * Returns all attributes in a specific namespace as a Properties object.
   *
   * @param namespace the namespace URI of the attributes, which may be null.
   *
   * @return the non-null set.
   */
16
  public Properties getAttributesInNamespace(String namespace) {
    Properties result = new Properties();
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      if (namespace == null) {
        if (attr.getNamespace() == null) {
          result.put(attr.getName(), attr.getValue());
        }
      } else {
        if (namespace.equals(attr.getNamespace())) {
          result.put(attr.getName(), attr.getValue());
        }
      }
    }
    return result;
###
343, equalsXMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1067, 1103
5
/**
   * Returns true if the element equals another element.
   *
   * @param elt the element to compare to
   */
37
  public boolean equalsXMLElement(IXMLElement elt) {
    if (! this.name.equals(elt.getName())) {
      return false;
    }
    if (this.attributes.size() != elt.getAttributeCount()) {
      return false;
    }
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      if (! elt.hasAttribute(attr.getName(), attr.getNamespace())) {
        return false;
      }
      String value = elt.getAttribute(attr.getName(),
          attr.getNamespace(),
          null);
      if (! attr.getValue().equals(value)) {
        return false;
      }
      String type = elt.getAttributeType(attr.getName(),
          attr.getNamespace());
      if (! attr.getType().equals(type)) {
        return false;
      }
    }
    if (this.children.size() != elt.getChildrenCount()) {
      return false;
    }
    for (int i = 0; i < this.children.size(); i++) {
      IXMLElement child1 = this.getChildAtIndex(i);
      IXMLElement child2 = elt.getChildAtIndex(i);
      
      if (! child1.equalsXMLElement(child2)) {
        return false;
      }
    }
    return true;
###
346, getLineNr, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1019, 1020
8
/**
   * Returns the line number in the data where the element started.
   *
   * @return the line number, or NO_LINE if unknown.
   *
   * @see #NO_LINE
   * @see #getSystemID
   */
2
  public int getLineNr() {
    return this.lineNr;
###
348, removeChild, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 401, 405
5
/**
   * Removes a child element.
   *
   * @param child the non-null child to remove.
   */
5
  public void removeChild(IXMLElement child) {
    if (child == null) {
      throw new IllegalArgumentException("child must not be null");
    }
    this.children.remove(child);
###
350, createPCDataElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 202, 203
3
/**
   * Creates an element to be used for #PCDATA content.
   */
2
  public IXMLElement createPCDataElement() {
    return new XMLElement();
###
353, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 160, 162
6
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   */
3
  public XMLElement(String fullName,
      String namespace) {
    this(fullName, namespace, null, NO_LINE);
###
355, getAttributeNamespace, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 810, 815
7
/**
   * Returns the namespace of an attribute.
   *
   * @param name the non-null full name of the attribute.
   *
   * @return the namespace, or null if there is none associated.
   */
6
  public String getAttributeNamespace(String name) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      return null;
    } else {
      return attr.getNamespace();
###
358, getChildrenNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 541, 551
7
/**
   * Returns a vector of all child iterator named <I>name</I>.
   *
   * @param name the full name of the children to search for.
   *
   * @return the non-null vector of child iterator.
   */
11
  public ArrayList getChildrenNamed(String name) {
    ArrayList result = new ArrayList(this.children.size());
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String childName = child.getFullName();
      if ((childName != null) && childName.equals(name)) {
        result.add(child);
      }
    }
    return result;
###
361, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 251, 255
8
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   * @param systemID  the system ID of the XML data where the element starts.
   * @param lineNr  the line in the XML data where the element starts.
   */
5
  public IXMLElement createElement(String fullName,
      String namespace,
      String systemID,
      int  lineNr) {
    return new XMLElement(fullName, namespace, systemID, lineNr);
###
363, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 683, 690
9
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
8
  public String getAttribute(String name,
      String namespace,
      String defaultValue) {
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      return defaultValue;
    } else {
      return attr.getValue();
###
365, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 741, 746
9
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
6
  public int getAttribute(String name,
      String namespace,
      int  defaultValue) {
    String value = this.getAttribute(name, namespace,
        Integer.toString(defaultValue));
    return Integer.parseInt(value);
###
368, getFirstChildNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 492, 501
7
/**
   * Searches a child element.
   *
   * @param name the full name of the child to search for.
   *
   * @return the child element, or null if no such child was found.
   */
10
  public IXMLElement getFirstChildNamed(String name) {
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String childName = child.getFullName();
      if ((childName != null) && childName.equals(name)) {
        return child;
      }
    }
    return null;
###
370, getAttributeCount, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 636, 637
3
/**
   * Returns the number of attributes.
   */
2
  public int getAttributeCount() {
    return this.attributes.size();
###
372, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 147, 150
7
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   * @param systemID the system ID of the XML data where the element starts.
   * @param lineNr   the line in the XML data where the element starts.
   */
4
  public XMLElement(String fullName,
      String systemID,
      int  lineNr) {
    this(fullName, null, systemID, lineNr);
###
374, XMLElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 174, 195
8
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   * @param systemID  the system ID of the XML data where the element starts.
   * @param lineNr  the line in the XML data where the element starts.
   */
22
  public XMLElement(String fullName,
      String namespace,
      String systemID,
      int  lineNr) {
    this.attributes = new ArrayList();
    this.children = new ArrayList(8);
    this.fullName = fullName;
    if (namespace == null) {
      this.name = fullName;
    } else {
      int index = fullName.indexOf(':');
      if (index >= 0) {
        this.name = fullName.substring(index + 1);
      } else {
        this.name = fullName;
      }
    }
    this.namespace = namespace;
    this.content = null;
    this.lineNr = lineNr;
    this.systemID = systemID;
    this.parent = null;
###
375, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 212, 213
5
/**
   * Creates an empty element.
   *
   * @param fullName the name of the element.
   */
2
  public IXMLElement createElement(String fullName) {
    return new XMLElement(fullName);
###
376, setName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 336, 345
6
/**
   * Sets the name.
   *
   * @param fullName  the non-null full name.
   * @param namespace the namespace URI, which may be null.
   */
10
  public void setName(String fullName,
      String namespace) {
    int index = fullName.indexOf(':');
    if ((namespace == null) || (index < 0)) {
      this.name = fullName;
    } else {
      this.name = fullName.substring(index + 1);
    }
    this.fullName = fullName;
    this.namespace = namespace;
###
377, hasAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 941, 942
5
/**
   * Returns whether an attribute exists.
   *
   * @return true if the attribute exists.
   */
2
  public boolean hasAttribute(String name) {
    return this.findAttribute(name) != null;
###
378, removeAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 884, 889
5
/**
   * Removes an attribute.
   *
   * @param name the non-null name of the attribute.
   */
6
  public void removeAttribute(String name) {
    for (int i = 0; i < this.attributes.size(); i++) {
      XMLAttribute attr = (XMLAttribute) this.attributes.get(i);
      if (attr.getFullName().equals(name)) {
        this.attributes.remove(i);
        return;
###
379, createElement, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 237, 239
6
/**
   * Creates an empty element.
   *
   * @param fullName  the full name of the element
   * @param namespace the namespace URI.
   */
3
  public IXMLElement createElement(String fullName,
      String namespace) {
    return new XMLElement(fullName, namespace);
###
381, getAttributes, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 962, 969
5
/**
   * Returns all attributes as a Properties object.
   *
   * @return the non-null set.
   */
8
  public Properties getAttributes() {
    Properties result = new Properties();
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      result.put(attr.getFullName(), attr.getValue());
    }
    return result;
###
382, isLeaf, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 434, 435
5
/**
   * Returns whether the element is a leaf element.
   *
   * @return true if the element has no children.
   */
2
  public boolean isLeaf() {
    return this.children.isEmpty();
###
383, findAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 593, 601
7
/**
   * Searches an attribute.
   *
   * @param fullName the non-null full name of the attribute.
   *
   * @return the attribute, or null if the attribute does not exist.
   */
9
  private XMLAttribute findAttribute(String fullName) {
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      if (attr.getFullName().equals(fullName)) {
        return attr;
      }
    }
    return null;
###
384, findAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 613, 629
8
/**
   * Searches an attribute.
   *
   * @param name the non-null short name of the attribute.
   * @param namespace the name space, which may be null.
   *
   * @return the attribute, or null if the attribute does not exist.
   */
17
  private XMLAttribute findAttribute(String name,
      String namespace) {
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      boolean found = attr.getName().equals(name);
      if (namespace == null) {
        found &= (attr.getNamespace() == null);
      } else {
        found &= namespace.equals(attr.getNamespace());
      }
      
      if (found) {
        return attr;
      }
    }
    return null;
###
385, getChildrenCount, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 454, 455
5
/**
   * Returns the number of children.
   *
   * @return the count.
   */
2
  public int getChildrenCount() {
    return this.children.size();
###
386, getDoubleAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 702, 712
9
/**
   * Returns an attribute of the element.
   * If the attribute doesn't exist, <code>defaultValue</code> is returned.
   *
   * @param name     The name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param defaultValue Key to use if the attribute is missing.
   *
   */
11
  public double getDoubleAttribute(String name,
      String namespace,
      double defaultValue) {
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      return defaultValue;
    } else {
      try {
        return Double.parseDouble(attr.getValue());
      } catch (NumberFormatException e) {
        return defaultValue;
###
387, getChildrenNamed, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 563, 582
8
/**
   * Returns a vector of all child iterator named <I>name</I>.
   *
   * @param name    the name of the children to search for.
   * @param namespace the namespace, which may be null.
   *
   * @return the non-null vector of child iterator.
   */
20
  public ArrayList getChildrenNamed(String name,
      String namespace) {
    ArrayList result = new ArrayList(this.children.size());
    Iterator enm = this.children.iterator();
    while (enm.hasNext()) {
      IXMLElement child = (IXMLElement) enm.next();
      String str = child.getName();
      boolean found = (str != null) && (str.equals(name));
      str = child.getNamespace();
      if (str == null) {
        found &= (name == null);
      } else {
        found &= str.equals(namespace);
      }
      
      if (found) {
        result.add(child);
      }
    }
    return result;
###
388, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 775, 782
27
/**
   * Returns an attribute by looking up a key in a hashtable.
   * If the attribute doesn't exist, the value corresponding to defaultKey
   * is returned.
   * <P>
   * As an example, if valueSet contains the mapping <code>"one" =&gt;
   * "1"</code>
   * and the element contains the attribute <code>attr="one"</code>, then
   * <code>getAttribute("attr", mapping, defaultKey, false)</code> returns
   * <code>"1"</code>.
   *
   * @param name
   *   The name of the attribute.
   * @param namespace the namespace URI, which may be null.
   * @param valueSet
   *   HashMap mapping keySet().iterator to values.
   * @param defaultKey
   *   Key to use if the attribute is missing.
   *
   * </dl><dl><dt><b>Preconditions:</b></dt><dd>
   * <ul><li><code>name != null</code>
   *   <li><code>name</code> is a valid XML identifier
   *   <li><code>valueSet</code> != null
   *   <li>the keySet().iterator of <code>valueSet</code> are strings
   * </ul></dd></dl><dl>
   *
   */
8
  public Object getAttribute(String name, String namespace,
      Map valueSet,
      String  defaultKey) {
    String key = this.getAttribute(name, namespace, null);
    if (key == null || ! valueSet.containsKey(key)) {
      return valueSet.get(defaultKey);
    }
    return valueSet.get(key);
###
389, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 650, 651
9
/**
   * @deprecated As of NanoXML/Java 2.1, replaced by
   *       {@link #getAttribute(java.lang.String,java.lang.String)}
   * Returns the value of an attribute.
   *
   * @param name the non-null name of the attribute.
   *
   * @return the value, or null if the attribute does not exist.
   */
2
  public String getAttribute(String name) {
    return this.getAttribute(name, null);
###
390, removeAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 901, 914
6
/**
   * Removes an attribute.
   *
   * @param name the non-null name of the attribute.
   * @param namespace the namespace URI of the attribute, which may be null.
   */
14
  public void removeAttribute(String name,
      String namespace) {
    for (int i = 0; i < this.attributes.size(); i++) {
      XMLAttribute attr = (XMLAttribute) this.attributes.get(i);
      boolean found = attr.getName().equals(name);
      if (namespace == null) {
        found &= (attr.getNamespace() == null);
      } else {
        found &= attr.getNamespace().equals(namespace);
      }
      
      if (found) {
        this.attributes.remove(i);
        return;
###
391, setContent, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1043, 1044
6
/**
   * Sets the #PCDATA content. It is an error to call this method with a
   * non-null value if there are child objects.
   *
   * @param content the (possibly null) content.
   */
2
  public void setContent(String content) {
    this.content = content;
###
392, getSystemID, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 1006, 1007
7
/**
   * Returns the system ID of the data where the element started.
   *
   * @return the system ID, or null if unknown.
   *
   * @see #getLineNr
   */
2
  public String getSystemID() {
    return this.systemID;
###
393, getAttributeType, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 793, 798
7
/**
   * Returns the type of an attribute.
   *
   * @param name the non-null full name of the attribute.
   *
   * @return the type, or null if the attribute does not exist.
   */
6
  public String getAttributeType(String name) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      return null;
    } else {
      return attr.getType();
###
395, getChildAtIndex, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 479, 481
10
/**
   * Returns the child at a specific index.
   *
   * @param index the index of the child
   *
   * @return the non-null child
   *
   * @throws java.lang.ArrayIndexOutOfBoundsException
   *    if the index is out of bounds.
   */
3
  public IXMLElement getChildAtIndex(int index)
  throws ArrayIndexOutOfBoundsException {
    return (IXMLElement) this.children.get(index);
###
396, iterateChildren, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 424, 425
5
/**
   * Returns an enumeration of all child iterator.
   *
   * @return the non-null enumeration
   */
2
  public Iterator iterateChildren() {
    return this.children.iterator();
###
397, setName, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 323, 326
6
/**
   * Sets the full name. This method also sets the short name and clears the
   * namespace URI.
   *
   * @param name the non-null name.
   */
4
  public void setName(String name) {
    this.name = name;
    this.fullName = name;
    this.namespace = null;
###
398, insertChild, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 378, 392
6
/**
   * Inserts a child element.
   *
   * @param child the non-null child to add.
   * @param index where to put the child.
   */
15
  public void insertChild(IXMLElement child,
      int     index) {
    if (child == null) {
      throw new IllegalArgumentException("child must not be null");
    }
    if ((child.getName() == null) && (! this.children.isEmpty())) {
      IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);
      if (lastChild.getName() == null) {
        lastChild.setContent(lastChild.getContent()
        + child.getContent());
        return;
      }
    }
    ((XMLElement) child).parent = this;
    this.children.add(index, child);
###
399, getAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 663, 669
8
/**
   * Returns the value of an attribute.
   *
   * @param name the non-null full name of the attribute.
   * @param defaultValue the default value of the attribute.
   *
   * @return the value, or defaultValue if the attribute does not exist.
   */
7
  public String getAttribute(String name,
      String defaultValue) {
    XMLAttribute attr = this.findAttribute(name);
    if (attr == null) {
      return defaultValue;
    } else {
      return attr.getValue();
###
400, createMenuBar, SDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java, 249, 319
3
/**
   * Creates a menu bar.
   */
67
  protected JMenuBar createMenuBar(View v) {
    JMenuBar mb = new JMenuBar();
    // Get menus from application model
    JMenu fileMenu = null;
    JMenu editMenu = null;
    JMenu helpMenu = null;
    JMenu viewMenu = null;
    JMenu windowMenu = null;
    String fileMenuText = labels.getString("file.text");
    String editMenuText = labels.getString("edit.text");
    String viewMenuText = labels.getString("view.text");
    String windowMenuText = labels.getString("window.text");
    String helpMenuText = labels.getString("help.text");
    for (JMenu mm : getModel().createMenus(this, v)) {
      String text = mm.getText();
      if (text == null) {
      } else if (text.equals(fileMenuText)) {
        fileMenu = mm;
        continue;
      } else if (text.equals(editMenuText)) {
        editMenu = mm;
        continue;
      } else if (text.equals(viewMenuText)) {
        viewMenu = mm;
        continue;
      } else if (text.equals(windowMenuText)) {
        windowMenu = mm;
        continue;
      } else if (text.equals(helpMenuText)) {
        helpMenu = mm;
        continue;
      }
      mb.add(mm);
    }
    // Create missing standard menus
    if (fileMenu == null) {
      fileMenu = createFileMenu(v);
    }
    if (editMenu == null) {
      editMenu = createEditMenu(v);
    }
    if (viewMenu == null) {
      viewMenu = createViewMenu(v);
    }
    if (windowMenu == null) {
      windowMenu = createWindowMenu(v);
    }
    if (helpMenu == null) {
      helpMenu = createHelpMenu(v);
    }
    // Insert standard menus into menu bar
    if (fileMenu != null) {
      mb.add(fileMenu, 0);
    }
    if (editMenu != null) {
      mb.add(editMenu, Math.min(1, mb.getComponentCount()));
    }
    if (viewMenu != null) {
      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));
    }
    if (windowMenu != null) {
      mb.add(windowMenu);
    }
    if (helpMenu != null) {
      mb.add(helpMenu);
    }
    return mb;
###
401, iterateAttributeNames, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 925, 932
5
/**
   * Returns an enumeration of all attribute names.
   *
   * @return the non-null enumeration.
   */
8
  public Iterator iterateAttributeNames() {
    ArrayList result = new ArrayList();
    Iterator enm = this.attributes.iterator();
    while (enm.hasNext()) {
      XMLAttribute attr = (XMLAttribute) enm.next();
      result.add(attr.getFullName());
    }
    return result.iterator();
###
402, updateViewTitle, SDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java, 390, 402
6
/**
   * Updates the title of a view and displays it in the given frame.
   * 
   * @param view The view.
   * @param f The frame.
   */
13
  protected void updateViewTitle(View view, JFrame f) {
    URI uri = view.getURI();
    String title;
    if (uri == null) {
      title = labels.getString("unnamedFile");
    } else {
      title = URIUtil.getName(uri);
    }
    if (view.hasUnsavedChanges()) {
      title += "*";
    }
    view.setTitle(labels.getFormatted("frame.title", title, getName(), view.getMultipleOpenId()));
    f.setTitle(view.getTitle());
###
403, setAttribute, XMLElement, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java, 864, 874
7
/**
   * Sets an attribute.
   *
   * @param fullName the non-null full name of the attribute.
   * @param namespace the namespace URI of the attribute, which may be null.
   * @param value the non-null value of the attribute.
   */
11
  public void setAttribute(String fullName,
      String namespace,
      String value) {
    int index = fullName.indexOf(':');
    String name = fullName.substring(index + 1);
    XMLAttribute attr = this.findAttribute(name, namespace);
    if (attr == null) {
      attr = new XMLAttribute(fullName, name, namespace, value, "CDATA");
      this.attributes.add(attr);
    } else {
      attr.setValue(value);
###
404, wrapViewComponent, SDIApplication, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java, 209, 226
4
/**
   * Returns the view component. Eventually wraps it into
   * another component in order to provide additional functionality.
   */
17
  protected Component wrapViewComponent(View p) {
    JComponent c = p.getComponent();
    if (getModel() != null) {
      LinkedList<Action> toolBarActions = new LinkedList<Action>();
      int id = 0;
      for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, p))) {
        id++;
        JPanel panel = new JPanel(new BorderLayout());
        panel.add(tb, BorderLayout.NORTH);
        panel.add(c, BorderLayout.CENTER);
        c = panel;
        PreferencesUtil.installToolBarPrefsHandler(prefs, "toolbar." + id, tb);
        toolBarActions.addFirst(new ToggleVisibleAction(tb, tb.getName()));
      }
      p.getComponent().putClientProperty("toolBarActions", toolBarActions);
    }
    return c;
###
405, stringReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 97, 99
5
/**
  * Creates a new reader using a string as input.
  *
  * @param str the string containing the XML data
  */
3
   public static IXMLReader stringReader(String str)
   {
    return new StdXMLReader(new StringReader(str));
###
406, fileReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 113, 125
10
/**
  * Creates a new reader using a file as input.
  *
  * @param filename the name of the file containing the XML data
  *
  * @throws java.io.FileNotFoundException
  *   if the file could not be found
  * @throws java.io.IOException
  *   if an I/O error occurred
  */
11
   public static IXMLReader fileReader(String filename)
    throws FileNotFoundException,
       IOException
   {
    StdXMLReader r = new StdXMLReader(new FileInputStream(filename));
    r.setSystemID(filename);
    for (int i = 0; i < r.readers.size(); i++) {
     StackedReader sr = (StackedReader) r.readers.elementAt(i);
     sr.systemId = r.currentReader.systemId;
    }
    return r;
###
407, getSystemID, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 613, 615
3
/**
  * Returns the current system ID.
  */
3
   public String getSystemID()
   {
    return this.currentReader.systemId.toString();
###
408, getLineNr, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 567, 579
3
/**
  * Returns the line number of the data in the current stream.
  */
11
   public int getLineNr()
   {
    if (this.currentReader.lineReader == null) {
     StackedReader sr = (StackedReader) this.readers.peek();
     if (sr.lineReader == null) {
      return 0;
     } else {
      return sr.lineReader.getLineNumber() + 1;
     }
    }
    return this.currentReader.lineReader.getLineNumber() + 1;
###
409, StdXMLReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 346, 365
8
/**
  * Initializes the XML reader.
  *
  * @param stream the input for the XML data.
  *
  * @throws java.io.IOException
  *    if an I/O error occurred
  */
18
   public StdXMLReader(InputStream stream)
    throws IOException
   {
    PushbackInputStream pbstream = new PushbackInputStream(stream);
    StringBuffer charsRead = new StringBuffer();
    Reader reader = this.stream2reader(stream, charsRead);
    this.currentReader = new StackedReader();
    this.readers = new Stack();
    this.currentReader.lineReader = new LineNumberReader(reader);
    this.currentReader.pbReader
     = new PushbackReader(this.currentReader.lineReader, 2);
    this.currentReader.publicId = "";
    try {
     this.currentReader.systemId = new URL("file:.");
    } catch (MalformedURLException e) {
     // never happens
    }
    this.startNewStream(new StringReader(charsRead.toString()));
###
410, getEncoding, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 216, 270
7
/**
  * Scans the encoding from an &lt;?xml...?&gt; tag.
  *
  * @param str the first tag in the XML data.
  *
  * @return the encoding, or null if no encoding has been specified.
  */
42
   protected String getEncoding(String str)
   {
    if (! str.startsWith("<?xml")) {
     return null;
    }
    int index = 5;
    while (index < str.length()) {
     StringBuffer key = new StringBuffer();
     while ((index < str.length()) && (str.charAt(index) <= ' ')) {
      index++;
     }
     while ((index < str.length())
        && (str.charAt(index) >= 'a')
        && (str.charAt(index) <= 'z')) {
      key.append(str.charAt(index));
      index++;
     }
     while ((index < str.length()) && (str.charAt(index) <= ' ')) {
      index++;
     }
     if ((index >= str.length()) || (str.charAt(index) != '=')) {
      break;
     }
     while ((index < str.length()) && (str.charAt(index) != '\'')
        && (str.charAt(index) != '"')) {
      index++;
     }
     if (index >= str.length()) {
      break;
     }
     char delimiter = str.charAt(index);
     index++;
     int index2 = str.indexOf(delimiter, index);
     if (index2 < 0) {
      break;
     }
     if (key.toString().equals("encoding")) {
      return str.substring(index, index2);
     }
     index = index2 + 1;
    }
    return null;
###
411, startNewStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 519, 521
7
/**
  * Starts a new stream from a Java reader. The new stream is used
  * temporary to read data from. If that stream is exhausted, control
  * returns to the parent stream.
  *
  * @param reader the non-null reader to read the new data from
  */
3
   public void startNewStream(Reader reader)
   {
    this.startNewStream(reader, false);
###
412, unread, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 451, 454
8
/**
  * Pushes the last character read back to the stream.
  *
  * @param ch the character to push back.
  *
  * @throws java.io.IOException
  *   if an I/O error occurred
  */
4
   public void unread(char ch)
    throws IOException
   {
    this.currentReader.pbReader.unread(ch);
###
413, setPublicID, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 604, 606
5
/**
  * Sets the public ID of the current stream.
  *
  * @param publicID the public ID
  */
3
   public void setPublicID(String publicID)
   {
    this.currentReader.publicId = publicID;
###
414, stream2reader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 283, 333
9
/**
  * Converts a stream to a reader while detecting the encoding.
  *
  * @param stream  the input for the XML data.
  * @param charsRead buffer where to put characters that have been read
  *
  * @throws java.io.IOException
  *   if an I/O error occurred
  */
40
   protected Reader stream2reader(InputStream  stream,
                  StringBuffer charsRead)
    throws IOException
   {
    PushbackInputStream pbstream = new PushbackInputStream(stream);
    int b = pbstream.read();
    switch (b) {
     case 0x00:
     case 0xFE:
     case 0xFF:
      pbstream.unread(b);
      return new InputStreamReader(pbstream, "UTF-16");
     case 0xEF:
      for (int i = 0; i < 2; i++) {
         pbstream.read();
      }
      return new InputStreamReader(pbstream, "UTF-8");
     case 0x3C:
      b = pbstream.read();
      charsRead.append('<');
      while ((b > 0) && (b != 0x3E)) {
         charsRead.append((char) b);
         b = pbstream.read();
      }
      if (b > 0) {
         charsRead.append((char) b);
      }
      String encoding = this.getEncoding(charsRead.toString());
      if (encoding == null) {
         return new InputStreamReader(pbstream, "UTF-8");
      }
      charsRead.setLength(0);
      try {
         return new InputStreamReader(pbstream, encoding);
      } catch (UnsupportedEncodingException e) {
         return new InputStreamReader(pbstream, "UTF-8");
      }
      default:
         charsRead.append((char) b);
         return new InputStreamReader(pbstream, "UTF-8");
###
415, openStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 471, 508
13
/**
  * Opens a stream from a public and system ID.
  *
  * @param publicID the public ID, which may be null
  * @param systemID the system ID, which is never null
  *
  * @throws java.net.MalformedURLException
  *   if the system ID does not contain a valid URL
  * @throws java.io.FileNotFoundException
  *   if the system ID refers to a local file which does not exist
  * @throws java.io.IOException
  *   if an error occurred opening the stream
  */
31
   public Reader openStream(String publicID,
              String systemID)
    throws MalformedURLException,
       FileNotFoundException,
       IOException
   {
    URL url = new URL(this.currentReader.systemId, systemID);
    if (url.getRef() != null) {
     String ref = url.getRef();
     if (url.getFile().length() > 0) {
      url = new URL(url.getProtocol(), url.getHost(), url.getPort(),
              url.getFile());
      url = new URL("jar:" + url + '!' + ref);
     } else {
      url = StdXMLReader.class.getResource(ref);
     }
    }
    this.currentReader.publicId = publicID;
    this.currentReader.systemId = url;
    StringBuffer charsRead = new StringBuffer();
    Reader reader = this.stream2reader(url.openStream(), charsRead);
    if (charsRead.length() == 0) {
     return reader;
    }
    String charsReadStr = charsRead.toString();
    PushbackReader pbreader = new PushbackReader(reader,
                           charsReadStr.length());
    for (int i = charsReadStr.length() - 1; i >= 0; i--) {
     pbreader.unread(charsReadStr.charAt(i));
    }
    return pbreader;
###
416, read, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 377, 392
8
/**
  * Reads a character.
  *
  * @return the character
  *
  * @throws java.io.IOException
  *    if no character could be read
  */
13
   public char read()
    throws IOException
   {
    int ch = this.currentReader.pbReader.read();
    while (ch < 0) {
     if (this.readers.empty()) {
      throw new IOException("Unexpected EOF");
     }
     this.currentReader.pbReader.close();
     this.currentReader = (StackedReader) this.readers.pop();
     ch = this.currentReader.pbReader.read();
    }
    return (char) ch;
###
417, StdXMLReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 176, 187
5
/**
  * Initializes the XML reader.
  *
  * @param reader the input for the XML data.
  */
11
   public StdXMLReader(Reader reader)
   {
    this.currentReader = new StackedReader();
    this.readers = new Stack();
    this.currentReader.lineReader = new LineNumberReader(reader);
    this.currentReader.pbReader
     = new PushbackReader(this.currentReader.lineReader, 2);
    this.currentReader.publicId = "";
    try {
     this.currentReader.systemId = new URL("file:.");
    } catch (MalformedURLException e) {
###
418, atEOF, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 423, 439
6
/**
  * Returns true if there are no more characters left to be read.
  *
  * @throws java.io.IOException
  *    if an I/O error occurred
  */
14
   public boolean atEOF()
    throws IOException
   {
    int ch = this.currentReader.pbReader.read();
    while (ch < 0) {
     if (this.readers.empty()) {
      return true;
     }
     this.currentReader.pbReader.close();
     this.currentReader = (StackedReader) this.readers.pop();
     ch = this.currentReader.pbReader.read();
    }
    this.currentReader.pbReader.unread(ch);
    return false;
###
419, atEOFOfCurrentStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 403, 412
7
/**
  * Returns true if the current stream has no more characters left to be
  * read.
  *
  * @throws java.io.IOException
  *    if an I/O error occurred
  */
9
   public boolean atEOFOfCurrentStream()
    throws IOException
   {
    int ch = this.currentReader.pbReader.read();
    if (ch < 0) {
     return true;
    } else {
     this.currentReader.pbReader.unread(ch);
     return false;
###
420, StdXMLReader, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 142, 167
13
/**
  * Initializes the reader from a system and public ID.
  *
  * @param publicID the public ID which may be null.
  * @param systemID the non-null system ID.
  *
  * @throws MalformedURLException
  *   if the system ID does not contain a valid URL
  * @throws FileNotFoundException
  *   if the system ID refers to a local file which does not exist
  * @throws IOException
  *   if an error occurred opening the stream
  */
23
   public StdXMLReader(String publicID,
             String systemID)
    throws MalformedURLException,
       FileNotFoundException,
       IOException
   {
    URL systemIDasURL = null;
    try {
     systemIDasURL = new URL(systemID);
    } catch (MalformedURLException e) {
     systemID = "file:" + systemID;
     try {
      systemIDasURL = new URL(systemID);
     } catch (MalformedURLException e2) {
      throw e;
     }
    }
    this.currentReader = new StackedReader();
    this.readers = new Stack();
    Reader reader = this.openStream(publicID, systemIDasURL.toString());
    this.currentReader.lineReader = new LineNumberReader(reader);
    this.currentReader.pbReader
     = new PushbackReader(this.currentReader.lineReader, 2);
###
421, setSystemID, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 591, 595
8
/**
  * Sets the system ID of the current stream.
  *
  * @param systemID the system ID
  *
  * @throws java.net.MalformedURLException
  *   if the system ID does not contain a valid URL
  */
5
   public void setSystemID(String systemID)
    throws MalformedURLException
   {
    this.currentReader.systemId = new URL(this.currentReader.systemId,
                      systemID);
###
422, finalize, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 196, 205
3
/**
  * Cleans up the object when it's destroyed.
  */
10
   protected void finalize()
    throws Throwable
   {
    this.currentReader.lineReader = null;
    this.currentReader.pbReader = null;
    this.currentReader.systemId = null;
    this.currentReader.publicId = null;
    this.currentReader = null;
    this.readers.clear();
    super.finalize();
###
423, getStreamLevel, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 558, 560
3
/**
  * Returns the current "level" of the stream on the stack of streams.
  */
3
   public int getStreamLevel()
   {
    return this.readers.size();
###
424, startNewStream, StdXMLReader, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java, 534, 551
9
/**
  * Starts a new stream from a Java reader. The new stream is used
  * temporary to read data from. If that stream is exhausted, control
  * returns to the parent stream.
  *
  * @param reader the non-null reader to read the new data from
  * @param isInternalEntity true if the reader is produced by resolving
  *             an internal entity
  */
16
   public void startNewStream(Reader  reader,
                boolean isInternalEntity)
   {
    StackedReader oldReader = this.currentReader;
    this.readers.push(this.currentReader);
    this.currentReader = new StackedReader();
    if (isInternalEntity) {
     this.currentReader.lineReader = null;
     this.currentReader.pbReader = new PushbackReader(reader, 2);
    } else {
     this.currentReader.lineReader = new LineNumberReader(reader);
     this.currentReader.pbReader
      = new PushbackReader(this.currentReader.lineReader, 2);
    }
    this.currentReader.systemId = oldReader.systemId;
    this.currentReader.publicId = oldReader.publicId;
###
426, invalidAttributeValue, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 345, 353
13
/**
  * Throws an XMLValidationException to indicate that an attribute has an
  * invalid value.
  *
  * @param systemID     the system ID of the XML data of the element
  * @param lineNr     the line number in the XML data of the element
  * @param elementName  the name of the element
  * @param attributeName  the name of the attribute
  * @param attributeValue the value of the attribute
  *
  * @throws net.n3.nanoxml.XMLValidationException
  *    of course :-)
  */
9
   public void invalidAttributeValue(String systemID,
                   int  lineNr,
                   String elementName,
                   String attributeName,
                   String attributeValue)
    throws XMLValidationException
   {
    XMLUtil.errorInvalidAttributeValue(systemID, lineNr, elementName,
                     attributeName, attributeValue);
###
430, getDelegate, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 77, 79
3
/**
  * Returns the delegate.
  */
3
   public IXMLValidator getDelegate()
   {
    return this.delegate;
###
432, setParameterEntityResolver, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 99, 101
5
/**
  * Sets the parameter entity resolver.
  *
  * @param resolver the entity resolver.
  */
3
   public void setParameterEntityResolver(IXMLEntityResolver resolver)
   {
    this.delegate.setParameterEntityResolver(resolver);
###
433, getParameterEntityResolver, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 110, 112
5
/**
  * Returns the parameter entity resolver.
  *
  * @return the entity resolver.
  */
3
   public IXMLEntityResolver getParameterEntityResolver()
   {
    return this.delegate.getParameterEntityResolver();
###
434, ValidatorPlugin, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 57, 59
3
/**
  * Initializes the plugin.
  */
3
   public ValidatorPlugin()
   {
    this.delegate = null;
###
438, finalize, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 66, 70
3
/**
  * Cleans up the object when it's destroyed.
  */
5
   protected void finalize()
    throws Throwable
   {
    this.delegate = null;
    super.finalize();
###
439, setDelegate, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 88, 90
5
/**
  * Sets the delegate.
  *
  * @param delegate the delegate
  */
3
   public void setDelegate(IXMLValidator delegate)
   {
    this.delegate = delegate;
###
440, unexpectedAttribute, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 321, 328
12
/**
  * Throws an XMLValidationException to indicate that an attribute is
  * unexpected.
  *
  * @param systemID    the system ID of the XML data of the element
  * @param lineNr    the line number in the XML data of the element
  * @param elementName   the name of the element
  * @param attributeName the name of the unexpected attribute
  *
  * @throws net.n3.nanoxml.XMLValidationException
  *    of course :-)
  */
8
   public void unexpectedAttribute(String systemID,
                   int  lineNr,
                   String elementName,
                   String attributeName)
    throws XMLValidationException
   {
    XMLUtil.errorUnexpectedAttribute(systemID, lineNr, elementName,
                     attributeName);
###
441, parseDTD, ValidatorPlugin, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java, 128, 134
12
/**
  * Parses the DTD. The validator object is responsible for reading the
  * full DTD.
  *
  * @param publicID     the public ID, which may be null.
  * @param reader     the reader to read the DTD from.
  * @param entityResolver the entity resolver.
  * @param external     true if the DTD is external.
  *
  * @throws java.lang.Exception
  *   if something went wrong.
  */
7
   public void parseDTD(String       publicID,
            IXMLReader     reader,
            IXMLEntityResolver entityResolver,
            boolean      external)
    throws Exception
   {
    this.delegate.parseDTD(publicID, reader, entityResolver, external);
###
444, StdXMLBuilder, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 72, 74
3
/**
  * Creates the builder.
  */
3
   public StdXMLBuilder()
   {
    this(new XMLElement());
###
445, StdXMLBuilder, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 83, 87
5
/**
  * Creates the builder.
  *
  * @param prototype the prototype to use when building the tree.
  */
5
   public StdXMLBuilder(IXMLElement prototype)
   {
    this.stack = null;
    this.root = null;
    this.prototype = prototype;
###
447, addPCData, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 282, 318
12
/**
  * This method is called when a PCDATA element is encountered. A Java
  * reader is supplied from which you can read the data. The reader will
  * only read the data of the element. You don't need to check for
  * boundaries. If you don't read the full element, the rest of the data
  * is skipped. You also don't have to care about entities; they are
  * resolved by the parser.
  *
  * @param reader   the Java reader from which you can retrieve the data.
  * @param systemID the system ID of the XML data source.
  * @param lineNr   the line in the source where the element starts.
  */
30
   public void addPCData(Reader reader,
             String systemID,
             int  lineNr)
   {
    int bufSize = 2048;
    int sizeRead = 0;
    StringBuffer str = new StringBuffer(bufSize);
    char[] buf = new char[bufSize];
    for (;;) {
     if (sizeRead >= bufSize) {
      bufSize *= 2;
      str.ensureCapacity(bufSize);
     }
     int size;
     try {
      size = reader.read(buf);
     } catch (IOException e) {
      break;
     }
     if (size < 0) {
      break;
     }
     str.append(buf, 0, size);
     sizeRead += size;
    }
    IXMLElement elt = this.prototype.createElement(null, systemID, lineNr);
    elt.setContent(str.toString());
    if (! this.stack.empty()) {
     IXMLElement top = (IXMLElement) this.stack.peek();
     top.addChild(elt);
###
448, finalize, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 94, 101
3
/**
  * Cleans up the object when it's destroyed.
  */
8
   protected void finalize()
    throws Throwable
   {
    this.prototype = null;
    this.root = null;
    this.stack.clear();
    this.stack = null;
    super.finalize();
###
449, addAttribute, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 241, 265
17
/**
  * This method is called when a new attribute of an XML element is
  * encountered.
  *
  * @param key    the key (name) of the attribute.
  * @param nsPrefix   the prefix used to identify the namespace. If no
  *           namespace has been specified, this parameter is null.
  * @param nsURI    the URI associated with the namespace. If no
  *           namespace has been specified, or no URI is
  *           associated with nsPrefix, this parameter is null.
  * @param value    the value of the attribute.
  * @param type     the type of the attribute. If no type is known,
  *           "CDATA" is returned.
  *
  * @throws java.lang.Exception
  *   If an exception occurred while processing the event.
  */
21
   public void addAttribute(String key,
              String nsPrefix,
              String nsURI,
              String value,
              String type)
    throws Exception
   {
    String fullName = key;
    if (nsPrefix != null) {
     fullName = nsPrefix + ':' + key;
    }
    IXMLElement top = (IXMLElement) this.stack.peek();
    if (top.hasAttribute(fullName)) {
     throw new XMLParseException(top.getSystemID(),
                   top.getLineNr(),
                   "Duplicate attribute: " + key);
    }
    if (nsPrefix != null) {
     top.setAttribute(fullName, nsURI, value);
    } else {
     top.setAttribute(fullName, value);
###
450, endElement, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 207, 218
15
/**
  * This method is called when the end of an XML elemnt is encountered.
  *
  * @see #startElement
  *
  * @param name     the name of the element.
  * @param nsPrefix   the prefix used to identify the namespace. If no
  *           namespace has been specified, this parameter is null.
  * @param nsURI    the URI associated with the namespace. If no
  *           namespace has been specified, or no URI is
  *           associated with nsPrefix, this parameter is null.
  */
 --------------
// nothing to do
 --------------
10
   public void endElement(String name,
              String nsPrefix,
              String nsURI)
   {
    IXMLElement elt = (IXMLElement) this.stack.pop();
    if (elt.getChildrenCount() == 1) {
     IXMLElement child = elt.getChildAtIndex(0);
     if (child.getName() == null) {
      elt.setContent(child.getContent());
      elt.removeChildAtIndex(0);
###
451, startBuilding, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 111, 115
6
/**
  * This method is called before the parser starts processing its input.
  *
  * @param systemID the system ID of the XML data source.
  * @param lineNr   the line on which the parsing starts.
  */
5
   public void startBuilding(String systemID,
               int  lineNr)
   {
    this.stack = new Stack();
    this.root = null;
###
452, startElement, StdXMLBuilder, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java, 147, 169
14
/**
  * This method is called when a new XML element is encountered.
  *
  * @see #endElement
  *
  * @param name   the name of the element.
  * @param nsPrefix   the prefix used to identify the namespace. If no
  *       namespace has been specified, this parameter is null.
  * @param nsURI  the URI associated with the namespace. If no
  *       namespace has been specified, or no URI is
  *       associated with nsPrefix, this parameter is null.
  * @param systemID   the system ID of the XML data source.
  * @param lineNr   the line in the source where the element starts.
  */
19
   public void startElement(String name,
              String nsPrefix,
              String nsURI,
              String systemID,
              int  lineNr)
   {
    String fullName = name;
    if (nsPrefix != null) {
     fullName = nsPrefix + ':' + name;
    }
    IXMLElement elt = this.prototype.createElement(fullName, nsURI,
                           systemID, lineNr);
    if (this.stack.empty()) {
     this.root = elt;
    } else {
     IXMLElement top = (IXMLElement) this.stack.peek();
     top.addChild(elt);
    }
    this.stack.push(elt);
###
454, setReader, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 173, 175
5
/**
  * Sets the reader from which the parser retrieves its data.
  *
  * @param reader the reader
  */
3
   public void setReader(IXMLReader reader)
   {
    this.reader = reader;
###
455, setValidator, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 129, 131
5
/**
  * Sets the validator that validates the XML data.
  *
  * @param validator the non-null validator
  */
3
   public void setValidator(IXMLValidator validator)
   {
    this.validator = validator;
###
456, setResolver, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 151, 153
5
/**
  * Sets the entity resolver.
  *
  * @param resolver the non-null resolver
  */
3
   public void setResolver(IXMLEntityResolver resolver)
   {
    this.entityResolver = resolver;
###
457, scanSomeTag, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 269, 294
10
/**
  * Scans an XML tag.
  *
  * @param allowCDATA true if CDATA sections are allowed at this point
  * @param defaultNamespace the default namespace URI (or null)
  * @param namespaces list of defined namespaces
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
22
   protected void scanSomeTag(boolean  allowCDATA,
                String   defaultNamespace,
                Properties namespaces)
    throws Exception
   {
    String str = XMLUtil.read(this.reader, '&');
    char ch = str.charAt(0);
    if (ch == '&') {
     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),
                     reader.getLineNr(),
                     str);
    }
    switch (ch) {
     case '?':
      this.processPI();
      break;
     case '!':
      this.processSpecialTag(allowCDATA);
      break;
     default:
      this.reader.unread(ch);
      this.processElement(defaultNamespace, namespaces);
###
458, processElement, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 461, 655
12
/**
  * Processes a regular element.
  *
  * @param defaultNamespace the default namespace URI (or null)
  * @param namespaces list of defined namespaces
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
 --------------
// END PATCH W. Randelshofer Don't read DTD
 --------------
165
   protected void processElement(String   defaultNamespace,
                 Properties namespaces)
    throws Exception
   {
    String fullName = XMLUtil.scanIdentifier(this.reader);
    String name = fullName;
    XMLUtil.skipWhitespace(this.reader, null);
    String prefix = null;
    int colonIndex = name.indexOf(':');
    if (colonIndex > 0) {
     prefix = name.substring(0, colonIndex);
     name = name.substring(colonIndex + 1);
    }
    Vector attrNames = new Vector();
    Vector attrValues = new Vector();
    Vector attrTypes = new Vector();
    this.validator.elementStarted(fullName,
                  this.reader.getSystemID(),
                  this.reader.getLineNr());
    char ch;
    for (;;) {
     ch = this.reader.read();
     if ((ch == '/') || (ch == '>')) {
      break;
     }
     this.reader.unread(ch);
     this.processAttribute(attrNames, attrValues, attrTypes);
     XMLUtil.skipWhitespace(this.reader, null);
    }
    Properties extraAttributes = new Properties();
    this.validator.elementAttributesProcessed(fullName,
                        extraAttributes,
                        this.reader.getSystemID(),
                        this.reader.getLineNr());
    Enumeration enm = extraAttributes.keys();
    while (enm.hasMoreElements()) {
     String key = (String) enm.nextElement();
     String value = extraAttributes.getProperty(key);
     attrNames.addElement(key);
     attrValues.addElement(value);
     attrTypes.addElement("CDATA");
    }
    for (int i = 0; i < attrNames.size(); i++) {
     String key = (String) attrNames.elementAt(i);
     String value = (String) attrValues.elementAt(i);
     String type = (String) attrTypes.elementAt(i);
     if (key.equals("xmlns")) {
      defaultNamespace = value;
     } else if (key.startsWith("xmlns:")) {
      namespaces.put(key.substring(6), value);
     }
    }
    if (prefix == null) {
     this.builder.startElement(name, prefix, defaultNamespace,
                   this.reader.getSystemID(),
                   this.reader.getLineNr());
    } else {
     this.builder.startElement(name, prefix,
                   namespaces.getProperty(prefix),
                   this.reader.getSystemID(),
                   this.reader.getLineNr());
    }
    for (int i = 0; i < attrNames.size(); i++) {
     String key = (String) attrNames.elementAt(i);
     if (key.startsWith("xmlns")) {
      continue;
     }
     String value = (String) attrValues.elementAt(i);
     String type = (String) attrTypes.elementAt(i);
     colonIndex = key.indexOf(':');
     if (colonIndex > 0) {
      String attPrefix = key.substring(0, colonIndex);
      key = key.substring(colonIndex + 1);
      this.builder.addAttribute(key, attPrefix,
                    namespaces.getProperty(attPrefix),
                    value, type);
     } else {
      this.builder.addAttribute(key, null, null, value, type);
     }
    }
    if (prefix == null) {
     this.builder.elementAttributesProcessed(name, prefix,
                         defaultNamespace);
    } else {
     this.builder.elementAttributesProcessed(name, prefix,
                         namespaces
                           .getProperty(prefix));
    }
    if (ch == '/') {
     if (this.reader.read() != '>') {
      XMLUtil.errorExpectedInput(reader.getSystemID(),
                     reader.getLineNr(),
                     "`>'");
     }
     this.validator.elementEnded(name,
                   this.reader.getSystemID(),
                   this.reader.getLineNr());
     if (prefix == null) {
      this.builder.endElement(name, prefix, defaultNamespace);
     } else {
      this.builder.endElement(name, prefix,
                  namespaces.getProperty(prefix));
     }
     return;
    }
    StringBuffer buffer = new StringBuffer(16);
    for (;;) {
     buffer.setLength(0);
     String str;
     for (;;) {
      XMLUtil.skipWhitespace(this.reader, buffer);
      str = XMLUtil.read(this.reader, '&');
      if ((str.charAt(0) == '&') && (str.charAt(1) != '#')) {
         XMLUtil.processEntity(str, this.reader,
                   this.entityResolver);
      } else {
         break;
      }
     }
     if (str.charAt(0) == '<') {
      str = XMLUtil.read(this.reader, '\0');
      if (str.charAt(0) == '/') {
         XMLUtil.skipWhitespace(this.reader, null);
         str = XMLUtil.scanIdentifier(this.reader);
         if (! str.equals(fullName)) {
          XMLUtil.errorWrongClosingTag(reader.getSystemID(),
                         reader.getLineNr(),
                         name, str);
         }
         XMLUtil.skipWhitespace(this.reader, null);
         if (this.reader.read() != '>') {
          XMLUtil.errorClosingTagNotEmpty(reader.getSystemID(),
                          reader.getLineNr());
         }
         this.validator.elementEnded(fullName,
                       this.reader.getSystemID(),
                       this.reader.getLineNr());
         if (prefix == null) {
           this.builder.endElement(name, prefix, defaultNamespace);
         } else {
           this.builder.endElement(name, prefix,
                       namespaces.getProperty(prefix));
         }
         break;
      } else { // <[^/]
         this.reader.unread(str.charAt(0));
         this.scanSomeTag(true, //CDATA allowed
                defaultNamespace,
                (Properties) namespaces.clone());
      }
     } else { // [^<]
      if (str.charAt(0) == '&') {
         ch = XMLUtil.processCharLiteral(str);
         buffer.append(ch);
      } else {
         reader.unread(str.charAt(0));
      }
      this.validator.PCDataAdded(this.reader.getSystemID(),
                     this.reader.getLineNr());
      Reader r = new ContentReader(this.reader,
                     this.entityResolver,
                     buffer.toString());
      this.builder.addPCData(r, this.reader.getSystemID(),
                   this.reader.getLineNr());
      r.close();
###
459, getResolver, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 162, 164
5
/**
  * Returns the entity resolver.
  *
  * @return the non-null resolver
  */
3
   public IXMLEntityResolver getResolver()
   {
    return this.entityResolver;
###
460, finalize, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 91, 98
3
/**
  * Cleans up the object when it's destroyed.
  */
8
   protected void finalize()
    throws Throwable
   {
    this.builder = null;
    this.reader = null;
    this.entityResolver = null;
    this.validator = null;
    super.finalize();
###
461, processDocType, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 393, 445
6
/**
  * Processes a document type declaration.
  *
  * @throws java.lang.Exception
  *    if an error occurred reading or parsing the data
  */
49
   protected void processDocType()
    throws Exception
   {
    if (! XMLUtil.checkLiteral(this.reader, "OCTYPE")) {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "<!DOCTYPE");
     return;
    }
    XMLUtil.skipWhitespace(this.reader, null);
    String systemID = null;
    StringBuffer publicID = new StringBuffer();
    String rootElement = XMLUtil.scanIdentifier(this.reader);
    XMLUtil.skipWhitespace(this.reader, null);
    char ch = this.reader.read();
    if (ch == 'P') {
     systemID = XMLUtil.scanPublicID(publicID, reader);
     XMLUtil.skipWhitespace(this.reader, null);
     ch = this.reader.read();
    } else if (ch == 'S') {
     systemID = XMLUtil.scanSystemID(reader);
     XMLUtil.skipWhitespace(this.reader, null);
     ch = this.reader.read();
    }
    if (ch == '[') {
     this.validator.parseDTD(publicID.toString(),
                 this.reader,
                 this.entityResolver,
                 false);
     XMLUtil.skipWhitespace(this.reader, null);
     ch = this.reader.read();
    }
    if (ch != '>') {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "`>'");
    }
// BEGIN PATCH W. Randelshofer Don't read DTD
  if (false) {
    if (systemID != null) {
     Reader reader = this.reader.openStream(publicID.toString(),
                        systemID);
     this.reader.startNewStream(reader);
     this.reader.setSystemID(systemID);
     this.reader.setPublicID(publicID.toString());
     this.validator.parseDTD(publicID.toString(),
                 this.reader,
                 this.entityResolver,
                 true);
###
462, StdXMLParser, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 79, 84
3
/**
  * Creates a new parser.
  */
6
   public StdXMLParser()
   {
    this.builder = null;
    this.validator = null;
    this.reader = null;
    this.entityResolver = new XMLEntityResolver();
###
463, scanData, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 223, 253
9
/**
  * Scans the XML data for elements.
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
 --------------
// throw new XMLException(e);
 --------------
28
   protected void scanData()
    throws Exception
   {
    while ((! this.reader.atEOF()) && (this.builder.getResult() == null)) {
     String str = XMLUtil.read(this.reader, '&');
     char ch = str.charAt(0);
     if (ch == '&') {
      XMLUtil.processEntity(str, this.reader, this.entityResolver);
      continue;
     }
     switch (ch) {
      case '<':
         this.scanSomeTag(false, // don't allow CDATA
                null,  // no default namespace
                new Properties());
         break;
      case ' ':
      case '\t':
      case '\r':
      case '\n':
         // skip whitespace
         break;
      default:
         XMLUtil.errorInvalidInput(reader.getSystemID(),
                     reader.getLineNr(),
                     "`" + ch + "' (0x"
                     + Integer.toHexString((int) ch)
                     + ')');
###
464, getValidator, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 140, 142
5
/**
  * Returns the validator that validates the XML data.
  *
  * @return the validator
  */
3
   public IXMLValidator getValidator()
   {
    return this.validator;
###
465, PasteAction, PasteAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/PasteAction.java, 46, 47
1
/** Creates a new instance which acts on the currently focused component. */
2
  public PasteAction() {
    this(null);
###
466, processCDATA, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 369, 383
6
/**
  * Processes a CDATA section.
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
14
   protected void processCDATA()
    throws Exception
   {
    if (! XMLUtil.checkLiteral(this.reader, "CDATA[")) {
     XMLUtil.errorExpectedInput(reader.getSystemID(),
                  reader.getLineNr(),
                  "<![[CDATA[");
    }
    this.validator.PCDataAdded(this.reader.getSystemID(),
                 this.reader.getLineNr());
    Reader reader = new CDATAReader(this.reader);
    this.builder.addPCData(reader, this.reader.getSystemID(),
               this.reader.getLineNr());
    reader.close();
###
467, processPI, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 305, 317
6
/**
  * Processes a "processing instruction".
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
11
   protected void processPI()
    throws Exception
   {
    XMLUtil.skipWhitespace(this.reader, null);
    String target = XMLUtil.scanIdentifier(this.reader);
    XMLUtil.skipWhitespace(this.reader, null);
    Reader reader = new PIReader(this.reader);
    if (! target.equalsIgnoreCase("xml")) {
     this.builder.newProcessingInstruction(target, reader);
    }
    reader.close();
###
468, parse, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 198, 211
8
/**
  * Parses the data and lets the builder create the logical data structure.
  *
  * @return the logical structure built by the builder
  *
  * @throws net.n3.nanoxml.XMLException
  *    if an error occurred reading or parsing the data
  */
14
   public Object parse()
    throws XMLException
   {
    try {
     this.builder.startBuilding(this.reader.getSystemID(),
                  this.reader.getLineNr());
     this.scanData();
     return this.builder.getResult();
    } catch (XMLException e) {
     throw e;
    } catch (Exception e) {
      XMLException error = new XMLException(e);
      error.initCause(e);
      throw error;
###
469, getReader, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 184, 186
5
/**
  * Returns the reader from which the parser retrieves its data.
  *
  * @return the reader
  */
3
   public IXMLReader getReader()
   {
    return this.reader;
###
470, getBuilder, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 118, 120
5
/**
  * Returns the builder which creates the logical structure of the XML data.
  *
  * @return the builder
  */
3
   public IXMLBuilder getBuilder()
   {
    return this.builder;
###
471, setBuilder, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 107, 109
5
/**
  * Sets the builder which creates the logical structure of the XML data.
  *
  * @param builder the non-null builder
  */
3
   public void setBuilder(IXMLBuilder builder)
   {
    this.builder = builder;
###
472, processSpecialTag, StdXMLParser, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java, 329, 358
8
/**
  * Processes a tag that starts with a bang (&lt;!...&gt;).
  *
  * @param allowCDATA true if CDATA sections are allowed at this point
  *
  * @throws java.lang.Exception
  *   if something went wrong
  */
25
   protected void processSpecialTag(boolean allowCDATA)
    throws Exception
   {
    String str = XMLUtil.read(this.reader, '&');
    char ch = str.charAt(0);
    if (ch == '&') {
     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),
                     reader.getLineNr(),
                     str);
    }
    switch (ch) {
     case '[':
      if (allowCDATA) {
         this.processCDATA();
      } else {
         XMLUtil.errorUnexpectedCDATA(reader.getSystemID(),
                      reader.getLineNr());
      }
      return;
     case 'D':
      this.processDocType();
      return;
     case '-':
      XMLUtil.skipComment(this.reader);
      return;
###
473, installViewListeners, RedoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/RedoAction.java, 87, 92
3
/**
   * Installs listeners on the view object.
   */
6
  @Override
  protected void installViewListeners(View p) {
    super.installViewListeners(p);
    Action redoActionInView = p.getActionMap().get(ID);
    if (redoActionInView != null && redoActionInView != this) {
      redoActionInView.addPropertyChangeListener(redoActionPropertyListener);
###
474, RedoAction, RedoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/RedoAction.java, 58, 60
1
/** Creates a new instance. */
3
  public RedoAction(Application app, View view) {
    super(app, view);
    labels.configureAction(this, ID);
###
475, createDefaultXMLParser, XMLParserFactory, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLParserFactory.java, 71, 85
15
/**
   * Creates a default parser.
   *
   * @see #DEFAULT_CLASS
   * @see #CLASS_KEY
   *
   * @return the non-null parser.
   *
   * @throws java.lang.ClassNotFoundException
   *    if the class of the parser or validator could not be found.
   * @throws java.lang.InstantiationException
   *    if the parser could not be created
   * @throws java.lang.IllegalAccessException
   *    if the parser could not be created
   */
15
  public static IXMLParser createDefaultXMLParser()
  throws ClassNotFoundException,
      InstantiationException,
      IllegalAccessException {
    // BEGIN PATCH W. Randelshofer catch AccessControlException
    String className = XMLParserFactory.DEFAULT_CLASS;
    try {
      className = System.getProperty(XMLParserFactory.CLASS_KEY,
          XMLParserFactory.DEFAULT_CLASS);
    } catch (AccessControlException e) {
      // do nothing
    }
    // END PATCH W. Randelshofer catch AccessControlException
    return XMLParserFactory.createXMLParser(className,
        new StdXMLBuilder());
###
476, createDefaultXMLParser, XMLParserFactory, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLParserFactory.java, 106, 119
17
/**
   * Creates a default parser.
   *
   * @see #DEFAULT_CLASS
   * @see #CLASS_KEY
   *
   * @param builder the XML builder.
   *
   * @return the non-null parser.
   *
   * @throws java.lang.ClassNotFoundException
   *    if the class of the parser could not be found.
   * @throws java.lang.InstantiationException
   *    if the parser could not be created
   * @throws java.lang.IllegalAccessException
   *    if the parser could not be created
   */
14
  public static IXMLParser createDefaultXMLParser(IXMLBuilder builder)
  throws ClassNotFoundException,
      InstantiationException,
      IllegalAccessException {
    // BEGIN PATCH W. Randelshofer catch AccessControlException
    String className = XMLParserFactory.DEFAULT_CLASS;
    try {
     className = System.getProperty(XMLParserFactory.CLASS_KEY,
        XMLParserFactory.DEFAULT_CLASS);
     } catch (AccessControlException e) {
       // do nothing
     }
    // END PATCH W. Randelshofer catch AccessControlException
    return XMLParserFactory.createXMLParser(className, builder);
###
477, installViewListeners, UndoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/UndoAction.java, 83, 87
3
/**
   * Installs listeners on the view object.
   */
5
  @Override protected void installViewListeners(View p) {
    super.installViewListeners(p);
    Action undoActionInView = p.getActionMap().get(ID);
    if (undoActionInView != null && undoActionInView != this) {
    undoActionInView.addPropertyChangeListener(redoActionPropertyListener);
###
478, XMLAttribute, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 82, 92
9
/**
  * Creates a new attribute.
  *
  * @param fullName  the non-null full name
  * @param name    the non-null short name
  * @param namespace the namespace URI, which may be null
  * @param value   the value of the attribute
  * @param type    the type of the attribute
  */
11
   XMLAttribute(String fullName,
        String name,
        String namespace,
        String value,
        String type)
   {
    this.fullName = fullName;
    this.name = name;
    this.namespace = namespace;
    this.value = value;
    this.type = type;
###
480, UndoAction, UndoAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/UndoAction.java, 56, 58
1
/** Creates a new instance. */
3
  public UndoAction(Application app, View view) {
    super(app, view);
    labels.configureAction(this, ID);
###
481, setValue, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 137, 139
5
/**
  * Sets the value of the attribute.
  *
  * @param value the new value.
  */
3
   void setValue(String value)
   {
    this.value = value;
###
483, getValue, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 126, 128
3
/**
  * Returns the value of the attribute.
  */
3
   String getValue()
   {
    return this.value;
###
485, getName, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 108, 110
3
/**
  * Returns the short name of the attribute.
  */
3
   String getName()
   {
    return this.name;
###
487, getNamespace, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 117, 119
3
/**
  * Returns the namespace of the attribute.
  */
3
   String getNamespace()
   {
    return this.namespace;
###
489, getFullName, XMLAttribute, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java, 99, 101
3
/**
  * Returns the full name of the attribute.
  */
3
   String getFullName()
   {
    return this.fullName;
###
490, ClearSelectionAction, ClearSelectionAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/ClearSelectionAction.java, 46, 47
1
/** Creates a new instance which acts on the currently focused component. */
2
  public ClearSelectionAction() {
    this(null);
###
493, DuplicateAction, DuplicateAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DuplicateAction.java, 45, 46
1
/** Creates a new instance which acts on the currently focused component. */
2
  public DuplicateAction() {
    this(null);
###
496, CopyAction, CopyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CopyAction.java, 54, 57
5
/** Creates a new instance which acts on the specified component.
   *
   * @param target The target of the action. Specify null for the currently
   * focused component.
   */
4
  public CopyAction(JComponent target) {
    super(target);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
497, buildMessage, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 164, 186
11
/**
  * Builds the exception message
  *
  * @param systemID   the system ID from where the data came
  * @param lineNr     the line number in the XML data where the exception
  *           occurred.
  * @param e      the encapsulated exception.
  * @param msg      the message of the exception.
  * @param reportParams true if the systemID, lineNr and e params need to be
  *           appended to the message
  */
19
   private static String buildMessage(String  systemID,
                    int     lineNr,
                    Exception e,
                    String  msg,
                    boolean   reportParams)
   {
    String str = msg;
    if (reportParams) {
     if (systemID != null) {
      str += ", SystemID='" + systemID + "'";
     }
     if (lineNr >= 0) {
      str += ", Line=" + lineNr;
     }
     if (e != null) {
      str += ", Exception: " + e;
     }
    }
    return str;
###
498, CopyAction, CopyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CopyAction.java, 45, 46
1
/** Creates a new instance which acts on the currently focused component. */
2
  public CopyAction() {
    this(null);
###
499, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 118, 122
9
/**
  * Creates a new exception.
  *
  * @param systemID the system ID of the XML data where the exception
  *         occurred
  * @param lineNr   the line number in the XML data where the exception
  *         occurred.
  * @param msg    the message of the exception.
  */
5
   public XMLException(String systemID,
             int  lineNr,
             String msg)
   {
    this(systemID, lineNr, null, msg, true);
###
500, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 101, 105
9
/**
  * Creates a new exception.
  *
  * @param systemID the system ID of the XML data where the exception
  *         occurred
  * @param lineNr   the line number in the XML data where the exception
  *         occurred.
  * @param e    the encapsulated exception.
  */
5
   public XMLException(String systemID,
             int  lineNr,
             Exception e)
   {
    this(systemID, lineNr, e, "Nested Exception", true);
###
501, printStackTrace, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 253, 259
5
/**
  * Dumps the exception stack to an output stream.
  *
  * @param stream the output stream
  */
6
   public void printStackTrace(PrintStream stream)
   {
    super.printStackTrace(stream);
    if (this.encapsulatedException != null) {
     stream.println("*** Nested Exception:");
     this.encapsulatedException.printStackTrace(stream);
###
502, getSystemID, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 206, 208
4
/**
  * Returns the system ID of the XML data where the exception occurred.
  * If there is no system ID known, null is returned.
  */
3
   public String getSystemID()
   {
    return this.systemID;
###
503, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 75, 77
5
/**
  * Creates a new exception.
  *
  * @param msg the message of the exception.
  */
3
   public XMLException(String msg)
   {
    this(null, -1, null, msg, false);
###
504, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 137, 149
11
/**
  * Creates a new exception.
  *
  * @param systemID   the system ID from where the data came
  * @param lineNr     the line number in the XML data where the exception
  *           occurred.
  * @param e      the encapsulated exception.
  * @param msg      the message of the exception.
  * @param reportParams true if the systemID, lineNr and e params need to be
  *           appended to the message
  */
13
   public XMLException(String  systemID,
             int     lineNr,
             Exception e,
             String  msg,
             boolean   reportParams)
   {
    super(XMLException.buildMessage(systemID, lineNr, e, msg,
                    reportParams));
    this.systemID = systemID;
    this.lineNr = lineNr;
    this.encapsulatedException = e;
    this.msg = XMLException.buildMessage(systemID, lineNr, e, msg,
                       reportParams);
###
506, DeleteAction, DeleteAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DeleteAction.java, 54, 55
1
/** Creates a new instance which acts on the currently focused component. */
2
  public DeleteAction() {
    this(null);
###
507, contains, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 80, 81
3
/**
   * Tests if a point is contained in the connector.
   */
2
  public boolean contains(Point2D.Double p) {
    return getOwner().contains(p);
###
508, getException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 226, 228
4
/**
  * Returns the encapsulated exception, or null if no exception is
  * encapsulated.
  */
3
   public Exception getException()
   {
    return this.encapsulatedException;
###
509, DeleteAction, DeleteAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DeleteAction.java, 63, 80
5
/** Creates a new instance which acts on the specified component.
   *
   * @param target The target of the action. Specify null for the currently
   * focused component.
   */
17
  public DeleteAction(JComponent target) {
    super(ID);
    this.target = target;
    if (target != null) {
      // Register with a weak reference on the JComponent.
      propertyHandler = new PropertyChangeListener() {
        @Override
        public void propertyChange(PropertyChangeEvent evt) {
          if (evt.getPropertyName().equals("enabled")) {
            setEnabled((Boolean) evt.getNewValue());
          }
        }
      };
      target.addPropertyChangeListener(new WeakPropertyChangeListener(propertyHandler));
    }
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
510, AbstractConnector, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 63, 64
3
/**
   * Constructs a connector with the given owner figure.
   */
2
  public AbstractConnector(Figure owner) {
    this.owner = owner;
###
511, printStackTrace, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 237, 243
5
/**
  * Dumps the exception stack to a print writer.
  *
  * @param writer the print writer
  */
6
   public void printStackTrace(PrintWriter writer)
   {
    super.printStackTrace(writer);
    if (this.encapsulatedException != null) {
     writer.println("*** Nested Exception:");
     this.encapsulatedException.printStackTrace(writer);
###
512, findPoint, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 97, 98
5
/**
   * Gets the connection point. Override when the connector
   * does not need to distinguish between the start and end
   * point of a connection.
   */
2
  protected Point2D.Double findPoint(ConnectionFigure connection) {
    return Geom.center(getBounds());
###
513, finalize, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 193, 198
3
/**
  * Cleans up the object when it's destroyed.
  */
6
   protected void finalize()
    throws Throwable
   {
    this.systemID = null;
    this.encapsulatedException = null;
    super.finalize();
###
514, getOwner, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 104, 105
3
/**
   * Gets the connector's owner.
   */
2
  public Figure getOwner() {
    return owner;
###
515, XMLException, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 86, 88
5
/**
  * Creates a new exception.
  *
  * @param e the encapsulated exception.
  */
3
   public XMLException(Exception e)
   {
    this(null, -1, e, "Nested Exception", false);
###
516, setOwner, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 110, 111
3
/**
   * Sets the connector's owner.
   */
2
  protected void setOwner(Figure newValue) {
    owner = newValue;
###
517, printStackTrace, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 267, 273
3
/**
  * Dumps the exception stack to System.err.
  */
6
   public void printStackTrace()
   {
    super.printStackTrace();
    if (this.encapsulatedException != null) {
     System.err.println("*** Nested Exception:");
     this.encapsulatedException.printStackTrace();
###
518, AbstractConnector, AbstractConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java, 57, 58
5
/**
   * Constructs a connector that has no owner. It is only
   * used internally to resurrect a connectors from a
   * StorableOutput. It should never be called directly.
   */
2
  public AbstractConnector() {
    owner = null;
###
519, getLineNr, XMLException, JHotDraw741
jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java, 216, 218
4
/**
  * Returns the line number in the XML data where the exception occurred.
  * If there is no line number known, -1 is returned.
  */
3
   public int getLineNr()
   {
    return this.lineNr;
###
521, CutAction, CutAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CutAction.java, 45, 46
1
/** Creates a new instance which acts on the currently focused component. */
2
  public CutAction() {
    this(null);
###
522, contains, LocatorConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/LocatorConnector.java, 69, 70
3
/**
   * Tests if a point is contained in the connector.
   */
2
  @Override public boolean contains(Point2D.Double p) {
    return getBounds().contains(p);
###
525, ZoomEditorAction, ZoomEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ZoomEditorAction.java, 37, 38
3
/**
   * Creates a new instance.
   */
2
  public ZoomEditorAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {
    this(editor, scaleFactor, button, true);
###
527, chop, ChopDiamondConnector, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/connector/ChopDiamondConnector.java, 44, 119
3
/**
   * Return an appropriate connection point on the edge of a diamond figure
   */
76
  protected Point2D.Double chop(Figure target, Point2D.Double from) {
    target = getConnectorTarget(target);
    Rectangle2D.Double r = target.getBounds();
    
    if (target.get(DiamondFigure.IS_QUADRATIC)) {
      double side = Math.max(r.width, r.height);
      r.x -= (side - r.width) / 2;
      r.y -= (side - r.height) / 2;
      r.width = r.height = side;
    }
    double growx;
    double growy;
    // FIXME - This code is wrong. Copy correct code from DiamondFigure.
    switch (target.get(STROKE_PLACEMENT)) {
      case INSIDE : {
        growx = growy = 0f;
        break;
      }
      case OUTSIDE : {
        double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);
        double scale = getStrokeTotalWidth(target) * 2d / lineLength;
        growx = scale * r.height;
        growy = scale * r.width;
        //growy = getStrokeTotalWidth() * SQRT2;
        break;
      }
      case CENTER :
      default :
        double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);
        double scale = getStrokeTotalWidth(target) / lineLength;
        growx = scale * r.height;
        growy = scale * r.width;
        //growx = growy = getStrokeTotalWidth() / 2d * SQRT2;
        break;
    }
    Geom.grow(r, growx, growy);
    
    // Center point
    Point2D.Double c1 = new Point2D.Double(r.x + r.width/2, r.y + (r.height/2));
    Point2D.Double p2 = new Point2D.Double(r.x + r.width/2, r.y + r.height);
    Point2D.Double p4 = new Point2D.Double(r.x + r.width/2, r.y);
    
    // If overlapping, just return the opposite corners
    if (r.contains(from)) {
      if (from.y > r.y && from.y < (r.y +r.height/2)) {
        return p2;
      } else {
        return p4;
      }
    }
    
    // Calculate angle to determine quadrant
    double ang = Geom.pointToAngle(r, from);
    
    // Dermine line points
    Point2D.Double p1 = new Point2D.Double(r.x + r.width  , r.y + (r.height/2));
    Point2D.Double p3 = new Point2D.Double(r.x      , r.y + (r.height/2));
    Point2D.Double rp = null; // This will be returned
    
    // Get the intersection with edges
    if (ang > 0 && ang < 1.57) {
      rp = Geom.intersect(p1.x, p1.y, p2.x, p2.y, c1.x, c1.y, from.x, from.y);
    } else if (ang > 1.575 && ang < 3.14) {
      rp = Geom.intersect(p2.x, p2.y, p3.x, p3.y, c1.x, c1.y, from.x, from.y);
    } else if (ang > -3.14 && ang < -1.575) {
      rp = Geom.intersect(p3.x, p3.y, p4.x, p4.y, c1.x, c1.y, from.x, from.y);
    } else if (ang > -1.57 && ang < 0) {
      rp = Geom.intersect(p4.x, p4.y, p1.x, p1.y, c1.x, c1.y, from.x, from.y);
    }
    
    // No proper edge found, we should send one of four corners
    if (rp == null) {
      rp = Geom.angleToPoint(r, ang);
    }
    
    return rp;
###
529, configureJCheckBoxMenuItem, ActionUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/ActionUtil.java, 59, 69
3
/**
   * Configures a JCheckBoxMenuItem for an Action.
   */
11
  public static void configureJCheckBoxMenuItem(final JCheckBoxMenuItem mi, final Action a) {
    mi.setSelected((Boolean) a.getValue(ActionUtil.SELECTED_KEY));
    PropertyChangeListener propertyHandler = new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals(ActionUtil.SELECTED_KEY)) {
          mi.setSelected((Boolean) a.getValue(ActionUtil.SELECTED_KEY));
        }
      }
    };
    a.addPropertyChangeListener(propertyHandler);
    mi.putClientProperty("actionPropertyHandler", propertyHandler);
###
530, PrintApplicationFileAction, PrintApplicationFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/PrintApplicationFileAction.java, 52, 54
1
/** Creates a new instance. */
3
  public PrintApplicationFileAction(Application app) {
    super(app, null);
    putValue(Action.NAME, "OSX Print File");
###
531, ExitAction, ExitAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/ExitAction.java, 52, 55
1
/** Creates a new instance. */
4
  public ExitAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
532, actionPerformed, OpenApplicationFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/OpenApplicationFileAction.java, 65, 88
6
/**
   * Opens a new view.
   * <p>
   * The file name is passed in the action command of the action event.
   *
   */
22
  @Override
  public void actionPerformed(ActionEvent evt) {
    final Application app = getApplication();
    final String filename = evt.getActionCommand();
    if (app.isEnabled()) {
      app.setEnabled(false);
      // Search for an empty view
      View emptyView = app.getActiveView();
      if (emptyView == null
          || emptyView.getURI() != null
          || emptyView.hasUnsavedChanges()) {
        emptyView = null;
      }
      final View p;
      if (emptyView == null) {
        p = app.createView();
        app.add(p);
        app.show(p);
      } else {
        p = emptyView;
      }
      openView(p, new File(filename).toURI());
###
533, OpenApplicationFileAction, OpenApplicationFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/OpenApplicationFileAction.java, 54, 56
1
/** Creates a new instance. */
3
  public OpenApplicationFileAction(Application app) {
    super(app);
    putValue(Action.NAME, "OSX Open File");
###
534, installViewListeners, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 122, 123
3
/**
   * Installs listeners on the view object.
   */
2
  protected void installViewListeners(View p) {
    p.addPropertyChangeListener(viewListener);
###
535, isEnabled, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 157, 161
8
/**
   * Returns true if the action is enabled.
   * The enabled state of the action depends on the state that has been set
   * using setEnabled() and on the enabled state of the application.
   *
   * @return true if the action is enabled, false otherwise
   * @see Action#isEnabled
   */
5
  @Override
  public boolean isEnabled() {
    return getActiveView() != null
        && getActiveView().isEnabled()
        && this.enabled;
###
536, updateView, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 79, 91
4
/**
   * Updates the listeners of this action depending on the current view
   * of the application.
   */
13
  protected void updateView(View oldValue, View newValue) {
    // We only need to do this, if the view has not been explicitly set
    if (view == null) {
      if (oldValue != null) {
        uninstallViewListeners(oldValue);
      }
      if (newValue != null) {
        installViewListeners(newValue);
      }
      firePropertyChange(VIEW_PROPERTY, oldValue, newValue);
      updateEnabled(oldValue != null && oldValue.isEnabled(),
          newValue != null && newValue.isEnabled());
      updateView();
###
537, setPropertyName, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 98, 101
3
/**
   * Sets the property name.
   */
4
  protected void setPropertyName(String name) {
    this.propertyName = name;
    if (name != null) {
      updateView();
###
538, getPropertyName, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 108, 109
3
/**
   * Gets the property name.
   */
2
  protected String getPropertyName() {
    return propertyName;
###
539, uninstallViewListeners, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 129, 130
3
/**
   * Uninstalls listeners on the view object.
   */
2
  protected void uninstallViewListeners(View p) {
    p.removePropertyChangeListener(viewListener);
###
540, AbstractViewAction, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 63, 72
1
/** Creates a new instance which acts on the specified view of the application. */
10
  public AbstractViewAction(Application app, View view) {
    this.app = app;
    this.view = view;
    this.enabled = true;
    if (view == null) {
      app.addPropertyChangeListener(applicationListener);
    } else {
      view.addPropertyChangeListener(viewListener);
    }
    updateView(null, getActiveView());
###
541, updateEnabled, AbstractViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java, 137, 138
4
/**
   * Updates the enabled state of this action depending on the new enabled
   * state of the view.
   */
2
  protected void updateEnabled(boolean oldValue, boolean newValue) {
    firePropertyChange("enabled", oldValue, newValue && isEnabled());
###
543, AboutAction, AboutAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/app/AboutAction.java, 43, 46
1
/** Creates a new instance. */
4
  public AboutAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
544, AttributeChangeEdit, AttributeChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/AttributeChangeEdit.java, 34, 38
1
/** Creates a new instance. */
5
  public AttributeChangeEdit(Figure owner, AttributeKey<T> name, T oldValue, T newValue) {
    this.owner = owner;
    this.name = name;
    this.oldValue = oldValue;
    this.newValue = newValue;
###
545, CompositeFigureEdit, CompositeFigureEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java, 57, 59
5
/**
   * Creates new CompositeFigureEdit which uses the specified presentation name.
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeFigureEdit(Figure figure, String presentationName) {
    super(presentationName);
    this.figure = figure;
###
546, CompositeFigureEdit, CompositeFigureEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java, 47, 49
5
/**
   * Creates new CompositeFigureEdit which uses the specified significance.
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeFigureEdit(Figure figure, boolean isSignificant) {
    super(isSignificant);
    this.figure = figure;
###
547, CompositeFigureEdit, CompositeFigureEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java, 38, 39
6
/**
   * Creates a new {@code CompositeFigureEdit} which uses
   * CompoundEdit.getPresentatioName and is significant.
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public CompositeFigureEdit(Figure figure) {
    this.figure = figure;
###
548, ArrowTip, ArrowTip, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/ArrowTip.java, 47, 48
4
/**
   * Constructs an arrow tip with the specified angle and outer and inner 
   * radius.
   */
2
  public ArrowTip(double angle, double outerRadius, double innerRadius) {
    this(angle, outerRadius, innerRadius, true, false, true);
###
549, ArrowTip, ArrowTip, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/ArrowTip.java, 54, 58
3
/**
   * Constructs an arrow tip with the specified parameters.
   */
5
  public ArrowTip(double angle, double outerRadius, double innerRadius, boolean isFilled, boolean isStroked, boolean isSolid) {
    super(isFilled, isStroked, isSolid);
    this.angle = angle;
    this.outerRadius = outerRadius;
    this.innerRadius = innerRadius;
###
550, AbstractLineDecoration, AbstractLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java, 46, 49
3
/**
   * Constructs an arrow tip with the given angle and radius.
   */
4
  public AbstractLineDecoration(boolean isFilled, boolean isStroked, boolean isSolid) {
    this.isFilled = isFilled;
    this.isStroked = isStroked;
    this.isSolid = isSolid;
###
551, draw, AbstractLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java, 66, 85
4
/**
   * Draws the arrow tip in the direction specified by the given two
   * Points. (template method)
   */
20
  public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {
    Path2D.Double path = getTransformedDecoratorPath(f, p1, p2);
    Color color;
    if (isFilled) {
      if (isSolid) {
        color = f.get(STROKE_COLOR);
      } else {
        color = f.get(FILL_COLOR);
      }
      if (color != null) {
        g.setColor(color);
        g.fill(path);
      }
    }
    if (isStroked) {
      color = f.get(STROKE_COLOR);
      if (color != null) {
        g.setColor(color);
        g.setStroke(AttributeKeys.getStroke(f));
        g.draw(path);
###
552, getDrawingArea, AbstractLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java, 93, 114
3
/**
   * Returns the drawing area of the decorator.
   */
22
  public Rectangle2D.Double getDrawingArea(Figure f, Point2D.Double p1, Point2D.Double p2) {
    Path2D.Double path = getTransformedDecoratorPath(f, p1, p2);
    Rectangle2D b = path.getBounds2D();
    Rectangle2D.Double area = new Rectangle2D.Double(b.getX(), b.getY(), b.getWidth(), b.getHeight());
    
    if (isStroked) {
      double strokeWidth = f.get(STROKE_WIDTH);
      int strokeJoin = f.get(STROKE_JOIN);
      double miterLimit = (f.get(STROKE_MITER_LIMIT) * strokeWidth);
      
      double grow;
      if (strokeJoin == BasicStroke.JOIN_MITER) {
        grow  = (int) (1 + strokeWidth / 2 * miterLimit);
      } else {
        grow  = (int) (1 + strokeWidth / 2);
      }
      Geom.grow(area, grow, grow);
    } else {
      Geom.grow(area, 1, 1); // grow due to antialiasing
    }
    
    return area;
###
554, PerpendicularBar, PerpendicularBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java, 36, 37
3
/**
   * Constructs a perpendicular line with a height of 10.
   */
2
  public PerpendicularBar() {
    this(10);
###
555, PerpendicularBar, PerpendicularBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java, 43, 46
3
/**
   * Constructs a perpendicular line with the given height.
   */
3
  public PerpendicularBar(double height) {
    super(false, true, false);
    this.height = height;
###
556, getDecoratorPath, PerpendicularBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java, 53, 60
4
/**
   * Calculates the path of the decorator...a simple line
   * perpendicular to the figure.
   */
6
  protected Path2D.Double getDecoratorPath(Figure f) {
    Path2D.Double path = new Path2D.Double();
    double halfHeight = height / 2;
    path.moveTo(+halfHeight, 0);
    path.lineTo(-halfHeight, 0);
    return path;
###
560, CompositeLineDecoration, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 51, 53
3
/**
   * Constructs a composite line decoration with the two supplied decorations.
   */
3
  public CompositeLineDecoration(LineDecoration decoration1, LineDecoration decoration2) {
    addDecoration(decoration1);
    addDecoration(decoration2);
###
561, addDecoration, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 61, 63
5
/**
   * Add another line decoration into the composite line decoration.
   * The new decoration will be appended to the existing decorations
   * and is also the last drawn.
   */
3
  public void addDecoration(LineDecoration decoration) {
    if (decoration != null) {
      decorations.add(decoration);
###
562, draw, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 71, 73
4
/**
   * Draws the arrow tip in the direction specified by the given two
   * Points.. (template method)
   */
3
  public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {
    for (LineDecoration decoration : decorations) {
      decoration.draw(g, f, p1, p2);
###
563, getDrawingArea, CompositeLineDecoration, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java, 80, 91
3
/**
   * Returns the drawing area of the decorator.
   */
12
  public Rectangle2D.Double getDrawingArea(Figure f, Point2D.Double p1, Point2D.Double p2) {
    Rectangle2D.Double r = null;
    
    for (LineDecoration decoration : decorations) {
      Rectangle2D.Double aR = decoration.getDrawingArea(f, p1, p2);
      if (r == null)
        r = aR;
      else
        r.add(aR);
    }
    
    return r;
###
564, HandleMulticaster, HandleMulticaster, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/HandleMulticaster.java, 35, 37
1
/** Creates a new instance. */
3
  public HandleMulticaster(Handle handle) {
    this.handles = new LinkedList<Handle>();
    this.handles.add(handle);
###
571, getFigure, FigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java, 67, 68
3
/**
   *  Gets the changed figure
   */
2
  public Figure getFigure() {
    return (Figure) getSource();
###
572, FigureEvent, FigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java, 57, 61
3
/**
   * Constructs an event for the given source Figure.
   */
5
  public FigureEvent(Figure source, AttributeKey attribute, Object oldValue, Object newValue) {
    super(source);
    this.attribute = attribute;
    this.oldValue = oldValue;
    this.newValue = newValue;
###
573, FigureEvent, FigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java, 49, 51
4
/**
   * Constructs an event for the given source Figure.
   * @param invalidatedArea The bounds of the invalidated area on the drawing.
   */
3
  public FigureEvent(Figure source, Rectangle2D.Double invalidatedArea) {
    super(source);
    this.invalidatedArea = invalidatedArea;
###
574, HandleEvent, HandleEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/HandleEvent.java, 42, 44
1
/** Creates a new instance. */
3
  public HandleEvent(Handle src, Rectangle invalidatedArea) {
    super(src);
    this.invalidatedArea = invalidatedArea;
###
575, CompositeFigureEvent, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 47, 51
6
/**
   * Constructs an event for the provided CompositeFigure.
   * @param source The composite figure.
   * @param child The changed figure.
   * @param invalidatedArea The bounds of the invalidated area on the drawing.
   */
5
  public CompositeFigureEvent(CompositeFigure source, Figure child, Rectangle2D.Double invalidatedArea, int zIndex) {
    super(source);
    this.child = child;
    this.invalidatedArea = invalidatedArea;
    this.index = 0;
###
576, getInvalidatedArea, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 71, 72
3
/**
   *  Gets the bounds of the invalidated area on the drawing.
   */
2
  public Rectangle2D.Double getInvalidatedArea() {
    return invalidatedArea;
###
577, getChildFigure, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 64, 65
3
/**
   *  Gets the changed child figure.
   */
2
  public Figure getChildFigure() {
    return child;
###
578, getCompositeFigure, CompositeFigureEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java, 58, 59
3
/**
   *  Gets the changed drawing.
   */
2
  public CompositeFigure getCompositeFigure() {
    return (CompositeFigure) getSource();
###
582, OpenFileAction, OpenFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java, 56, 59
1
/** Creates a new instance. */
4
  public OpenFileAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
583, createDialog, OpenFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java, 222, 261
3
/** We implement JFileChooser.showDialog by ourselves, so that we can center
   * dialogs properly on screen on Mac OS X.
   */
35
  protected JDialog createDialog(URIChooser chooser, Component parent) throws HeadlessException {
    String title = chooser.getDialogTitle();
    if (chooser instanceof JFileChooser) {
      ((JFileChooser) chooser).getAccessibleContext().setAccessibleDescription(title);
    }
    JDialog dialog;
    Window window = (parent instanceof Window) ? (Window) parent : SwingUtilities.getWindowAncestor(parent);
    if (window instanceof Frame) {
      dialog = new JDialog((Frame) window, title, true);
    } else {
      dialog = new JDialog((Dialog) window, title, true);
    }
    dialog.setComponentOrientation(chooser.getComponent().getComponentOrientation());
    Container contentPane = dialog.getContentPane();
    contentPane.setLayout(new BorderLayout());
    contentPane.add(chooser.getComponent(), BorderLayout.CENTER);
    if (JDialog.isDefaultLookAndFeelDecorated()) {
      boolean supportsWindowDecorations =
          UIManager.getLookAndFeel().getSupportsWindowDecorations();
      if (supportsWindowDecorations) {
        dialog.getRootPane().setWindowDecorationStyle(JRootPane.FILE_CHOOSER_DIALOG);
      }
    }
    //dialog.pack();
    Preferences prefs = PreferencesUtil.userNodeForPackage(getApplication().getModel().getClass());
    PreferencesUtil.installFramePrefsHandler(prefs, "openChooser", dialog);
    /*
    if (window.getBounds().isEmpty()) {
    Rectangle screenBounds = window.getGraphicsConfiguration().getBounds();
    dialog.setLocation(screenBounds.x + (screenBounds.width - dialog.getWidth()) / 2, //
    screenBounds.y + (screenBounds.height - dialog.getHeight()) / 3);
    } else {
    dialog.setLocationRelativeTo(parent);
    }*/
    return dialog;
###
584, showDialog, OpenFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java, 185, 216
3
/** We implement JFileChooser.showDialog by ourselves, so that we can center
   * dialogs properly on screen on Mac OS X.
   */
29
  public int showDialog(URIChooser chooser, Component parent) {
    final Component finalParent = parent;
    final int[] returnValue = new int[1];
    final JDialog dialog = createDialog(chooser, finalParent);
    dialog.addWindowListener(new WindowAdapter() {
      @Override
      public void windowClosing(WindowEvent e) {
        returnValue[0] = JFileChooser.CANCEL_OPTION;
      }
    });
    chooser.addActionListener(new ActionListener() {
      @Override
      public void actionPerformed(ActionEvent e) {
        if (e.getActionCommand().equals("CancelSelection")) {
          returnValue[0] = JFileChooser.CANCEL_OPTION;
          dialog.setVisible(false);
        } else if (e.getActionCommand().equals("ApproveSelection")) {
          returnValue[0] = JFileChooser.APPROVE_OPTION;
          dialog.setVisible(false);
        }
      }
    });
    returnValue[0] = JFileChooser.ERROR_OPTION;
    chooser.rescanCurrentDirectory();
    dialog.setVisible(true);
    //chooser.firePropertyChange("JFileChooserDialogIsClosingProperty", dialog, null);
    dialog.removeAll();
    dialog.dispose();
    return returnValue[0];
###
585, LoadFileAction, LoadFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/LoadFileAction.java, 57, 60
1
/** Creates a new instance. */
4
  public LoadFileAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
586, ExportFileAction, ExportFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ExportFileAction.java, 53, 56
1
/** Creates a new instance. */
4
  public ExportFileAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
587, ClearRecentFilesMenuAction, ClearRecentFilesMenuAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ClearRecentFilesMenuAction.java, 42, 46
1
/** Creates a new instance. */
5
  public ClearRecentFilesMenuAction(Application app) {
    super(app);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
    updateEnabled();
###
588, installApplicationListeners, ClearRecentFilesMenuAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ClearRecentFilesMenuAction.java, 52, 57
3
/**
   * Installs listeners on the application object.
   */
6
  @Override protected void installApplicationListeners(Application app) {
    super.installApplicationListeners(app);
    if (applicationListener == null) {
      applicationListener = createApplicationListener();
    }
    app.addPropertyChangeListener(applicationListener);
###
589, fireHandleRequestRemove, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 124, 137
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireHandleRequestRemove(Rectangle invalidatedArea) {
    HandleEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == HandleListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new HandleEvent(this, invalidatedArea);
        }
        ((HandleListener) listeners[i + 1]).handleRequestRemove(event);
###
591, areaInvalidated, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 275, 276
7
/**
   * Sent when a region used by the figure needs to be repainted.
   * The implementation of this method assumes that the handle
   * is located on the bounds of the figure or inside the figure.
   * If the handle is located elsewhere this method must be reimpleted
   * by the subclass.
   */
2
  public void areaInvalidated(FigureEvent evt) {
    updateBounds();
###
593, addHandleListener, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 63, 64
3
/**
   * Adds a listener for this handle.
   */
2
  public void addHandleListener(HandleListener l) {
    listenerList.add(HandleListener.class, l);
###
594, removeHandleListener, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 70, 71
3
/**
   * Removes a listener for this handle.
   */
2
  public void removeHandleListener(HandleListener l) {
    listenerList.remove(HandleListener.class, l);
###
595, AbstractHandle, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 48, 53
1
/** Creates a new instance. */
6
  public AbstractHandle(Figure owner) {
    if (owner == null) {
      throw new IllegalArgumentException("owner must not be null");
    }
    this.owner = owner;
    owner.addFigureListener(this);
###
596, getCursor, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 310, 311
3
/**
   * Returns a cursor for the handle.
   */
2
  public Cursor getCursor() {
    return Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);
###
597, LoadRecentFileAction, LoadRecentFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/LoadRecentFileAction.java, 47, 50
1
/** Creates a new instance. */
4
  public LoadRecentFileAction(Application app, View view, URI uri) {
    super(app, view);
    this.uri = uri;
    putValue(Action.NAME, URIUtil.getName(uri));
###
598, fireHandleRequestSecondaryHandles, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 146, 159
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireHandleRequestSecondaryHandles() {
    HandleEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == HandleListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new HandleEvent(this, null);
        }
        ((HandleListener) listeners[i + 1]).handleRequestSecondaryHandles(event);
###
599, getToolTipText, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 379, 380
4
/**
   * Returns a tooltip for the specified location.
   * By default, AbstractHandle returns null.
   */
2
  public String getToolTipText(Point p) {
    return toolTipText;
###
600, draw, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 167, 170
3
/**
   * Draws this handle.
   */
4
  public void draw(Graphics2D g) {
    drawCircle(g,
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_FILL_COLOR),
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_STROKE_COLOR));
###
601, fireUndoableEditHappened, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 116, 117
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
2
  protected void fireUndoableEditHappened(UndoableEdit edit) {
    view.getDrawing().fireUndoableEditHappened(edit);
###
602, figureChanged, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 303, 304
3
/**
   * Sent when the bounds or shape of a figure has changed.
   */
2
  public void figureChanged(FigureEvent evt) {
    updateBounds();
###
605, fireAreaInvalidated, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 94, 107
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireAreaInvalidated(Rectangle invalidatedArea) {
    HandleEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == HandleListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new HandleEvent(this, invalidatedArea);
        }
        ((HandleListener) listeners[i + 1]).areaInvalidated(event);
###
606, isCombinableWith, AbstractHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java, 318, 319
4
/**
   * Returns true, if the given handle is an instance of the same
   * class or of a subclass of this handle,.
   */
2
  public boolean isCombinableWith(Handle handle) {
    return getClass().isAssignableFrom(handle.getClass());
###
607, trackStart, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 113, 119
3
/**
   * Disconnects the connection.
   */
7
  public void trackStart(Point anchor, int modifiersEx) {
    savedTarget = getTarget();
    start = anchor;
    savedLiner = getOwner().getLiner();
    getOwner().setLiner(null);
    //disconnect();
    fireHandleRequestSecondaryHandles();
###
608, getSource, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 103, 107
4
/**
   * Gets the side of the connection that is unaffected by
   * the change.
   */
5
  protected Connector getSource() {
    if (getTarget() == getOwner().getStartConnector()) {
      return getOwner().getEndConnector();
    }
    return getOwner().getStartConnector();
###
609, trackStep, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 125, 138
3
/**
   * Finds a new connectableConnector of the connection.
   */
14
  public void trackStep(Point anchor, Point lead, int modifiersEx) {
    Point2D.Double p = view.viewToDrawing(lead);
    view.getConstrainer().constrainPoint(p);
    connectableFigure = findConnectableFigure(p, view.getDrawing());
    if (connectableFigure != null) {
      Connector aTarget = findConnectionTarget(p, view.getDrawing());
      if (aTarget != null) {
        p = aTarget.getAnchor();
      }
    }
    getOwner().willChange();
    setLocation(p);
    getOwner().changed();
    repaintConnectors();
###
614, draw, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 209, 226
3
/**
   * Draws this handle.
   */
16
  @Override
  public void draw(Graphics2D g) {
    Graphics2D gg = (Graphics2D) g.create();
    gg.transform(view.getDrawingToViewTransform());
    for (Connector c : connectors) {
      c.draw(gg);
    }
    gg.dispose();
    if (getTarget() == null) {
      drawCircle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_STROKE_COLOR));
    } else {
      drawCircle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_STROKE_COLOR));
###
615, trackEnd, AbstractConnectionHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java, 145, 180
4
/**
   * Connects the figure to the new connectableConnector. If there is no
   * new connectableConnector the connection reverts to its original one.
   */
34
  public void trackEnd(Point anchor, Point lead, int modifiersEx) {
    ConnectionFigure f = getOwner();
    // Change node type
    if ((modifiersEx & (InputEvent.META_DOWN_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.ALT_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK)) != 0 &&
        (modifiersEx & InputEvent.BUTTON2_DOWN_MASK) == 0) {
      f.willChange();
      int index = getBezierNodeIndex();
      BezierPath.Node v = f.getNode(index);
      if (index > 0 && index < f.getNodeCount()) {
        v.mask = (v.mask + 3) % 4;
      } else if (index == 0) {
        v.mask = ((v.mask & BezierPath.C2_MASK) == 0) ? BezierPath.C2_MASK : 0;
      } else {
        v.mask = ((v.mask & BezierPath.C1_MASK) == 0) ? BezierPath.C1_MASK : 0;
      }
      f.setNode(index, v);
      f.changed();
      fireHandleRequestSecondaryHandles();
    }
    Point2D.Double p = view.viewToDrawing(lead);
    view.getConstrainer().constrainPoint(p);
    Connector target = findConnectionTarget(p, view.getDrawing());
    if (target == null) {
      target = savedTarget;
    }
    setLocation(p);
    if (target != savedTarget) {
      disconnect();
      connect(target);
    }
    getOwner().setLiner(savedLiner);
    getOwner().updateConnection();
    connectableConnector = null;
    connectors = Collections.emptyList();
###
618, getTool, ToolEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java, 52, 53
3
/**
   * Gets the tool which is the source of the event.
   */
2
  public Tool getTool() {
    return (Tool) getSource();
###
619, getView, ToolEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java, 58, 59
3
/**
   * Gets the drawing view of the tool.
   */
2
  public DrawingView getView() {
    return view;
###
620, ToolEvent, ToolEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java, 43, 46
1
/** Creates a new instance. */
4
  public ToolEvent(Tool src, DrawingView view, Rectangle invalidatedArea) {
    super(src);
    this.view = view;
    this.invalidatedArea = invalidatedArea;
###
621, draw, BezierControlPointHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierControlPointHandle.java, 88, 139
3
/**
   * Draws this handle.
   */
51
  public void draw(Graphics2D g) {
    BezierFigure f = getBezierFigure();
    if (f.getNodeCount() > index) {
      BezierPath.Node v = f.getNode(index);
      Point2D.Double p0 = new Point2D.Double(v.x[0], v.y[0]);
      Point2D.Double pc = new Point2D.Double(v.x[controlPointIndex], v.y[controlPointIndex]);
      Figure tOwner = getTransformOwner();
      if (tOwner.get(TRANSFORM) != null) {
        tOwner.get(TRANSFORM).transform(p0, p0);
        tOwner.get(TRANSFORM).transform(pc, pc);
      }
      Color handleFillColor;
      Color handleStrokeColor;
      Stroke stroke1;
      Color strokeColor1;
      Stroke stroke2;
      Color strokeColor2;
      if (getEditor().getTool().supportsHandleInteraction()) {
        handleFillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_FILL_COLOR);
        handleStrokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_STROKE_COLOR);
        stroke1 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_1);
        strokeColor1 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_1);
        stroke2 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_2);
        strokeColor2 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_2);
      } else {
        handleFillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_FILL_COLOR_DISABLED);
        handleStrokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_STROKE_COLOR_DISABLED);
        stroke1 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_1_DISABLED);
        strokeColor1 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_1_DISABLED);
        stroke2 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_2_DISABLED);
        strokeColor2 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_2_DISABLED);
      }
      if (stroke1 != null && strokeColor1 != null) {
        g.setStroke(stroke1);
        g.setColor(strokeColor1);
        g.draw(new Line2D.Double(
            view.drawingToView(p0),
            view.drawingToView(pc)));
      }
      if (stroke2 != null && strokeColor2 != null) {
        g.setStroke(stroke2);
        g.setColor(strokeColor2);
        g.draw(new Line2D.Double(
            view.drawingToView(p0),
            view.drawingToView(pc)));
      }
      if (v.keepColinear && v.mask == BezierPath.C1C2_MASK &&
          (index > 0 && index < f.getNodeCount() - 1 || f.isClosed())) {
        drawCircle(g, handleStrokeColor, handleFillColor);
      } else {
        drawCircle(g, handleFillColor, handleStrokeColor);
###
622, BezierControlPointHandle, BezierControlPointHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierControlPointHandle.java, 43, 44
1
/** Creates a new instance. */
2
  public BezierControlPointHandle(BezierFigure owner, int index, int coord) {
    this(owner, index, coord, owner);
###
626, AbstractRotateHandle, AbstractRotateHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractRotateHandle.java, 45, 46
1
/** Creates a new instance. */
2
  public AbstractRotateHandle(Figure owner) {
    super(owner);
###
628, ColorWheelImageProducer, ColorWheelImageProducer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelImageProducer.java, 49, 57
1
/** Creates a new instance. */
9
  public ColorWheelImageProducer(ColorSystem sys, int w, int h) {
    super(w, h, null, 0, w);
    pixels = new int[w * h];
    this.w = w;
    this.h = h;
    this.colorSystem = sys;
    setAnimated(true);
    
    newPixels(pixels, ColorModel.getRGBdefault(), 0, w);
###
630, getBoundedRangeModel, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 101, 102
3
/**
   * Returns the bounded range model of the specified color componentIndex.
   */
2
  public DefaultBoundedRangeModel getBoundedRangeModel(int componentIndex) {
    return componentModels[componentIndex];
###
631, unconfigureSlider, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 87, 94
3
/**
   * Unconfigures a JSlider from this AbstractColorSystem.
   */
8
  public void unconfigureSlider(JSlider slider) {
    if (slider.getClientProperty("colorSliderModel") == this) {
      // XXX - This creates a NullPointerException ??
      //slider.setUI((SliderUI) UIManager.getUI(slider));
      slider.setModel(new DefaultBoundedRangeModel());
      slider.putClientProperty("colorSliderModel", null);
      slider.putClientProperty("colorComponentIndex", null);
      removeColorSlider(slider);
###
632, getSliderValue, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 108, 109
3
/**
   * Returns the value of the specified color componentIndex.
   */
2
  public int getSliderValue(int componentIndex) {
    return componentModels[componentIndex].getValue();
###
633, configureSlider, DefaultColorSliderModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java, 71, 81
5
/**
   * Configures a JSlider for this AbstractColorSystem.
   * If the JSlider is already configured for another AbstractColorSystem,
   * it is unconfigured first.
   */
11
  public void configureSlider(int componentIndex, JSlider slider) {
    if (slider.getClientProperty("colorSliderModel") != null) {
      ((DefaultColorSliderModel) slider.getClientProperty("colorSliderModel")).unconfigureSlider(slider);
    }
    if (!(slider.getUI() instanceof ColorSliderUI)) {
      slider.setUI((ColorSliderUI) ColorSliderUI.createUI(slider));
    }
    slider.setModel(getBoundedRangeModel(componentIndex));
    slider.putClientProperty("colorSliderModel", this);
    slider.putClientProperty("colorComponentIndex", new Integer(componentIndex));
    addColorSlider(slider);
###
634, SaveFileAction, SaveFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/SaveFileAction.java, 52, 53
1
/** Creates a new instance. */
2
  public SaveFileAction(Application app, View view) {
    this(app, view, false);
###
635, printQuartz, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 147, 218
4
/**
   * On Mac OS X with the Quartz rendering engine, the following code achieves
   * the best results.
   */
66
  public void printQuartz(PrintableView v) {
    Frame frame = (Frame) SwingUtilities.getWindowAncestor(v.getComponent());
    final Pageable pageable = v.createPageable();
    final double resolution = 300d;
    JobAttributes jobAttr = new JobAttributes();
    // FIXME - PageAttributes should be retrieved from View
    PageAttributes pageAttr = new PageAttributes();
    pageAttr.setMedia(PageAttributes.MediaType.A4);
    pageAttr.setPrinterResolution((int) resolution);
    final PrintJob pj = frame.getToolkit().getPrintJob(
        frame,
        "Job Title",
        jobAttr,
        pageAttr);
    getActiveView().setEnabled(false);
    new Worker() {
      protected Object construct() throws PrinterException {
        // Compute page format from settings of the print job
        Paper paper = new Paper();
        paper.setSize(
            pj.getPageDimension().width / resolution * 72d,
            pj.getPageDimension().height / resolution * 72d);
        paper.setImageableArea(64d, 32d, paper.getWidth() - 96d, paper.getHeight() - 64);
        PageFormat pageFormat = new PageFormat();
        pageFormat.setPaper(paper);
        // Print the job
        try {
          for (int i = 0,  n = pageable.getNumberOfPages(); i < n; i++) {
            PageFormat pf = pageable.getPageFormat(i);
            pf = pageFormat;
            Graphics g = pj.getGraphics();
            if (g instanceof Graphics2D) {
              pageable.getPrintable(i).print(g, pf, i);
            } else {
              BufferedImage buf = new BufferedImage(
                  (int) (pf.getImageableWidth() * resolution / 72d),
                  (int) (pf.getImageableHeight() * resolution / 72d),
                  BufferedImage.TYPE_INT_RGB);
              Graphics2D bufG = buf.createGraphics();

              bufG.setBackground(Color.WHITE);
              bufG.fillRect(0, 0, buf.getWidth(), buf.getHeight());
              bufG.scale(resolution / 72d, resolution / 72d);
              bufG.translate(-pf.getImageableX(), -pf.getImageableY());
              pageable.getPrintable(i).print(bufG, pf, i);
              bufG.dispose();
              g.drawImage(buf,
                  (int) (pf.getImageableX() * resolution / 72d),
                  (int) (pf.getImageableY() * resolution / 72d),
                  null);
              buf.flush();
            }
            g.dispose();
          }
        } finally {
          pj.end();
        }
        return null;
      }
      protected void failed(Throwable error) {
         error.printStackTrace();
      }
      protected void finished() {
        getActiveView().setEnabled(true);
      }
    }.start();
###
636, printJava2D, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 81, 109
3
/*
   * This prints at 72 DPI only. We might need this for some JVM versions on
   * Mac OS X.*/
28
  public void printJava2D(PrintableView v) {
    Pageable pageable = v.createPageable();
    if (pageable == null) {
      throw new InternalError("View does not have a method named java.awt.Pageable createPageable()");
    }
    try {
      PrinterJob job = PrinterJob.getPrinterJob();
      // FIXME - PrintRequestAttributeSet should be retrieved from View
      PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();
      attr.add(new PrinterResolution(300, 300, PrinterResolution.DPI));
      job.setPageable(pageable);
      if (job.printDialog()) {
        try {
          job.print();
        } catch (PrinterException e) {
          String message = (e.getMessage() == null) ? e.toString() : e.getMessage();
          View view = getActiveView();
          ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
          JSheet.showMessageSheet(view.getComponent(),
              "<html>" + UIManager.getString("OptionPane.css") +
              "<b>" + labels.getString("couldntPrint") + "</b><br>" +
              ((message == null) ? "" : message));
        }
      } else {
        System.out.println("JOB ABORTED!");
      }
    } catch (Throwable t) {
      t.printStackTrace();
###
637, printJava2DAlternative, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 116, 139
3
/*
   * This prints at 72 DPI only. We might need this for some JVM versions on
   * Mac OS X.*/
23
  public void printJava2DAlternative(PrintableView v) {
    Pageable pageable = v.createPageable();
    if (pageable == null) {
      throw new InternalError("View does not have a method named java.awt.Pageable createPageable()");
    }
    try {
      final PrinterJob job = PrinterJob.getPrinterJob();
      PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();
      attr.add(new PrinterResolution(300, 300, PrinterResolution.DPI));
      job.setPageable(pageable);
      if (job.printDialog(attr)) {
        try {
          job.print();
        } catch (PrinterException e) {
          ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
          JSheet.showMessageSheet(getActiveView().getComponent(),
              labels.getFormatted("couldntPrint", e));
        }
      } else {
        System.out.println("JOB ABORTED!");
      }
    } catch (Throwable t) {
      t.printStackTrace();
###
638, PrintFileAction, PrintFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java, 61, 64
1
/** Creates a new instance. */
4
  public PrintFileAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
###
639, ViewPropertyAction, ViewPropertyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/view/ViewPropertyAction.java, 46, 47
1
/** Creates a new instance. */
2
  public ViewPropertyAction(Application app, View view, String propertyName, Object propertyValue) {
    this(app, view, propertyName, propertyValue.getClass(), propertyValue);
###
640, FocusWindowAction, FocusWindowAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/window/FocusWindowAction.java, 40, 53
1
/** Creates a new instance. */
14
  public FocusWindowAction(View view) {
    this.view = view;
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
    labels.configureAction(this, ID);
    //setEnabled(false);
    setEnabled(view != null);
    
    view.addPropertyChangeListener(ppc = new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
        String name = evt.getPropertyName();
        if (name.equals(View.TITLE_PROPERTY)) {
          putValue(Action.NAME,
              evt.getNewValue()
###
641, OpenRecentFileAction, OpenRecentFileAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenRecentFileAction.java, 49, 52
1
/** Creates a new instance. */
4
  public OpenRecentFileAction(Application app, URI uri) {
    super(app);
    this.uri = uri;
    putValue(Action.NAME, URIUtil.getName(uri));
###
642, ToggleViewPropertyAction, ToggleViewPropertyAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/action/view/ToggleViewPropertyAction.java, 47, 48
1
/** Creates a new instance. */
2
  public ToggleViewPropertyAction(Application app, View view, String propertyName) {
    this(app, view, propertyName, Boolean.TYPE, true, false);
###
645, get, AbstractAttributedFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedFigure.java, 95, 96
3
/**
   * Gets an attribute from the figure.
   */
2
  public <T> T get(AttributeKey<T> key) {
    return key.get(attributes);
###
647, set, AbstractAttributedFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedFigure.java, 85, 89
5
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
5
  public <T> void set(AttributeKey<T> key, T newValue) {
    if (forbiddenAttributes == null
        || ! forbiddenAttributes.contains(key)) {
      T oldValue = (T) key.put(attributes, newValue);
      fireAttributeChanged(key, oldValue, newValue);
###
649, get, AbstractAttributedCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedCompositeFigure.java, 96, 98
3
/**
   * Gets an attribute from the figure.
   */
3
  @Override
  public <T> T get(AttributeKey<T> key) {
    return key.get(attributes);
###
652, set, AbstractAttributedCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedCompositeFigure.java, 78, 83
5
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
6
  @Override
  public <T> void set(AttributeKey<T> key, T newValue) {
    if (forbiddenAttributes == null || !forbiddenAttributes.contains(key)) {
      Object oldValue = attributes.put(key, newValue);
      setAttributeOnChildren(key, newValue);
      fireAttributeChanged(key, oldValue, newValue);
###
655, transform, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 290, 294
3
/**
   * Transforms the figure.
   */
5
  public void transform(AffineTransform tx) {
    for (Figure f : getChildren()) {
      f.transform(tx);
    }
    invalidate();
###
656, getLayouter, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 431, 432
9
/**
   * Get a Layouter object which encapsulated a layout
   * algorithm for this figure. Typically, a Layouter
   * accesses the child components of this figure and arranges
   * their graphical presentation.
   *
   *
   * @return layout strategy used by this figure
   */
2
  public Layouter getLayouter() {
    return layouter;
###
657, fireFigureRemoved, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 673, 686
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireFigureRemoved(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        }
        ((CompositeFigureListener) listeners[i + 1]).figureRemoved(event);
###
658, bringToFront, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 280, 283
5
/**
   * Brings a figure to the front of the drawing.
   *
   * @param figure that is part of the drawing
   */
4
  public synchronized void bringToFront(Figure figure) {
    if (basicRemove(figure) != -1) {
      basicAdd(figure);
      fireAreaInvalidated(figure.getDrawingArea());
###
659, fireFigureAdded, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 651, 664
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireFigureAdded(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        }
        ((CompositeFigureListener) listeners[i + 1]).figureAdded(event);
###
660, setLayouter, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 464, 465
12
/**
   * Set a Layouter object which encapsulated a layout
   * algorithm for this figure. Typically, a Layouter
   * accesses the child components of this figure and arranges
   * their graphical presentation. It is a good idea to set
   * the Layouter in the protected initialize() method
   * so it can be recreated if a GraphicalCompositeFigure is
   * read and restored from a StorableInput stream.
   *
   *
   * @param newLayouter  encapsulation of a layout algorithm.
   */
2
  public void setLayouter(Layouter newLayouter) {
    this.layouter = newLayouter;
###
661, removeAll, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 219, 221
5
/**
   * Removes all specified children.
   *
   * @see #add
   */
3
  public void removeAll(Collection<? extends Figure> figures) {
    for (Figure f : figures) {
      remove(f);
###
662, sendToBack, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 268, 271
5
/**
   * Sends a figure to the back of the composite figure.
   *
   * @param figure that is part of this composite figure
   */
4
  public synchronized void sendToBack(Figure figure) {
    if (basicRemove(figure) != -1) {
      basicAdd(0, figure);
      fireAreaInvalidated(figure.getDrawingArea());
###
664, basicRemoveAllChildren, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 246, 248
5
/**
   * Removes all children.
   *
   * @see #add
   */
3
  public void basicRemoveAllChildren() {
    for (Figure f : new LinkedList<Figure>(getChildren())) {
      basicRemove(f);
###
665, layout, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 441, 448
6
/**
   * A layout algorithm is used to define how the child components
   * should be laid out in relation to each other. The task for
   * layouting the child components for presentation is delegated
   * to a Layouter which can be plugged in at runtime.
   */
8
  public void layout() {
    if (getLayouter() != null) {
      Rectangle2D.Double bounds = getBounds();
      Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);
      Rectangle2D.Double r = getLayouter().layout(
          this, p, p);
      setBounds(new Point2D.Double(r.x, r.y), new Point2D.Double(r.x + r.width, r.y + r.height));
      invalidate();
###
666, removeAllChildren, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 230, 238
5
/**
   * Removes all children.
   *
   * @see #add
   */
9
  public void removeAllChildren() {
    willChange();
    for (Figure f : new LinkedList<Figure>(getChildren())) {
      if (getDrawing() != null) {
        f.removeNotify(getDrawing());
      }
      int index = basicRemove(f);
    }
    changed();
###
667, getChildrenFrontToBack, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 330, 331
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
2
  public java.util.List<Figure> getChildrenFrontToBack() {
    return children.size() == 0 ? new LinkedList<Figure>() : new ReversedList<Figure>(getChildren());
###
668, basicRemoveAll, AbstractCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java, 257, 259
5
/**
   * Removes all children.
   *
   * @see #add
   */
3
  public void basicRemoveAll(Collection<? extends Figure> figures) {
    for (Figure f : figures) {
      basicRemove(f);
###
670, JColorWheel, JColorWheel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/JColorWheel.java, 84, 85
3
/**
   * Creates a new instance.
   */
2
  public JColorWheel() {
    this(new HSVRGBColorSystem());
###
671, JHarmonicColorWheel, JHarmonicColorWheel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/JHarmonicColorWheel.java, 128, 141
1
/** Creates new form. */
11
  public JHarmonicColorWheel() {
    super(new HSLRYBColorSystem());
    initComponents();
    setRadialComponentIndex(2);
    setVerticalComponentIndex(1);
    getModel().setComponentValue(1, 1f);
    setWheelInsets(new Insets(5, 5, 5, 5));
    modelHandler = new ModelHandler();
    DefaultHarmonicColorModel p = new DefaultHarmonicColorModel();
    setHarmonicColorModel(p);
    setToolTipText("");
###
675, draw, BezierNodeHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierNodeHandle.java, 67, 93
3
/**
   * Draws this handle.
   */
27
  @Override
  public void draw(Graphics2D g) {
    BezierFigure f = getOwner();
    int size = f.getNodeCount();
    boolean isClosed = f.isClosed();
    Color fillColor;
    Color strokeColor;
    if (getEditor().getTool().supportsHandleInteraction()) {
      fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR);
      strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR);
    } else {
      fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR_DISABLED);
      strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR_DISABLED);
    }
    if (size > index) {
      BezierPath.Node v = f.getNode(index);
      if (v.mask == 0 ||
          index == 0 && v.mask == BezierPath.C1_MASK && !isClosed ||
          index == size - 1 && v.mask == BezierPath.C2_MASK && !isClosed) {
        drawRectangle(g, fillColor, strokeColor);
      } else if (v.mask == BezierPath.C1_MASK ||
          v.mask == BezierPath.C2_MASK ||
          index == 0 && !isClosed ||
          index == size - 1 && !isClosed) {
        drawDiamond(g, fillColor, strokeColor);
      } else {
        drawCircle(g, fillColor, strokeColor);
###
676, BezierNodeHandle, BezierNodeHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierNodeHandle.java, 46, 47
1
/** Creates a new instance. */
2
  public BezierNodeHandle(BezierFigure owner, int index) {
    this(owner, index, owner);
###
677, ConnectorHandle, ConnectorHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java, 63, 66
1
/** Creates a new instance. */
4
  public ConnectorHandle(Connector connector, ConnectionFigure prototype) {
    super(connector.getOwner());
    this.connector = connector;
    this.prototype = prototype;
###
678, createConnection, ConnectorHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java, 193, 194
4
/**
   * Creates the ConnectionFigure. By default the figure prototype is
   * cloned.
   */
2
  protected ConnectionFigure createConnection() {
    return (ConnectionFigure) prototype.clone();
###
679, findConnectableConnector, ConnectorHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java, 228, 234
3
/**
   * Finds a connection end figure.
   */
6
  protected Connector findConnectableConnector(Figure connectableFigure, Point2D.Double p) {
    Connector target = (connectableFigure == null) ? null : connectableFigure.findConnector(p, getConnection());
    if ((connectableFigure != null) && connectableFigure.isConnectable() && !connectableFigure.includes(getOwner()) && getConnection().canConnect(connector, target)) {
      return target;
    }
    return null;
###
680, draw, CloseHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java, 47, 51
3
/**
   * Draws this handle.
   */
5
  public void draw(Graphics2D g) {
    drawRectangle(g, (pressed) ? Color.orange : Color.white, Color.black);
    Rectangle r = getBounds();
    g.drawLine(r.x, r.y, r.x+r.width, r.y+r.height);
    g.drawLine(r.x+r.width, r.y, r.x, r.y+r.height);
###
681, CloseHandle, CloseHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java, 32, 33
1
/** Creates a new instance. */
2
  public CloseHandle(Figure owner) {
    this(owner, new RelativeLocator(1.0, 0.0));
###
682, CloseHandle, CloseHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java, 36, 37
1
/** Creates a new instance. */
2
  public CloseHandle(Figure owner, Locator locator) {
    super(owner, locator);
###
683, FontSizeHandle, FontSizeHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/FontSizeHandle.java, 40, 41
1
/** Creates a new instance. */
2
  public FontSizeHandle(TextHolderFigure owner) {
    super(owner, new FontSizeLocator());
###
684, draw, BezierScaleHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierScaleHandle.java, 55, 58
3
/**
   * Draws this handle.
   */
4
  public void draw(Graphics2D g) {
    drawCircle(g, 
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_FILL_COLOR),
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_STROKE_COLOR)
###
685, BezierScaleHandle, BezierScaleHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierScaleHandle.java, 43, 44
1
/** Creates a new instance. */
2
  public BezierScaleHandle(BezierFigure owner) {
    super(owner);
###
687, DragHandle, DragHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/DragHandle.java, 44, 45
1
/** Creates a new instance. */
2
  public DragHandle(Figure owner) {
    super(owner);
###
688, setLocation, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 59, 62
3
/**
   * Sets the start point of the connection.
   */
4
  protected void setLocation(Point2D.Double p) {
    getOwner().willChange();
    getOwner().setEndPoint(p);
    getOwner().changed();
###
689, disconnect, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 47, 48
3
/**
   * Disconnects the start figure.
   */
2
  protected void disconnect() {
    getOwner().setEndConnector(null);
###
690, ConnectionEndHandle, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 33, 34
3
/**
   * Constructs the connection handle for the given start figure.
   */
2
  public ConnectionEndHandle(ConnectionFigure owner) {
    super(owner);
###
691, connect, ConnectionEndHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java, 40, 41
3
/**
   * Sets the start of the connection.
   */
2
  protected void connect(Connector c) {
    getOwner().setEndConnector(c);
###
692, BoundsOutlineHandle, BoundsOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java, 53, 86
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   * 
   * @param owner
   */
34
  public BoundsOutlineHandle(Figure owner, boolean isTransformHandle, boolean isHoverHandle) {
    super(owner);
    if (isTransformHandle) {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;
    } else {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;
###
693, BoundsOutlineHandle, BoundsOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java, 95, 109
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   *
   * @param owner
   */
15
  public BoundsOutlineHandle(Figure owner, //
      AttributeKey<Stroke> stroke1Enabled, AttributeKey<Color> strokeColor1Enabled,//
      AttributeKey<Stroke> stroke2Enabled, AttributeKey<Color> strokeColor2Enabled,//
      AttributeKey<Stroke> stroke1Disabled, AttributeKey<Color> strokeColor1Disabled,//
      AttributeKey<Stroke> stroke2Disabled, AttributeKey<Color> strokeColor2Disabled
      ) {
    super(owner);
    this.stroke1Enabled = stroke1Enabled;
    this.strokeColor1Enabled = strokeColor1Enabled;
    this.stroke2Enabled = stroke2Enabled;
    this.strokeColor2Enabled = strokeColor2Enabled;
    this.stroke1Disabled = stroke1Disabled;
    this.strokeColor1Disabled = strokeColor1Disabled;
    this.stroke2Disabled = stroke2Disabled;
    this.strokeColor2Disabled = strokeColor2Disabled;
###
694, BoundsOutlineHandle, BoundsOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java, 44, 45
5
/**
   * Creates a bounds outline handle for resizing a component.
   * 
   * @param owner
   */
2
  public BoundsOutlineHandle(Figure owner) {
    this(owner, false, false);
###
695, disconnect, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 47, 48
3
/**
   * Disconnects the start figure.
   */
2
  protected void disconnect() {
    getOwner().setStartConnector(null);
###
696, setLocation, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 59, 62
3
/**
   * Sets the start point of the connection.
   */
4
  protected void setLocation(Point2D.Double p) {
    getOwner().willChange();
    getOwner().setStartPoint(p);
    getOwner().changed();
###
697, removeFromSource, WeakPropertyChangeListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/WeakPropertyChangeListener.java, 76, 84
4
/**
   *  Method that can be subclassed to provide additional remove
   *  support.  Default implementation only supports StandardBeans.
   */
9
  protected void removeFromSource(PropertyChangeEvent event) {
    // Remove ourselves from the source
    Object src = event.getSource();
    try {
      src.getClass().getMethod("removePropertyChangeListener", new Class[] {PropertyChangeListener.class}).invoke(src, this);
    } catch (Exception ex) {
      InternalError ie = new InternalError("Could not remove WeakPropertyChangeListener from "+src+".");
      ie.initCause(ex);
      throw ie;
###
698, connect, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 40, 41
3
/**
   * Sets the start of the connection.
   */
2
  protected void connect(Connector c) {
    getOwner().setStartConnector(c);
###
699, ConnectionStartHandle, ConnectionStartHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java, 33, 34
3
/**
   * Constructs the connection handle for the given start figure.
   */
2
  public ConnectionStartHandle(ConnectionFigure owner) {
    super(owner);
###
700, setOpenFileHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 190, 205
8
/**
   * Pass this method an {@code ActionListener} equipped to
   * handle document events from the Finder.
   * Documents are registered with the Finder via the
   * CFBundleDocumentTypes dictionary in the application bundle's Info.plist.
   * <p>
   * The filename is passed as the {@code actionCommand}.
   */
15
  public static void setOpenFileHandler(ActionListener fileHandler) {
    setHandler(new OSXAdapter("handleOpenFile", fileHandler) {
      // Override OSXAdapter.callTarget to send information on the
      // file to be opened
      @Override
      public boolean callTarget(Object appleEvent) {
        if (appleEvent != null) {
          try {
            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);
            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);
            targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, filename));
          } catch (Exception ex) {
          }
        }
        return true;
###
701, setHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 241, 257
4
/** 
   * {@code setHandler} creates a Proxy object from the passed
   * {@code OSXAdapter} and adds it as an {@code ApplicationListener}.
   */
17
  @SuppressWarnings("unchecked")
  public static void setHandler(OSXAdapter adapter) {
    try {
      Class applicationClass = Class.forName("com.apple.eawt.Application");
      if (macOSXApplication == null) {
        macOSXApplication = applicationClass.getConstructor((Class[]) null).newInstance((Object[]) null);
      }
      Class applicationListenerClass = Class.forName("com.apple.eawt.ApplicationListener");
      Method addListenerMethod = applicationClass.getDeclaredMethod("addApplicationListener", new Class[]{applicationListenerClass});
      // Create a proxy object around this handler that can be reflectively added as an Apple ApplicationListener
      Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[]{applicationListenerClass}, adapter);
      addListenerMethod.invoke(macOSXApplication, new Object[]{osxAdapterProxy});
    } catch (ClassNotFoundException cnfe) {
      System.err.println("This version of Mac OS X does not support the Apple EAWT.  ApplicationEvent handling has been disabled (" + cnfe + ")");
    } catch (Exception ex) {  // Likely a NoSuchMethodException or an IllegalAccessException loading/invoking eawt.Application methods
      System.err.println("Mac OS X Adapter could not talk to EAWT:");
      ex.printStackTrace();
###
702, callTarget, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 286, 295
4
/** Override this method to perform any operations on the event
   * that comes with the various callbacks.
   * See setOpenFileHandler above for an example.
   */
10
  public boolean callTarget(Object appleEvent) throws InvocationTargetException, IllegalAccessException {
    if (targetAction != null) {
      targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, proxySignature));
      return true;
    } else {
      Object result = targetMethod.invoke(targetObject, (Object[]) null);
      if (result == null) {
        return true;
      }
      return Boolean.valueOf(result.toString()).booleanValue();
###
703, setAboutHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 144, 156
4
/**
   * The action listener will be called when the user selects the About item
   * in the application menu.
   */
13
  public static void setAboutHandler(ActionListener aboutHandler) {
    boolean enableAboutMenu = (aboutHandler != null);
    if (enableAboutMenu) {
      setHandler(new OSXAdapter("handleAbout", aboutHandler));
    }
    // If we're setting a handler, enable the About menu item by calling
    // com.apple.eawt.Application reflectively
    try {
      Method enableAboutMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledAboutMenu", new Class[]{boolean.class});
      enableAboutMethod.invoke(macOSXApplication, new Object[]{Boolean.valueOf(enableAboutMenu)});
    } catch (Exception ex) {
      System.err.println("OSXAdapter could not access the About Menu");
      ex.printStackTrace();
###
704, setPreferencesHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 166, 178
6
/**
   * Pass this method an {@code ActionListener} equipped to
   * display application options.
   * They will be called when the Preferences menu item is selected from the
   * application menu.
   */
13
  public static void setPreferencesHandler(ActionListener prefsHandler) {
    boolean enablePrefsMenu = (prefsHandler != null);
    if (enablePrefsMenu) {
      setHandler(new OSXAdapter("handlePreferences", prefsHandler));
    }
    // If we're setting a handler, enable the Preferences menu item by calling
    // com.apple.eawt.Application reflectively
    try {
      Method enablePrefsMethod = macOSXApplication.getClass().getDeclaredMethod("setEnabledPreferencesMenu", new Class[]{boolean.class});
      enablePrefsMethod.invoke(macOSXApplication, new Object[]{Boolean.valueOf(enablePrefsMenu)});
    } catch (Exception ex) {
      System.err.println("OSXAdapter could not access the Preferences Menu");
      ex.printStackTrace();
###
705, isCorrectMethod, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 320, 321
5
/**
   * Compare the method that was called to the intended method when the
   * OSXAdapter instance was created (e.g. handleAbout, handleQuit,
   * handleOpenFile, etc.).
   */
2
  protected boolean isCorrectMethod(Method method, Object[] args) {
    return (proxySignature.equals(method.getName()) && args.length == 1);
###
706, setReOpenApplicationHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 121, 122
8
/**
   * Called when the application receives a Reopen Application event from the
   * Finder or another application. Usually this will come when a user clicks
   * on your application icon in the Dock. If there is any special code that
   * needs to run when your user clicks on your application icon in the Dock
   * or when a Reopen Application event is sent from another application,
   * include that code as part of this handler.
   */
2
  public static void setReOpenApplicationHandler(ActionListener reopenHandler) {
    setHandler(new OSXAdapter("handleReOpenApplication", reopenHandler));
###
707, setQuitHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 128, 135
4
/**
   * The action listener will be called when the Quit menu item is selected
   * from the application menu.
   */
7
  public static void setQuitHandler(ActionListener aboutHandler) {
    setHandler(new OSXAdapter("handleQuit", aboutHandler) {
      // Override OSXAdapter.callTarget to always return false.
      @Override
      public boolean callTarget(Object appleEvent)  throws InvocationTargetException, IllegalAccessException {
        super.callTarget(appleEvent);
        return false;
###
708, OSXAdapter, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 266, 269
5
/** 
   * Each OSXAdapter has the name of the EAWT method it intends to listen for
   * (handleAbout, for example), the Object that will ultimately perform the
   * task, and the Method to be called on that Object.
   */
4
  protected OSXAdapter(String proxySignature, Object target, Method handler) {
    this.proxySignature = proxySignature;
    this.targetObject = target;
    this.targetMethod = handler;
###
709, setApplicationEventHandled, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 330, 338
6
/** 
   * It is important to mark the ApplicationEvent as handled and cancel the
   * default behavior.
   * This method checks for a boolean result from the proxy method and sets 
   * the event accordingly.
   */
9
  protected void setApplicationEventHandled(Object event, boolean handled) {
    if (event != null) {
      try {
        Method setHandledMethod = event.getClass().getDeclaredMethod("setHandled", new Class[]{boolean.class});
        // If the target method returns a boolean, use that as a hint
        setHandledMethod.invoke(event, new Object[]{Boolean.valueOf(handled)});
      } catch (Exception ex) {
        System.err.println("OSXAdapter was unable to handle an ApplicationEvent: " + event);
        ex.printStackTrace();
###
710, setPrintFileHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 217, 232
8
/**
   * Pass this method an {@code ActionListener} equipped to
   * handle document events from the Finder.
   * Documents are registered with the Finder via the
   * CFBundleDocumentTypes dictionary in the application bundle's Info.plist.
   * <p>
   * The filename is passed as the {@code actionCommand}.
   */
15
  public static void setPrintFileHandler(ActionListener fileHandler) {
    setHandler(new OSXAdapter("handlePrintFile", fileHandler) {
      // Override OSXAdapter.callTarget to send information on the
      // file to be opened
      @Override
      public boolean callTarget(Object appleEvent) {
        if (appleEvent != null) {
          try {
            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod("getFilename", (Class[]) null);
            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);
            targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, filename));
          } catch (Exception ex) {
          }
        }
        return true;
###
711, setOpenApplicationHandler, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 110, 111
9
/**
   * The action listener will be called when the application receives an Open
   * Application event from the Finder or another application. Usually this
   * will come from the Finder when a user double-clicks your application
   * icon. If there is any special code that you want to run when you user
   * launches your application from the Finder or by sending an Open
   * Application event from another application, include that code as part of
   * this handler. The Open Application event is sent after AWT has been loaded.
   */
2
  public static void setOpenApplicationHandler(ActionListener openHandler) {
    setHandler(new OSXAdapter("handleOpenApplication", openHandler));
###
712, OSXAdapter, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 277, 279
5
/**
   * Each OSXAdapter has the name of the EAWT method it intends to listen for
   * (handleAbout, for example), the Object that will ultimately perform the
   * task, and the Method to be called on that Object.
   */
3
  protected OSXAdapter(String proxySignature, ActionListener handler) {
    this.proxySignature = proxySignature;
    this.targetAction = handler;
###
713, invoke, OSXAdapter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java, 304, 312
5
/**
   * InvocationHandler implementation.
   * This is the entry point for our proxy object; it is called every time an 
   * ApplicationListener method is invoked.
   */
9
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (isCorrectMethod(method, args)) {
      boolean handled = callTarget(args[0]);
      setApplicationEventHandled(args[0], handled);
    }
    // All of the ApplicationListener methods are void;
    // return null regardless of what happens
    return null;
###
714, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 65, 66
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, int oldValue, int newValue) {
    this(source, propertyName, Integer.TYPE, oldValue, newValue);
###
715, addEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 156, 166
6
/** Adds the specified edit to this one, if it is a {@code PropertyChangeEdit}
   * from the same owner and the same property.
   *
   * @param anEdit Edit to be added.
   * @return True if added.
   */
10
  @Override
  public boolean addEdit(UndoableEdit anEdit) {
    if (anEdit instanceof PropertyChangeEdit) {
      PropertyChangeEdit that = (PropertyChangeEdit) anEdit;
      if (that.source == this.source && that.propertyName.equals(this.propertyName)) {
        this.newValue = that.newValue;
        return true;
      }
    }
    return false;
###
716, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 85, 86
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, char oldValue, char newValue) {
    this(source, propertyName, Character.TYPE, oldValue, newValue);
###
717, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 75, 76
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, float oldValue, float newValue) {
    this(source, propertyName, Float.TYPE, oldValue, newValue);
###
718, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 60, 61
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, boolean oldValue, boolean newValue) {
    this(source, propertyName, Boolean.TYPE, oldValue, newValue);
###
719, undo, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 110, 118
1
/** Undoes the change. */
9
  @Override
  public void undo() throws CannotRedoException {
    super.undo();
    try {
      getSetter().invoke(source, oldValue);
    } catch (Exception e) {
      InternalError ie = new InternalError("Couldn't invoke setter for property \"" + propertyName + "\" in " + source);
      ie.initCause(e);
      throw ie;
###
720, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 70, 71
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, long oldValue, long newValue) {
    this(source, propertyName, Long.TYPE, oldValue, newValue);
###
721, redo, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 123, 131
1
/** Redoes the change. */
9
  @Override
  public void redo() throws CannotRedoException {
    super.redo();
    try {
      getSetter().invoke(source, newValue);
    } catch (Exception e) {
      InternalError ie = new InternalError("Couldn't invoke setter for property \"" + propertyName + "\" in " + source);
      ie.initCause(e);
      throw ie;
###
722, getSetter, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 99, 105
5
/**
   * Returns the setter for the property.
   *
   * @return the setter method.
   */
7
  protected Method getSetter() {
    try {
      return source.getClass().getMethod("set" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1), type);
    } catch (Exception e) {
      InternalError ie = new InternalError("Couldn't find setter for property \"" + propertyName + "\" in " + source);
      ie.initCause(e);
      throw ie;
###
723, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 80, 81
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, double oldValue, double newValue) {
    this(source, propertyName, Double.TYPE, oldValue, newValue);
###
724, getPresentationName, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 139, 141
4
/** Returns the presentation name of the undoable edit.
   * This is the same as the property name, unless you have set a different
   * presentation name.
   */
3
  @Override
  public String getPresentationName() {
    return presentationName;
###
725, setPresentationName, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 146, 147
2
/** Sets the presentation name of the undoable edit.
   */
2
  public void setPresentationName(String presentationName) {
    this.presentationName = presentationName;
###
726, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 90, 91
1
/** Creates a new PropertyChangeEdit. */
2
  public PropertyChangeEdit(Object source, String propertyName, String oldValue, String newValue) {
    this(source, propertyName, String.class, oldValue, newValue);
###
727, PropertyChangeEdit, PropertyChangeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java, 50, 55
1
/** Creates a new PropertyChangeEdit. */
6
  public <T> PropertyChangeEdit(Object source, String propertyName, Class<T> type, T oldValue, T newValue) {
    this.source = source;
    this.propertyName = this.presentationName = propertyName;
    this.type = type;
    this.oldValue = oldValue;
    this.newValue = newValue;
###
728, removePropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 79, 93
6
/** Removes a {@code PropertyChangeListener}. If the listener was added
   * wrapped into a {@code WeakPropertyChangeListener}, the
   * {@code WeakPropertyChangeListener} is removed.
   *
   * @param listener
   */
15
  public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {
    // Removes a property change listener from our list.
    // We need a somewhat complex procedure here in case a listener
    // has been registered using addPropertyChangeListener(propertyName, new WeakPropertyChangeListener(listener));
    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners(propertyName)) {
      if (l == listener) {
        propertySupport.removePropertyChangeListener(propertyName, l);
        break;
      }
      if (l instanceof WeakPropertyChangeListener) {
        WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;
        PropertyChangeListener target = wl.getTarget();
        if (target == listener) {
          propertySupport.removePropertyChangeListener(propertyName, l);
          break;
###
729, addPropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 43, 44
4
/** Adds a {@code PropertyChangeListener} which can optionally be wrapped
   * into a {@code WeakPropertyChangeListener}.
   * @param listener
   */
2
  public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {
    propertySupport.addPropertyChangeListener(propertyName, listener);
###
730, addPropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 35, 36
4
/** Adds a {@code PropertyChangeListener} which can optionally be wrapped
   * into a {@code WeakPropertyChangeListener}.
   * @param listener
   */
2
  public void addPropertyChangeListener(PropertyChangeListener listener) {
    propertySupport.addPropertyChangeListener(listener);
###
731, removePropertyChangeListener, AbstractBean, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java, 53, 67
6
/** Removes a {@code PropertyChangeListener}. If the listener was added
   * wrapped into a {@code WeakPropertyChangeListener}, the
   * {@code WeakPropertyChangeListener} is removed.
   *
   * @param listener
   */
15
  public void removePropertyChangeListener(PropertyChangeListener listener) {
    // Removes a property change listener from our list.
    // We need a somewhat complex procedure here in case a listener
    // has been registered using addPropertyChangeListener(new WeakPropertyChangeListener(listener));
    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners()) {
      if (l == listener) {
        propertySupport.removePropertyChangeListener(l);
        break;
      }
      if (l instanceof WeakPropertyChangeListener) {
        WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;
        PropertyChangeListener target = wl.getTarget();
        if (target == listener) {
          propertySupport.removePropertyChangeListener(l);
          break;
###
732, addEdgeResizeHandles, ResizeHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ResizeHandleKit.java, 58, 62
4
/**
   * Fills the given Vector with handles at each
   * the north, south, east, and west of the figure.
   */
5
  static public void addEdgeResizeHandles(Figure f, Collection<Handle> handles) {
    handles.add(south(f));
    handles.add(north(f));
    handles.add(east(f));
    handles.add(west(f));
###
734, addCornerResizeHandles, ResizeHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ResizeHandleKit.java, 47, 51
4
/**
   * Creates handles for each corner of a
   * figure and adds them to the provided collection.
   */
5
  static public void addCornerResizeHandles(Figure f, Collection<Handle> handles) {
    handles.add(southEast(f));
    handles.add(southWest(f));
    handles.add(northEast(f));
    handles.add(northWest(f));
###
753, NullHandle, NullHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/NullHandle.java, 34, 35
1
/** Creates a new instance. */
2
  public NullHandle(Figure owner, Locator locator) {
    super(owner, locator);
###
754, addLeadHandles, NullHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/NullHandle.java, 56, 60
4
/**
   * Creates handles for each lead of a
   * figure and adds them to the provided collection.
   */
5
  static public void addLeadHandles(Figure f, Collection<Handle> handles) {
    handles.add(new NullHandle(f, new RelativeLocator(0f,0f)));
    handles.add(new NullHandle(f, new RelativeLocator(0f,1f)));
    handles.add(new NullHandle(f, new RelativeLocator(1f,0f)));
    handles.add(new NullHandle(f, new RelativeLocator(1f,1f)));
###
755, RotateHandle, RotateHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RotateHandle.java, 30, 31
1
/** Creates a new instance. */
2
  public RotateHandle(Figure owner) {
    super(owner);
###
756, draw, MoveHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java, 63, 72
7
/**
   * Draws this handle.
   * <p>
   * If the figure is transformable, the handle is drawn as a filled rectangle.
   * If the figure is not transformable, the handle is drawn as an unfilled
   * rectangle.
   */
10
  @Override
  public void draw(Graphics2D g) {
    if (getOwner().isTransformable()) {
      drawRectangle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_STROKE_COLOR));
    } else {
      drawRectangle(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_STROKE_COLOR));
###
757, addMoveHandles, MoveHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java, 49, 53
4
/**
   * Creates handles for each corner of a
   * figure and adds them to the provided collection.
   */
5
  static public void addMoveHandles(Figure f, Collection<Handle> handles) {
    handles.add(southEast(f));
    handles.add(southWest(f));
    handles.add(northEast(f));
    handles.add(northWest(f));
###
758, MoveHandle, MoveHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java, 41, 42
1
/** Creates a new instance. */
2
  public MoveHandle(Figure owner, Locator locator) {
    super(owner, locator);
###
759, TextOverflowHandle, TextOverflowHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TextOverflowHandle.java, 35, 36
1
/** Creates a new instance. */
2
  public TextOverflowHandle(TextHolderFigure owner) {
    super(owner);
###
760, draw, TextOverflowHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TextOverflowHandle.java, 50, 59
3
/**
   * Draws this handle.
   */
10
  @Override public void draw(Graphics2D g) {
    if (getOwner().isTextOverflow()) {
    drawRectangle(g, 
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_FILL_COLOR),
        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR)
        );
      g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));
      Rectangle r = basicGetBounds();
      g.drawLine(r.x+1, r.y+1, r.x+r.width-2, r.y+r.height-2);
      g.drawLine(r.x+r.width-2, r.y+1, r.x+1, r.y+r.height-2);
###
763, CMYKICCColorSystem, CMYKICCColorSystem, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/CMYKICCColorSystem.java, 39, 45
3
/**
   * Creates a new instance.
   */
7
  public CMYKICCColorSystem() {
    try {
      read(getClass().getResourceAsStream("Generic CMYK Profile.icc"));
    } catch (IOException e) {
      InternalError err = new InternalError("Couldn't load \"Generic CMYK Profile.icc\".");
      err.initCause(e);
      throw err;
###
764, RoundRectangleRadiusHandle, RoundRectangleRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RoundRectangleRadiusHandle.java, 41, 42
1
/** Creates a new instance. */
2
  public RoundRectangleRadiusHandle(Figure owner) {
    super(owner);
###
765, draw, RoundRectangleRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RoundRectangleRadiusHandle.java, 48, 57
3
/**
   * Draws this handle.
   */
10
  @Override
  public void draw(Graphics2D g) {
    if (getEditor().getTool().supportsHandleInteraction()) {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));
    } else {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));
###
766, ColorTrackImageProducer, ColorTrackImageProducer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorTrackImageProducer.java, 41, 56
1
/** Creates a new instance. */
16
  public ColorTrackImageProducer(int w, int h, int trackBuffer, boolean isHorizontal) {
    super(w, h, null, 0, w);
    pixels = new int[w*h];
    this.w = w;
    this.h = h;
    // trackBuffer must be even
    this.trackBuffer = (trackBuffer % 2 == 1) ? trackBuffer - 1 : trackBuffer;
    this.componentIndex = componentIndex;
    this.isHorizontal = isHorizontal;
    newPixels(pixels, new DirectColorModel(24,
              0x00ff0000,  // Red
              0x0000ff00,  // Green
              0x000000ff  // Blue
              )
              , 0, w);
    setAnimated(true);
###
770, getTickLength, ColorSliderUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java, 361, 362
6
/**
   * Gets the height of the tick area for horizontal sliders and the width of the
   * tick area for vertical sliders.  BasicSliderUI uses the returned value to
   * determine the tick area rectangle.  If you want to give your ticks some room,
   * make this larger than you need and paint your ticks away from the sides in paintTicks().
   */
2
  protected int getTickLength() {
    return 4;
###
771, ColorSliderUI, ColorSliderUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java, 47, 48
1
/** Creates a new instance. */
2
  public ColorSliderUI(JSlider b)   {
    super(b);
###
772, mousePressed, QuaquaTrackListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java, 438, 462
7
/**
     * If the mouse is pressed above the "thumb" component
     * then reduce the scrollbars value by one page ("page up"),
     * otherwise increase it by one page.  If there is no
     * thumb then page up if the mouse is in the upper half
     * of the track.
     */
25
    public void mousePressed(MouseEvent e) {
      if ( !slider.isEnabled() )
        return;
      
      currentMouseX = e.getX();
      currentMouseY = e.getY();
      
      if (slider.isRequestFocusEnabled()) {
        slider.requestFocus();
      }
      
      // Clicked inside the Thumb area?
      if (thumbRect.contains(currentMouseX, currentMouseY) ) {
        super.mousePressed(e);
      } else {
        Dimension sbSize = slider.getSize();
        int direction = POSITIVE_SCROLL;
        
        switch ( slider.getOrientation() ) {
          case JSlider.VERTICAL:
            slider.setValue(valueForYPosition(currentMouseY));
            break;
          case JSlider.HORIZONTAL:
            slider.setValue(valueForXPosition(currentMouseX));
            break;
###
773, ColorWheelChooser, ColorWheelChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelChooser.java, 39, 56
3
/**
   * Creates a new instance.
   */
18
  public ColorWheelChooser() {
    initComponents();
    
        int textSliderGap = UIManager.getInt("ColorChooser.textSliderGap");
    if (textSliderGap != 0) {
      BorderLayout layout = (BorderLayout) getLayout();
      layout.setHgap(textSliderGap);
}
    
    colorWheel = new JColorWheel();
    add(colorWheel);
    
    ccModel.configureSlider(2, brightnessSlider);
    colorWheel.setModel(ccModel);
    
    ccModel.addChangeListener(new ChangeListener() {
      public void stateChanged(ChangeEvent evt) {
        setColorToModel(ccModel.getColor());
###
774, initComponents, ColorWheelChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelChooser.java, 66, 74
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
7
  private void initComponents() {//GEN-BEGIN:initComponents
    brightnessSlider = new javax.swing.JSlider();
    setLayout(new java.awt.BorderLayout());
    brightnessSlider.setMajorTickSpacing(50);
    brightnessSlider.setOrientation(javax.swing.JSlider.VERTICAL);
    brightnessSlider.setPaintTicks(true);
    add(brightnessSlider, java.awt.BorderLayout.EAST);
###
788, SerializationInputOutputFormat, SerializationInputOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/SerializationInputOutputFormat.java, 73, 74
3
/** Creates a new instance with format name "Drawing", file extension "xml"
   * and mime type "image/x-jhotdraw".
   */
2
  public SerializationInputOutputFormat() {
    this("Drawing", "ser", new DefaultDrawing());
###
789, ImageInputFormat, ImageInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageInputFormat.java, 93, 95
8
/** Creates a new image input format for the specified image format.
   *
   * @param formatName The format name for the javax.imageio.ImageIO object.
   * @param description The format description to be used for the file filter.
   * @param fileExtension The file extension to be used for the file filter.
   * @param mimeType The mime type used for filtering data flavors from
   * Transferable objects.
   */
3
  public ImageInputFormat(ImageHolderFigure prototype, String formatName, String description, String fileExtension,
      String mimeType) {
    this(prototype, formatName, description, new String[]{fileExtension}, new String[]{mimeType});
###
790, ImageInputFormat, ImageInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageInputFormat.java, 81, 82
2
/** Creates a new image input format for all formats supported by
   * {@code javax.imageio.ImageIO}. */
2
  public ImageInputFormat(ImageHolderFigure prototype) {
    this(prototype, "Image", "Image", ImageIO.getReaderFileSuffixes(), ImageIO.getReaderMIMETypes());
###
803, north, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 81, 82
3
/**
   * North.
   */
2
  static public Locator north() {
    return new RelativeDecoratorLocator(0.5, 0.0);
###
804, addCornerTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 47, 51
4
/**
   * Creates handles for each corner of a
   * figure and adds them to the provided collection.
   */
5
  static public void addCornerTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(southEast(f));
    handles.add(southWest(f));
    handles.add(northEast(f));
    handles.add(northWest(f));
###
805, RelativeDecoratorLocator, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 46, 47
1
/** Creates a new instance. */
2
  public RelativeDecoratorLocator(double relativeX, double relativeY) {
    super(relativeX, relativeY);
###
806, addScaleMoveTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 68, 70
3
/**
   * Adds handles for scaling and moving a Figure.
   */
3
  static public void addScaleMoveTransformHandles(Figure f, Collection<Handle> handles) {
    addCornerTransformHandles(f, handles);
    addEdgeTransformHandles(f, handles);
###
807, northWest, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 102, 103
3
/**
   * North west.
   */
2
  static public Locator northWest() {
    return new RelativeDecoratorLocator(0.0, 0.0);
###
808, addEdgeTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 58, 62
4
/**
   * Fills the given Vector with handles at each
   * the north, south, east, and west of the figure.
   */
5
  static public void addEdgeTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(south(f));
    handles.add(north(f));
    handles.add(east(f));
    handles.add(west(f));
###
809, west, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 88, 89
3
/**
   * West.
   */
2
  static public Locator west() {
    return new RelativeDecoratorLocator(0.0, 0.5);
###
810, northEast, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 95, 96
3
/**
   * North east.
   */
2
  static public Locator northEast() {
    return new RelativeDecoratorLocator(1.0, 0.0);
###
811, addGroupTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 86, 95
3
/**
   * Adds handles for scaling, moving, rotating and shearing a Figure.
   */
10
  static public void addGroupTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(new BoundsOutlineHandle(f,
        GROUP_BOUNDS_STROKE_1, GROUP_BOUNDS_COLOR_1,
        GROUP_BOUNDS_STROKE_2, GROUP_BOUNDS_COLOR_2,
        GROUP_BOUNDS_STROKE_1_DISABLED, GROUP_BOUNDS_COLOR_1_DISABLED,
        GROUP_BOUNDS_STROKE_2_DISABLED, GROUP_BOUNDS_COLOR_2_DISABLED
        ));
    addCornerTransformHandles(f, handles);
    addEdgeTransformHandles(f, handles);
    handles.add(new RotateHandle(f));
###
812, south, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 109, 110
3
/**
   * South.
   */
2
  static public Locator south() {
    return new RelativeDecoratorLocator(0.5, 1.0);
###
813, addTransformHandles, TransformHandleKit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 76, 80
3
/**
   * Adds handles for scaling, moving, rotating and shearing a Figure.
   */
5
  static public void addTransformHandles(Figure f, Collection<Handle> handles) {
    handles.add(new BoundsOutlineHandle(f, true, false));
    addCornerTransformHandles(f, handles);
    addEdgeTransformHandles(f, handles);
    handles.add(new RotateHandle(f));
###
814, southWest, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 123, 124
3
/**
   * South west.
   */
2
  static public Locator southWest() {
    return new RelativeDecoratorLocator(0.0, 1.0);
###
815, southEast, RelativeDecoratorLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java, 116, 117
3
/**
   * South east.
   */
2
  static public Locator southEast() {
    return new RelativeDecoratorLocator(1.0, 1.0);
###
817, draw, TransformHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java, 159, 170
3
/**
     * Draws this handle.
     */
12
    public void draw(Graphics2D g) {
      if (getEditor().getTool().supportsHandleInteraction()) {
        //drawArc(g);
        
        drawDiamond(g,
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR),
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR));
        
        } else {
        drawDiamond(g,
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR_DISABLED),
            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR_DISABLED));        
###
818, BezierTool, BezierTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/BezierTool.java, 60, 61
1
/** Creates a new instance. */
2
  public BezierTool(BezierFigure prototype) {
    this(prototype, null);
###
819, BezierTool, BezierTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/BezierTool.java, 65, 66
1
/** Creates a new instance. */
2
  public BezierTool(BezierFigure prototype, Map<AttributeKey, Object> attributes) {
    this(prototype, attributes, null);
###
820, AbstractTool, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 74, 77
1
/** Creates a new instance. */
4
  public AbstractTool() {
    editorProxy = new DrawingEditorProxy();
    setInputMap(createInputMap());
    setActionMap(createActionMap());
###
821, fireToolStarted, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 316, 329
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireToolStarted(DrawingView view) {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, view, new Rectangle(0, 0, -1, -1));
        }
        ((ToolListener) listeners[i + 1]).toolStarted(event);
###
822, createInputMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 264, 265
5
/** Override this method to create a tool-specific input map, which
   * overrides the input map of the drawing edtior.
   * <p>
   * The implementation of this class returns null.
   */
2
  protected InputMap createInputMap() {
    return null;
###
823, createActionMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 273, 274
5
/** Override this method to create a tool-specific action map, which
   * overrides the action map of the drawing edtior.
   * <p>
   * The implementation of this class returns null.
   */
2
  protected ActionMap createActionMap() {
    return null;
###
825, editDelete, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 170, 171
5
/**
   * Deletes the selection.
   * Depending on the tool, this could be selected figures, selected points
   * or selected text.
   */
2
  public void editDelete() {
    getView().getDrawing().removeAll(getView().getSelectedFigures());
###
826, fireToolDone, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 338, 351
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireToolDone() {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, getView(), new Rectangle(0, 0, -1, -1));
        }
        ((ToolListener) listeners[i + 1]).toolDone(event);
###
827, DOMStorableInputOutputFormat, DOMStorableInputOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/DOMStorableInputOutputFormat.java, 81, 92
7
/** Creates a new instance using the specified parameters.
   *
   * @param factory The factory for creating Figures from XML elements.
   * @param description The format description to be used for the file filter.
   * @param fileExtension The file extension to be used for file filter.
   * @param mimeType The Mime Type is used for clipboard access.
   */
12
  public DOMStorableInputOutputFormat(
      DOMFactory factory,
      String description, String fileExtension, String mimeType) {
    this.factory = factory;
    this.fileExtension = fileExtension;
    this.mimeType = mimeType;
    try {
      this.dataFlavor = new DataFlavor(mimeType);
    } catch (ClassNotFoundException ex) {
      InternalError error = new InternalError("Unable to create data flavor for mime type:" + mimeType);
      error.initCause(ex);
      throw error;
###
828, fireAreaInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 371, 384
4
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireAreaInvalidated(Rectangle invalidatedArea) {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, getView(), invalidatedArea);
        }
        ((ToolListener) listeners[i + 1]).areaInvalidated(event);
###
829, DOMStorableInputOutputFormat, DOMStorableInputOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/DOMStorableInputOutputFormat.java, 70, 71
3
/** Creates a new instance with format name "Drawing", file extension "xml"
   * and mime type "image/x-jhotdraw".
   */
2
  public DOMStorableInputOutputFormat(DOMFactory factory) {
    this(factory, "Drawing", "xml", "image/x-jhotdraw");
###
830, getInputMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 146, 147
3
/**
   * Gets the input map of the Tool
   */
2
  public InputMap getInputMap() {
    return inputMap;
###
832, fireBoundsInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 414, 428
4
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   */
14
  protected void fireBoundsInvalidated(Rectangle invalidatedArea) {
    ToolEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ToolListener.class) {
        // Lazily create the event:
        if (event == null) {
          event = new ToolEvent(this, getView(), invalidatedArea);
        }
        ((ToolListener) listeners[i + 1]).boundsInvalidated(event);
###
834, setActionMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 154, 155
4
/**
   * Sets the ActionMap for the Tool.
   * @see #keyPressed
   */
2
  public void setActionMap(ActionMap newValue) {
    actionMap = newValue;
###
836, keyPressed, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 220, 254
7
/**
   * The Tool uses the InputMap to determine what to do, when a key is pressed.
   * If the corresponding value of the InputMap is a String, the ActionMap
   * of the tool is used, to find the action to be performed.
   * If the corresponding value of the InputMap is a ActionListener, the
   * actionPerformed method of the ActionListener is performed.
   */
34
  public void keyPressed(KeyEvent evt) {
    if (!evt.isConsumed()) {
      if (evt.getSource() instanceof Container) {
        editor.setActiveView(editor.findView((Container) evt.getSource()));
      }
      Object obj = null;
      if (inputMap != null) {
        // Lookup the input map of the tool
        obj = inputMap.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));
      }
      if (obj == null) {
        // Fall back to the input map of the drawing editor
        InputMap im = editor.getInputMap();
        if (im != null) {
          obj = im.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));
        }
      }
      ActionListener al = null;
      if (obj instanceof ActionListener) {
        al = (ActionListener) obj;
      } else if (obj != null) {
        // Lookup the action map of the tool
        if (actionMap != null) {
          al = actionMap.get(obj);
        }
        if (al == null) {
          // Fall back to the action map of the drawing editor
          al = editor.getActionMap().get(obj);
        }
      }
      if (al != null) {
        evt.consume();
        al.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, "tool", evt.getWhen(), evt.getModifiers()));
        fireToolDone();
###
838, fireAreaInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 360, 364
4
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   */
5
  protected void fireAreaInvalidated(Rectangle2D.Double r) {
    Point p1 = getView().drawingToView(new Point2D.Double(r.x, r.y));
    Point p2 = getView().drawingToView(new Point2D.Double(r.x + r.width, r.y + r.height));
    fireAreaInvalidated(
        new Rectangle(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y));
###
839, getActionMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 161, 162
3
/**
   * Gets the action map of the Tool
   */
2
  public ActionMap getActionMap() {
    return actionMap;
###
840, maybeFireBoundsInvalidated, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 396, 406
7
/**
   * Notify all listenerList that have registered interest for
   * notification on this event type.
   *
   * Note: This method only fires an event, if the invalidated area
   * is outside of the canvas bounds.
   */
11
  protected void maybeFireBoundsInvalidated(Rectangle invalidatedArea) {
    Drawing d = getDrawing();
    Rectangle2D.Double canvasBounds = new Rectangle2D.Double(0, 0, 0, 0);
    if (d.get(CANVAS_WIDTH) != null) {
      canvasBounds.width += d.get(CANVAS_WIDTH);
    }
    if (d.get(CANVAS_HEIGHT) != null) {
      canvasBounds.height += d.get(CANVAS_HEIGHT);
    }
    if (!canvasBounds.contains(invalidatedArea)) {
       fireBoundsInvalidated(invalidatedArea);
###
841, setInputMap, AbstractTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java, 139, 140
6
/**
   * Sets the InputMap for the Tool.
   *
   * @see #keyPressed
   * @see #setActionMap
   */
2
  public void setInputMap(InputMap newValue) {
    inputMap = newValue;
###
842, ImageOutputFormat, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 56, 57
1
/** Creates a new image output format for Portable Network Graphics PNG. */
2
  public ImageOutputFormat() {
    this("PNG", "Portable Network Graphics (PNG)", "png", BufferedImage.TYPE_INT_ARGB);
###
843, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 115, 117
5
/**
   * Writes the drawing to the specified output stream.
   * This method applies the specified transform to the drawing, and draws
   * it on an image of the specified size.
   */
3
  public void write(OutputStream out, Drawing drawing,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    write(out, drawing, drawing.getChildren(), drawingTransform, imageSize);
###
844, createTransferable, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 125, 126
5
/**
   * Writes the drawing to the specified output stream.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
2
  public Transferable createTransferable(Drawing drawing, java.util.List<Figure> figures, double scaleFactor) throws IOException {
    return new ImageTransferable(toImage(drawing, figures, scaleFactor, true));
###
845, ImageOutputFormat, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 68, 73
8
/** Creates a new image output format for the specified image format.
   *
   * @param formatName The format name for the javax.imageio.ImageIO object.
   * @param description The format description to be used for the file filter.
   * @param fileExtension The file extension to be used for file filter.
   * @param bufferedImageType The BufferedImage type used to produce the image.
   *      The value of this parameter must match with the format name.
   */
6
  public ImageOutputFormat(String formatName, String description, String fileExtension,
      int bufferedImageType) {
    this.formatName = formatName;
    this.description = description;
    this.fileExtension = fileExtension;
    this.imageType = bufferedImageType;
###
846, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 107, 108
5
/**
   * Writes the drawing to the specified output stream.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
2
  public void write(OutputStream out, Drawing drawing) throws IOException {
    write(out, drawing, drawing.getChildren(), null, null);
###
847, toImage, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 221, 272
9
/**
   * Creates a BufferedImage from the specified list of figures.
   *
   * @param drawing The drawing.
   * @param figures A list of figures of the drawing.
   * @param transform The AffineTransform to be used when drawing
   * the figures.
   * @param imageSize The width and height of the image.
   */
51
  public BufferedImage toImage(
      Drawing drawing,
      java.util.List<Figure> figures,
      AffineTransform transform,
      Dimension imageSize) {
    
    // Create the buffered image and clear it
    Color background = drawing.get(CANVAS_FILL_COLOR);
    double opacity = drawing.get(CANVAS_FILL_OPACITY);
    if (background == null) {
      background = new Color(0xff, 0xff, 0xff, 0x0);
    } else {
      background = new Color(background.getRed(), background.getGreen(), background.getBlue(), (int)(background.getAlpha() * opacity));
    }
    BufferedImage buf = new BufferedImage(
        Math.max(1,imageSize.width), Math.max(1,imageSize.height),
        (background.getAlpha() == 255) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB
        );
    Graphics2D g = buf.createGraphics();
    
    // Clear the buffered image with the background color
    Composite savedComposite = g.getComposite();
    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));
    g.setColor(background);
    g.fillRect(0,0,buf.getWidth(),buf.getHeight());
    g.setComposite(savedComposite);
    
    // Draw the figures onto the buffered image
    setRenderingHints(g);
    g.transform(transform);
    for (Figure f : figures) {
      f.draw(g);
    }
    g.dispose();
    
    // Convert the image, if it does not have the specified image type
    if (imageType != BufferedImage.TYPE_INT_ARGB) {
      BufferedImage buf2 = new BufferedImage(
          buf.getWidth(), buf.getHeight(),
          imageType
          );
      g = buf2.createGraphics();
      setRenderingHints(g);
      g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));
      g.drawImage(buf, 0, 0, null);
      g.dispose();
      buf.flush();
      buf = buf2;
    }
    
    return buf;
###
848, north, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 135, 136
5
/**
   * North.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator north(boolean isTransform) {
    return new RelativeLocator(0.5, 0.0, isTransform);
###
849, RelativeLocator, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 56, 57
1
/** Creates a new instance. */
2
  public RelativeLocator(double relativeX, double relativeY) {
    this(relativeX, relativeY, false);
###
850, east, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 112, 113
3
/**
   * Non-transforming East.
   */
2
  static public Locator east() {
    return east(false);
###
851, toImage, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 168, 206
14
/**
   * Creates a BufferedImage from the specified list of figures.
   * <p>
   * The images are drawn using the specified scale factor. If some figures
   * have a drawing area located at negative coordinates, then the drawing
   * coordinates are translated, so that all figures are visible on the
   * image.
   *
   * @param drawing The drawing.
   * @param figures A list of figures of the drawing.
   * @param scaleFactor The scale factor used when drawing the figures.
   * @param clipToFigures If this is true, the image is clipped to the figures.
   * If this is false, the image includes the drawing area,  
   */
37
  public BufferedImage toImage(Drawing drawing,
      java.util.List<Figure> figures,
      double scaleFactor, boolean clipToFigures) {
    
    // Determine the draw bounds of the figures
    Rectangle2D.Double drawBounds = null;
    for (Figure f : figures) {
      if (drawBounds == null) {
        drawBounds = f.getDrawingArea();
      } else {
        drawBounds.add(f.getDrawingArea());
      }
    }
    if (clipToFigures) {
    AffineTransform transform = new AffineTransform();
      transform.translate(-drawBounds.x * scaleFactor, 
          -drawBounds.y * scaleFactor);
    transform.scale(scaleFactor, scaleFactor);
    return toImage(drawing, figures, transform,
        new Dimension(
        (int) (drawBounds.width * scaleFactor),
        (int) (drawBounds.height * scaleFactor)
        )
        );
    } else {
    AffineTransform transform = new AffineTransform();
    if (drawBounds.x < 0) {
      transform.translate(-drawBounds.x * scaleFactor, 0);
    }
    if (drawBounds.y < 0) {
      transform.translate(0, -drawBounds.y * scaleFactor);
    }
    transform.scale(scaleFactor, scaleFactor);
     return toImage(drawing, figures, transform,
        new Dimension(
        (int) ((Math.max(0, drawBounds.x)+drawBounds.width) * scaleFactor),
        (int) ((Math.max(0, drawBounds.y)+drawBounds.height) * scaleFactor)
###
852, southWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 217, 218
3
/**
   * Non-transforming South west.
   */
2
  static public Locator southWest() {
    return southWest(false);
###
853, center, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 233, 234
3
/**
   * Non-transforming Center.
   */
2
  static public Locator center() {
    return center(false);
###
854, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 93, 98
5
/**
   * Writes the drawing to the specified file.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
6
  public void write(File file, Drawing drawing) throws IOException {
    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));
    try {
      write(out, drawing);
    } finally {
        out.close();
###
855, south, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 195, 196
5
/**
   * South.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator south(boolean isTransform) {
    return new RelativeLocator(0.5, 1.0, isTransform);
###
856, north, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 127, 128
3
/**
   * Non-transforming North.
   */
2
  static public Locator north() {
    return north(false);
###
857, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 134, 135
5
/**
   * Writes the figures to the specified output stream.
   * This method ensures that all figures of the drawing are visible on
   * the image.
   */
2
  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {
    write(out, drawing, figures, null, null);
###
858, southEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 202, 203
3
/**
   * Non-transforming South east.
   */
2
  static public Locator southEast() {
    return southEast(false);
###
859, RelativeLocator, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 51, 52
1
/** Creates a new instance. */
2
  public RelativeLocator() {
    this(0, 0, false);
###
860, write, ImageOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java, 142, 151
5
/**
   * Writes the figures to the specified output stream.
   * This method applies the specified transform to the drawing, and draws
   * it on an image of the specified size.
   */
10
  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    BufferedImage img;
    if (drawingTransform == null || imageSize == null) {
      img = toImage(drawing, figures, 1d, false);
    } else {
      img = toImage(drawing, figures, drawingTransform, imageSize);
    }
    ImageIO.write(img, formatName, out);
    img.flush();
###
861, southEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 210, 211
5
/**
   * South East.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator southEast(boolean isTransform) {
    return new RelativeLocator(1.0, 1.0, isTransform);
###
862, west, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 142, 143
3
/**
   * Non-transforming West.
   */
2
  static public Locator west() {
    return west(false);
###
863, northEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 157, 158
3
/**
   * Non-transforming North east.
   */
2
  static public Locator northEast() {
    return northEast(false);
###
864, east, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 120, 121
5
/**
   * East.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator east(boolean isTransform) {
    return new RelativeLocator(1.0, 0.5, isTransform);
###
865, west, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 150, 151
5
/**
   * West.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator west(boolean isTransform) {
    return new RelativeLocator(0.0, 0.5, isTransform);
###
866, RelativeLocator, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 67, 70
8
/**
   * @param relativeX x-position relative to bounds expressed as a value
   * between 0 and 1.
   * @param relativeY y-position relative to bounds expressed as a value
   * between 0 and 1.
   * @param isTransform Set this to true, if the locator shall honor the
   * TRANSFORM attribute of the Figure.
   */
4
  public RelativeLocator(double relativeX, double relativeY, boolean isTransform) {
    this.relativeX = relativeX;
    this.relativeY = relativeY;
    this.isTransform = isTransform;
###
867, south, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 187, 188
3
/**
   * Non-transforming South.
   */
2
  static public Locator south() {
    return south(false);
###
868, northWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 180, 181
5
/**
   * North West.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator northWest(boolean isTransform) {
    return new RelativeLocator(0.0, 0.0, isTransform);
###
869, northWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 172, 173
3
/**
   * Non-transforming North west.
   */
2
  static public Locator northWest() {
    return northWest(false);
###
870, northEast, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 165, 166
5
/**
   * Norht East.
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator northEast(boolean isTransform) {
    return new RelativeLocator(1.0, 0.0, isTransform);
###
871, southWest, RelativeLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java, 226, 227
6
/**
   * South West.
   *
   * @param isTransform Set this to true, if RelativeLocator shall honour
   * the AttributesKey.TRANSFORM attribute of the Figure.
   */
2
  static public Locator southWest(boolean isTransform) {
    return new RelativeLocator(0.0, 1.0, isTransform);
###
872, TextInputFormat, TextInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/io/TextInputFormat.java, 77, 78
3
/** Creates a new image output format for text, for a figure that can not.
   * hold multiple lines of text.
   */
2
  public TextInputFormat(TextHolderFigure prototype) {
    this(prototype, "Text", "Text", "txt", false);
###
873, mouseDragged, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 236, 254
3
/**
   * Adjust the created connection.
   */
17
  public void mouseDragged(java.awt.event.MouseEvent e) {
    repaintConnectors(e);
    if (createdFigure != null) {
      createdFigure.willChange();
      Point2D.Double endPoint = viewToDrawing(new Point(e.getX(), e.getY()));
      getView().getConstrainer().constrainPoint(endPoint);
      Figure endFigure = getDrawing().findFigureExcept(endPoint, createdFigure);
      endConnector = (endFigure == null) ? null : endFigure.findConnector(endPoint, prototype);
      if (endConnector != null && canConnect(createdFigure, startConnector, endConnector)) {
        endPoint = endConnector.getAnchor();
      }
      Rectangle r = new Rectangle(getView().drawingToView(createdFigure.getEndPoint()));
      createdFigure.setEndPoint(endPoint);
      r.add(getView().drawingToView(endPoint));
      r.grow(ANCHOR_WIDTH + 2, ANCHOR_WIDTH + 2);
      getView().getComponent().repaint(r);
      createdFigure.changed();
###
874, repaintConnectors, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 170, 199
4
/**
   * Updates the list of connectors that we draw when the user
   * moves or drags the mouse over a figure to which can connect.
   */
30
  public void repaintConnectors(MouseEvent evt) {
    Rectangle2D.Double invalidArea = null;
    Point2D.Double targetPoint = viewToDrawing(new Point(evt.getX(), evt.getY()));
    Figure aFigure = getDrawing().findFigureExcept(targetPoint, createdFigure);
    if (aFigure != null && !aFigure.isConnectable()) {
      aFigure = null;
    }
    if (targetFigure != aFigure) {
      for (Connector c : connectors) {
        if (invalidArea == null) {
          invalidArea = c.getDrawingArea();
        } else {
          invalidArea.add(c.getDrawingArea());
        }
      }
      targetFigure = aFigure;
      if (targetFigure != null) {
        connectors = targetFigure.getConnectors(getPrototype());
        for (Connector c : connectors) {
          if (invalidArea == null) {
            invalidArea = c.getDrawingArea();
          } else {
            invalidArea.add(c.getDrawingArea());
          }
        }
      }
    }
    if (invalidArea != null) {
      getView().getComponent().repaint(
          getView().drawingToView(invalidArea));
###
875, mouseReleased, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 262, 305
4
/**
   * Connects the figures if the mouse is released over another
   * figure.
   */
40
  @Override
  public void mouseReleased(MouseEvent e) {
    if (createdFigure != null &&
        startConnector != null && endConnector != null &&
        createdFigure.canConnect(startConnector, endConnector)) {
      createdFigure.willChange();
      createdFigure.setStartConnector(startConnector);
      createdFigure.setEndConnector(endConnector);
      createdFigure.updateConnection();
      createdFigure.changed();
      final Figure addedFigure = createdFigure;
      final Drawing addedDrawing = getDrawing();
      getDrawing().fireUndoableEditHappened(new AbstractUndoableEdit() {
        public String getPresentationName() {
          return presentationName;
        }
        public void undo() throws CannotUndoException {
          super.undo();
          addedDrawing.remove(addedFigure);
        }
        public void redo() throws CannotRedoException {
          super.redo();
          addedDrawing.add(addedFigure);
        }
      });
      targetFigure = null;
      Point2D.Double anchor = startConnector.getAnchor();
      Rectangle r = new Rectangle(getView().drawingToView(anchor));
      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);
      fireAreaInvalidated(r);
      anchor = endConnector.getAnchor();
      r = new Rectangle(getView().drawingToView(anchor));
      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);
      fireAreaInvalidated(r);
      startConnector = endConnector = null;
      createdFigure = null;
      creationFinished(createdFigure);
    } else {
      if (isToolDoneAfterCreation()) {
        fireToolDone();
###
876, mousePressed, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 208, 230
5
/**
   * Manipulates connections in a context dependent way. If the
   * mouse down hits a figure start a new connection. If the mousedown
   * hits a connection split a segment or join two segments.
   */
20
  public void mousePressed(MouseEvent evt) {
    super.mousePressed(evt);
    getView().clearSelection();
    Point2D.Double startPoint = viewToDrawing(anchor);
    Figure startFigure = getDrawing().findFigure(startPoint);
    startConnector = (startFigure == null) ? null : startFigure.findConnector(startPoint, prototype);
    if (startConnector != null && canConnect(prototype, startConnector)) {
      Point2D.Double anchor = startConnector.getAnchor();
      createdFigure = createFigure();
      createdFigure.setStartPoint(anchor);
      createdFigure.setEndPoint(anchor);
      getDrawing().add(createdFigure);
      Rectangle r = new Rectangle(getView().drawingToView(anchor));
      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);
      fireAreaInvalidated(r);
    } else {
      startConnector = null;
      createdFigure = null;
    }
    endConnector = null;
###
877, setToolDoneAfterCreation, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 389, 391
5
/**
   * If this is set to false, the CreationTool does not fire toolDone
   * after a new Figure has been created. This allows to create multiple
   * figures consecutively.
   */
3
  public void setToolDoneAfterCreation(boolean newValue) {
    boolean oldValue = isToolDoneAfterCreation;
    isToolDoneAfterCreation = newValue;
###
878, canConnect, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 158, 159
9
/**
   * This method is called on the Figure, onto which the user wants
   * to end a new connection.
   * 
   * @param f The ConnectionFigure.
   * @param startConnector The Connector of the start Figure.
   * @param endConnector The Connector of the end Figure.
   * @return True, if a connection can be made.
   */
2
  protected boolean canConnect(ConnectionFigure f, Connector startConnector, Connector endConnector) {
    return f.canConnect(startConnector, endConnector);
###
879, ConnectionTool, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 91, 92
2
/** Creates a new instance.
   */
2
  public ConnectionTool(ConnectionFigure prototype) {
    this(prototype, null, null);
###
880, createFigure, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 329, 338
4
/**
   * Creates the ConnectionFigure. By default the figure prototype is
   * cloned.
   */
10
  @SuppressWarnings("unchecked")
  protected ConnectionFigure createFigure() {
    ConnectionFigure f = (ConnectionFigure) prototype.clone();
    getEditor().applyDefaultAttributesTo(f);
    if (prototypeAttributes != null) {
      for (Map.Entry<AttributeKey, Object> entry : prototypeAttributes.entrySet()) {
        f.set(entry.getKey(), entry.getValue());
      }
    }
    return f;
###
881, creationFinished, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 378, 380
5
/**
   * This method allows subclasses to do perform additonal user interactions
   * after the new figure has been created.
   * The implementation of this class just invokes fireToolDone.
   */
3
  protected void creationFinished(Figure createdFigure) {
    if (isToolDoneAfterCreation()) {
      fireToolDone();
###
882, canConnect, ConnectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java, 145, 146
8
/**
   * This method is called on the Figure, onto which the user wants
   * to start a new connection.
   * 
   * @param f The ConnectionFigure.
   * @param startConnector The Connector of the start Figure.
   * @return True, if a connection can be made.
   */
2
  protected boolean canConnect(ConnectionFigure f, Connector startConnector) {
    return f.canConnect(startConnector);
###
883, DrawingPageable, DrawingPageable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/print/DrawingPageable.java, 50, 54
1
/** Creates a new instance. */
5
  public DrawingPageable(Drawing drawing) {
    this.drawing = drawing;
    Paper paper = new Paper();
    pageFormat = new PageFormat();
    pageFormat.setPaper(paper);
###
884, createOverlay, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 88, 89
4
/**
   * Creates the overlay within the given container.
   * @param view the DrawingView
   */
2
  public void createOverlay(DrawingView view) {
    createOverlay(view, null);
###
885, getText, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 139, 140
4
/**
   * Gets the text contents of the overlay.
   * @return The text value
   */
2
  public String getText() {
    return textArea.getText();
###
886, FloatingTextArea, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 73, 81
3
/**
   * Constructor for the FloatingTextArea object
   */
9
  public FloatingTextArea() {
    textArea = new JTextArea();
    textArea.setWrapStyleWord(true);
    textArea.setLineWrap(true);
    editScrollContainer = new JScrollPane(textArea,
        JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
        JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
    editScrollContainer.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
    editScrollContainer.setBorder(BorderFactory.createLineBorder(Color.black));
###
887, getPreferredSize, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 148, 149
5
/**
   * Gets the preferred size of the overlay.
   * @param cols Description of the Parameter
   * @return The preferredSize value
   */
2
  public Dimension getPreferredSize(int cols) {
    return new Dimension(textArea.getWidth(), textArea.getHeight());
###
888, createOverlay, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 102, 108
6
/**
   * Creates the overlay for the given Container using a
   * specific font.
   * @param view the DrawingView
   * @param figure the figure holding the text
   */
7
  public void createOverlay(DrawingView view, TextHolderFigure figure) {
    view.getComponent().add(editScrollContainer, 0);
    editedFigure = figure;
    this.view = view;
    if (editedFigure != null) {
      editedFigure.addFigureListener(figureHandler);
      updateWidget();
###
889, setBounds, FloatingTextArea, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java, 127, 132
5
/**
   * Positions and sizes the overlay.
   * @param r the bounding Rectangle2D.Double for the overlay
   * @param text the text to edit
   */
6
  public void setBounds(Rectangle2D.Double r, String text) {
    textArea.setText(text);
    editScrollContainer.setBounds(view.drawingToView(r));
    editScrollContainer.setVisible(true);
    textArea.setCaretPosition(0);
    textArea.requestFocus();
###
891, createOverlay, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 70, 71
3
/**
   * Creates the overlay for the given Component.
   */
2
  public void createOverlay(DrawingView view) {
    createOverlay(view, null);
###
892, getText, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 144, 145
3
/**
   * Gets the text contents of the overlay.
   */
2
  public String getText() {
    return textField.getText();
###
893, createOverlay, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 82, 91
4
/**
   * Creates the overlay for the given Container using a
   * specific font.
   */
10
  public void createOverlay(DrawingView view, TextHolderFigure figure) {
    view.getComponent().add(textField, 0);
    textField.setText(figure.getText());
    textField.setColumns(figure.getTextColumns());
    textField.selectAll();
    textField.setVisible(true);
    editedFigure = figure;
    editedFigure.addFigureListener(figureHandler);
    this.view = view;
    updateWidget();
###
894, removeActionListener, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 136, 137
3
/**
   * Remove an action listener
   */
2
  public void removeActionListener(ActionListener listener) {
    textField.removeActionListener(listener);
###
895, getPreferredSize, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 151, 153
3
/**
   * Gets the preferred size of the overlay.
   */
3
  public Dimension getPreferredSize(int cols) {
    textField.setColumns(cols);
    return textField.getPreferredSize();
###
896, addActionListener, FloatingTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java, 129, 130
3
/**
   * Adds an action listener
   */
2
  public void addActionListener(ActionListener listener) {
    textField.addActionListener(listener);
###
897, ElbowLiner, ElbowLiner, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/liner/ElbowLiner.java, 41, 42
1
/** Creates a new instance. */
2
  public ElbowLiner() {
    this(20);
###
898, CurvedLiner, CurvedLiner, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/liner/CurvedLiner.java, 40, 41
1
/** Creates a new instance. */
2
  public CurvedLiner() {
    this(20);
###
900, BezierLabelLocator, BezierLabelLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java, 55, 58
9
/** Creates a new locator.
   *
   * @param relativePosition The relative position of the label on the polyline.
   * 0.0 specifies the start of the bezier path, 1.0 the
   * end of the polyline. Values between 0.0 and 1.0 are relative positions
   * on the bezier path.
   * @param angle The angle of the distance vector.
   * @param distance The length of the distance vector.
   */
4
  public BezierLabelLocator(double relativePosition, double angle, double distance) {
    this.relativePosition = relativePosition;
    this.angle = angle;
    this.distance = distance;
###
901, getRelativePoint, BezierLabelLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java, 73, 92
4
/**
   * Returns the coordinates of the relative point on the path
   * of the specified bezier figure.
   */
20
  public Point2D.Double getRelativePoint(BezierFigure owner) {
    Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);
    Point2D.Double nextPoint = owner.getPointOnPath(
        (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,
        3);
    
    double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
    if (relativePosition >= 0.5) {
      dir += Math.PI;
    }
    double alpha = dir + angle;
    
    Point2D.Double p = new Point2D.Double(
        point.x + distance * Math.cos(alpha),
        point.y + distance * Math.sin(alpha)
        );
    
    if (Double.isNaN(p.x)) p = point;
    
    return p;
###
903, getRelativeLabelPoint, BezierLabelLocator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java, 100, 148
4
/**
   * Returns a Point2D.Double on the polyline that is at the provided relative position.
   * XXX - Implement this and move it to BezierPath
   */
49
  public Point2D.Double getRelativeLabelPoint(BezierFigure owner, Figure label) {
    // Get a point on the path an the next point on the path
    Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);
    if (point == null) {
      return new Point2D.Double(0,0);
    }
    Point2D.Double nextPoint = owner.getPointOnPath(
        (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,
        3);
    
    double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);
    if (relativePosition >= 0.5) {
      dir += Math.PI;
    }
    double alpha = dir + angle;
    
    Point2D.Double p = new Point2D.Double(
        point.x + distance * Math.cos(alpha),
        point.y + distance * Math.sin(alpha)
        );
    if (Double.isNaN(p.x)) p = point;
    
    Dimension2DDouble labelDim = label.getPreferredSize();
    if (relativePosition == 0.5 && 
        p.x >= point.x - distance / 2 && 
        p.x <= point.x + distance / 2) {
      if (p.y >= point.y) {
        // South East
        return new Point2D.Double(p.x - labelDim.width / 2, p.y);
      } else {
        // North East
        return new Point2D.Double(p.x - labelDim.width / 2, p.y - labelDim.height);
      }
    } else {
      if (p.x >= point.x) {
        if (p.y >= point.y) {
          // South East
          return new Point2D.Double(p.x, p.y);
        } else {
          // North East
          return new Point2D.Double(p.x, p.y - labelDim.height);
        }
      } else {
        if (p.y >= point.y) {
          // South West
          return new Point2D.Double(p.x - labelDim.width,  p.y);
        } else {
          // North West
          return new Point2D.Double(p.x - labelDim.width, p.y - labelDim.height);
###
905, SlantedLiner, SlantedLiner, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/liner/SlantedLiner.java, 41, 42
1
/** Creates a new instance. */
2
  public SlantedLiner() {
    this(20);
###
906, getBeanDescriptor, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
908, getPropertyDescriptors, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
909, getMethodDescriptors, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
911, getDefaultEventIndex, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
913, getDefaultPropertyIndex, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
914, getEventSetDescriptors, JDisclosureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
916, getBeanDescriptor, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
917, getEventSetDescriptors, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
919, getDefaultEventIndex, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
920, getPropertyDescriptors, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
921, getDefaultPropertyIndex, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
922, getMethodDescriptors, JAttributeTextAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
927, getPropertyDescriptors, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
928, getDefaultPropertyIndex, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
929, getEventSetDescriptors, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
931, getDefaultEventIndex, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
932, getMethodDescriptors, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
934, getBeanDescriptor, JAttributeTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
935, JAttributeSlider, JAttributeSlider, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSlider.java, 30, 31
1
/** Creates new instance. */
2
  public JAttributeSlider() {
    this(JSlider.VERTICAL, 0, 100, 50);
###
939, getDefaultEventIndex, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
940, getBeanDescriptor, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
941, getPropertyDescriptors, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
942, getDefaultPropertyIndex, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
943, getMethodDescriptors, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
945, getEventSetDescriptors, JAttributeSliderBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
948, outcode, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 173, 188
16
/**
   * This method computes a binary OR of the appropriate mask values
   * indicating, for each side of Rectangle r1, whether or not the
   * Rectangle r2 is on the same side of the edge as the rest
   * of this Rectangle.
   *
   *
   *
   *
   *
   *
   *
   *
   * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,
   * OUT_TOP.
   */
13
  public static int outcode(Rectangle r1, Rectangle r2) {
    int outcode = 0;
    if (r2.x > r1.x + r1.width) {
      outcode = OUT_RIGHT;
    } else if (r2.x + r2.width < r1.x) {
      outcode = OUT_LEFT;
    }
    if (r2.y > r1.y + r1.height) {
      outcode |= OUT_BOTTOM;
    } else if (r2.y + r2.height < r1.y) {
      outcode |= OUT_TOP;
    }
    return outcode;
###
949, range, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 360, 367
4
/**
   * Constains a value to the given range.
   * @return the constrained value
   */
8
  public static int range(int min, int max, int value) {
    if (value < min) {
      value = min;
    }
    if (value > max) {
      value = max;
    }
    return value;
###
950, length, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 408, 409
3
/**
   * Gets the distance between to points
   */
2
  public static double length(double x1, double y1, double x2, double y2) {
    return sqrt(length2(x1, y1, x2, y2));
###
951, length2, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 401, 402
3
/**
   * Gets the square distance between two points.
   */
2
  public static double length2(double x1, double y1, double x2, double y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
###
952, ovalAngleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 535, 538
3
/**
   * Gets the point on an oval that corresponds to the given angle.
   */
4
  public static Point2D.Double ovalAngleToPoint(Rectangle2D.Double r, double angle) {
    Point2D.Double center = Geom.center(r);
    Point2D.Double p = Geom.polarToPoint2D(angle, r.width / 2, r.height / 2);
    return new Point2D.Double(center.x + p.x, center.y + p.y);
###
953, ovalAngleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 526, 529
3
/**
   * Gets the point on an oval that corresponds to the given angle.
   */
4
  public static Point ovalAngleToPoint(Rectangle r, double angle) {
    Point center = Geom.center(r);
    Point p = Geom.polarToPoint(angle, r.width / 2, r.height / 2);
    return new Point(center.x + p.x, center.y + p.y);
###
954, length, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 415, 416
3
/**
   * Gets the distance between to points
   */
2
  public static double length(Point2D.Double p1, Point2D.Double p2) {
    return sqrt(length2(p1.x, p1.y, p2.x, p2.y));
###
955, lineContainsPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 43, 68
4
/**
   * Tests if a point is on a line.
   * <p>changed Werner Randelshofer 2003-11-26
   */
21
  public static boolean lineContainsPoint(int x1, int y1,
      int x2, int y2,
      int px, int py, double tolerance) {
    Rectangle r = new Rectangle(new Point(x1, y1));
    r.add(x2, y2);
    r.grow(max(2, (int) ceil(tolerance)), max(2, (int) ceil(tolerance)));
    if (!r.contains(px, py)) {
      return false;
    }
    double a, b, x, y;
    if (x1 == x2) {
      return (abs(px - x1) <= tolerance);
    }
    if (y1 == y2) {
      return (abs(py - y1) <= tolerance);
    }
    a = (double) (y1 - y2) / (double) (x1 - x2);
    b = (double) y1 - a * (double) x1;
    x = (py - b) / a;
    y = a * px + b;
    return (min(abs(x - px), abs(y - py)) <= tolerance);
###
956, polarToPoint2D, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 517, 520
3
/**
   * Converts a polar to a point
   */
4
  public static Point2D.Double polarToPoint2D(double angle, double fx, double fy) {
    double si = sin(angle);
    double co = cos(angle);
    return new Point2D.Double(fx * co + 0.5, fy * si + 0.5);
###
957, pointToAngle, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 435, 438
3
/**
   * Gets the angle of a point relative to a rectangle.
   */
4
  public static double pointToAngle(Rectangle r, Point p) {
    int px = p.x - (r.x + r.width / 2);
    int py = p.y - (r.y + r.height / 2);
    return atan2(py * r.width, px * r.height);
###
958, contains, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 833, 837
11
/**
   * Returns true, if rectangle 1 contains rectangle 2.
   * <p>
   * This method is similar to Rectangle2D.contains, but also returns true,
   * when rectangle1 contains rectangle2 and either or both of them
   * are empty.
   *
   * @param r1 Rectangle 1.
   * @param r2 Rectangle 2.
   * @return true if r1 contains r2.
   */
5
  public static boolean contains(Rectangle2D.Double r1, Rectangle2D.Double r2) {
    return (r2.x >= r1.x &&
        r2.y >= r1.y &&
        (r2.x + max(0, r2.width)) <= r1.x + max(0, r1.width) &&
        (r2.y + max(0, r2.height)) <= r1.y + max(0, r1.height));
###
959, angleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 484, 502
3
/**
   * Gets the point on a rectangle that corresponds to the given angle.
   */
18
  public static Point2D.Double angleToPoint(Rectangle2D.Double r, double angle) {
    double si = sin(angle);
    double co = cos(angle);
    double e = 0.0001;
    double x = 0, y = 0;
    if (abs(si) > e) {
      x = (1.0 + co / abs(si)) / 2.0 * r.width;
      x = range(0, r.width, x);
    } else if (co >= 0.0) {
      x = r.width;
    }
    if (abs(co) > e) {
      y = (1.0 + si / abs(co)) / 2.0 * r.height;
      y = range(0, r.height, y);
    } else if (si >= 0.0) {
      y = r.height;
    }
    return new Point2D.Double(r.x + x, r.y + y);
###
960, direction, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 140, 154
4
/**
   * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from
   * one point to another one.
   */
14
  public static int direction(double x1, double y1, double x2, double y2) {
    int direction = 0;
    double vx = x2 - x1;
    double vy = y2 - y1;
    if (vy < vx && vx > -vy) {
      direction = OUT_RIGHT;
    } else if (vy > vx && vy > -vx) {
      direction = OUT_TOP;
    } else if (vx < vy && vx < -vy) {
      direction = OUT_LEFT;
    } else {
      direction = OUT_BOTTOM;
    }
    return direction;
###
961, angleToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 460, 478
3
/**
   * Gets the point on a rectangle that corresponds to the given angle.
   */
18
  public static Point angleToPoint(Rectangle r, double angle) {
    double si = sin(angle);
    double co = cos(angle);
    double e = 0.0001;
    int x = 0, y = 0;
    if (abs(si) > e) {
      x = (int) ((1.0 + co / abs(si)) / 2.0 * r.width);
      x = range(0, r.width, x);
    } else if (co >= 0.0) {
      x = r.width;
    }
    if (abs(co) > e) {
      y = (int) ((1.0 + si / abs(co)) / 2.0 * r.height);
      y = range(0, r.height, y);
    } else if (si >= 0.0) {
      y = r.height;
    }
    return new Point(r.x + x, r.y + y);
###
962, chop, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 246, 329
5
/**
   * Returns a point on the edge of the bezier path which crosses the line
   * from the center of the bezier path to the specified point.
   * If no edge crosses the line, the nearest C0 control point is returned.
   */
77
  public static Point2D.Double chop(Shape shape, Point2D.Double p) {
    Rectangle2D bounds = shape.getBounds2D();
    Point2D.Double ctr = new Point2D.Double(bounds.getCenterX(), bounds.getCenterY());
    // Chopped point
    double cx = -1;
    double cy = -1;
    double len = Double.MAX_VALUE;
    // Try for points along edge
    PathIterator i = shape.getPathIterator(new AffineTransform(), 1);
    double[] coords = new double[6];
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    double moveToX = prevX;
    double moveToY = prevY;
    i.next();
    for (; !i.isDone(); i.next()) {
      switch (i.currentSegment(coords)) {
        case PathIterator.SEG_MOVETO:
          moveToX = coords[0];
          moveToY = coords[1];
          break;
        case PathIterator.SEG_CLOSE:
          coords[0] = moveToX;
          coords[1] = moveToY;
          break;
      }
      Point2D.Double chop = Geom.intersect(
          prevX, prevY,
          coords[0], coords[1],
          p.x, p.y,
          ctr.x, ctr.y);
      if (chop != null) {
        double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
        if (cl < len) {
          len = cl;
          cx = chop.x;
          cy = chop.y;
        }
      }
      prevX = coords[0];
      prevY = coords[1];
    }
    /*
    if (isClosed() && size() > 1) {
    Node first = get(0);
    Node last = get(size() - 1);
    Point2D.Double chop = Geom.intersect(
    first.x[0], first.y[0],
    last.x[0], last.y[0],
    p.x, p.y,
    ctr.x, ctr.y
    );
    if (chop != null) {
    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
    if (cl < len) {
    len = cl;
    cx = chop.x;
    cy = chop.y;
    }
    }
    }*/

    // if none found, pick closest vertex
    if (len == Double.MAX_VALUE) {
      i = shape.getPathIterator(new AffineTransform(), 1);
      for (; !i.isDone(); i.next()) {
        i.currentSegment(coords);
        double l = Geom.length2(ctr.x, ctr.y, coords[0], coords[1]);
        if (l < len) {
          len = l;
          cx = coords[0];
          cy = coords[1];
        }
      }
    }
    return new Point2D.Double(cx, cy);
###
963, length, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 394, 395
3
/**
   * Gets the distance between to points
   */
2
  public static long length(int x1, int y1, int x2, int y2) {
    return (long) sqrt(length2(x1, y1, x2, y2));
###
964, grow, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 815, 819
23
/**
   * Resizes the <code>Rectangle2D.Double</code> both horizontally and vertically.
   * <p>
   * This method modifies the <code>Rectangle2D.Double</code> so that it is
   * <code>h</code> units larger on both the left and right side,
   * and <code>v</code> units larger at both the top and bottom.
   * <p>
   * The new <code>Rectangle2D.Double</code> has (<code>x&nbsp;-&nbsp;h</code>,
   * <code>y&nbsp;-&nbsp;v</code>) as its top-left corner, a
   * width of
   * <code>width</code>&nbsp;<code>+</code>&nbsp;<code>2h</code>,
   * and a height of
   * <code>height</code>&nbsp;<code>+</code>&nbsp;<code>2v</code>.
   * <p>
   * If negative values are supplied for <code>h</code> and
   * <code>v</code>, the size of the <code>Rectangle2D.Double</code>
   * decreases accordingly.
   * The <code>grow</code> method does not check whether the resulting
   * values of <code>width</code> and <code>height</code> are
   * non-negative.
   * @param h the horizontal expansion
   * @param v the vertical expansion
   */
5
  public static void grow(Rectangle2D.Double r, double h, double v) {
    r.x -= h;
    r.y -= v;
    r.width += h * 2d;
    r.height += v * 2d;
###
965, outcode, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 207, 222
16
/**
   * This method computes a binary OR of the appropriate mask values
   * indicating, for each side of Rectangle r1, whether or not the
   * Rectangle r2 is on the same side of the edge as the rest
   * of this Rectangle.
   *
   *
   *
   *
   *
   *
   *
   *
   * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,
   * OUT_TOP.
   */
13
  public static int outcode(Rectangle2D.Double r1, Rectangle2D.Double r2) {
    int outcode = 0;
    if (r2.x > r1.x + r1.width) {
      outcode = OUT_RIGHT;
    } else if (r2.x + r2.width < r1.x) {
      outcode = OUT_LEFT;
    }
    if (r2.y > r1.y + r1.height) {
      outcode |= OUT_BOTTOM;
    } else if (r2.y + r2.height < r1.y) {
      outcode |= OUT_TOP;
    }
    return outcode;
###
966, direction, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 119, 133
4
/**
   * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from
   * one point to another one.
   */
14
  public static int direction(int x1, int y1, int x2, int y2) {
    int direction = 0;
    int vx = x2 - x1;
    int vy = y2 - y1;
    if (vy < vx && vx > -vy) {
      direction = OUT_RIGHT;
    } else if (vy > vx && vy > -vx) {
      direction = OUT_TOP;
    } else if (vx < vy && vx < -vy) {
      direction = OUT_LEFT;
    } else {
      direction = OUT_BOTTOM;
    }
    return direction;
###
968, range, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 374, 381
4
/**
   * Constains a value to the given range.
   * @return the constrained value
   */
8
  public static double range(double min, double max, double value) {
    if (value < min) {
      value = min;
    }
    if (value > max) {
      value = max;
    }
    return value;
###
969, angle, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 453, 454
3
/**
   * Gets the angle of the specified line.
   */
2
  public static double angle(double x1, double y1, double x2, double y2) {
    return atan2(y2 - y1, x2 - x1);
###
970, lineContainsPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 75, 104
4
/**
   * Tests if a point is on a line.
   * <p>changed Werner Randelshofer 2003-11-26
   */
25
  public static boolean lineContainsPoint(double x1, double y1,
      double x2, double y2,
      double px, double py, double tolerance) {
    Rectangle2D.Double r = new Rectangle2D.Double(x1, y1, 0, 0);
    r.add(x2, y2);
    double grow = max(2, (int) ceil(tolerance));
    r.x -= grow;
    r.y -= grow;
    r.width += grow * 2;
    r.height += grow * 2;
    if (!r.contains(px, py)) {
      return false;
    }
    double a, b, x, y;
    if (x1 == x2) {
      return (abs(px - x1) <= tolerance);
    }
    if (y1 == y2) {
      return (abs(py - y1) <= tolerance);
    }
    a = (double) (y1 - y2) / (double) (x1 - x2);
    b = (double) y1 - a * (double) x1;
    x = (py - b) / a;
    y = a * px + b;
    return (min(abs(x - px), abs(y - py)) <= tolerance);
###
971, lineContainsPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 33, 36
3
/**
   * Tests if a point is on a line.
   */
4
  public static boolean lineContainsPoint(int x1, int y1,
      int x2, int y2,
      int px, int py) {
    return lineContainsPoint(x1, y1, x2, y2, px, py, 3d);
###
972, polarToPoint, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 508, 511
3
/**
   * Converts a polar to a point
   */
4
  public static Point polarToPoint(double angle, double fx, double fy) {
    double si = sin(angle);
    double co = cos(angle);
    return new Point((int) (fx * co + 0.5), (int) (fy * si + 0.5));
###
973, pointToAngle, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 444, 447
3
/**
   * Gets the angle of a point relative to a rectangle.
   */
4
  public static double pointToAngle(Rectangle2D.Double r, Point2D.Double p) {
    double px = p.x - (r.x + r.width / 2);
    double py = p.y - (r.y + r.height / 2);
    return atan2(py * r.width, px * r.height);
###
975, cap, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 424, 429
5
/**
   * Caps the line defined by p1 and p2 by the number of units
   * specified by radius.
   * @return A new end point for the line.
   */
6
  public static Point2D.Double cap(Point2D.Double p1, Point2D.Double p2, double radius) {
    double angle = PI / 2 - atan2(p2.x - p1.x, p2.y - p1.y);
    Point2D.Double p3 = new Point2D.Double(
        p2.x + radius * cos(angle),
        p2.y + radius * sin(angle));
    return p3;
###
976, length2, Geom, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java, 387, 388
3
/**
   * Gets the square distance between two points.
   */
2
  public static long length2(int x1, int y1, int x2, int y2) {
    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
###
991, reset, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 79, 81
17
/**
   * Resets this <code>Polygon</code> object to an empty polygon.
   * The coordinate arrays and the data in them are left untouched
   * but the number of points is reset to zero to mark the old
   * vertex data as invalid and to start accumulating new vertex
   * data at the beginning.
   * All internally-cached data relating to the old vertices
   * are discarded.
   * Note that since the coordinate arrays from before the reset
   * are reused, creating a new empty <code>Polygon</code> might
   * be more memory efficient than resetting the current one if
   * the number of vertices in the new polygon data is significantly
   * smaller than the number of vertices in the data from before the
   * reset.
   * @see     java.awt.Polygon#invalidate
   * 
   */
3
  public void reset() {
    npoints = 0;
    invalidate();
###
993, contains, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 149, 150
9
/**
   * Determines whether the specified {@link Point} is inside this 
   * <code>Polygon</code>.
   * @param p the specified <code>Point</code> to be tested
   * @return <code>true</code> if the <code>Polygon</code> contains the
   *       <code>Point</code>; <code>false</code> otherwise.
   * @see #contains(double, double)
   * 
   */
2
  public boolean contains(Point p) {
    return contains(p.x, p.y);
###
994, getBounds, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 136, 137
9
/**
   * Gets the bounding box of this <code>Polygon</code>. 
   * The bounding box is the smallest {@link Rectangle} whose
   * sides are parallel to the x and y axes of the 
   * coordinate space, and can completely contain the <code>Polygon</code>.
   * @return a <code>Rectangle</code> that defines the bounds of this 
   * <code>Polygon</code>.
   * 
   */
2
  public Rectangle getBounds() {
    return getBounds2D().getBounds();
###
998, inside, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 182, 184
13
/**
   * Determines whether the specified coordinates are contained in this 
   * <code>Polygon</code>.
   * @param x the specified X coordinate to be tested
   * @param y the specified Y coordinate to be tested
   * @return {@code true} if this {@code Polygon} contains
   *     the specified coordinates {@code (x,y)};
   *     {@code false} otherwise.
   * @see #contains(double, double)
   * @deprecated As of JDK version 1.1,
   * replaced by <code>contains(int, int)</code>.
   * 
   */
3
  @Deprecated
  public boolean inside(int x, int y) {
    return contains((double) x, (double) y);
###
1001, contains, Polygon2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 165, 166
12
/**
   * Determines whether the specified coordinates are inside this 
   * <code>Polygon</code>.   
   * <p>
   * @param x the specified X coordinate to be tested
   * @param y the specified Y coordinate to be tested
   * @return {@code true} if this {@code Polygon} contains
   *     the specified coordinates {@code (x,y)};
   *     {@code false} otherwise.
   * @see #contains(double, double)
   * 
   */
2
  public boolean contains(int x, int y) {
    return contains((double) x, (double) y);
###
1004, translate, Double, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 362, 370
8
/**
     * Translates the vertices of the <code>Polygon</code> by
     * <code>deltaX</code> along the x axis and by
     * <code>deltaY</code> along the y axis.
     * @param deltaX the amount to translate along the X axis
     * @param deltaY the amount to translate along the Y axis
     * 
     */
9
    @Override
    public void translate(double deltaX, double deltaY) {
      for (int i = 0; i < npoints; i++) {
        xpoints[i] += deltaX;
        ypoints[i] += deltaY;
      }
      if (bounds != null) {
        bounds.x += deltaX;
        bounds.y += deltaY;
###
1005, calculateBounds, Double, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 385, 401
7
/*
     * Calculates the bounding box of the points passed to the constructor.
     * Sets <code>bounds</code> to the result.
     * @param xpoints[] array of <i>x</i> coordinates
     * @param ypoints[] array of <i>y</i> coordinates
     * @param npoints the total number of points
     */
16
    void calculateBounds(double xpoints[], double ypoints[], int npoints) {
      double boundsMinX = java.lang.Double.MAX_VALUE;
      double boundsMinY = java.lang.Double.MAX_VALUE;
      double boundsMaxX = -java.lang.Double.MAX_VALUE;
      double boundsMaxY = -java.lang.Double.MAX_VALUE;
      for (int i = 0; i < npoints; i++) {
        double x = xpoints[i];
        boundsMinX = Math.min(boundsMinX, x);
        boundsMaxX = Math.max(boundsMaxX, x);
        double y = ypoints[i];
        boundsMinY = Math.min(boundsMinY, y);
        boundsMaxY = Math.max(boundsMaxY, y);
      }
      bounds = new Rectangle2D.Double(boundsMinX, boundsMinY,
          boundsMaxX - boundsMinX,
          boundsMaxY - boundsMinY);
###
1006, updateBounds, Double, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 408, 421
4
/*
     * Resizes the bounding box to accomodate the specified coordinates.
     * @param x,&nbsp;y the specified coordinates
     */
13
    void updateBounds(double x, double y) {
      if (x < bounds.x) {
        bounds.width = bounds.width + (bounds.x - x);
        bounds.x = x;
      } else {
        bounds.width = Math.max(bounds.width, x - bounds.x);
      // bounds.x = bounds.x;
      }
      if (y < bounds.y) {
        bounds.height = bounds.height + (bounds.y - y);
        bounds.y = y;
      } else {
        bounds.height = Math.max(bounds.height, y - bounds.y);
###
1007, updateBounds, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 717, 730
4
/*
     * Resizes the bounding box to accomodate the specified coordinates.
     * @param x,&nbsp;y the specified coordinates
     */
13
    void updateBounds(float x, float y) {
      if (x < bounds.x) {
        bounds.width = bounds.width + (bounds.x - x);
        bounds.x = x;
      } else {
        bounds.width = Math.max(bounds.width, x - bounds.x);
      // bounds.x = bounds.x;
      }
      if (y < bounds.y) {
        bounds.height = bounds.height + (bounds.y - y);
        bounds.y = y;
      } else {
        bounds.height = Math.max(bounds.height, y - bounds.y);
###
1009, Float, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 635, 656
16
/**
     * Constructs and initializes a <code>Polygon</code> from the specified
     * parameters.
     * @param xpoints an array of X coordinates
     * @param ypoints an array of Y coordinates
     * @param npoints the total number of points in the
     *        <code>Polygon</code>
     * @exception  NegativeArraySizeException if the value of
     *             <code>npoints</code> is negative.
     * @exception  IndexOutOfBoundsException if <code>npoints</code> is
     *       greater than the length of <code>xpoints</code>
     *       or the length of <code>ypoints</code>.
     * @exception  NullPointerException if <code>xpoints</code> or
     *       <code>ypoints</code> is <code>null</code>.
     * 
     */
21
    public Float(float xpoints[], float ypoints[], int npoints) {
      // Fix 4489009: should throw IndexOutofBoundsException instead
      // of OutofMemoryException if npoints is huge and > {x,y}points.length
      if (npoints > xpoints.length || npoints > ypoints.length) {
        throw new IndexOutOfBoundsException("npoints > xpoints.length || " +
            "npoints > ypoints.length");
      }
      // Fix 6191114: should throw NegativeArraySizeException with
      // negative npoints
      if (npoints < 0) {
        throw new NegativeArraySizeException("npoints < 0");
      }
      // Fix 6343431: Applet compatibility problems if arrays are not
      // exactly npoints in length
      this.npoints = npoints;
      this.xpoints = new float[npoints];
      System.arraycopy(xpoints, 0, this.xpoints, 0,
          npoints);
      this.ypoints = new float[npoints];
      System.arraycopy(ypoints, 0, this.ypoints, 0,
          npoints);
###
1010, calculateBounds, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 694, 710
7
/*
     * Calculates the bounding box of the points passed to the constructor.
     * Sets <code>bounds</code> to the result.
     * @param xpoints[] array of <i>x</i> coordinates
     * @param ypoints[] array of <i>y</i> coordinates
     * @param npoints the total number of points
     */
16
    void calculateBounds(float xpoints[], float ypoints[], int npoints) {
      float boundsMinX = java.lang.Float.MAX_VALUE;
      float boundsMinY = java.lang.Float.MAX_VALUE;
      float boundsMaxX = -java.lang.Float.MAX_VALUE;
      float boundsMaxY = -java.lang.Float.MAX_VALUE;
      for (int i = 0; i < npoints; i++) {
        float x = xpoints[i];
        boundsMinX = Math.min(boundsMinX, x);
        boundsMaxX = Math.max(boundsMaxX, x);
        float y = ypoints[i];
        boundsMinY = Math.min(boundsMinY, y);
        boundsMaxY = Math.max(boundsMaxY, y);
      }
      bounds = new Rectangle2D.Float(boundsMinX, boundsMinY,
          boundsMaxX - boundsMinX,
          boundsMaxY - boundsMinY);
###
1011, translate, Float, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 667, 669
8
/**
     * Translates the vertices of the <code>Polygon</code> by
     * <code>deltaX</code> along the x axis and by
     * <code>deltaY</code> along the y axis.
     * @param deltaX the amount to translate along the X axis
     * @param deltaY the amount to translate along the Y axis
     * 
     */
3
    @Override
    public void translate(double deltaX, double deltaY) {
      translate((float) deltaX, (float) deltaY);
###
1012, getWindingRule, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 926, 927
6
/**
     * Returns the winding rule for determining the interior of the
     * path.
     * @return an integer representing the current winding rule.
     * @see PathIterator#WIND_NON_ZERO
     */
2
    public int getWindingRule() {
      return WIND_EVEN_ODD;
###
1013, next, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 944, 945
5
/**
     * Moves the iterator forwards, along the primary direction of
     * traversal, to the next segment of the path when there are
     * more points in that direction.
     */
2
    public void next() {
      index++;
###
1014, isDone, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 935, 936
5
/**
     * Tests if there are more points to read.
     * @return <code>true</code> if there are more points to read;
     *      <code>false</code> otherwise.
     */
2
    public boolean isDone() {
      return index > poly.npoints;
###
1015, currentSegment, PolygonPathIteratorDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 966, 975
18
/**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
     * A <code>float</code> array of length 2 must be passed in and
     * can be used to store the coordinates of the point(s).
     * Each point is stored as a pair of <code>float</code> x,&nbsp;y
     * coordinates.  SEG_MOVETO and SEG_LINETO types return one
     * point, and SEG_CLOSE does not return any points.
     * @param coords a <code>float</code> array that specifies the
     * coordinates of the point(s)
     * @return an integer representing the type and coordinates of the
     *     current path segment.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_CLOSE
     */
10
    public int currentSegment(float[] coords) {
      if (index >= poly.npoints) {
        return SEG_CLOSE;
      }
      coords[0] = (float) poly.xpoints[index];
      coords[1] = (float) poly.ypoints[index];
      if (transform != null) {
        transform.transform(coords, 0, coords, 0, 1);
      }
      return (index == 0 ? SEG_MOVETO : SEG_LINETO);
###
1016, getWindingRule, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1031, 1032
6
/**
     * Returns the winding rule for determining the interior of the
     * path.
     * @return an integer representing the current winding rule.
     * @see PathIterator#WIND_NON_ZERO
     */
2
    public int getWindingRule() {
      return WIND_EVEN_ODD;
###
1017, currentSegment, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1071, 1080
18
/**
     * Returns the coordinates and type of the current path segment in
     * the iteration.
     * The return value is the path segment type:
     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.
     * A <code>float</code> array of length 2 must be passed in and
     * can be used to store the coordinates of the point(s).
     * Each point is stored as a pair of <code>float</code> x,&nbsp;y
     * coordinates.  SEG_MOVETO and SEG_LINETO types return one
     * point, and SEG_CLOSE does not return any points.
     * @param coords a <code>float</code> array that specifies the
     * coordinates of the point(s)
     * @return an integer representing the type and coordinates of the
     *     current path segment.
     * @see PathIterator#SEG_MOVETO
     * @see PathIterator#SEG_LINETO
     * @see PathIterator#SEG_CLOSE
     */
10
    public int currentSegment(float[] coords) {
      if (index >= poly.npoints) {
        return SEG_CLOSE;
      }
      coords[0] = (float) poly.xpoints[index];
      coords[1] = (float) poly.ypoints[index];
      if (transform != null) {
        transform.transform(coords, 0, coords, 0, 1);
      }
      return (index == 0 ? SEG_MOVETO : SEG_LINETO);
###
1018, isDone, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1040, 1041
5
/**
     * Tests if there are more points to read.
     * @return <code>true</code> if there are more points to read;
     *      <code>false</code> otherwise.
     */
2
    public boolean isDone() {
      return index > poly.npoints;
###
1019, next, PolygonPathIteratorFloat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java, 1049, 1050
5
/**
     * Moves the iterator forwards, along the primary direction of
     * traversal, to the next segment of the path when there are
     * more points in that direction.
     */
2
    public void next() {
      index++;
###
1021, hashCode, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 188, 194
5
/**
   * Returns the hash code for this Insets2DDouble.
   *
   * @return  a hash code for this Insets2DDouble.
   */
7
  public int hashCode() {
    double sum1 = getLeft() + getBottom();
    double sum2 = getRight() + getTop();
    double val1 = sum1 * (sum1 + 1)/2 + getLeft();
    double val2 = sum2 * (sum2 + 1)/2 + getTop();
    double sum3 = val1 + val2;
    return java.lang.Float.floatToIntBits((float) (sum3 * (sum3 + 1)/2 + val2));
###
1023, clone, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 199, 204
3
/**
   * Creates a new object of the same class as this object.
   */
6
  public Object clone() {
    try {
      return super.clone();
    } catch (CloneNotSupportedException e) {
      // this shouldn't happen, since we are Cloneable
      throw new InternalError();
###
1024, add, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 97, 102
5
/**
   * Adds the specified insets to the current insets.
   *
   * @param i The insets to be added.
   */
6
  public void add(Insets2D i) {
    set(
        getTop() + i.getTop(),
        getLeft() + i.getLeft(),
        getBottom() + i.getBottom(),
        getRight() + i.getRight()
###
1027, subtractTo, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 155, 160
6
/**
   * Subtracts the current insets to the specified Rectangle2D making the
   * rectangle smaller.
   *
   * @param r The Rectangle2D.
   */
6
  public void subtractTo(Rectangle2D r) {
    r.setRect(
        r.getX() + getLeft(),
        r.getY() + getTop(),
        r.getWidth() - getLeft() - getRight(),
        r.getHeight() - getTop() - getBottom()
###
1029, subtract, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 141, 146
5
/**
   * Subtracts the specified insets from the current insets.
   *
   * @param i The insets to be subtracted.
   */
6
  public void subtract(Insets2D i) {
    set(
        getTop() - i.getTop(),
        getLeft() - i.getLeft(),
        getBottom() - i.getBottom(),
        getRight() - i.getRight()
###
1030, subtract, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 128, 133
8
/**
   * Subtracts the specified insets from the current insets.
   *
   * @param top The top insets.
   * @param left The left insets.
   * @param bottom The bottom insets.
   * @param right The right insets.
   */
6
  public void subtract(double top, double left, double bottom, double right) {
    set(
        getTop() - top,
        getLeft() - left,
        getBottom() - bottom,
        getRight() - right
###
1031, add, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 84, 89
8
/**
   * Adds the specified insets to the current insets.
   *
   * @param top The top insets.
   * @param left The left insets.
   * @param bottom The bottom insets.
   * @param right The right insets.
   */
6
  public void add(double top, double left, double bottom, double right) {
    set(
        getTop() + top,
        getLeft() + left,
        getBottom() + bottom,
        getRight() + right
###
1032, set, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 72, 73
5
/**
   * Sets the insets.
   *
   * @param i The new insets.
   */
2
  public void set(Insets2D i) {
    set(i.getTop(), i.getLeft(), i.getBottom(), i.getRight());
###
1033, addTo, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 112, 117
6
/**
   * Adds the current insets to the specified Rectangle2D making the
   * rectangle larger.
   *
   * @param r The Rectangle2D.
   */
6
  public void addTo(Rectangle2D r) {
    r.setRect(
        r.getX() - getLeft(),
        r.getY() - getTop(),
        r.getWidth() + getLeft() + getRight(),
        r.getHeight() + getTop() + getBottom()
###
1035, equals, Insets2D, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java, 172, 180
9
/**
   * Checks whether two insets objects are equal. Two instances
   * of <code>Insets2DDouble</code> are equal if the four integer values
   * of the fields <code>top</code>, <code>left</code>,
   * <code>bottom</code>, and <code>right</code> are all equal.
   * @return    <code>true</code> if the two insets are equal;
   *              otherwise <code>false</code>.
   * @since     JDK1.1
   */
9
  public boolean equals(Object obj) {
    if (obj instanceof Insets2D) {
      Insets2D that = (Insets2D)obj;
      return ((getTop() == that.getTop()) &&
          (getLeft() == that.getLeft()) &&
          (getBottom() == that.getBottom()) &&
          (getRight() == that.getRight()));
    }
    return false;
###
1038, Dimension2DDouble, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 72, 74
7
/** 
   * Constructs a <code>Dimension2DDouble</code> and initializes
   * it to the specified width and specified height.
   *
   * @param width the specified width 
   * @param height the specified height
   */
3
  public Dimension2DDouble(double width, double height) {
  this.width = width;
  this.height = height;
###
1039, Dimension2DDouble, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 61, 62
8
/** 
   * Creates an instance of <code>Dimension2DDouble</code> whose width  
   * and height are the same as for the specified dimension. 
   *
   * @param  d   the specified dimension for the 
   *         <code>width</code> and 
   *         <code>height</code> values
   */
2
  public Dimension2DDouble(Dimension2DDouble d) {
  this(d.width, d.height);
###
1040, hashCode, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 152, 154
5
/**
   * Returns the hash code for this <code>Dimension2DDouble</code>.
   *
   * @return  a hash code for this <code>Dimension2DDouble</code>
   */
3
  public int hashCode() {
    float sum = (float) (width + height);
    return Float.floatToIntBits(sum * (sum + 1)/2 + (float) width);
###
1041, setSize, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 103, 105
10
/**
   * Sets the size of this <code>Dimension2DDouble</code> object to
   * the specified width and height in double precision.
   * Note that if <code>width</code> or <code>height</code>
   * are larger than <code>Integer.MAX_VALUE</code>, they will
   * be reset to <code>Integer.MAX_VALUE</code>.
   *
   * @param width  the new width for the <code>Dimension2DDouble</code> object
   * @param height the new height for the <code>Dimension2DDouble</code> object
   */
3
  public void setSize(double width, double height) {
    this.width = width;
    this.height = height;
###
1042, Dimension2DDouble, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 49, 50
4
/** 
   * Creates an instance of <code>Dimension2DDouble</code> with a width 
   * of zero and a height of zero. 
   */
2
  public Dimension2DDouble() {
  this(0, 0);
###
1043, setSize, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 132, 133
9
/**
   * Sets the size of this <code>Dimension2DDouble</code> object to the specified size.
   * This method is included for completeness, to parallel the
   * <code>setSize</code> method defined by <code>Component</code>.
   * @param  d  the new size for this <code>Dimension2DDouble</code> object
   * @see    Dimension2DDouble#getSize
   * @see    java.awt.Component#setSize
   * @since  JDK1.1
   */
2
  public void setSize(Dimension2DDouble d) {
  setSize(d.width, d.height);
###
1044, getWidth, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 81, 82
4
/**
   * Returns the width of this dimension in double precision.
   * @return the width of this dimension in double precision
   */
2
  public double getWidth() {
  return width;
###
1045, getHeight, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 89, 90
4
/**
   * Returns the height of this dimension in double precision.
   * @return the height of this dimension in double precision
   */
2
  public double getHeight() {
  return height;
###
1046, getSize, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 119, 120
11
/**
   * Gets the size of this <code>Dimension2DDouble</code> object.
   * This method is included for completeness, to parallel the
   * <code>getSize</code> method defined by <code>Component</code>.
   *
   * @return   the size of this dimension, a new instance of 
   *       <code>Dimension2DDouble</code> with the same width and height
   * @see    Dimension2DDouble#setSize
   * @see    java.awt.Component#getSize
   * @since  JDK1.1
   */
2
  public Dimension2DDouble getSize() {
  return new Dimension2DDouble(width, height);
###
1047, equals, Dimension2DDouble, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java, 139, 144
3
/**
   * Checks whether two dimension objects have equal values.
   */
6
  public boolean equals(Object obj) {
  if (obj instanceof Dimension2DDouble) {
    Dimension2DDouble d = (Dimension2DDouble)obj;
    return (width == d.width) && (height == d.height);
  }
  return false;
###
1049, isSelectable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 536, 538
4
/**
   * Checks whether this figure is selectable. By default
   * {@code AbstractFigure} can be selected.
   */
3
  @Override
  public boolean isSelectable() {
    return isSelectable;
###
1050, fireFigureRemoved, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 204, 218
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureRemoved() {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, getBounds());
          }
          ((FigureListener) listeners[i + 1]).figureRemoved(event);
###
1051, willChange, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 409, 415
4
/**
   * Informs that a figure is about to change something that
   * affects the contents of its display box.
   */
7
  @Override
  public void willChange() {
    if (changingDepth == 0) {
      fireAreaInvalidated();
      invalidate();
    }
    changingDepth++;
###
1052, getTool, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 477, 479
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
3
  @Override
  public Tool getTool(Point2D.Double p) {
    return null;
###
1053, handleMouseClick, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 485, 487
3
/**
   * Handles a mouse click.
   */
3
  @Override
  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {
    return false;
###
1054, changed, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 424, 432
3
/**
   * Informs that a figure changed the area of its display box.
   */
9
  @Override
  public void changed() {
    if (changingDepth == 1) {
      validate();
      fireFigureChanged(getDrawingArea());
    } else if (changingDepth < 0) {
      throw new InternalError("changed was called without a prior call to willChange. "+changingDepth);
    }
    changingDepth--;
###
1055, isTransformable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 566, 568
4
/**
   * Checks whether this figure is transformable. By default
   * {@code AbstractFigure} can be transformed.
   */
3
  @Override
  public boolean isTransformable() {
    return isTransformable;
###
1057, fireFigureAdded, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 180, 194
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureAdded() {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, getBounds());
          }
          ((FigureListener) listeners[i + 1]).figureAdded(event);
###
1058, findConnector, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 442, 444
7
/**
   * Returns the Figures connector for the specified location.
   * By default a ChopBoxConnector is returned.
   *
   *
   * @see ChopRectangleConnector
   */
3
  @Override
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopRectangleConnector(this);
###
1059, fireFigureHandlesChanged, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 297, 312
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
16
  protected void fireFigureHandlesChanged() {
    Rectangle2D.Double changedArea = getDrawingArea();
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, changedArea);
          }
          ((FigureListener) listeners[i + 1]).figureHandlesChanged(event);
###
1060, fireAttributeChanged, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 272, 287
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
16
  protected void fireAttributeChanged(AttributeKey attribute, Object oldValue, Object newValue) {
    if (listenerList.getListenerCount() > 0 &&
        (oldValue == null || newValue == null || !oldValue.equals(newValue))) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, attribute, oldValue, newValue);
          }
          ((FigureListener) listeners[i + 1]).attributeChanged(event);
###
1061, fireAreaInvalidated, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 115, 129
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireAreaInvalidated(Rectangle2D.Double invalidatedArea) {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, invalidatedArea);
          }
          ((FigureListener) listeners[i + 1]).areaInvalidated(event);
###
1062, fireFigureRequestRemove, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 156, 170
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureRequestRemove() {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, getBounds());
          }
          ((FigureListener) listeners[i + 1]).figureRequestRemove(event);
###
1063, fireAreaInvalidated, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 107, 108
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
2
  public void fireAreaInvalidated() {
    fireAreaInvalidated(getDrawingArea());
###
1066, getActions, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 468, 470
6
/**
   * Returns a collection of actions which are presented to the user
   * in a popup menu.
   * <p>The collection may contain null entries. These entries are used
   * interpreted as separators in the popup menu.
   */
3
  @Override
  public Collection<Action> getActions(Point2D.Double p) {
    return Collections.emptyList();
###
1067, fireFigureChanged, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 232, 246
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  protected void fireFigureChanged(Rectangle2D.Double changedArea) {
    if (listenerList.getListenerCount() > 0) {
      FigureEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (listeners[i] == FigureListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureEvent(this, changedArea);
          }
          ((FigureListener) listeners[i + 1]).figureChanged(event);
###
1068, isConnectable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 521, 523
4
/**
   * Checks whether this figure is connectable. By default
   * {@code AbstractFigure} can be connected.
   */
3
  @Override
  public boolean isConnectable() {
    return isConnectable;
###
1069, fireUndoableEditHappened, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 323, 325
5
/**
   * Notify all UndoableEditListener of the Drawing, to which this Figure has
   * been added to. If this Figure is not part of a Drawing, the event is
   * lost.
   */
3
  protected void fireUndoableEditHappened(UndoableEdit edit) {
    if (getDrawing() != null) {
      getDrawing().fireUndoableEditHappened(edit);
###
1071, isRemovable, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 551, 553
4
/**
   * Checks whether this figure is removable. By default
   * {@code AbstractFigure} can be removed.
   */
3
  @Override
  public boolean isRemovable() {
    return isRemovable;
###
1072, fireAreaInvalidated, AbstractFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java, 139, 147
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
9
  protected void fireAreaInvalidated(FigureEvent event) {
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == FigureListener.class) {
        ((FigureListener) listeners[i + 1]).areaInvalidated(event);
###
1094, getKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 104, 105
4
/**
   * Returns the key string.
   * @return key string.
   */
2
  public String getKey() {
    return key;
###
1095, setUndoable, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 188, 219
8
/**
   * Sets the attribute and returns an UndoableEditEvent which can be used
   * to undo it.
   * <p>
   * Note: Unlike in previous versions of JHotDraw 7, this method does
   * not call {@code f.willChange()} before setting the value, and
   * {@code f.changed()} afterwards.
   */
27
  public UndoableEdit setUndoable(final Figure f, final T value) {
    if (value == null && !isNullValueAllowed) {
      throw new NullPointerException("Null value not allowed for AttributeKey " + key);
    }
    final Object restoreData = f.getAttributesRestoreData();
    f.set(this, value);
    UndoableEdit edit = new AbstractUndoableEdit() {
      @Override
      public String getPresentationName() {
        return AttributeKey.this.getPresentationName();
      }
      @Override
      public void undo() {
        super.undo();
        f.willChange();
        f.restoreAttributesTo(restoreData);
        f.changed();
      }
      @Override
      public void redo() {
        super.redo();
        f.willChange();
        f.set(AttributeKey.this, value);
        f.changed();
      }
    };
    return edit;
###
1096, getDefaultValue, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 121, 122
5
/**
   * Returns the default value of the attribute.
   *
   * @return the default value.
   */
2
  public T getDefaultValue() {
    return defaultValue;
###
1097, put, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 269, 274
8
/**
   * Use this method to perform a type-safe put operation of an attribute
   * into a Map.
   *
   * @param a An attribute map.
   * @param value The new value.
   * @return The old value.
   */
6
  @SuppressWarnings("unchecked")
  public T put(Map<AttributeKey, Object> a, T value) {
    if (value == null && !isNullValueAllowed) {
      throw new NullPointerException("Null value not allowed for AttributeKey " + key);
    }
    return (T) a.put(this, value);
###
1098, get, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 158, 160
7
/**
   * Gets the value of the attribute denoted by this AttributeKey from
   * a Map.
   * 
   * @param a A Map.
   * @return The value of the attribute.
   */
3
  @SuppressWarnings("unchecked")
  public T get(Map<AttributeKey, Object> a) {
    return a.containsKey(this) ? (T) a.get(this) : defaultValue;
###
1099, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 77, 78
2
/** Creates a new instance with the specified attribute key, type token class,
   * default value, and allowing or disallowing null values. */
2
  public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed) {
    this(key, clazz, defaultValue, isNullValueAllowed, null);
###
1100, putClone, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 250, 257
6
/**
   * Convenience method for putting a clone of a value on a map.
   *
   * @param a the map
   * @param value the attribute value
   */
7
  public void putClone(Map<AttributeKey, Object> a, T value) {
    try {
       put(a, value == null ? null : clazz.cast(Methods.invoke(value, "clone")));
    } catch (NoSuchMethodException ex) {
      InternalError e = new InternalError();
      e.initCause(ex);
      throw e;
###
1101, getClone, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 128, 136
3
/**
   * Gets a clone of the value from the Figure.
   */
9
  @SuppressWarnings("unchecked")
  public T getClone(Figure f) {
    T value = f.get(this);
    try {
      return value == null ? null : clazz.cast(Methods.invoke(value, "clone"));
    } catch (NoSuchMethodException ex) {
      InternalError e = new InternalError();
      e.initCause(ex);
      throw e;
###
1102, setClone, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 233, 240
10
/**
   * Convenience method for setting a clone of a value on a figure.
   * <p>
   * Note: Unlike in previous versions of JHotDraw 7, this method does
   * not call {@code f.willChange()} before setting the value, and
   * {@code f.changed()} afterwards.
   *
   * @param f the Figure
   * @param value the attribute value
   */
7
  public void setClone(Figure f, T value) {
    try {
       f.set(this, value == null ? null : clazz.cast(Methods.invoke(value, "clone")));
    } catch (NoSuchMethodException ex) {
      InternalError e = new InternalError();
      e.initCause(ex);
      throw e;
###
1103, getPresentationName, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 112, 113
4
/**
   * Returns a localized human friendly presentation of the key.
   * @return the presentation name of the key.
   */
2
  public String getPresentationName() {
    return (labels == null) ? key : labels.getString("attribute." + key + ".text");
###
1104, get, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 147, 148
7
/**
   * Gets the value of the attribute denoted by this AttributeKey from
   * a Figure.
   * 
   * @param f A figure.
   * @return The value of the attribute.
   */
2
  public T get(Figure f) {
    return f.get(this);
###
1105, isAssignable, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 291, 296
6
/**
   * Returns true if the specified value is assignable with this key.
   *
   * @param value
   * @return True if assignable.
   */
5
  public boolean isAssignable(Object value) {
    if (value == null) {
      return isNullValueAllowed();
    }
    return clazz.isInstance(value);
###
1106, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 65, 66
2
/** Creates a new instance with the specified attribute key, type token class,
   * default value null, and allowing null values. */
2
  public AttributeKey(String key, Class<T> clazz) {
    this(key, clazz, null, true);
###
1107, set, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 173, 177
10
/**
   * Convenience method for setting a value on a Figure.
   * <p>
   * Note: Unlike in previous versions of JHotDraw 7, this method does
   * not call {@code f.willChange()} before setting the value, and
   * {@code f.changed()} afterwards.
   *
   * @param f the Figure
   * @param value the attribute value
   */
5
  public void set(Figure f, T value) {
    if (value == null && !isNullValueAllowed) {
      throw new NullPointerException("Null value not allowed for AttributeKey " + key);
    }
    f.set(this, value);
###
1108, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 71, 72
2
/** Creates a new instance with the specified attribute key, type token class,
   * and default value, and allowing null values. */
2
  public AttributeKey(String key, Class<T> clazz, T defaultValue) {
    this(key, clazz, defaultValue, true);
###
1109, AttributeKey, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 92, 97
11
/** Creates a new instance with the specified attribute key, type token class,
   * default value, and allowing or disallowing null values. 
   * 
   * @param key The key string. 
   * @param clazz This is used as a "type token" for assignability checks
   * at runtime.
   * @param isNullValueAllowed whether null values are allowed.
   * @param labels ResourceBundle for human friendly representation of this
   * attribute key. The ResourceBundle must have a property named
   * {@code "attribute." + key + ".text"}.
   */
6
  public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed, ResourceBundleUtil labels) {
    this.key = key;
    this.clazz = clazz;
    this.defaultValue = defaultValue;
    this.isNullValueAllowed = isNullValueAllowed;
    this.labels = (labels == null) ? ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels") : labels;
###
1110, isNullValueAllowed, AttributeKey, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java, 281, 282
4
/**
   * Returns true if null values are allowed.
   * @return true if null values are allowed.
   */
2
  public boolean isNullValueAllowed() {
    return isNullValueAllowed;
###
1111, getPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 425, 426
4
/**
   * Convenience method for getting the point coordinate of
   * the first control point of the specified node.
   */
2
  public Point2D.Double getPoint(int index) {
    return path.get(index).getControlPoint(0);
###
1112, BezierFigure, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 97, 99
9
/**
   * Creates an empty BezierFigure, for example without any
   * <code>BezierPath.Node</code>s.
   * The BezierFigure will not draw anything, unless at least two nodes
   * are added to it.
   *
   * @param isClosed Specifies whether the <code>BezierPath</code> shall
   * be closed.
   */
3
  public BezierFigure(boolean isClosed) {
    path = new BezierPath();
    set(PATH_CLOSED, isClosed);
###
1113, getNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 418, 419
3
/**
   * Gets a control point.
   */
2
  public BezierPath.Node getNode(int index) {
    return (BezierPath.Node) path.get(index).clone();
###
1114, setStartPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 460, 465
5
/**
   * Convenience method for setting the point coordinate of the start point.
   * If the BezierFigure has not at least two nodes, nodes are added
   * to the figure until the BezierFigure has at least two nodes.
   */
6
  public void setStartPoint(Point2D.Double p) {
    // Add two nodes if we haven't at least two nodes
    for (int i=getNodeCount(); i < 2; i++) {
      addNode(0, new BezierPath.Node(p.x, p.y));
    }
    setPoint(0, p);
###
1115, findNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 498, 506
5
/**
   * Finds a control point index.
   * Returns -1 if no control point could be found.
   * FIXME - Move this to BezierPath
   */
9
  public int findNode(Point2D.Double p) {
    BezierPath tp = path;
    for (int i=0; i < tp.size(); i++) {
      BezierPath.Node p2 = tp.get(i);
      if (p2.x[0] == p.x && p2.y[0] == p.y) {
        return i;
      }
    }
    return -1;
###
1116, getEndPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 489, 491
3
/**
   * Convenience method for getting the end point.
   */
3
  @Override
  public Point2D.Double getEndPoint() {
    return getPoint(getNodeCount() - 1, 0);
###
1117, setPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 450, 453
3
/**
   * Sets the point coordinate of a control point.
   */
4
  public void setPoint(int index, int coord, Point2D.Double p) {
    BezierPath.Node cp = new BezierPath.Node(path.get(index));
    cp.setControlPoint(coord, p);
    setNode(index, cp);
###
1118, getStartPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 482, 484
3
/**
   * Convenience method for getting the start point.
   */
3
  @Override
  public Point2D.Double getStartPoint() {
    return getPoint(0, 0);
###
1119, splitSegment, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 624, 625
4
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   */
2
  public int splitSegment(Point2D.Double split, float tolerance) {
    return path.splitSegment(split, tolerance);
###
1120, getCappedPath, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 344, 388
7
/**
   * Returns a path which is cappedPath at the ends, to prevent
   * it from drawing under the end caps.
   */
 --------------
// EDITING
 --------------
45
  protected BezierPath getCappedPath() {
    if (cappedPath == null) {
      cappedPath = (BezierPath) path.clone();
      if (isClosed()) {
        cappedPath.setClosed(true);
      } else {
        if (cappedPath.size() > 1) {
          if (get(START_DECORATION) != null) {
            BezierPath.Node p0 = cappedPath.get(0);
            BezierPath.Node p1 = cappedPath.get(1);
            Point2D.Double pp;
            if ((p0.getMask() & BezierPath.C2_MASK) != 0) {
              pp = p0.getControlPoint(2);
            } else if ((p1.getMask() & BezierPath.C1_MASK) != 0) {
              pp = p1.getControlPoint(1);
            } else {
              pp = p1.getControlPoint(0);
            }
            double radius = get(START_DECORATION).getDecorationRadius(this);
            double lineLength = Geom.length(p0.getControlPoint(0), pp);
            cappedPath.set(0,0, Geom.cap(pp, p0.getControlPoint(0), - Math.min(radius, lineLength)));
          }
          if (get(END_DECORATION) != null) {
            BezierPath.Node p0 = cappedPath.get(cappedPath.size() - 1);
            BezierPath.Node p1 = cappedPath.get(cappedPath.size() - 2);
            
            Point2D.Double pp;
            if ((p0.getMask() & BezierPath.C1_MASK) != 0) {
              pp = p0.getControlPoint(1);
            } else if ((p1.getMask() & BezierPath.C2_MASK) != 0) {
              pp = p1.getControlPoint(2);
            } else {
              pp = p1.getControlPoint(0);
            }
            
            
            double radius = get(END_DECORATION).getDecorationRadius(this);
            double lineLength = Geom.length(p0.getControlPoint(0), pp);
            cappedPath.set(cappedPath.size() - 1, 0, Geom.cap(pp, p0.getControlPoint(0), -Math.min(radius, lineLength)));
          }
          cappedPath.invalidatePath();
        }
      }
    }
    return cappedPath;
###
1121, joinSegments, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 617, 618
5
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the polyline.
   * @return true if the two segments were joined.
   */
2
  public int joinSegments(Point2D.Double join, float tolerance) {
    return path.joinSegments(join, tolerance);
###
1122, BezierFigure, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 85, 86
7
/**
   * Creates an empty <code>BezierFigure</code>, for example without any
   * <code>BezierPath.Node</code>s.
   * The BezierFigure will not draw anything, if at least two nodes
   * are added to it. The <code>BezierPath</code> created by this constructor
   * is not closed.
   */
2
  public BezierFigure() {
    this(false);
###
1123, getNodeCount, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 567, 568
3
/**
   * Gets the node count.
   */
2
  public int getNodeCount() {
    return path.size();
###
1124, setPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 437, 445
3
/**
   * Sets the point coordinate of control point 0 at the specified node.
   */
9
  public void setPoint(int index, Point2D.Double p) {
    BezierPath.Node node = path.get(index);
    double dx = p.x - node.x[0];
    double dy = p.y - node.y[0];
    for (int i=0; i < node.x.length; i++) {
      node.x[i] += dx;
      node.y[i] += dy;
    }
    invalidate();
###
1125, findConnector, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 112, 114
4
/**
   * Returns the Figures connector for the specified location.
   * By default a {@link ChopBezierConnector} is returned.
   */
3
  @Override
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopBezierConnector(this);
###
1126, removeNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 555, 556
3
/**
   * Removes the Node at the specified index.
   */
2
  public BezierPath.Node removeNode(int index) {
     return path.remove(index);
###
1127, findSegment, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 517, 518
9
/**
   * Gets the segment of the polyline that is hit by
   * the given Point2D.Double.
   * 
   * @param find a Point on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   * @return the index of the segment or -1 if no segment was hit.
   */
2
  public int findSegment(Point2D.Double find, double tolerance) {
    return getBezierPath().findSegment(find, tolerance);
###
1128, setBounds, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 322, 326
6
/**
   * Sets the location of the first and the last <code>BezierPath.Node</code>
   * of the BezierFigure.
   * If the BezierFigure has not at least two nodes, nodes are added
   * to the figure until the BezierFigure has at least two nodes.
   */
5
  @Override
  public void setBounds(Point2D.Double anchor, Point2D.Double lead) {
    setStartPoint(anchor);
    setEndPoint(lead);
    invalidate();
###
1129, addNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 402, 405
6
/**
   * Adds a node to the list of points.
   */
 --------------
// COMPOSITE FIGURES
 --------------
4
  public void addNode(final int index, BezierPath.Node p) {
    final BezierPath.Node newPoint = new BezierPath.Node(p);
    path.add(index, p);
    invalidate();
###
1130, getBezierPath, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 286, 287
6
/**
   * Returns a clone of the bezier path of this figure.
   */
 --------------
// SHAPE AND BOUNDS
 --------------
2
  public BezierPath getBezierPath() {
    return (BezierPath) path.clone();
###
1131, getPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 431, 432
3
/**
   * Gets the point coordinate of a control point.
   */
2
  public Point2D.Double getPoint(int index, int coord) {
    return path.get(index).getControlPoint(coord);
###
1132, setNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 410, 412
6
/**
   * Sets a control point.
   */
 --------------
// CLONING
 --------------
3
  public void setNode(int index, BezierPath.Node p) {
    path.set(index, p);
    invalidate();
###
1133, addNode, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 396, 397
6
/**
   * Adds a control point.
   */
 --------------
// CONNECTING
 --------------
2
  public void addNode(BezierPath.Node p) {
    addNode(getNodeCount(), p);
###
1134, joinSegments, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 529, 535
9
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the polyline.
   * @return true if the two segments were joined.
   *
   * @param join a Point at a node on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
7
  public boolean joinSegments(Point2D.Double join, double tolerance) {
    int i = findSegment(join, tolerance);
    if (i != -1 && i > 1) {
      removeNode(i);
      return true;
    }
    return false;
###
1135, splitSegment, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 545, 550
8
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   *
   * @param split a Point on (or near) a line segment on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
6
  public int splitSegment(Point2D.Double split, double tolerance) {
    int i = findSegment(split, tolerance);
    if (i != -1) {
      addNode(i + 1, new BezierPath.Node(split));
    }
    return i+1;
###
1136, removeAllNodes, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 561, 562
3
/**
   * Removes the Point2D.Double at the specified index.
   */
2
  protected void removeAllNodes() {
    path.clear();
###
1138, setEndPoint, BezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java, 472, 477
5
/**
   * Convenience method for setting the point coordinate of the end point.
   * If the BezierFigure has not at least two nodes, nodes are added
   * to the figure until the BezierFigure has at least two nodes.
   */
6
  public void setEndPoint(Point2D.Double p) {
    // Add two nodes if we haven't at least two nodes
    for (int i=getNodeCount(); i < 2; i++) {
      addNode(0, new BezierPath.Node(p.x, p.y));
    }
    setPoint(getNodeCount() - 1, p);
###
1139, addChangeListener, AbstractConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractConstrainer.java, 44, 45
3
/**
   * Adds a <code>ChangeListener</code>.
   */
2
  public void addChangeListener(ChangeListener l) {
    listenerList.add(ChangeListener.class, l);
###
1140, removeChangeListener, AbstractConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractConstrainer.java, 51, 52
3
/**
   * Removes a <code>ChangeListener</code>.
   */
2
  public void removeChangeListener(ChangeListener l) {
    listenerList.remove(ChangeListener.class, l);
###
1169, fireUndoableEditHappened, AbstractDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractDrawing.java, 55, 69
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
15
  @Override
  public void fireUndoableEditHappened(UndoableEdit edit) {
    UndoableEditEvent event = null;
    if (listenerList.getListenerCount() > 0) {
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >= 0; i -= 2) {
        if (event == null) {
          event = new UndoableEditEvent(this, edit);
        }
        if (listeners[i] == UndoableEditListener.class) {
          ((UndoableEditListener) listeners[i + 1]).undoableEditHappened(event);
###
1171, getLock, AbstractDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractDrawing.java, 105, 107
3
/**
   * The drawing view synchronizes on the lock when drawing a drawing.
   */
3
  @Override
  public Object getLock() {
    return lock;
###
1174, invalidateSortOrder, DefaultDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java, 202, 203
3
/**
   * Invalidates the sort order.
   */
2
  private void invalidateSortOrder() {
    needsSorting = true;
###
1175, ensureSorted, DefaultDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java, 210, 213
4
/**
   * Ensures that the children are sorted in z-order sequence from back to
   * front.
   */
4
  private void ensureSorted() {
    if (needsSorting) {
      Collections.sort(children, FigureLayerComparator.INSTANCE);
      needsSorting = false;
###
1176, getFiguresFrontToBack, DefaultDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java, 194, 196
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
3
  public java.util.List<Figure> getFiguresFrontToBack() {
    ensureSorted();
    return new ReversedList<Figure>(getChildren());
###
1177, createInputMap, DefaultDrawingEditor, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingEditor.java, 303, 341
16
/** Override this method to create a tool-specific input map, which
   * overrides the input map of the drawing edtior.
   * <p>
   * The implementation of this class creates an input map for the following
   * action ID's:
   * <ul>
   * <li>DeleteAction</li>
   * <li>SelectAllAction/li>
   * <li>IncreaseHandleDetailLevelAction</li>
   * <li>MoveConstrainedAction.West, .East, .North, .South</li>
   * <li>MoveAction.West, .East, .North, .South</li>
   * <li>CutAction</li>
   * <li>CopyAction</li>
   * <li>PasteAction</li>
   * </ul>
   */
32
  protected InputMap createInputMap() {
    InputMap m = new InputMap();
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), DeleteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_BACK_SPACE, 0), DeleteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, 0), SelectAllAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_DOWN_MASK), SelectAllAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.META_DOWN_MASK), SelectAllAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), IncreaseHandleDetailLevelAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), MoveConstrainedAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), MoveConstrainedAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), MoveConstrainedAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), MoveConstrainedAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.ALT_DOWN_MASK), MoveAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.ALT_DOWN_MASK), MoveAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.ALT_DOWN_MASK), MoveAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.ALT_DOWN_MASK), MoveAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.SHIFT_DOWN_MASK), MoveAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.SHIFT_DOWN_MASK), MoveAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.SHIFT_DOWN_MASK), MoveAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.SHIFT_DOWN_MASK), MoveAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK), MoveAction.West.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK), MoveAction.East.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.CTRL_DOWN_MASK), MoveAction.North.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.CTRL_DOWN_MASK), MoveAction.South.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_DOWN_MASK), CopyAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.META_DOWN_MASK), CopyAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK), PasteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.META_DOWN_MASK), PasteAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_DOWN_MASK), CutAction.ID);
    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.META_DOWN_MASK), CutAction.ID);

    return m;
###
1178, DefaultDrawingEditor, DefaultDrawingEditor, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingEditor.java, 108, 116
1
/** Creates a new instance. */
8
  public DefaultDrawingEditor() {
    toolHandler = new ToolHandler();
    setDefaultAttribute(FILL_COLOR, Color.white);
    setDefaultAttribute(STROKE_COLOR, Color.black);
    setDefaultAttribute(TEXT_COLOR, Color.black);
    views = new HashSet<DrawingView>();
    inputMap = createInputMap();
    actionMap = createActionMap();
###
1179, setTarget, DrawingEditorProxy, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DrawingEditorProxy.java, 62, 68
3
/**
   * Sets the target of the proxy.
   */
7
  public void setTarget(DrawingEditor newValue) {
    if (target != null) {
      target.removePropertyChangeListener(forwarder);
    }
    this.target = newValue;
    if (target != null) {
      target.addPropertyChangeListener(forwarder);
###
1180, DrawingEditorProxy, DrawingEditorProxy, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DrawingEditorProxy.java, 55, 56
1
/** Creates a new instance. */
2
  public DrawingEditorProxy() {
    forwarder = new Forwarder();
###
1203, getDefaultEventIndex, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 145, 146
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1204, getDefaultPropertyIndex, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 134, 135
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1207, getEventSetDescriptors, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 111, 112
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1208, getPropertyDescriptors, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 100, 101
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1210, getMethodDescriptors, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 122, 123
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1211, getBeanDescriptor, DefaultDrawingViewBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java, 84, 85
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1228, createEditorColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 559, 637
31
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Microsoft Office:
   * <ul>
   * <li>When the user clicks on the action region, the default color of the
   * DrawingEditor is applied to the selected figures.</li>
   * <li>When the user opens the popup menu, a color palette is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the current default color of the
   * DrawingEditor.</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
73
  public static JPopupButton createEditorColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape) {
    final JPopupButton popupButton = new JPopupButton();
    popupButton.setPopupAlpha(1f);
    if (defaultAttributes == null) {
      defaultAttributes = new HashMap<AttributeKey, Object>();
    }
    popupButton.setAction(
        new DefaultAttributeAction(editor, attributeKey, defaultAttributes),
        new Rectangle(0, 0, 22, 22));
    popupButton.setColumnCount(columnCount, false);
    boolean hasNullColor = false;
    for (ColorIcon swatch : swatches) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, swatch.getColor());
      if (swatch.getColor() == null) {
        hasNullColor = true;
      }
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty(labelKey),
          swatch));
      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());
      a.setUpdateEnabledState(false);
    }
    // No color
    if (!hasNullColor) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, null);
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty("attribute.color.noColor"),
          new ColorIcon(null, labels.getToolTipTextProperty("attribute.color.noColor"), swatches.get(0).getIconWidth(), swatches.get(0).getIconHeight())));
      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.noColor"));
      a.setUpdateEnabledState(false);
    }
    // Color chooser
    ImageIcon chooserIcon = new ImageIcon(
        Images.createImage(
        ButtonFactory.class, "/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png"));
    Action a;
    popupButton.add(
        a = new EditorColorChooserAction(
        editor,
        attributeKey,
        "color",
        chooserIcon,
        defaultAttributes));
    labels.configureToolBarButton(popupButton, labelKey);
    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.colorChooser"));
    Icon icon = new EditorColorIcon(editor,
        attributeKey,
        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),
        colorShape);
    popupButton.setIcon(icon);
    popupButton.setDisabledIcon(icon);
    popupButton.setFocusable(false);
    editor.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        popupButton.repaint();
      }
    });
    return popupButton;
###
1235, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 748, 756
31
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the color of the selected
   * figures. If no figures are selected, the default color of the
   * DrawingEditor is displayed.</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
9
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape) {
    return createSelectionColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        colorShape, new LinkedList<Disposable>());
###
1238, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 879, 887
16
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   */
9
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels) {
    return createDrawingColorButton(
        editor, attributeKey,
        swatches, columnCount,
        labelKey, labels,
        null);
###
1245, addAlignmentButtonsTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 1499, 1528
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar.
   */
29
  public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor, java.util.List<Disposable> dsp) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    AbstractSelectedAction d;
    bar.add(d = new AlignAction.West(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.East(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.Horizontal(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.North(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.South(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new AlignAction.Vertical(editor)).setFocusable(false);
    dsp.add(d);
    bar.addSeparator();
    bar.add(d = new MoveAction.West(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new MoveAction.East(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new MoveAction.North(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(d = new MoveAction.South(editor)).setFocusable(false);
    dsp.add(d);
    bar.addSeparator();
    bar.add(new BringToFrontAction(editor)).setFocusable(false);
    dsp.add(d);
    bar.add(new SendToBackAction(editor)).setFocusable(false);
    dsp.add(d);
###
1249, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 667, 675
27
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the color of the selected
   * figures. If no figures are selected, the default color of the
   * DrawingEditor is displayed.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   */
9
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels) {
    return createSelectionColorButton(
        editor, attributeKey,
        swatches, columnCount,
        labelKey, labels,
        null);
###
1252, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 911, 918
21
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   */
8
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes) {
    return createDrawingColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        new Rectangle(1, 17, 20, 4));
###
1253, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 944, 952
23
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
9
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape) {
    return createDrawingColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        colorShape, new LinkedList<Disposable>());
###
1254, addAttributesButtonsTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 422, 436
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar
   */
13
  public static void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JButton b;
    b = bar.add(new PickAttributesAction(editor));
    b.setFocusable(false);
    b = bar.add(new ApplyAttributesAction(editor));
    b.setFocusable(false);
    bar.addSeparator();
    addColorButtonsTo(bar, editor);
    bar.addSeparator();
    addStrokeButtonsTo(bar, editor);
    bar.addSeparator();
    addFontButtonsTo(bar, editor);
###
1255, addAlignmentButtonsTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 1492, 1493
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar
   */
2
  public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor) {
    addAlignmentButtonsTo(bar, editor, new LinkedList<Disposable>());
###
1256, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 707, 714
29
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   */
8
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes) {
    return createSelectionColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        new Rectangle(1, 17, 20, 4));
###
1257, createEditorColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 477, 485
25
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Microsoft Office:
   * <ul>
   * <li>When the user clicks on the action region, the default color of the
   * DrawingEditor is applied to the selected figures.</li>
   * <li>When the user opens the popup menu, a color palette is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   */
9
  public static JPopupButton createEditorColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels) {
    return createEditorColorButton(
        editor, attributeKey,
        swatches, columnCount,
        labelKey, labels,
        null);
###
1258, addToolTo, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 313, 328
5
/**
   * Method addSelectionToolTo must have been invoked prior to this on the
   * JToolBar.
   *
   */
13
  public static JToggleButton addToolTo(JToolBar tb, DrawingEditor editor,
      Tool tool, String labelKey,
      ResourceBundleUtil labels) {
    ButtonGroup group = (ButtonGroup) tb.getClientProperty("toolButtonGroup");
    ToolListener toolHandler = (ToolListener) tb.getClientProperty("toolHandler");
    JToggleButton t = new JToggleButton();
    labels.configureToolBarButton(t, labelKey);
    t.addItemListener(new ToolButtonListener(tool, editor));
    t.setFocusable(false);
    tool.addToolListener(toolHandler);
    group.add(t);
    tb.add(t);
    return t;
###
1259, createDrawingColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 978, 1052
23
/**
   * Creates a color button, with an action region and a popup menu. The
   * button acts on attributes of the Drawing object in the current DrawingView
   * of the DrawingEditor.
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
70
  public static JPopupButton createDrawingColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape, java.util.List<Disposable> dsp) {
    final JPopupButton popupButton = new JPopupButton();
    popupButton.setPopupAlpha(1f);
    if (defaultAttributes == null) {
      defaultAttributes = new HashMap<AttributeKey, Object>();
    }
    popupButton.setColumnCount(columnCount, false);
    boolean hasNullColor = false;
    for (ColorIcon swatch : swatches) {
      DrawingAttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, swatch.getColor());
      if (swatch.getColor() == null) {
        hasNullColor = true;
      }
      popupButton.add(a =
          new DrawingAttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty(labelKey),
          swatch));
      dsp.add(a);
      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());
      a.setUpdateEnabledState(false);
    }
    // No color
    if (!hasNullColor) {
      DrawingAttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, null);
      popupButton.add(a =
          new DrawingAttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty("attribute.color.noColor"),
          new ColorIcon(null, labels.getToolTipTextProperty("attribute.color.noColor"))));
      dsp.add(a);
      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.noColor"));
      a.setUpdateEnabledState(false);
    }
    // Color chooser
    ImageIcon chooserIcon = new ImageIcon(
        Images.createImage(ButtonFactory.class, "/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png"));
    DrawingColorChooserAction a;
    popupButton.add(
        a = new DrawingColorChooserAction(
        editor,
        attributeKey,
        "color",
        chooserIcon,
        defaultAttributes));
    dsp.add(a);
    labels.configureToolBarButton(popupButton, labelKey);
    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.colorChooser"));
    Icon icon = new DrawingColorIcon(editor,
        attributeKey,
        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),
        colorShape);
    popupButton.setIcon(icon);
    popupButton.setDisabledIcon(icon);
    popupButton.setFocusable(false);
    if (editor != null) {
      dsp.add(new SelectionComponentRepainter(editor, popupButton));
    }
    return popupButton;
###
1260, createEditorColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 518, 525
30
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Microsoft Office:
   * <ul>
   * <li>When the user clicks on the action region, the default color of the
   * DrawingEditor is applied to the selected figures.</li>
   * <li>When the user opens the popup menu, a color palette is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A rectangle on the color button displays the current default color of
   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,
   * width, height).</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   */
8
  public static JPopupButton createEditorColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes) {
    return createEditorColorButton(editor, attributeKey,
        swatches, columnCount, labelKey, labels, defaultAttributes,
        new Rectangle(1, 17, 20, 4));
###
1261, createToggleGridButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 1536, 1560
4
/**
   * Creates a button which toggles between two GridConstrainer for
   * a DrawingView.
   */
21
  public static AbstractButton createToggleGridButton(final DrawingView view) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    final JToggleButton toggleButton;
    toggleButton = new JToggleButton();
    labels.configureToolBarButton(toggleButton, "view.toggleGrid");
    toggleButton.setFocusable(false);
    toggleButton.addItemListener(new ItemListener() {
      public void itemStateChanged(ItemEvent event) {
        view.setConstrainerVisible(toggleButton.isSelected());
      //view.getComponent().repaint();
      }
    });
    view.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        // String constants are interned
        if (evt.getPropertyName() == DrawingView.CONSTRAINER_VISIBLE_PROPERTY) {
          toggleButton.setSelected(view.isConstrainerVisible());
        }
      }
    });
    return toggleButton;
###
1262, createSelectionColorButton, ButtonFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java, 790, 860
31
/**
   * Creates a color button, with an action region and a popup menu. The
   * button works like the color button in Adobe Fireworks:
   * <ul>
   * <li>When the user clicks at the button a popup menu with a color palette
   * is displayed.
   * Choosing a color from the palette changes the default color of the
   * editor and also changes the color of the selected figures.</li>
   * <li>A shape on the color button displays the color of the selected
   * figures. If no figures are selected, the default color of the
   * DrawingEditor is displayed.</li>
   * </ul>
   *
   * @param editor The DrawingEditor.
   * @param attributeKey The AttributeKey of the color.
   * @param swatches A list with labeled colors containing the color palette
   * of the popup menu. The actual labels are retrieved from the supplied
   * resource bundle. This is usually a LinkedHashMap, so that the colors have
   * a predictable order.
   * @param columnCount The number of columns of the color palette.
   * @param labelKey The resource bundle key used for retrieving the icon and
   * the tooltip of the button.
   * @param labels The resource bundle.
   * @param defaultAttributes A set of attributes which are also applied to
   * the selected figures, when a color is selected. This can be used, to
   * set attributes that otherwise prevent the color from being shown. For
   * example, when the color attribute is set, we wan't the gradient attribute
   * of the Figure to be cleared.
   * @param colorShape This shape is superimposed on the icon of the button.
   * The shape is drawn with the default color of the DrawingEditor.
   */
68
  public static JPopupButton createSelectionColorButton(
      DrawingEditor editor, AttributeKey<Color> attributeKey,
      java.util.List<ColorIcon> swatches, int columnCount,
      String labelKey, ResourceBundleUtil labels,
      Map<AttributeKey, Object> defaultAttributes,
      Shape colorShape, java.util.List<Disposable> dsp) {
    final JPopupButton popupButton = new JPopupButton();
    popupButton.setPopupAlpha(1f);
    if (defaultAttributes == null) {
      defaultAttributes = new HashMap<AttributeKey, Object>();
    }
    popupButton.setColumnCount(columnCount, false);
    boolean hasNullColor = false;
    for (ColorIcon swatch : swatches) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, swatch.getColor());
      if (swatch.getColor() == null) {
        hasNullColor = true;
      }
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty(labelKey),
          swatch));
      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());
      a.setUpdateEnabledState(false);
      dsp.add(a);
    }
    // No color
    if (!hasNullColor) {
      AttributeAction a;
      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);
      attributes.put(attributeKey, null);
      popupButton.add(a =
          new AttributeAction(
          editor,
          attributes,
          labels.getToolTipTextProperty("attribute.color.noColor"),
          new ColorIcon(null, labels.getToolTipTextProperty("attribute.color.noColor"))));
      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.noColor"));
      a.setUpdateEnabledState(false);
      dsp.add(a);
    }
    // Color chooser
    ImageIcon chooserIcon = new ImageIcon(
        Images.createImage(ButtonFactory.class, "/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png"));
    AttributeAction a;
    popupButton.add(
        a = new SelectionColorChooserAction(
        editor,
        attributeKey,
        labels.getToolTipTextProperty("attribute.color.colorChooser"),
        chooserIcon,
        defaultAttributes));
    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty("attribute.color.colorChooser"));
    dsp.add(a);
    labels.configureToolBarButton(popupButton, labelKey);
    Icon icon = new SelectionColorIcon(editor,
        attributeKey,
        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),
        colorShape);
    popupButton.setIcon(icon);
    popupButton.setDisabledIcon(icon);
    popupButton.setFocusable(false);
    dsp.add(new SelectionComponentRepainter(editor, popupButton));
    return popupButton;
###
1264, DefaultAttributeAction, DefaultAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DefaultAttributeAction.java, 38, 39
1
/** Creates a new instance. */
2
  public DefaultAttributeAction(DrawingEditor editor, AttributeKey key) {
    this(editor, key, null, null);
###
1265, DefaultAttributeAction, DefaultAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DefaultAttributeAction.java, 48, 49
1
/** Creates a new instance. */
2
  public DefaultAttributeAction(DrawingEditor editor, AttributeKey key, Icon icon) {
    this(editor, key, null, icon);
###
1266, setDrawing, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 71, 76
5
/**
   * Sets the GridConstrainer to be edited by this panel.
   * 
   * @param newValue The GridConstrainer.
   */
6
  public void setDrawing(Drawing newValue) {
    drawing = newValue;
    // XXX - This does not work, we must pass the drawing editor here!
    opacitySliderHandler.setDrawing(drawing);
    opacityFieldHandler.setDrawing(drawing);
    updatePanel();
###
1268, updateDrawing, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 82, 88
3
/**
   * Updates the drawing due to changes made on this panel.
   */
7
  private void updateDrawing() {
    if (drawing != null) {
      drawing.willChange();
      drawing.fireUndoableEditHappened(
          CANVAS_FILL_COLOR.setUndoable(drawing, colorButton.getBackground())
          );
      drawing.changed();
###
1269, EditCanvasPanel, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 44, 57
1
/** Creates new form. */
14
  public EditCanvasPanel() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    colorButton.putClientProperty("Quaqua.Button.style", "colorWell");
    opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);
    opacityPopupButton.add(opacitySlider);
    opacityPopupButton.putClientProperty("JButton.buttonType", "toolbar");
    add(opacityPopupButton);
    NumberFormatter nf = new NumberFormatter();
    nf.setMaximum(1d);
    nf.setMinimum(0d);
    opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));
    opacityFieldHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacityField, null);
    opacitySliderHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacitySlider, null);
###
1270, initComponents, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 129, 165
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
30
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    bgColorButtonGroup = new javax.swing.ButtonGroup();
    colorLabel = new javax.swing.JLabel();
    colorButton = new javax.swing.JButton();
    opacityLabel = new javax.swing.JLabel();
    opacityField = new org.jhotdraw.gui.JAttributeTextField<Double>();
    opacityPopupButton = new org.jhotdraw.gui.JPopupButton();
    setLayout(new java.awt.GridBagLayout());
    colorLabel.setText(labels.getString("attribute.canvasFillColor.text")); // NOI18N
    colorLabel.setToolTipText(labels.getString("attribute.backgroundColor.toolTipText")); // NOI18N
    add(colorLabel, new java.awt.GridBagConstraints());
    colorButton.setText(" ");
    colorButton.setToolTipText(labels.getString("attribute.backgroundColor.toolTipText")); // NOI18N
    colorButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        colorButtonPerformed(evt);
      }
    });
    add(colorButton, new java.awt.GridBagConstraints());
    opacityLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/attributeOpacity.png"))); // NOI18N
    opacityLabel.setToolTipText(labels.getString("attribute.opacity.toolTipText")); // NOI18N
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
    add(opacityLabel, gridBagConstraints);
    opacityField.setColumns(3);
    add(opacityField, new java.awt.GridBagConstraints());
    opacityPopupButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/popupIcon.png"))); // NOI18N
    opacityPopupButton.setToolTipText(labels.getString("attribute.opacity.toolTipText")); // NOI18N
    add(opacityPopupButton, new java.awt.GridBagConstraints());
###
1271, getDrawing, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 106, 107
5
/**
   * Returns the GridConstrainer currently being edited by this panel.
   * 
   * @return The GridConstrainer.
   */
2
  public Drawing getDrawing() {
    return drawing;
###
1272, updatePanel, EditCanvasPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java, 95, 97
3
/**
   * Updates the panel due to changes made on the drawing.
   */
3
  private void updatePanel() {
    if (drawing != null) {
      colorButton.setBackground(drawing.get(CANVAS_FILL_COLOR));
###
1273, DrawingAttributeAction, DrawingAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingAttributeAction.java, 40, 41
1
/** Creates a new instance. */
2
  public DrawingAttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {
    this(editor, key, value, null, icon);
###
1274, DrawingAttributeAction, DrawingAttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingAttributeAction.java, 35, 36
1
/** Creates a new instance. */
2
  public DrawingAttributeAction(DrawingEditor editor, AttributeKey key, Object value) {
    this(editor, key, value, null, null);
###
1275, ColorIcon, ColorIcon, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ColorIcon.java, 36, 37
1
/** Creates a new instance. */
2
  public ColorIcon(int rgb) {
    this(new Color(rgb));
###
1276, DrawingColorChooserAction, DrawingColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java, 34, 35
1
/** Creates a new instance. */
2
  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {
    this(editor, key, null, null);
###
1277, DrawingColorChooserAction, DrawingColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java, 42, 43
1
/** Creates a new instance. */
2
  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, String name) {
    this(editor, key, name, null);
###
1278, DrawingColorChooserAction, DrawingColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java, 38, 39
1
/** Creates a new instance. */
2
  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {
    this(editor, key, null, icon);
###
1279, initComponents, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 271, 273
7
/** This method is called from within the constructor to
   * initialize the form.<p>
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.<p>
   * NOTE: To prevent undesired layout effects when using floating
   * text fields, the DefaultDrawingView must not use a layout manager.
   */
2
  private void initComponents() {
    setLayout(null);
###
1280, toggleSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 833, 838
4
/**
   * If a figure isn't selected it is added to the selection.
   * Otherwise it is removed from the selection.
   */
6
  @Override
  public void toggleSelection(Figure figure) {
    if (selectedFigures.contains(figure)) {
      removeFromSelection(figure);
    } else {
      addToSelection(figure);
###
1281, getBackgroundPaint, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1547, 1561
4
/**
   * Returns a paint for drawing the background of the drawing area.
   * @return Paint.
   */
14
  protected Paint getBackgroundPaint(
      int x, int y) {
    if (backgroundTile == null) {
      backgroundTile = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);
      Graphics2D g = backgroundTile.createGraphics();
      g.setColor(Color.white);
      g.fillRect(0, 0, 16, 16);
      g.setColor(new Color(0xdfdfdf));
      g.fillRect(0, 0, 8, 8);
      g.fillRect(8, 8, 8, 8);
      g.dispose();
    }
    return new TexturePaint(backgroundTile,
        new Rectangle(x, y, backgroundTile.getWidth(), backgroundTile.getHeight()));
###
1282, invalidateHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 931, 962
3
/**
   * Invalidates the handles.
   */
27
  private void invalidateHandles() {
    if (handlesAreValid) {
      handlesAreValid = false;
      Rectangle invalidatedArea = null;
      for (Handle handle : selectionHandles) {
        handle.removeHandleListener(eventHandler);
        if (invalidatedArea == null) {
          invalidatedArea = handle.getDrawingArea();
        } else {
          invalidatedArea.add(handle.getDrawingArea());
        }
        handle.dispose();
      }
      for (Handle handle : secondaryHandles) {
        handle.removeHandleListener(eventHandler);
        if (invalidatedArea == null) {
          invalidatedArea = handle.getDrawingArea();
        } else {
          invalidatedArea.add(handle.getDrawingArea());
        }
        handle.dispose();
      }
      selectionHandles.clear();
      secondaryHandles.clear();
      setActiveHandle(null);
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1284, selectAll, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 852, 868
3
/**
   * Selects all selectable figures.
   */
13
  @Override
  public void selectAll() {
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    selectedFigures.clear();
    for (Figure figure : drawing.getChildren()) {
      if (figure.isSelectable()) {
        selectedFigures.add(figure);
      }
    }
    Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
    invalidateHandles();
    fireSelectionChanged(oldSelection, newSelection);
    repaint();
###
1285, drawCanvas, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 589, 611
4
/** Draws the canvas. If the {@code AttributeKeys.CANVAS_FILL_OPACITY} is
   * not fully opaque, the canvas area is filled with the background paint
   * before the {@code AttributeKeys.CANVAS_FILL_COLOR} is drawn.
   */
19
  protected void drawCanvas(Graphics2D g) {
    Rectangle cb = getCanvasViewBounds();
    // Retrieve the canvasColor color from the drawing
    Color canvasColor;
    if (drawing == null) {
      canvasColor = CANVAS_FILL_COLOR.getDefaultValue();
    } else {
      canvasColor = drawing.get(CANVAS_FILL_COLOR);
      if (canvasColor != null) {
        canvasColor = new Color((canvasColor.getRGB() & 0xffffff) | ((int) (drawing.get(CANVAS_FILL_OPACITY) * 255) << 24), true);
      }
    }
    if (canvasColor == null || canvasColor.getAlpha() != 255) {
      g.setPaint(getBackgroundPaint(cb.x, cb.y));
      g.fillRect(cb.x, cb.y, cb.width, cb.height);
    }
    if (canvasColor != null) {
      g.setColor(canvasColor);
      g.fillRect(cb.x, cb.y, cb.width, cb.height);
###
1286, drawDrawingNonvolatileBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 435, 522
1
/** Draws the drawing double buffered using a buffered image. */
78
  protected void drawDrawingNonvolatileBuffered(Graphics2D g) {
    Rectangle vr = getVisibleRect();
    Point shift = new Point(0, 0);
    if (bufferedArea.contains(vr) ||
        bufferedArea.width >= vr.width && bufferedArea.height >= vr.height) {
      // The visible rect fits into the buffered area, but may be shifted; shift the buffered area.
      shift.x = bufferedArea.x - vr.x;
      shift.y = bufferedArea.y - vr.y;
      if (shift.x > 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x - shift.x, vr.y, shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      } else if (shift.x < 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x + vr.width, vr.y, -shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      }
      if (shift.y > 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y - shift.y, bufferedArea.width, shift.y + bufferedArea.height - vr.height));
      } else if (shift.y < 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y + vr.height, bufferedArea.width, -shift.y + bufferedArea.height - vr.height));
      }
      bufferedArea.x = vr.x;
      bufferedArea.y = vr.y;
    } else {
      // The buffered drawing area does not match the visible rect;
      // resize it, and mark everything as dirty.
      bufferedArea.setBounds(vr);
      dirtyArea.setBounds(vr);
      if (drawingBufferNV != null && //
          (drawingBufferNV.getWidth() != vr.width ||
          drawingBufferNV.getHeight() != vr.height)) {
        // The dimension of the drawing buffer does not fit into the visible rect;
        // throw the buffer away.
        drawingBufferNV.flush();
        drawingBufferNV = null;
      }
    }
    // Update the contents of the buffer if necessary
    int valid = (drawingBufferNV == null) ? //
        VolatileImage.IMAGE_INCOMPATIBLE : VolatileImage.IMAGE_OK;
    switch (valid) {
      case VolatileImage.IMAGE_INCOMPATIBLE:
        // old buffer doesn't work with new GraphicsConfig; (re-)create it
        try {
          drawingBufferNV = getGraphicsConfiguration().createCompatibleImage(vr.width, vr.height, Transparency.TRANSLUCENT);
        } catch (OutOfMemoryError e) {
          drawingBufferNV = null;
        }
        dirtyArea.setBounds(bufferedArea);
        break;
    }
    if (drawingBufferNV == null) {
      // There is not enough memory available for a drawing buffer;
      // draw without buffering.
      drawDrawing(g);
      return;
    }
    if (!dirtyArea.isEmpty()) {
      // An area of the drawing buffer is dirty; repaint it
      Graphics2D gBuf = drawingBufferNV.createGraphics();
      setViewRenderingHints(gBuf);
      // For shifting and cleaning, we need to erase everything underneath
      gBuf.setComposite(AlphaComposite.Src);
      // Perform shifting if needed
      if (shift.x != 0 || shift.y != 0) {
        gBuf.copyArea(Math.max(0, -shift.x), Math.max(0, -shift.y), drawingBufferNV.getWidth() - Math.abs(shift.x), drawingBufferNV.getHeight() - Math.abs(shift.y), shift.x, shift.y);
        shift.x = shift.y = 0;
      }
      // Clip the dirty area
      gBuf.translate(-bufferedArea.x, -bufferedArea.y);
      gBuf.clip(dirtyArea);
      // Clear the dirty area
      gBuf.setBackground(new Color(0x0, true));
      gBuf.clearRect(dirtyArea.x, dirtyArea.y, dirtyArea.width, dirtyArea.height);
      gBuf.setComposite(AlphaComposite.SrcOver);
      // Repaint the dirty area
      drawDrawing(gBuf);
      gBuf.dispose();
    }
    g.drawImage(drawingBufferNV, bufferedArea.x, bufferedArea.y, null);
    dirtyArea.setSize(-1, -1);
###
1287, printComponent, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 530, 543
5
/**
   * Prints the drawing view.
   * Uses high quality rendering hints for printing. Only prints the drawing.
   * Doesn't print the canvasColor, the grid, the handles and the tool.
   */
12
  @Override
  public void printComponent(Graphics gr) {
    Graphics2D g = (Graphics2D) gr;
    // Set rendering hints for quality
    g.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);
    g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
    g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
    drawDrawing(g);
###
1288, isDrawingDoubleBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1539, 1540
2
/** Returns true, if the the drawing is double buffered.
   */
2
  public boolean isDrawingDoubleBuffered() {
    return isDrawingDoubleBuffered;
###
1289, viewToDrawing, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1266, 1270
3
/**
   * Converts view coordinates to drawing coordinates.
   */
5
  @Override
  public Point2D.Double viewToDrawing(Point p) {
    return new Point2D.Double(
        (p.x + translation.x) / scaleFactor,
        (p.y + translation.y) / scaleFactor);
###
1290, addToSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 737, 762
3
/**
   * Adds a figure to the current selection.
   */
24
  public void addToSelection(Figure figure) {
    if (DEBUG) {
      System.out.println("DefaultDrawingView" + ".addToSelection(" + figure + ")");
    }
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    if (selectedFigures.add(figure)) {
      figure.addFigureListener(handleInvalidator);
      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
      Rectangle invalidatedArea = null;
      if (handlesAreValid && getEditor() != null) {
        for (Handle h : figure.createHandles(detailLevel)) {
          h.setView(this);
          selectionHandles.add(h);
          h.addHandleListener(eventHandler);
          if (invalidatedArea == null) {
            invalidatedArea = h.getDrawingArea();
          } else {
            invalidatedArea.add(h.getDrawingArea());
          }
        }
      }
      fireSelectionChanged(oldSelection, newSelection);
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1291, paintComponent, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 309, 327
5
/**
   * Paints the drawing view.
   * Uses rendering hints for fast painting. Paints the canvasColor, the
   * grid, the drawing, the handles and the current tool.
   */
19
  @Override
  public void paintComponent(Graphics gr) {
    long start = System.currentTimeMillis();
    Graphics2D g = (Graphics2D) gr;
    setViewRenderingHints(g);
    drawBackground(g);
    drawCanvas(g);
    drawConstrainer(g);
    if (isDrawingDoubleBuffered()) {
      if (isWindows) {
        drawDrawingNonvolatileBuffered(g);
      } else {
        drawDrawingVolatileBuffered(g);
      }
    } else {
      drawDrawing(g);
    }
    drawHandles(g);
    drawTool(g);
###
1292, drawBackground, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 135, 137
1
/** Draws the background of the drawing view. */
3
  protected void drawBackground(Graphics2D g) {
    g.setColor(getBackground());
    g.fillRect(0, 0, getWidth(), getHeight());
###
1293, setBounds, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1167, 1170
3
/**
   * Side effect: Changes view Translation.
   */
4
  @Override
  public void setBounds(int x, int y, int width, int height) {
    super.setBounds(x, y, width, height);
    validateViewTranslation();
###
1294, removeFromSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 808, 816
3
/**
   * Removes a figure from the selection.
   */
8
  public void removeFromSelection(Figure figure) {
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    if (selectedFigures.remove(figure)) {
      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
      invalidateHandles();
      figure.removeFigureListener(handleInvalidator);
      fireSelectionChanged(oldSelection, newSelection);
      repaint();
###
1295, drawDrawingVolatileBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 331, 429
1
/** Draws the drawing double buffered using a volatile image. */
90
  protected void drawDrawingVolatileBuffered(Graphics2D g) {
    Rectangle vr = getVisibleRect();
    Point shift = new Point(0, 0);
    if (bufferedArea.contains(vr) ||
        bufferedArea.width >= vr.width && bufferedArea.height >= vr.height) {
      // The visible rect fits into the buffered area, but may be shifted; shift the buffered area.
      shift.x = bufferedArea.x - vr.x;
      shift.y = bufferedArea.y - vr.y;
      if (shift.x > 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x - shift.x, vr.y, shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      } else if (shift.x < 0) {
        dirtyArea.add(new Rectangle(bufferedArea.x + vr.width, vr.y, -shift.x + bufferedArea.width - vr.width, bufferedArea.height));
      }
      if (shift.y > 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y - shift.y, bufferedArea.width, shift.y + bufferedArea.height - vr.height));
      } else if (shift.y < 0) {
        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y + vr.height, bufferedArea.width, -shift.y + bufferedArea.height - vr.height));
      }
      bufferedArea.x = vr.x;
      bufferedArea.y = vr.y;
    } else {
      // The buffered drawing area does not match the visible rect;
      // resize it, and mark everything as dirty.
      bufferedArea.setBounds(vr);
      dirtyArea.setBounds(vr);
      if (drawingBufferV != null && //
          (drawingBufferV.getWidth() != vr.width ||
          drawingBufferV.getHeight() != vr.height)) {
        // The dimension of the drawing buffer does not fit into the visible rect;
        // throw the buffer away.
        drawingBufferV.flush();
        drawingBufferV = null;
      }
    }
    // Update the contents of the buffer if necessary
    while (true) {
      int valid = (drawingBufferV == null) ? //
          VolatileImage.IMAGE_INCOMPATIBLE : //
          drawingBufferV.validate(getGraphicsConfiguration());
      switch (valid) {
        case VolatileImage.IMAGE_INCOMPATIBLE:
          // old buffer doesn't work with new GraphicsConfig; (re-)create it
          try {
            drawingBufferV = getGraphicsConfiguration().createCompatibleVolatileImage(vr.width, vr.height, Transparency.TRANSLUCENT);
          } catch (OutOfMemoryError e) {
            drawingBufferV = null;
          }
          dirtyArea.setBounds(bufferedArea);
          break;
        case VolatileImage.IMAGE_RESTORED:
          // image was restored, but buffer lost; redraw everything
          dirtyArea.setBounds(bufferedArea);
          break;
      }
      if (drawingBufferV == null) {
        // There is not enough memory available for a drawing buffer;
        // draw without buffering.
        drawDrawing(g);
        break;
      }
      if (!dirtyArea.isEmpty()) {
        // An area of the drawing buffer is dirty; repaint it
        Graphics2D gBuf = drawingBufferV.createGraphics();
        setViewRenderingHints(gBuf);
        // For shifting and cleaning, we need to erase everything underneath
        gBuf.setComposite(AlphaComposite.Src);
        // Perform shifting if needed
        if (shift.x != 0 || shift.y != 0) {
          gBuf.copyArea(Math.max(0, -shift.x), Math.max(0, -shift.y), drawingBufferV.getWidth() - Math.abs(shift.x), drawingBufferV.getHeight() - Math.abs(shift.y), shift.x, shift.y);
          shift.x = shift.y = 0;
        }
        // Clip the dirty area
        gBuf.translate(-bufferedArea.x, -bufferedArea.y);
        gBuf.clip(dirtyArea);
        // Clear the dirty area
        gBuf.setBackground(new Color(0x0, true));
        gBuf.clearRect(dirtyArea.x, dirtyArea.y, dirtyArea.width, dirtyArea.height);
        gBuf.setComposite(AlphaComposite.SrcOver);
        // Repaint the dirty area
        drawDrawing(gBuf);
        gBuf.dispose();
      }
      if (!drawingBufferV.contentsLost()) {
        g.drawImage(drawingBufferV, bufferedArea.x, bufferedArea.y, null);
      }
      if (drawingBufferV.contentsLost()) {
        dirtyArea.setBounds(bufferedArea);
      } else {
        dirtyArea.setSize(-1, -1);
        break;
###
1296, getCanvasViewBounds, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 562, 582
5
/**
   * Returns the bounds of the canvas on the drawing view.
   *
   * @return The current bounds of the canvas on the drawing view.
   */
17
  protected Rectangle getCanvasViewBounds() {
    // Position of the zero coordinate point on the view
    int x = -translation.x;
    int y = -translation.y;
    int w = getWidth();
    int h = getHeight();
    if (getDrawing() != null) {
      Double cw = getDrawing().get(CANVAS_WIDTH);
      Double ch = getDrawing().get(CANVAS_HEIGHT);
      if (cw != null && ch != null) {
        Point lowerRight = drawingToView(
            new Point2D.Double(cw, ch));
        w = lowerRight.x - x;
        h = lowerRight.y - y;
      }
    }
    return new Rectangle(x, y, w, h);
###
1297, isFigureSelected, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 890, 892
3
/**
   * Test whether a given figure is selected.
   */
3
  @Override
  public boolean isFigureSelected(Figure checkFigure) {
    return selectedFigures.contains(checkFigure);
###
1298, setDrawingDoubleBuffered, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1521, 1534
9
/** Sets whether the drawing is double buffered.
   * <p>
   * The default value is true.
   * <p>
   * This is a bound property.
   * <p>
   * If the drawing view is used for editing, you should leave this to true.
   * If the drawing view is used for viewing only, you should set this to false.
   */
13
  public void setDrawingDoubleBuffered(boolean newValue) {
    boolean oldValue = isDrawingDoubleBuffered;
    isDrawingDoubleBuffered =
        newValue;
    if (!isDrawingDoubleBuffered && drawingBufferV != null) {
      drawingBufferV.flush();
      drawingBufferV = null;
    }
    if (!isDrawingDoubleBuffered && drawingBufferNV != null) {
      drawingBufferNV.flush();
      drawingBufferNV = null;
    }
    firePropertyChange(DRAWING_DOUBLE_BUFFERED_PROPERTY, oldValue, newValue);
###
1299, getSecondaryHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 923, 925
3
/**
   * Gets the currently active secondary handles.
   */
3
  private java.util.List<Handle> getSecondaryHandles() {
    validateHandles();
    return Collections.unmodifiableList(secondaryHandles);
###
1300, getSelectedFigures, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 899, 901
4
/**
   * Gets the current selection as a FigureSelection. A FigureSelection
   * can be cut, copied, pasted.
   */
3
  @Override
  public Set<Figure> getSelectedFigures() {
    return Collections.unmodifiableSet(selectedFigures);
###
1301, findHandle, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1014, 1031
4
/**
   * Finds a handle at a given coordinates.
   * @return A handle, null if no handle is found.
   */
15
  @Override
  public Handle findHandle(
      Point p) {
    validateHandles();
    for (Handle handle : new ReversedList<Handle>(getSecondaryHandles())) {
      if (handle.contains(p)) {
        return handle;
      }
    }
    for (Handle handle : new ReversedList<Handle>(getSelectionHandles())) {
      if (handle.contains(p)) {
        return handle;
      }
    }
    return null;
###
1302, addToSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 771, 799
3
/**
   * Adds a collection of figures to the current selection.
   */
28
  public void addToSelection(Collection<Figure> figures) {
    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
    Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
    boolean selectionChanged = false;
    Rectangle invalidatedArea = null;
    for (Figure figure : figures) {
      if (selectedFigures.add(figure)) {
        selectionChanged = true;
        newSelection.add(figure);
        figure.addFigureListener(handleInvalidator);
        if (handlesAreValid && getEditor() != null) {
          for (Handle h : figure.createHandles(detailLevel)) {
            h.setView(this);
            selectionHandles.add(h);
            h.addHandleListener(eventHandler);
            if (invalidatedArea == null) {
              invalidatedArea = h.getDrawingArea();
            } else {
              invalidatedArea.add(h.getDrawingArea());
            }
          }
        }
      }
    }
    if (selectionChanged) {
      fireSelectionChanged(oldSelection, newSelection);
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1303, findFigure, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1062, 1065
4
/**
   * Finds a figure at a given coordinates.
   * @return A figure, null if no figure is found.
   */
4
  @Override
  public Figure findFigure(
      Point p) {
    return getDrawing().findFigure(viewToDrawing(p));
###
1304, drawingToView, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1245, 1250
3
/**
   * Converts drawing coordinates to view coordinates.
   */
6
  @Override
  public Point drawingToView(
      Point2D.Double p) {
    return new Point(
        (int) (p.x * scaleFactor) - translation.x,
        (int) (p.y * scaleFactor) - translation.y);
###
1305, clearSelection, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 875, 883
3
/**
   * Clears the current selection.
   */
8
  @Override
  public void clearSelection() {
    if (getSelectionCount() > 0) {
      Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);
      selectedFigures.clear();
      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);
      invalidateHandles();
      fireSelectionChanged(oldSelection, newSelection);
###
1306, validateViewTranslation, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1177, 1238
4
/**
   * Updates the view translation taking into account the current dimension
   * of the view JComponent, the size of the drawing, and the scale factor.
   */
52
  private void validateViewTranslation() {
    if (getDrawing() == null) {
      translation.x = translation.y = 0;
      return;
    }
    Point oldTranslation = (Point) translation.clone();
    int width = getWidth();
    int height = getHeight();
    Insets insets = getInsets();
    Rectangle2D.Double da = getDrawingArea();
    Rectangle r = new Rectangle((int) (da.x * scaleFactor), (int) (da.y * scaleFactor), (int) (da.width * scaleFactor), (int) (da.height * scaleFactor));
    int cw, ch;
    Double cwd = getDrawing().get(CANVAS_WIDTH);
    Double chd = getDrawing().get(CANVAS_HEIGHT);
    if (cwd == null || chd == null) {
      // The canvas size is not explicitly specified.
      cw = Math.max(width - insets.left - insets.right, (int) ((Math.max(0, da.x) + da.width) * scaleFactor));
      ch = Math.max(height - insets.top - insets.bottom, (int) ((Math.max(0, da.y) + da.height) * scaleFactor));
      //Place the canvas at the top left
      translation.x = insets.top;
      translation.y = insets.left;
    } else {
      // The canvas size is explicitly specified.
      cw = (int) (cwd * scaleFactor);
      ch = (int) (chd * scaleFactor);
      //Place the canvas at the center
      if (cw < width) {
        translation.x = insets.left + (width - insets.left - insets.right - cw) / -2;
      }
      if (ch < height) {
        translation.y = insets.top + (height - insets.top - insets.bottom - ch) / -2;
      }
    }
    if (r.y + r.height - translation.y > (height - insets.bottom)) {
      // We cut off the lower part of the drawing -> shift the canvas up
      translation.y = r.y + r.height - (height - insets.bottom);
    }
    if (Math.min(0, r.y) - translation.y < insets.top) {
      // We cut off the upper part of the drawing -> shift the canvas down
      translation.y = Math.min(0, r.y) - insets.top;
    }
    if (r.x + r.width - translation.x > (width - insets.right)) {
      // We cut off the right part of the drawing -> shift the canvas left
      translation.x = r.x + r.width - (width - insets.right);
    }
    if (Math.min(0, r.x) - translation.x < insets.left) {
      // We cut off the left part of the drawing -> shift the canvas right
      translation.x = Math.min(0, r.x) - insets.left;
    }
    if (!oldTranslation.equals(translation)) {
      bufferedArea.translate(oldTranslation.x - translation.x, oldTranslation.y - translation.y);
      fireViewTransformChanged();
###
1307, fireSelectionChanged, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1094, 1118
6
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   * Also notify listeners who listen for
   * {@link EditableComponent#SELECTION_EMPTY_PROPERTY}.
   */
23
  protected void fireSelectionChanged(
      Set<Figure> oldValue,
      Set<Figure> newValue) {
    if (listenerList.getListenerCount() > 0) {
      FigureSelectionEvent event = null;
      // Notify all listeners that have registered interest for
      // Guaranteed to return a non-null array
      Object[] listeners = listenerList.getListenerList();
      // Process the listeners last to first, notifying
      // those that are interested in this event
      for (int i = listeners.length - 2; i >=
          0; i -=
              2) {
        if (listeners[i] == FigureSelectionListener.class) {
          // Lazily create the event:
          if (event == null) {
            event = new FigureSelectionEvent(this, oldValue, newValue);
          }
          ((FigureSelectionListener) listeners[i + 1]).selectionChanged(event);
        }
      }
    }
    firePropertyChange(EditableComponent.SELECTION_EMPTY_PROPERTY, oldValue.isEmpty(), newValue.isEmpty());
###
1308, getSelectionCount, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 907, 909
3
/**
   * Gets the number of selected figures.
   */
3
  @Override
  public int getSelectionCount() {
    return selectedFigures.size();
###
1309, DefaultDrawingView, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 240, 249
1
/** Creates new instance. */
9
  public DefaultDrawingView() {
    initComponents();
    eventHandler = createEventHandler();
    setToolTipText("dummy"); // Set a dummy tool tip text to turn tooltips on
    setFocusable(true);
    addFocusListener(eventHandler);
    setTransferHandler(new DefaultDrawingViewTransferHandler());
    setBackground(new Color(0xb0b0b0));
    setOpaque(true);
###
1310, getCompatibleHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 1038, 1054
4
/**
   * Gets compatible handles.
   * @return A collection containing the handle and all compatible handles.
   */
14
  @Override
  public Collection<Handle> getCompatibleHandles(Handle master) {
    validateHandles();
    HashSet<Figure> owners = new HashSet<Figure>();
    LinkedList<Handle> compatibleHandles = new LinkedList<Handle>();
    owners.add(master.getOwner());
    compatibleHandles.add(master);
    for (Handle handle : getSelectionHandles()) {
      if (!owners.contains(handle.getOwner()) && handle.isCombinableWith(master)) {
        owners.add(handle.getOwner());
        compatibleHandles.add(handle);
      }
    }
    return compatibleHandles;
###
1311, getSelectionHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 915, 917
3
/**
   * Gets the currently active selection handles.
   */
3
  private java.util.List<Handle> getSelectionHandles() {
    validateHandles();
    return Collections.unmodifiableList(selectionHandles);
###
1312, validateHandles, DefaultDrawingView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java, 971, 1003
3
/**
   * Validates the handles.
   */
30
  private void validateHandles() {
    // Validate handles only, if they are invalid, and if
    // the DrawingView has a DrawingEditor.
    if (!handlesAreValid && getEditor() != null) {
      handlesAreValid = true;
      selectionHandles.clear();
      Rectangle invalidatedArea = null;
      while (true) {
        for (Figure figure : getSelectedFigures()) {
          for (Handle handle : figure.createHandles(detailLevel)) {
            handle.setView(this);
            selectionHandles.add(handle);
            handle.addHandleListener(eventHandler);
            if (invalidatedArea == null) {
              invalidatedArea = handle.getDrawingArea();
            } else {
              invalidatedArea.add(handle.getDrawingArea());
            }
          }
        }
        if (selectionHandles.size() == 0 && detailLevel != 0) {
          // No handles are available at the desired detail level.
          // Retry with detail level 0.
          detailLevel = 0;
          continue;
        }
        break;
      }
      if (invalidatedArea != null) {
        repaint(invalidatedArea);
###
1365, importData, DefaultDrawingViewTransferHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewTransferHandler.java, 74, 295
1
/** Imports data and stores the transferred figures into the supplied transferFigures collection. */
204
  @SuppressWarnings("unchecked")
  protected boolean importData(final JComponent comp, Transferable t, final HashSet<Figure> transferFigures, final Point dropPoint) {
    if (DEBUG) {
      System.out.println("DefaultDrawingViewTransferHandler.importData(comp,t)");
    }
    boolean retValue;
    if (comp instanceof DrawingView) {
      final DrawingView view = (DrawingView) comp;
      final Drawing drawing = view.getDrawing();
      if (drawing.getInputFormats() == null ||
          drawing.getInputFormats().size() == 0) {
        if (DEBUG) {
          System.out.println("DefaultDrawingViewTransferHandler  import failed; drawing has no import formats");
        }
        retValue = false;
      } else {
        retValue = false;
        try {
          DataFlavor[] transferFlavors = t.getTransferDataFlavors();
          // Workaround for Mac OS X:
          // The Apple JVM messes up the sequence of the data flavors.
          if (System.getProperty("os.name").toLowerCase().startsWith("mac")) {
            // Search for a suitable input format
            SearchLoop:
            for (InputFormat format : drawing.getInputFormats()) {
              if (DEBUG) {
                System.out.println("DefaultDrawingViewTransferHandler  trying format:" + format);
              }
              for (DataFlavor flavor : transferFlavors) {
                if (DEBUG) {
                  System.out.println("DefaultDrawingViewTransferHandler  trying flavor:" + flavor.getMimeType());
                }
                if (format.isDataFlavorSupported(flavor)) {
                  LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());
                  try {
                    format.read(t, drawing, false);
                    if (DEBUG) {
                      System.out.println("DefaultDrawingViewTransferHandler  import succeeded");
                    }
                    final LinkedList<Figure> importedFigures = new LinkedList<Figure>(drawing.getChildren());
                    importedFigures.removeAll(existingFigures);
                    view.clearSelection();
                    view.addToSelection(importedFigures);
                    transferFigures.addAll(importedFigures);
                    moveToDropPoint(comp, transferFigures, dropPoint);
                    drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {
                      @Override
                      public String getPresentationName() {
                        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
                        return labels.getString("edit.paste.text");
                      }
                      @Override
                      public void undo() throws CannotUndoException {
                        super.undo();
                        drawing.removeAll(importedFigures);
                      }
                      @Override
                      public void redo() throws CannotRedoException {
                        super.redo();
                        drawing.addAll(importedFigures);
                      }
                    });
                    retValue = true;
                    break SearchLoop;
                  } catch (IOException e) {
                    if (DEBUG) {
                      System.out.println("  import failed");
                      e.printStackTrace();
                    }
                    // failed to read transferalbe, try with next InputFormat
                  }
                }
              }
            }
          } else {
            // Search for a suitable input format
            SearchLoop:
            for (DataFlavor flavor : transferFlavors) {
              if (DEBUG) {
                System.out.println("DefaultDrawingViewTransferHandler  trying flavor:" + flavor.getMimeType());
              }
              for (InputFormat format : drawing.getInputFormats()) {
                if (format.isDataFlavorSupported(flavor)) {
                  if (DEBUG) {
                    System.out.println("DefaultDrawingViewTransferHandler  trying format:" + format);
                  }
                  LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());
                  try {
                    format.read(t, drawing, false);
                    if (DEBUG) {
                      System.out.println("DefaultDrawingViewTransferHandler  import succeeded");
                    }
                    final LinkedList<Figure> importedFigures = new LinkedList<Figure>(drawing.getChildren());
                    importedFigures.removeAll(existingFigures);
                    view.clearSelection();
                    view.addToSelection(importedFigures);
                    transferFigures.addAll(importedFigures);
                    moveToDropPoint(comp, transferFigures, dropPoint);
                    drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {
                      @Override
                      public String getPresentationName() {
                        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
                        return labels.getString("edit.paste.text");
                      }
                      @Override
                      public void undo() throws CannotUndoException {
                        super.undo();
                        drawing.removeAll(importedFigures);
                      }
                      @Override
                      public void redo() throws CannotRedoException {
                        super.redo();
                        drawing.addAll(importedFigures);
                      }
                    });
                    retValue = true;
                    break SearchLoop;
                  } catch (IOException e) {
                    if (DEBUG) {
                      System.out.println("  import failed");
                      e.printStackTrace();
                    }
                    // failed to read transferalbe, try with next InputFormat
                  }
                }
              }
            }
          }
          // No input format found? Lets see if we got files - we
          // can handle these
          if (retValue == false && t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
            final java.util.List<File> files = (java.util.List<File>) t.getTransferData(DataFlavor.javaFileListFlavor);
            retValue = true;
            final LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());
            view.getEditor().setEnabled(false);
            // FIXME - We should perform the following code in a
            // worker thread.
            new Worker<LinkedList<Figure>>() {
              @Override
              public LinkedList<Figure> construct() throws Exception {
                for (File file : files) {
                  FileFormatLoop:
                  for (InputFormat format : drawing.getInputFormats()) {
                    if (file.isFile() &&
                        format.getFileFilter().accept(file)) {
                      if (DEBUG) {
                        System.out.println("DefaultDrawingViewTransferHandler  importing file " + file);
                      }
                      format.read(file, drawing, false);
                    }
                  }
                }
                return new LinkedList<Figure>(drawing.getChildren());
              }
              @Override
              public void failed(Throwable error) {
                error.printStackTrace();
              }
              @Override
              public void done(final LinkedList<Figure> importedFigures) {
                importedFigures.removeAll(existingFigures);
                if (importedFigures.size() > 0) {
                  view.clearSelection();
                  view.addToSelection(importedFigures);
                  transferFigures.addAll(importedFigures);
                  moveToDropPoint(comp, transferFigures, dropPoint);
                  drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {
                    @Override
                    public String getPresentationName() {
                      ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
                      return labels.getString("edit.paste.text");
                    }
                    @Override
                    public void undo() throws CannotUndoException {
                      super.undo();
                      drawing.removeAll(importedFigures);
                    }
                    @Override
                    public void redo() throws CannotRedoException {
                      super.redo();
                      drawing.addAll(importedFigures);
                    }
                  });
                }
              }
              @Override
              public void finished() {
                view.getEditor().setEnabled(true);
              }
            }.start();
          }
        } catch (Throwable e) {
          if (DEBUG) {
            e.printStackTrace();
          }
        }
      }
    } else {
      retValue = super.importData(comp, t);
    }
    if (DEBUG) {
      System.out.println("DefaultDrawingViewTransferHandler .importData(comp,t):" + retValue);
    }
    return retValue;
###
1367, dragGestureRecognized, DragHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewTransferHandler.java, 629, 655
3
/**
     * a Drag gesture has been recognized
     */
26
    public void dragGestureRecognized(DragGestureEvent dge) {
      JComponent c = (JComponent) dge.getComponent();
      DefaultDrawingViewTransferHandler th = (DefaultDrawingViewTransferHandler) c.getTransferHandler();
      Transferable t = transferable;
      if (t != null) {
        scrolls = c.getAutoscrolls();
        c.setAutoscrolls(false);
        try {
//          dge.startDrag(null, t, this);
          Icon icon = th.getVisualRepresentation(t);
          Image dragImage;
          if (icon instanceof ImageIcon) {
            dragImage = ((ImageIcon) icon).getImage();
          } else {
            dragImage = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_ARGB);
            Graphics g = ((BufferedImage) dragImage).createGraphics();
            icon.paintIcon(c, g, 0, 0);
            g.dispose();
          }
          dge.startDrag(null, dragImage, imageOffset, t, this);
          return;
        } catch (RuntimeException re) {
          c.setAutoscrolls(scrolls);
        }
      }
      th.exportDone(c, t, NONE);
###
1372, findConnector, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 245, 246
5
/**
   * Returns the Figures connector for the specified location.
   * By default a ChopDiamondConnector is returned.
   * @see ChopDiamondConnector
   */
2
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopDiamondConnector(this);
###
1374, DiamondFigure, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 46, 47
1
/** Creates a new instance. */
2
  public DiamondFigure() {
    this(0, 0, 0, 0);
###
1375, transform, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 217, 222
4
/**
   * Moves the Figure to a new location.
   * @param tx the transformation matrix.
   */
6
  public void transform(AffineTransform tx) {
    Point2D.Double anchor = getStartPoint();
    Point2D.Double lead = getEndPoint();
    setBounds(
        (Point2D.Double) tx.transform(anchor, anchor),
        (Point2D.Double) tx.transform(lead, lead));
###
1376, contains, DiamondFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java, 169, 203
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
31
  public boolean contains(Point2D.Double p) {
    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();
    if (get(IS_QUADRATIC)) {
      double side = Math.max(r.width, r.height);
      r.x -= (side - r.width) / 2;
      r.y -= (side - r.height) / 2;
      r.width = r.height = side;
    }
    //   if (r.contains(p)) {
    double grow = AttributeKeys.getPerpendicularFillGrowth(this);
    double growx, growy;
    if (grow == 0d) {
      growx = growy = 0d;
    } else {
      double w = r.width / 2d;
      double h = r.height / 2d;
      double lineLength = Math.sqrt(w * w + h * h);
      double scale = grow / lineLength;
      double yb = scale * w;
      double xa = scale * h;
      growx = ((yb * yb) / xa + xa);
      growy = ((xa * xa) / yb + yb);
      Geom.grow(r, growx, growy);
    }
    Path2D.Double diamond = new Path2D.Double();
    diamond.moveTo((r.x + r.width / 2), r.y);
    diamond.lineTo((r.x + r.width), (r.y + r.height / 2));
    diamond.lineTo((r.x + r.width / 2), (r.y + r.height));
    diamond.lineTo(r.x, (r.y + r.height / 2));
    diamond.closePath();
    return diamond.contains(p);
###
1377, ToolBarLayout, ToolBarLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/ToolBarLayout.java, 46, 47
4
/**
   * Creates a layout manager that will lay out components along the
   * X-axis.  
   */
2
  public ToolBarLayout() {
    this(X_AXIS);
###
1378, AbstractTransferable, AbstractTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AbstractTransferable.java, 29, 30
1
/** Creates a new instance. */
2
  public AbstractTransferable(DataFlavor flavor) {
    this.flavors = new DataFlavor[] {flavor};
###
1379, getDefaultPropertyIndex, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1381, getBeanDescriptor, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1382, getPropertyDescriptors, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1385, getMethodDescriptors, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1386, getDefaultEventIndex, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1387, getEventSetDescriptors, JLifeFormattedTextFieldBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1388, getColumns, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 135, 136
5
/**
   * Gets the number of columns in this layout.
   * @return   the number of columns in this layout
   * @since    JDK1.1
   */
2
  public int getColumns() {
    return cols;
###
1389, VerticalGridLayout, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 89, 97
24
/**
   * Creates a grid layout with the specified number of rows and
   * columns. All components in the layout are given equal size.
   * <p>
   * In addition, the horizontal and vertical gaps are set to the
   * specified values. Horizontal gaps are placed at the left and
   * right edges, and between each of the columns. Vertical gaps are
   * placed at the top and bottom edges, and between each of the rows.
   * <p>
   * One, but not both, of <code>rows</code> and <code>cols</code> can
   * be zero, which means that any number of objects can be placed in a
   * row or in a column.
   * <p>
   * All <code>VerticalGridLayout</code> constructors defer to this one.
   * @param   rows   the rows, with the value zero meaning
   *           any number of rows
   * @param   cols   the columns, with the value zero meaning
   *           any number of columns
   * @param   hgap   the horizontal gap
   * @param   vgap   the vertical gap
   * @exception   IllegalArgumentException  if the value of both
   *      <code>rows</code> and <code>cols</code> is
   *      set to zero
   */
9
  public VerticalGridLayout(int rows, int cols, int hgap, int vgap, boolean isVertical) {
    if ((rows == 0) && (cols == 0)) {
      throw new IllegalArgumentException("rows and cols cannot both be zero");
    }
    this.rows = rows;
    this.cols = cols;
    this.hgap = hgap;
    this.vgap = vgap;
    this.isVertical = isVertical;
###
1390, setRows, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 116, 120
7
/**
   * Sets the number of rows in this layout to the specified value.
   * @param    rows   the number of rows in this layout
   * @exception  IllegalArgumentException  if the value of both
   *         <code>rows</code> and <code>cols</code> is set to zero
   * @since    JDK1.1
   */
5
  public void setRows(int rows) {
    if ((rows == 0) && (this.cols == 0)) {
      throw new IllegalArgumentException("rows and cols cannot both be zero");
    }
    this.rows = rows;
###
1391, minimumLayoutSize, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 274, 299
18
/**
   * Determines the minimum size of the container argument using this
   * grid layout.
   * <p>
   * The minimum width of a grid layout is the largest minimum width
   * of any of the components in the container times the number of columns,
   * plus the horizontal padding times the number of columns plus one,
   * plus the left and right insets of the target container.
   * <p>
   * The minimum height of a grid layout is the largest minimum height
   * of any of the components in the container times the number of rows,
   * plus the vertical padding times the number of rows plus one, plus
   * the top and bottom insets of the target container.
   *
   * @param     parent   the container in which to do the layout
   * @return    the minimum dimensions needed to lay out the
   *            subcomponents of the specified container
   */
26
  public Dimension minimumLayoutSize(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = parent.getComponentCount();
      int nrows = rows;
      int ncols = cols;
      
      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = 0;
      int h = 0;
      for (int i = 0 ; i < ncomponents ; i++) {
        Component comp = parent.getComponent(i);
        Dimension d = comp.getMinimumSize();
        if (w < d.width) {
          w = d.width;
        }
        if (h < d.height) {
          h = d.height;
        }
      }
      return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,
      insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);
###
1393, getRows, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 105, 106
5
/**
   * Gets the number of rows in this layout.
   * @return  the number of rows in this layout
   * @since   JDK1.1
   */
2
  public int getRows() {
    return rows;
###
1394, setColumns, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 151, 155
12
/**
   * Sets the number of columns in this layout to the specified value.
   * Setting the number of columns has no affect on the layout
   * if the number of rows specified by a constructor or by
   * the <tt>setRows</tt> method is non-zero. In that case, the number
   * of columns displayed in the layout is determined by the total
   * number of components and the number of rows specified.
   * @param    cols   the number of columns in this layout
   * @exception  IllegalArgumentException  if the value of both
   *         <code>rows</code> and <code>cols</code> is set to zero
   * @since    JDK1.1
   */
5
  public void setColumns(int cols) {
    if ((cols == 0) && (this.rows == 0)) {
      throw new IllegalArgumentException("rows and cols cannot both be zero");
    }
    this.cols = cols;
###
1395, setVgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 190, 191
5
/**
   * Sets the vertical gap between components to the specified value.
   * @param     vgap  the vertical gap between components
   * @since    JDK1.1
   */
2
  public void setVgap(int vgap) {
    this.vgap = vgap;
###
1396, VerticalGridLayout, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 39, 40
4
/**
   * Creates a grid layout with a default of one column per component,
   * in a single row.
   */
2
  public VerticalGridLayout() {
    this(1, 0, 0, 0);
###
1397, getHgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 163, 164
5
/**
   * Gets the horizontal gap between components.
   * @return     the horizontal gap between components
   * @since    JDK1.1
   */
2
  public int getHgap() {
    return hgap;
###
1398, getVgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 181, 182
5
/**
   * Gets the vertical gap between components.
   * @return     the vertical gap between components
   * @since    JDK1.1
   */
2
  public int getVgap() {
    return vgap;
###
1400, layoutContainer, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 321, 365
18
/**
   * Lays out the specified container using this layout.
   * <p>
   * This method reshapes the components in the specified target
   * container in order to satisfy the constraints of the
   * <code>VerticalGridLayout</code> object.
   * <p>
   * The grid layout manager determines the size of individual
   * components by dividing the free space in the container into
   * equal-sized portions according to the number of rows and columns
   * in the layout. The container's free space equals the container's
   * size minus any insets and any specified horizontal or vertical
   * gap. All components in a grid layout are given the same size.
   *
   * @param    parent   the container in which to do the layout
   * @see    java.awt.Container
   * @see    java.awt.Container#doLayout
   */
45
  public void layoutContainer(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = parent.getComponentCount();
      int nrows = rows;
      int ncols = cols;
      boolean ltr = parent.getComponentOrientation().isLeftToRight();
      
      if (ncomponents == 0) {
        return;
      }
      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = parent.getWidth() - (insets.left + insets.right);
      int h = parent.getHeight() - (insets.top + insets.bottom);
      w = (w - (ncols - 1) * hgap) / ncols;
      h = (h - (nrows - 1) * vgap) / nrows;
      
      int i;
      if (ltr) {
        for (int c = 0, x = insets.left ; c < ncols ; c++, x += w + hgap) {
          for (int r = 0, y = insets.top ; r < nrows ; r++, y += h + vgap) {
            if (isVertical) {
              i = r + c * nrows;
            } else {
              i = r * ncols + c;
            }
            if (i < ncomponents) {
              parent.getComponent(i).setBounds(x, y, w, h);
            }
          }
        }
      } else {
        for (int c = 0, x = parent.getWidth() - insets.right - w; c < ncols ; c++, x -= w + hgap) {
          for (int r = 0, y = insets.top ; r < nrows ; r++, y += h + vgap) {
            if (isVertical) {
              i = r + c * nrows;
            } else {
              i = r * ncols + c;
            }
            if (i < ncomponents) {
              parent.getComponent(i).setBounds(x, y, w, h);
###
1401, setHgap, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 172, 173
5
/**
   * Sets the horizontal gap between components to the specified value.
   * @param    hgap   the horizontal gap between components
   * @since    JDK1.1
   */
2
  public void setHgap(int hgap) {
    this.hgap = hgap;
###
1402, VerticalGridLayout, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 55, 56
12
/**
   * Creates a grid layout with the specified number of rows and
   * columns. All components in the layout are given equal size.
   * <p>
   * One, but not both, of <code>rows</code> and <code>cols</code> can
   * be zero, which means that any number of objects can be placed in a
   * row or in a column.
   * @param   rows   the rows, with the value zero meaning
   *           any number of rows.
   * @param   cols   the columns, with the value zero meaning
   *           any number of columns.
   */
2
  public VerticalGridLayout(int rows, int cols) {
    this(rows, cols, 0, 0);
###
1403, preferredLayoutSize, VerticalGridLayout, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java, 227, 252
18
/**
   * Determines the preferred size of the container argument using
   * this grid layout.
   * <p>
   * The preferred width of a grid layout is the largest preferred
   * width of any of the components in the container times the number of
   * columns, plus the horizontal padding times the number of columns
   * plus one, plus the left and right insets of the target container.
   * <p>
   * The preferred height of a grid layout is the largest preferred
   * height of any of the components in the container times the number of
   * rows, plus the vertical padding times the number of rows plus one,
   * plus the top and bottom insets of the target container.
   *
   * @param   parent   the container in which to do the layout
   * @return  the preferred dimensions to lay out the
   *            subcomponents of the specified container
   */
26
  public Dimension preferredLayoutSize(Container parent) {
    synchronized (parent.getTreeLock()) {
      Insets insets = parent.getInsets();
      int ncomponents = parent.getComponentCount();
      int nrows = rows;
      int ncols = cols;
      
      if (nrows > 0) {
        ncols = (ncomponents + nrows - 1) / nrows;
      } else {
        nrows = (ncomponents + ncols - 1) / ncols;
      }
      int w = 0;
      int h = 0;
      for (int i = 0 ; i < ncomponents ; i++) {
        Component comp = parent.getComponent(i);
        Dimension d = comp.getPreferredSize();
        if (w < d.width) {
          w = d.width;
        }
        if (h < d.height) {
          h = d.height;
        }
      }
      return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,
      insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);
###
1404, getClipboard, ClipboardUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/ClipboardUtil.java, 36, 59
6
/** Returns the ClipboardService instance. If none is set, creates
   * a new one which tries to access the system clipboard. If this fails,
   * an instance with a JVM local clipboard is created.
   *
   * @return system clipboard or a proxy.
   */
20
  @SuppressWarnings("unchecked")
  public static Clipboard getClipboard() {
    if (instance != null) {
      return instance;
    }
    // Try to access the system clipboard
    try {
//      instance = new AWTClipboard(Toolkit.getDefaultToolkit().getSystemClipboard());
      instance = new OSXClipboard(Toolkit.getDefaultToolkit().getSystemClipboard());
    } catch (SecurityException e1) {
      // Fall back to JNLP ClipboardService
      try {
        Class serviceManager = Class.forName("javax.jnlp.ServiceManager");
        instance = new JNLPClipboard(serviceManager.getMethod("lookup", String.class).invoke(null, "javax.jnlp.ClipboardService"));
      } catch (Exception e2) {
        // Fall back to JVM local clipboard
        instance = new AWTClipboard(new Clipboard("JVM Local Clipboard"));
      }
    }
    return instance;
###
1422, getTarget, AWTClipboard, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AWTClipboard.java, 50, 51
1
/** Returns the proxy target. */
2
  public Clipboard getTarget() {
    return target;
###
1423, AWTClipboard, AWTClipboard, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AWTClipboard.java, 45, 46
5
/**
   * Creates a new proxy for the specified target object.
   *
   * @param target A Clipboard object.
   */
2
  public AWTClipboard(Clipboard target) {
    this.target = target;
###
1425, setError, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 127, 128
3
/**
   * Set the error thrown by constrct.
   */
2
  private synchronized void setError(Throwable x) {
    error = x;
###
1426, getError, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 120, 121
4
/**
   * Get the error produced by the worker thread, or null if it
   * hasn't thrown one.
   */
2
  protected synchronized Throwable getError() {
    return error;
###
1428, run, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 36, 54
4
/**
   * Calls #construct on the current thread and invokes
   * #done on the AWT event dispatcher thread.
   */
17
  public final void run() {
    try {
      setValue(construct());
    } catch (Throwable e) {
      setError(e);
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          failed(getError());
          finished();
        }
      });
      return;
    }
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        done(getValue());
        finished();
###
1429, getValue, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 105, 106
4
/**
   * Get the value produced by the worker thread, or null if it
   * hasn't been constructed yet.
   */
2
  protected synchronized T getValue() {
    return value;
###
1430, failed, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 86, 87
9
/**
   * Called on the event dispatching thread (not on the worker thread)
   * after the <code>construct</code> method has thrown an error.
   * <p>
   * The default implementation prints a stack trace. Subclasses may override
   * this method to perform failure actions on the Event Dispatch Thread.
   *
   * @param error The error thrown by construct.
   */
2
  protected void failed(Throwable error) {
    error.printStackTrace();
###
1432, setValue, Worker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java, 112, 113
3
/**
   * Set the value produced by construct.
   */
2
  private synchronized void setValue(T x) {
    value = x;
###
1433, getTransferData, CompositeTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/CompositeTransferable.java, 53, 56
11
/**
   * Returns an object which represents the data to be transferred.  The class
   * of the object returned is defined by the representation class of the flavor.
   *
   * @param flavor the requested flavor for the data
   * @see DataFlavor#getRepresentationClass
   * @exception IOException        if the data is no longer available
   *       in the requested flavor.
   * @exception UnsupportedFlavorException if the requested data flavor is
   *       not supported.
   */
4
  public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
    Transferable t = (Transferable) transferables.get(flavor);
    if (t == null) throw new UnsupportedFlavorException(flavor);
    return t.getTransferData(flavor);
###
1435, getTransferDataFlavors, CompositeTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/CompositeTransferable.java, 65, 66
6
/**
   * Returns an array of DataFlavor objects indicating the flavors the data
   * can be provided in.  The array should be ordered according to preference
   * for providing the data (from most richly descriptive to least descriptive).
   * @return an array of data flavors in which this data can be transferred
   */
2
  public DataFlavor[] getTransferDataFlavors() {
    return (DataFlavor[]) flavors.toArray(new DataFlavor[transferables.size()]);
###
1437, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 530, 542
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
13
  protected void fireOptionSelected(JOptionPane pane, int option, Object value, Object inputValue) {
    SheetEvent sheetEvent = null;
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == SheetListener.class) {
        // Lazily create the event:
        if (sheetEvent == null) {
          sheetEvent = new SheetEvent(this, pane, option, value, inputValue);
        }
        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);
###
1438, JSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 117, 119
3
/**
   * Creates a new JSheet.
   */
3
  public JSheet(Dialog owner) {
    super(owner);
    init();
###
1439, isDocumentModalitySupported, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 297, 298
4
/**
   * If this returns true, the JSheet uses native support for
   * sheet display.
   */
2
  private static boolean isDocumentModalitySupported() {
    return isDocumentModalitySupported;
###
1440, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 883, 885
17
/**
   * Brings up a sheet that displays a message using a default
   * icon determined by the <code>messageType</code> parameter.
   *
   * @param parentComponent determines the <code>Frame</code>
   *    in which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param listener This listener is notified when the sheet is dismissed.
   */
3
  public static void showMessageSheet(Component parentComponent,
      Object message, int messageType, SheetListener listener) {
    showMessageSheet(parentComponent, message, messageType, null, listener);
###
1441, isNativeSheetSupported, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 289, 290
4
/**
   * If this returns true, the JSheet uses native support for
   * sheet display.
   */
2
  private static boolean isNativeSheetSupported() {
    return isNativeSheetSupported;
###
1442, showOptionSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 956, 972
44
/**
   * Brings up a sheet with a specified icon, where the initial
   * choice is determined by the <code>initialValue</code> parameter and
   * the number of choices is determined by the <code>optionType</code>
   * parameter.
   * <p>
   * If <code>optionType</code> is <code>YES_NO_OPTION</code>,
   * or <code>YES_NO_CANCEL_OPTION</code>
   * and the <code>options</code> parameter is <code>null</code>,
   * then the options are
   * supplied by the look and feel.
   * <p>
   * The <code>messageType</code> parameter is primarily used to supply
   * a default icon from the look and feel.
   *
   * @param parentComponent determines the <code>Frame</code>
   *      in which the dialog is displayed;  if
   *          <code>null</code>, or if the
   *      <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param optionType an integer designating the options available on the
   *      dialog: <code>YES_NO_OPTION</code>,
   *      or <code>YES_NO_CANCEL_OPTION</code>
   * @param messageType an integer designating the kind of message this is,
   *          primarily used to determine the icon from the
   *      pluggable Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *          <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon    the icon to display in the dialog
   * @param options   an array of objects indicating the possible choices
   *          the user can make; if the objects are components, they
   *          are rendered properly; non-<code>String</code>
   *      objects are
   *          rendered using their <code>toString</code> methods;
   *          if this parameter is <code>null</code>,
   *      the options are determined by the Look and Feel
   * @param initialValue the object that represents the default selection
   *          for the dialog; only meaningful if <code>options</code>
   *      is used; can be <code>null</code>
   * @param listener The listener for SheetEvents.
   */
14
  public static void showOptionSheet(Component parentComponent,
      Object message, int optionType, int messageType,
      Icon icon, Object[] options, Object initialValue, SheetListener listener) {
    JOptionPane pane = new JOptionPane(message, messageType,
        optionType, icon,
        options, initialValue);
    pane.setInitialValue(initialValue);
    pane.setComponentOrientation(((parentComponent == null) ? JOptionPane.getRootFrame() : parentComponent).getComponentOrientation());
    int style = styleFromMessageType(messageType);
    JSheet sheet = createSheet(pane, parentComponent, style);
    pane.selectInitialValue();
    sheet.addSheetListener(listener);
    sheet.show();
    sheet.toFront();
###
1443, isAnimated, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 281, 282
4
/**
   * If this returns true, the JSheet uses a transition effect when shown
   * and when hidden.
   */
2
  public boolean isAnimated() {
    return isAnimated;
###
1444, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 861, 863
16
/**
   * Brings up a sheet that displays a message using a default
   * icon determined by the <code>messageType</code> parameter.
   *
   * @param parentComponent determines the <code>Frame</code>
   *    in which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   */
3
  public static void showMessageSheet(Component parentComponent,
      Object message, int messageType) {
    showMessageSheet(parentComponent, message, messageType, null, null);
###
1445, uninstallSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 237, 256
4
/**
   * Uninstalls the sheet on the owner.
   * This method is invoked immediately after the JSheet is hidden.
   */
19
  protected void uninstallSheet() {
    if (isInstalled) {
      Window owner = getOwner();
      if (owner != null) {
        // Note: We mustn't change the windows focusable state because
        // this also affects the focusable state of the JSheet.
        //owner.setFocusableWindowState(true);
        owner.setEnabled(true);
        //((JFrame) owner).setResizable(true);
        owner.removeComponentListener(ownerMovementHandler);
        if (shiftBackLocation != null) {
          owner.setLocation(shiftBackLocation);
        }
        if (oldFocusOwner != null) {
          owner.toFront();
          oldFocusOwner.requestFocus();
        }
      }
      isInstalled = false;
###
1446, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 839, 842
10
/**
   * Brings up an information-message sheet.
   *
   * @param parentComponent determines the <code>Frame</code> in
   *    which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param listener This listener is notified when the sheet is dismissed.
   */
4
  public static void showMessageSheet(Component parentComponent,
      Object message, SheetListener listener) {
    showMessageSheet(parentComponent, message,
        JOptionPane.INFORMATION_MESSAGE, listener);
###
1447, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 616, 618
11
/**
   * Brings up a sheet with the options <i>Yes</i>,
   * <i>No</i> and <i>Cancel</i>.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      sheet is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param listener The listener for SheetEvents.
   */
3
  public static void showConfirmSheet(Component parentComponent, Object message, SheetListener listener) {
    showConfirmSheet(parentComponent, message,
        JOptionPane.YES_NO_CANCEL_OPTION, listener);
###
1448, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 750, 753
15
/**
   * Shows a sheet requesting input from the user parented to
   * <code>parentComponent</code> and message type <code>messageType</code>.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *      dialog
   * @param message  the <code>Object</code> to display
   * @param messageType the type of message that is to be displayed:
   *           <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *           <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param listener The listener for SheetEvents.
   */
4
  public static void showInputSheet(Component parentComponent,
      Object message, int messageType, SheetListener listener) {
    showInputSheet(parentComponent, message,
        messageType, null, null, null, listener);
###
1449, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 553, 565
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
13
  protected void fireOptionSelected(JFileChooser pane, int option) {
    SheetEvent sheetEvent = null;
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == SheetListener.class) {
        // Lazily create the event:
        if (sheetEvent == null) {
          sheetEvent = new SheetEvent(this, pane, option, null);
        }
        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);
###
1450, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 493, 521
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
27
  protected void fireOptionSelected(JOptionPane pane) {
    Object value = pane.getValue();
    int option;
    if (value == null) {
      option = JOptionPane.CLOSED_OPTION;
    } else {
      if (pane.getOptions() == null) {
        if (value instanceof Integer) {
          option = ((Integer) value).intValue();
        } else {
          option = JOptionPane.CLOSED_OPTION;
        }
      } else {
        option = JOptionPane.CLOSED_OPTION;
        Object[] options = pane.getOptions();
        for (int i = 0, n = options.length; i < n; i++) {
          if (options[i].equals(value)) {
            option = i;
            break;
          }
        }
        if (option == JOptionPane.CLOSED_OPTION) {
          value = null;
        }
      }
    }
    fireOptionSelected(pane, option, value, pane.getInputValue());
###
1451, showSaveSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1100, 1102
9
/**
   * Displays a "Save File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showSaveSheet(JFileChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.SAVE_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1452, showOpenSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1114, 1116
9
/**
   * Displays an "Open File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showOpenSheet(JFileChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.OPEN_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1453, installSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 165, 229
4
/**
   * Installs the sheet on the owner.
   * This method is invoked just before the JSheet is shown.
   */
61
  protected void installSheet() {
    if (!isNativeSheetSupported() && !isInstalled) {
      Window owner = getOwner();
      if (owner != null) {
        // Determine the location for the sheet and its owner while
        // the sheet will be visible.
        // In case we have to shift the owner to fully display the
        // dialog, we remember the shift back position.
        Point ownerLoc = owner.getLocation();
        Point sheetLoc;
        if (isShowAsSheet()) {
          if (owner instanceof JFrame) {
            sheetLoc = new Point(
                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
                ownerLoc.y + owner.getInsets().top + ((JFrame) owner).getRootPane().getContentPane().getY());
          } else if (owner instanceof JDialog) {
            sheetLoc = new Point(
                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
                ownerLoc.y + owner.getInsets().top + ((JDialog) owner).getRootPane().getContentPane().getY());
          } else {
            sheetLoc = new Point(
                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
                ownerLoc.y + owner.getInsets().top);
          }
          if (sheetLoc.x < 0) {
            owner.setLocation(ownerLoc.x - sheetLoc.x, ownerLoc.y);
            sheetLoc.x = 0;
            shiftBackLocation = ownerLoc;
            oldLocation = owner.getLocation();
          } else {
            shiftBackLocation = null;
            oldLocation = ownerLoc;
          }
        } else {
          sheetLoc = new Point(
              ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
              ownerLoc.y + (owner.getHeight() - getHeight()) / 3);
        }
        setLocation(sheetLoc);
        oldFocusOwner = owner.getFocusOwner();
        // Note: We mustn't change the windows focusable state because
        // this also affects the focusable state of the JSheet.
        //owner.setFocusableWindowState(false);
        owner.setEnabled(false);
        // ((JFrame) owner).setResizable(false);
        if (isShowAsSheet()) {
          owner.addComponentListener(ownerMovementHandler);
        } else {
          if (owner instanceof Frame) {
            setTitle(((Frame) owner).getTitle());
          }
        }
      }
      isInstalled = true;
    } else {
      Window owner = getOwner();
      Point ownerLoc = owner.getLocation();
      Point sheetLoc = new Point(
          ownerLoc.x + (owner.getWidth() - getWidth()) / 2,
          ownerLoc.y + (owner.getHeight() - getHeight()) / 3);
        setLocation(sheetLoc);
###
1454, showSaveSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1128, 1130
9
/**
   * Displays a "Save File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showSaveSheet(URIChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.SAVE_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1455, showSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1212, 1261
8
/**
   * Displays a custom file chooser sheet with a custom approve button.
   *
   * @param   parent  the parent component of the dialog;
   *      can be <code>null</code>
   * @param   approveButtonText the text of the <code>ApproveButton</code>
   * @param listener The listener for SheetEvents.
   */
43
  public static void showSheet(final URIChooser chooser, Component parent,
      String approveButtonText, SheetListener listener) {
    if (approveButtonText != null) {
      chooser.setApproveButtonText(approveButtonText);
      chooser.setDialogType(URIChooser.CUSTOM_DIALOG);
    }
    // Begin Create Dialog
    Frame frame = parent instanceof Frame ? (Frame) parent
        : (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parent);
    if (chooser instanceof JFileChooser) {
    String title = ((JFileChooser) chooser).getUI().getDialogTitle((JFileChooser) chooser);
    ((JFileChooser) chooser).getAccessibleContext().setAccessibleDescription(title);
    }
    final JSheet sheet = new JSheet(frame);
    sheet.addSheetListener(listener);
    Container contentPane = sheet.getContentPane();
    contentPane.setLayout(new BorderLayout());
    contentPane.add(chooser.getComponent(), BorderLayout.CENTER);
    // End Create Dialog
    final ActionListener actionListener = new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        int option;
        if (evt.getActionCommand().equals("ApproveSelection")) {
          option = JFileChooser.APPROVE_OPTION;
        } else {
          option = JFileChooser.CANCEL_OPTION;
        }
        sheet.hide();
        sheet.fireOptionSelected(chooser, option);
        chooser.removeActionListener(this);
      }
    };
    chooser.addActionListener(actionListener);
    sheet.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        sheet.fireOptionSelected(chooser, JFileChooser.CANCEL_OPTION);
        chooser.removeActionListener(actionListener);
      }
    });
    chooser.rescanCurrentDirectory();
    sheet.pack();
    sheet.show();
    sheet.toFront();
###
1456, setAnimated, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 271, 274
7
/**
   * If this is set to true, the JSheet uses a transition effect when shown
   * and when hidden.
   */
 --------------
// QuaquaUtilities.setWindowAlpha(this, 240);
 --------------
4
  public void setAnimated(boolean newValue) {
    boolean oldValue = isAnimated;
    isAnimated = newValue;
    firePropertyChange("animated", oldValue, newValue);
###
1457, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 696, 700
24
/**
   * Brings up a sheet with a specified icon, where the number of
   * choices is determined by the <code>optionType</code> parameter.
   * The <code>messageType</code> parameter is primarily used to supply
   * a default icon from the look and feel.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      dialog is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the Object to display
   * @param optionType an int designating the options available on the dialog:
   *          <code>YES_NO_OPTION</code>,
   *      or <code>YES_NO_CANCEL_OPTION</code>
   * @param messageType an int designating the kind of message this is,
   *          primarily used to determine the icon from the pluggable
   *          Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *          <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon    the icon to display in the dialog
   * @param listener The listener for SheetEvents.
   */
5
  public static void showConfirmSheet(Component parentComponent,
      Object message, int optionType,
      int messageType, Icon icon, SheetListener listener) {
    showOptionSheet(parentComponent, message, optionType,
        messageType, icon, null, null, listener);
###
1458, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 711, 713
8
/**
   * Shows a question-message sheet requesting input from the user
   * parented to <code>parentComponent</code>.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *    dialog
   * @param listener The listener for SheetEvents.
   */
3
  public static void showInputSheet(Component parentComponent,
      Object message, SheetListener listener) {
    showInputSheet(parentComponent, message, JOptionPane.QUESTION_MESSAGE, listener);
###
1459, fireOptionSelected, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 575, 587
6
/**
   * Notify all listeners that have registered interest for
   *   notification on this event type.  The event instance
   *   is lazily created using the parameters passed into
   *   the fire method.
   */
13
  protected void fireOptionSelected(URIChooser pane, int option) {
    SheetEvent sheetEvent = null;
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == SheetListener.class) {
        // Lazily create the event:
        if (sheetEvent == null) {
          sheetEvent = new SheetEvent(this, pane, option, null);
        }
        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);
###
1460, removeSheetListener, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 483, 484
3
/**
   * Removes a sheet listener.
   */
2
  public void removeSheetListener(SheetListener l) {
    listenerList.remove(SheetListener.class, l);
###
1461, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 635, 638
14
/**
   * Brings up a sheet where the number of choices is determined
   * by the <code>optionType</code> parameter.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      sheet is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param optionType an int designating the options available on the dialog:
   *          <code>YES_NO_OPTION</code>, or
   *      <code>YES_NO_CANCEL_OPTION</code>
   * @param listener The listener for SheetEvents.
   */
4
  public static void showConfirmSheet(Component parentComponent,
      Object message, int optionType, SheetListener listener) {
    showConfirmSheet(parentComponent, message, optionType,
        JOptionPane.QUESTION_MESSAGE, listener);
###
1462, JSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 109, 111
3
/**
   * Creates a new JSheet.
   */
3
  public JSheet(Frame owner) {
    super(owner);
    init();
###
1464, showConfirmSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 666, 669
25
/**
   * Brings up a sheet where the number of choices is determined
   * by the <code>optionType</code> parameter, where the
   * <code>messageType</code>
   * parameter determines the icon to display.
   * The <code>messageType</code> parameter is primarily used to supply
   * a default icon from the Look and Feel.
   *
   * @param parentComponent determines the <code>Frame</code> in
   *      which the dialog is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param optionType an integer designating the options available
   *      on the dialog: <code>YES_NO_OPTION</code>,
   *      or <code>YES_NO_CANCEL_OPTION</code>
   * @param messageType an integer designating the kind of message this is;
   *          primarily used to determine the icon from the pluggable
   *          Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *          <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param listener The listener for SheetEvents.
   */
4
  public static void showConfirmSheet(Component parentComponent,
      Object message, int optionType, int messageType, SheetListener listener) {
    showConfirmSheet(parentComponent, message, optionType,
        messageType, null, listener);
###
1465, showSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1155, 1202
8
/**
   * Displays a custom file chooser sheet with a custom approve button.
   *
   * @param   parent  the parent component of the dialog;
   *      can be <code>null</code>
   * @param   approveButtonText the text of the <code>ApproveButton</code>
   * @param listener The listener for SheetEvents.
   */
41
  public static void showSheet(final JFileChooser chooser, Component parent,
      String approveButtonText, SheetListener listener) {
    if (approveButtonText != null) {
      chooser.setApproveButtonText(approveButtonText);
      chooser.setDialogType(JFileChooser.CUSTOM_DIALOG);
    }
    // Begin Create Dialog
    Frame frame = parent instanceof Frame ? (Frame) parent
        : (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parent);
    String title = chooser.getUI().getDialogTitle(chooser);
    chooser.getAccessibleContext().setAccessibleDescription(title);
    final JSheet sheet = new JSheet(frame);
    sheet.addSheetListener(listener);
    Container contentPane = sheet.getContentPane();
    contentPane.setLayout(new BorderLayout());
    contentPane.add(chooser, BorderLayout.CENTER);
    // End Create Dialog
    final ActionListener actionListener = new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        int option;
        if (evt.getActionCommand().equals("ApproveSelection")) {
          option = JFileChooser.APPROVE_OPTION;
        } else {
          option = JFileChooser.CANCEL_OPTION;
        }
        sheet.hide();
        sheet.fireOptionSelected(chooser, option);
        chooser.removeActionListener(this);
      }
    };
    chooser.addActionListener(actionListener);
    sheet.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        sheet.fireOptionSelected(chooser, JFileChooser.CANCEL_OPTION);
        chooser.removeActionListener(actionListener);
      }
    });
    chooser.rescanCurrentDirectory();
    sheet.pack();
    sheet.show();
    sheet.toFront();
###
1466, showSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 599, 602
7
/**
   * Displays an option pane as a sheet on its parent window.
   *
   * @param pane The option pane.
   * @param parentComponent The parent of the option pane.
   * @param listener The listener for SheetEvents.
   */
4
  public static void showSheet(JOptionPane pane, Component parentComponent, SheetListener listener) {
    final JSheet sheet = createSheet(pane, parentComponent, styleFromMessageType(pane.getMessageType()));
    sheet.addSheetListener(listener);
    sheet.show();
###
1467, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 906, 909
18
/**
   * Brings up a sheet displaying a message, specifying all parameters.
   *
   * @param parentComponent determines the <code>Frame</code> in which the
   *      sheet is displayed; if <code>null</code>,
   *      or if the <code>parentComponent</code> has no
   *      <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon    an icon to display in the sheet that helps the user
   *          identify the kind of message that is being displayed
   * @param listener This listener is notified when the sheet is dismissed.
   */
4
  public static void showMessageSheet(Component parentComponent,
      Object message, int messageType, Icon icon, SheetListener listener) {
    showOptionSheet(parentComponent, message, JOptionPane.DEFAULT_OPTION,
        messageType, icon, null, null, listener);
###
1468, getWindowForComponent, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1081, 1088
12
/**
   * Returns the specified component's toplevel <code>Frame</code> or
   * <code>Dialog</code>.
   *
   * @param parentComponent the <code>Component</code> to check for a
   *    <code>Frame</code> or <code>Dialog</code>
   * @return the <code>Frame</code> or <code>Dialog</code> that
   *    contains the component, or the default
   *       frame if the component is <code>null</code>,
   *    or does not have a valid
   *       <code>Frame</code> or <code>Dialog</code> parent
   */
8
  static Window getWindowForComponent(Component parentComponent) {
    if (parentComponent == null) {
      return JOptionPane.getRootFrame();
    }
    if (parentComponent instanceof Frame || parentComponent instanceof Dialog) {
      return (Window) parentComponent;
    }
    return getWindowForComponent(parentComponent.getParent());
###
1469, showOpenSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 1142, 1144
9
/**
   * Displays an "Open File" file chooser sheet. Note that the
   * text that appears in the approve button is determined by
   * the L&F.
   *
   * @param  parent  the parent component of the dialog,
   *      can be <code>null</code>.
   * @param listener The listener for SheetEvents.
   */
3
  public static void showOpenSheet(URIChooser chooser, Component parent, SheetListener listener) {
    chooser.setDialogType(JFileChooser.OPEN_DIALOG);
    showSheet(chooser, parent, null, listener);
###
1470, addSheetListener, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 476, 477
3
/**
   * Adds a sheet listener.
   */
2
  public void addSheetListener(SheetListener l) {
    listenerList.add(SheetListener.class, l);
###
1471, showMessageSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 823, 826
9
/**
   * Brings up an information-message sheet.
   *
   * @param parentComponent determines the <code>Frame</code> in
   *    which the dialog is displayed; if <code>null</code>,
   *    or if the <code>parentComponent</code> has no
   *    <code>Frame</code>, the sheet is displayed as a dialog.
   * @param message   the <code>Object</code> to display
   */
4
  public static void showMessageSheet(Component parentComponent,
      Object message) {
    showMessageSheet(parentComponent, message,
        JOptionPane.INFORMATION_MESSAGE);
###
1472, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 728, 732
12
/**
   * Shows a question-message sheet requesting input from the user and
   * parented to <code>parentComponent</code>. The input value will be
   * initialized to <code>initialSelectionValue</code>.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *    dialog
   * @param message the <code>Object</code> to display
   * @param initialSelectionValue the value used to initialize the input
   *         field
   * @param listener The listener for SheetEvents.
   */
5
  public static void showInputSheet(Component parentComponent, Object message,
      Object initialSelectionValue, SheetListener listener) {
    showInputSheet(parentComponent, message,
        JOptionPane.QUESTION_MESSAGE, null, null,
        initialSelectionValue, listener);
###
1473, showInputSheet, JSheet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java, 785, 811
29
/**
   * Prompts the user for input in a sheet where the
   * initial selection, possible selections, and all other options can
   * be specified. The user will able to choose from
   * <code>selectionValues</code>, where <code>null</code> implies the
   * user can input
   * whatever they wish, usually by means of a <code>JTextField</code>.
   * <code>initialSelectionValue</code> is the initial value to prompt
   * the user with. It is up to the UI to decide how best to represent
   * the <code>selectionValues</code>, but usually a
   * <code>JComboBox</code>, <code>JList</code>, or
   * <code>JTextField</code> will be used.
   *
   * @param parentComponent  the parent <code>Component</code> for the
   *      dialog
   * @param message  the <code>Object</code> to display
   * @param messageType the type of message to be displayed:
   *          <code>JOptionPane.ERROR_MESSAGE</code>,
   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,
   *      <code>JOptionPane.WARNING_MESSAGE</code>,
   *          <code>JOptionPane.QUESTION_MESSAGE</code>,
   *      or <code>JOptionPane.PLAIN_MESSAGE</code>
   * @param icon   the <code>Icon</code> image to display
   * @param selectionValues an array of <code>Object</code>s that
   *      gives the possible selections
   * @param initialSelectionValue the value used to initialize the input
   *         field
   * @param listener The listener for SheetEvents.
   */
22
  public static void showInputSheet(Component parentComponent,
      Object message, int messageType, Icon icon,
      Object[] selectionValues, Object initialSelectionValue, SheetListener listener) {
    JOptionPane pane = new JOptionPane(message, messageType,
        JOptionPane.OK_CANCEL_OPTION, icon,
        null, null);
    pane.setWantsInput(true);
    pane.setSelectionValues(selectionValues);
    pane.setInitialSelectionValue(initialSelectionValue);
    pane.setComponentOrientation(((parentComponent == null) ? JOptionPane.getRootFrame() : parentComponent).getComponentOrientation());
    int style = styleFromMessageType(messageType);
    JSheet sheet = createSheet(pane, parentComponent, style);
    pane.selectInitialValue();
    /*
    sheet.addWindowListener(new WindowAdapter() {
    public void windowClosed(WindowEvent evt) {
    sheet.dispose();
    }
    });*/
    sheet.addSheetListener(listener);
    sheet.show();
    sheet.toFront();
###
1477, updateText, JLifeFormattedTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java, 125, 144
3
/**
   * Updates the text of the field from the value.
   */
20
  protected void updateText() {
    if (updatingDepth++ == 0) {
      if (getFormatter() != null) {
        try {
          String newText = getFormatter().valueToString(getValue());
          setText(newText);
          if (!isFocusOwner()) {
            // This is like selectAll(), but we set the
            // cursor at the start of the field, because
            // the start of the field contains the most
            // significant part of the field content.
            setCaretPosition(getDocument().getLength());
            moveCaretPosition(0);
          }
        } catch (ParseException ex) {
          //ex.printStackTrace(); do nothing
        }
      }
    }
    updatingDepth--;
###
1478, updateValue, JLifeFormattedTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java, 108, 119
3
/**
   * Updates the value from the text of the field.
   */
12
  protected void updateValue() {
    if (updatingDepth++ == 0) {
      if (getFormatter() != null) {
        try {
          Object newValue = getFormatter().stringToValue(getText());
          setValue(newValue);
        } catch (ParseException ex) {
          //ex.printStackTrace();// do nothing
        }
      }
    }
    updatingDepth--;
###
1479, getDefaultFormatterFactory, JLifeFormattedTextField, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java, 151, 181
4
/**
   * Returns an AbstractFormatterFactory suitable for the passed in
   * Object type.
   */
25
  private AbstractFormatterFactory getDefaultFormatterFactory(Object type) {
    if (type instanceof DateFormat) {
      return new DefaultFormatterFactory(new DateFormatter((DateFormat) type));
    }
    if (type instanceof NumberFormat) {
      return new DefaultFormatterFactory(new NumberFormatter(
          (NumberFormat) type));
    }
    if (type instanceof Format) {
      return new DefaultFormatterFactory(new InternationalFormatter(
          (Format) type));
    }
    if (type instanceof Date) {
      return new DefaultFormatterFactory(new DateFormatter());
    }
    if (type instanceof Number) {
      AbstractFormatter displayFormatter = new NumberFormatter();
      ((NumberFormatter) displayFormatter).setValueClass(type.getClass());
      AbstractFormatter editFormatter = new NumberFormatter(
          new DecimalFormat("#.#"));
      ((NumberFormatter) editFormatter).setValueClass(type.getClass());
      return new DefaultFormatterFactory(displayFormatter,
          displayFormatter, editFormatter);
    }
    return new DefaultFormatterFactory(new DefaultFormatter());
###
1480, arrangeFramesVertically, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 163, 212
5
/**
   * Arranges the frames as efficiently as possibly with preference for
   * keeping vertical size maximal.<br>
   *
   */
50
  public void arrangeFramesVertically() {
    Component[] allFrames = getAllFrames();
    // do nothing if no frames to work with
    if (allFrames.length == 0) {
      return;
    }
    
    manager.setNormalSize();
    
    int vertFrames = (int)Math.floor(Math.sqrt(allFrames.length));
    int horFrames = (int)Math.ceil(Math.sqrt(allFrames.length));
    
    // first arrange the windows that have equal size
    int frameWidth = getBounds().width / horFrames;
    int frameHeight = getBounds().height / vertFrames;
    int x = 0;
    int y = 0;
    int frameIdx = 0;
    for (int horCnt = 0; horCnt < horFrames-1; horCnt++) {
      y = 0;
      for (int vertCnt = 0; vertCnt < vertFrames; vertCnt++) {
        try {
          ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
        } catch (PropertyVetoException e) {
          e.printStackTrace();
        }
        
        allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
        frameIdx++;
        y = y + frameHeight;
      }
      x = x + frameWidth;
    }
    
    // the rest of the frames are tiled down on the last column with equal
    // height
    frameHeight = getBounds().height / (allFrames.length - frameIdx);
    y = 0;
    for (; frameIdx < allFrames.length; frameIdx++) {
      try {
        ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
      } catch (PropertyVetoException e) {
        e.printStackTrace();
      }
      
      allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
      y = y + frameHeight;
    }
    
    checkDesktopSize();
###
1481, arrangeFramesHorizontally, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 220, 269
5
/**
   * Arranges the frames as efficiently as possibly with preference for
   * keeping horizontal size maximal.<br>
   *
   */
50
  public void arrangeFramesHorizontally() {
    Component[] allFrames = getAllFrames();
    // do nothing if no frames to work with
    if (allFrames.length == 0) {
      return;
    }
    
    manager.setNormalSize();
    
    int vertFrames = (int)Math.ceil(Math.sqrt(allFrames.length));
    int horFrames = (int)Math.floor(Math.sqrt(allFrames.length));
    
    // first arrange the windows that have equal size
    int frameWidth = getBounds().width / horFrames;
    int frameHeight = getBounds().height / vertFrames;
    int x = 0;
    int y = 0;
    int frameIdx = 0;
    for (int vertCnt = 0; vertCnt < vertFrames-1; vertCnt++) {
      x = 0;
      for (int horCnt = 0; horCnt < horFrames; horCnt++) {
        try {
          ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
        } catch (PropertyVetoException e) {
          e.printStackTrace();
        }
        
        allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
        frameIdx++;
        x = x + frameWidth;
      }
      y = y + frameHeight;
    }
    
    // the rest of the frames are tiled down on the last column with equal
    // height
    frameWidth = getBounds().width / (allFrames.length - frameIdx);
    x = 0;
    for (; frameIdx < allFrames.length; frameIdx++) {
      try {
        ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);
      } catch (PropertyVetoException e) {
        e.printStackTrace();
      }
      
      allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);
      x = x + frameWidth;
    }
    
    checkDesktopSize();
###
1482, setAllSize, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 276, 280
4
/**
   * Sets all component size properties ( maximum, minimum, preferred)
   * to the given dimension.
   */
5
  public void setAllSize(Dimension d) {
    setMinimumSize(d);
    setMaximumSize(d);
    setPreferredSize(d);
    setBounds(0, 0, d.width, d.height);
###
1483, arrangeFramesCascading, JMDIDesktopPane, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java, 73, 104
3
/**
   * Cascade all internal frames
   */
32
  private void arrangeFramesCascading() {
    JInternalFrame[] allFrames = getAllFrames();
    
    // do nothing if no frames to work with
    if (allFrames.length == 0) {
      return;
    }
    
    manager.setNormalSize();
    Insets insets = getInsets();
    int x = insets.left;
    int y = insets.top;
    int frameOffset=0;
    for (int i = allFrames.length - 1; i >= 0; i--) {
      Point p=SwingUtilities.convertPoint(allFrames[i].getContentPane(),0,0,allFrames[i]);
      frameOffset=Math.max(frameOffset,Math.max(p.x,p.y));
    }
    int frameHeight = (getBounds().height-insets.top-insets.bottom) - allFrames.length * frameOffset;
    int frameWidth = (getBounds().width-insets.left-insets.right) - allFrames.length * frameOffset;
    for (int i = allFrames.length - 1; i >= 0; i--) {
      try {
        allFrames[i].setMaximum(false);
      } catch (PropertyVetoException e) {
        e.printStackTrace();
      }
      
      allFrames[i].setBounds(x, y, frameWidth, frameHeight);
      x = x + frameOffset;
      y = y + frameOffset;
    }
    
    checkDesktopSize();
###
1501, JPopupButton, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 51, 54
1
/** Creates new form JToolBarMenu */
4
  public JPopupButton() {
    initComponents();
    setFocusable(false);
    itemFont = ITEM_FONT;
###
1503, setPopupAnchor, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 164, 165
12
/**
   * Sets the popup anchor.
   * <p>
   * <ul>
   * <li>SOUTH_WEST places the popup below the button and aligns it with its 
   * left bound.</li>
   * <li>SOUTH_EAST places the popup below the button and aligns it with its 
   * right bound.</li>
   * </ul> 
   * 
   * @param newValue SwingConstants.SOUTH_WEST or SOUTH_EAST.
   */
2
  public void setPopupAnchor(int newValue) {
    popupAnchor = newValue;
###
1505, getPopupAnchor, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 148, 149
5
/**
   * Gets the popup anchor.
   * 
   * @return SwingConstants.SOUTH_WEST or SOUTH_EAST.
   */
2
  public int getPopupAnchor() {
    return popupAnchor;
###
1510, initComponents, JPopupButton, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java, 212, 219
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
7
  private void initComponents() {
    addMouseListener(new java.awt.event.MouseAdapter() {
      public void mousePressed(java.awt.event.MouseEvent evt) {
        handleMousePressed(evt);
      }
      public void mouseReleased(java.awt.event.MouseEvent evt) {
        performAction(evt);
###
1534, getSelectionPath, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 282, 283
6
/**
   * Gets the selected Font.
   * This is a bound property.
   * 
   * @return The selected font, or null, if no font is selected.
   */
2
  public TreePath getSelectionPath() {
    return selectionPath;
###
1535, addActionListener, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 229, 230
8
/**
   * Adds an <code>ActionListener</code> to the font chooser.
   *
   * @param l  the listener to be added
   * 
   * @see #approveSelection
   * @see #cancelSelection
   */
2
  public void addActionListener(ActionListener l) {
    listenerList.add(ActionListener.class, l);
###
1536, setSelectedFont, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 377, 381
12
/**
   * Sets the selected Font.
   * <p>
   * Changing the selected font, causes a change of the
   * selection path, if the selected font is not the last
   * path segment of the selection path.
   * 
   * This is a bound property.
   * 
   * @param newValue The new selected font, or null if no font is to be
   * selected.
   */
5
  public void setSelectedFont(Font newValue) {
    Font oldValue = selectedFont;
    this.selectedFont = newValue;
    firePropertyChange(SELECTED_FONT_PROPERTY, oldValue, newValue);
    updateSelectionPath(newValue);
###
1537, setSelectionPath, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 297, 302
11
/**
   * Sets the selected Font.
   * This is a bound property.
   * <p>
   * Changing the selection path, causes a change of the
   * selected font, if the selected font is not the last
   * path segment of the selection path.
   * 
   * @param newValue The new selected font, or null if no font is to be
   * selected..
   */
6
  public void setSelectionPath(TreePath newValue) {
    TreePath oldValue = selectionPath;
    this.selectionPath = newValue;
    firePropertyChange(SELECTION_PATH_PROPERTY, oldValue, newValue);
    if (selectionPath != null && selectionPath.getPathCount() == 4) {
      setSelectedFont(((FontFaceNode) selectionPath.getLastPathComponent()).getFont());
###
1538, LabelFigure, LabelFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabelFigure.java, 40, 41
1
/** Creates a new instance. */
2
  public LabelFigure() {
    this("Label");
###
1539, cancelSelection, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 213, 218
9
/**
   * Called by the UI when the user chooses the Cancel button.
   * This can also be called by the programmer.
   * This method causes an action event to fire
   * with the command string equal to
   * <code>CANCEL_SELECTION</code>.
   *
   * @see #CANCEL_SELECTION
   */
6
  public void cancelSelection() {
    returnValue = CANCEL_OPTION;
    if (dialog != null) {
      dialog.setVisible(false);
    }
    fireActionPerformed(CANCEL_SELECTION);
###
1540, getUIClassID, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 181, 183
8
/**
   * Returns a string that specifies the name of the L&F class
   * that renders this component.
   *
   * @return "FontChooserUI"
   * @see JComponent#getUIClassID
   * @see UIDefaults#getUI
   */
3
  @Override
  public String getUIClassID() {
    return uiClassID;
###
1541, getSelectedFont, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 361, 362
6
/**
   * Gets the selected Font.
   * This is a bound property.
   * 
   * @return The selected font, or null, if no font is selected.
   */
2
  public Font getSelectedFont() {
    return selectedFont;
###
1542, getUI, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 159, 160
6
/**
   * Returns the look and feel (L&F) object that renders this component.
   *
   * @return the PanelUI object that renders this component
   * @since 1.4
   */
2
  public FontChooserUI getUI() {
    return (FontChooserUI) ui;
###
1543, loadAllFonts, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 310, 332
4
/**
   * Starts loading all fonts from the local graphics environment 
   * using a worker thread.
   */
21
  public synchronized static void loadAllFonts() {
    if (future == null) {
      future = new FutureTask<Font[]>(new Callable<Font[]>() {
        public Font[] call() throws Exception {
          long start = System.currentTimeMillis();
          Font[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();
          long end = System.currentTimeMillis();
          //System.out.println("JFontChooser has loaded all fonts. Elapsed:"+(end-start));
          // get rid of bogus fonts
          ArrayList<Font> goodFonts = new ArrayList<Font>(fonts.length);
          for (Font f : fonts) {
            Font decoded = Font.decode(f.getFontName());
            if (decoded.getFontName().equals(f.getFontName()) || decoded.getFontName().endsWith("-Derived")) {
              goodFonts.add(f);
            }
          }
          return goodFonts.toArray(new Font[goodFonts.size()]);
        // return fonts;
        }
      });
      new Thread(future).start();
###
1544, getAllFonts, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 344, 351
8
/**
   * Gets all fonts from the graphics environment. This may take a long
   * time. It is recommended to call loadAllFonts during the startup 
   * of an application. If you do this, you can retrieve the fonts from
   * this method from the AWT Event Dispatcher Thread.
   * 
   * @return All fonts.
   */
8
  public static synchronized Font[] getAllFonts() {
    loadAllFonts();
    try {
      return future.get().clone();
    } catch (InterruptedException ex) {
      return new Font[0];
    } catch (ExecutionException ex) {
      return new Font[0];
###
1545, updateUI, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 142, 149
5
/**
   * Resets the UI property with a value from the current look and feel.
   *
   * @see JComponent#updateUI
   */
8
  @Override
  public void updateUI() {
    // Try to get a browser UI from the UIManager.
    // Fall back to BasicBrowserUI, if none is available.
    if (UIManager.get(getUIClassID()) != null) {
      setUI((FontChooserUI) UIManager.getUI(this));
    } else {
      setUI(PaletteFontChooserUI.createUI(this));
###
1546, removeActionListener, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 240, 241
7
/**
   * Removes an <code>ActionListener</code> from the font chooser.
   *
   * @param l  the listener to be removed
   *
   * @see #addActionListener
   */
2
  public void removeActionListener(ActionListener l) {
    listenerList.remove(ActionListener.class, l);
###
1547, setUI, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 169, 170
6
/**
   * Sets the look and feel (L&F) object that renders this component.
   *
   * @param ui  the PanelUI L&F object
   * @see UIDefaults#getUI
   */
2
  public void setUI(FontChooserUI ui) {
    super.setUI(ui);
###
1548, approveSelection, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 196, 201
10
/**
   * Called by the UI when the user hits the Approve button
   * (labeled "Open" or "Save", by default). This can also be
   * called by the programmer.
   * This method causes an action event to fire
   * with the command string equal to
   * <code>APPROVE_SELECTION</code>.
   *
   * @see #APPROVE_SELECTION
   */
6
  public void approveSelection() {
    returnValue = APPROVE_OPTION;
    if (dialog != null) {
      dialog.setVisible(false);
    }
    fireActionPerformed(APPROVE_SELECTION);
###
1549, getModel, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 464, 465
6
/**
   * Gets the selected Font.
   * This is a bound property.
   * 
   * @return The selected font, or null, if no font is selected.
   */
2
  public FontChooserModel getModel() {
    return model;
###
1550, updateSelectionPath, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 392, 452
8
/**
   * Updates the selection path to the selected font.
   * <p>
   * This method is invoked, when a font is selected, and when then
   * structure of the model has changed.
   * 
   * @param newValue
   */
58
  protected void updateSelectionPath(Font newValue) {
    if (newValue == null || selectionPath == null || selectionPath.getPathCount() != 4 ||
        !((FontFaceNode) selectionPath.getLastPathComponent()).getFont().getFontName().equals(newValue.getFontName())) {
      if (newValue == null) {
        setSelectionPath(null);
      } else {
        TreePath path = selectionPath;
        FontCollectionNode oldCollection = (path != null && path.getPathCount() > 1) ? (FontCollectionNode) path.getPathComponent(1) : null;
        FontFamilyNode oldFamily = (path != null && path.getPathCount() > 2) ? (FontFamilyNode) path.getPathComponent(2) : null;
        FontFaceNode oldFace = (path != null && path.getPathCount() > 3) ? (FontFaceNode) path.getPathComponent(3) : null;
        FontCollectionNode newCollection = oldCollection;
        FontFamilyNode newFamily = oldFamily;
        FontFaceNode newFace = null;
        // search in the current family
        if (newFace == null && newFamily != null) {
          for (FontFaceNode face : newFamily.faces()) {
            if (face.getFont().getFontName().equals(newValue.getFontName())) {
              newFace = face;
              break;
            }
          }
        }
        // search in the current collection
        if (newFace == null && newCollection != null) {
          for (FontFamilyNode family : newCollection.families()) {
            for (FontFaceNode face : family.faces()) {
              if (face.getFont().getFontName().equals(newValue.getFontName())) {
                newFamily = family;
                newFace = face;
                break;
              }
            }
          }
        }
        // search in all collections
        if (newFace == null) {
          TreeNode root = (TreeNode) getModel().getRoot();
          OuterLoop:
          for (int i = 0, n = root.getChildCount(); i < n; i++) {
            FontCollectionNode collection = (FontCollectionNode) root.getChildAt(i);
            for (FontFamilyNode family : collection.families()) {
              for (FontFaceNode face : family.faces()) {
                if (face.getFont().getFontName().equals(newValue.getFontName())) {
                  newCollection = collection;
                  newFamily = family;
                  newFace = face;
                  break OuterLoop;
                }
              }
            }
          }
        }
        if (newFace != null) {
          setSelectionPath(new TreePath(new Object[]{
                getModel().getRoot(), newCollection, newFamily, newFace
              }));
        } else {
          setSelectionPath(null);
###
1551, JFontChooser, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 115, 131
1
/** Creates new form JFontChooser */
15
  public JFontChooser() {
    loadAllFonts();
    model = new DefaultFontChooserModel.UIResource();
    model.addTreeModelListener(modelHandler);
    updateUI();
    addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName() == "ancestor" && evt.getNewValue() != null) {
          Component ancestor = (Component) evt.getNewValue();
          try {
            ((DefaultFontChooserModel) model).setFonts(getAllFonts());
          } catch (Exception ex) {
            ex.printStackTrace();
          }
          JFontChooser.this.removePropertyChangeListener(this);
###
1552, fireActionPerformed, JFontChooser, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java, 249, 271
5
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type. The event instance
   * is lazily created using the <code>command</code> parameter.
   */
23
  protected void fireActionPerformed(String command) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    long mostRecentEventTime = EventQueue.getMostRecentEventTime();
    int modifiers = 0;
    AWTEvent currentEvent = EventQueue.getCurrentEvent();
    if (currentEvent instanceof InputEvent) {
      modifiers = ((InputEvent) currentEvent).getModifiers();
    } else if (currentEvent instanceof ActionEvent) {
      modifiers = ((ActionEvent) currentEvent).getModifiers();
    }
    ActionEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length - 2; i >= 0; i -= 2) {
      if (listeners[i] == ActionListener.class) {
        // Lazily create the event:
        if (e == null) {
          e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
              command, mostRecentEventTime,
              modifiers);
        }
        ((ActionListener) listeners[i + 1]).actionPerformed(e);
###
1553, setImageData, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 240, 244
4
/**
   * Sets the image data.
   * This clears the buffered image.
   */
5
  public void setImageData(byte[] imageData) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = null;
    changed();
###
1554, getBufferedImage, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 262, 274
4
/**
   * Gets the buffered image. If necessary, this method creates the buffered
   * image from the image data.
   */
13
  public BufferedImage getBufferedImage() {
    if (bufferedImage == null && imageData != null) {
      try {
        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));
      } catch (IOException e) {
        e.printStackTrace();
        // If we can't create a buffered image from the image data,
        // there is no use to keep the image data and try again, so
        // we drop the image data.
        imageData = null;
      }
    }
    return bufferedImage;
###
1557, PickAttributesAction, PickAttributesAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/PickAttributesAction.java, 35, 38
1
/** Creates a new instance. */
4
  public PickAttributesAction(DrawingEditor editor) {
    super(editor);
    labels.configureAction(this, "edit.pickAttributes");
    setEnabled(true);
###
1561, ImageFigure, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 57, 58
1
/** Creates a new instance. */
2
  public ImageFigure() {
    this(0, 0, 0, 0);
###
1563, setImage, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 229, 233
8
/**
   * Sets the image.
   *
   * @param imageData The image data. If this is null, a buffered image must
   * be provided.
   * @param bufferedImage An image constructed from the imageData. If this
   * is null, imageData must be provided.
   */
5
  public void setImage(byte[] imageData, BufferedImage bufferedImage) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = bufferedImage;
    changed();
###
1566, getEventSetDescriptors, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1567, setBufferedImage, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 251, 255
4
/**
   * Sets the buffered image.
   * This clears the image data.
   */
5
  public void setBufferedImage(BufferedImage image) {
    willChange();
    this.imageData = null;
    this.bufferedImage = image;
    changed();
###
1568, getDefaultEventIndex, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1569, getImageData, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 281, 296
4
/**
   * Gets the image data. If necessary, this method creates the image
   * data from the buffered image.
   */
16
  public byte[] getImageData() {
    if (bufferedImage != null && imageData == null) {
      try {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "PNG", bout);
        bout.close();
        imageData = bout.toByteArray();
      } catch (IOException e) {
        e.printStackTrace();
        // If we can't create image data from the buffered image,
        // there is no use to keep the buffered image and try again, so
        // we drop the buffered image.
        bufferedImage = null;
      }
    }
    return imageData;
###
1570, getDefaultPropertyIndex, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1572, transform, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 156, 161
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
6
  public void transform(AffineTransform tx) {
    Point2D.Double anchor = getStartPoint();
    Point2D.Double lead = getEndPoint();
    setBounds(
        (Point2D.Double) tx.transform(anchor, anchor),
        (Point2D.Double) tx.transform(lead, lead));
###
1573, getPropertyDescriptors, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1574, getBeanDescriptor, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1575, figureContains, ImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java, 138, 142
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
5
  public boolean figureContains(Point2D.Double p) {
    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this) + 1d;
    Geom.grow(r, grow, grow);
    return r.contains(p);
###
1576, getMethodDescriptors, JPopupButtonBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1577, GroupFigure, GroupFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GroupFigure.java, 28, 29
1
/** Creates a new instance. */
2
  public GroupFigure() {
    setConnectable(false);
###
1578, getMethodDescriptors, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 119, 120
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1579, getDefaultPropertyIndex, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 131, 132
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1580, getEventSetDescriptors, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 108, 109
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1581, getBeanDescriptor, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 81, 82
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1582, ZoomAction, ZoomAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ZoomAction.java, 34, 36
3
/**
   * Creates a new instance.
   */
3
  public ZoomAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {
    this((DrawingView) null, scaleFactor, button);
    setEditor(editor);
###
1583, getDefaultEventIndex, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 142, 143
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1585, getPropertyDescriptors, JLifeFormattedTexAreaBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java, 97, 98
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1588, GraphicalCompositeFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 105, 106
4
/**
   * Default constructor which uses nothing as presentation
   * figure. This constructor is needed by the Storable mechanism.
   */
2
  public GraphicalCompositeFigure() {
    this(null);
###
1589, getDrawingArea, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 152, 157
4
/**
   * Return the draw area. This method is delegated to the
   * encapsulated presentation figure.
   */
6
  public Rectangle2D.Double getDrawingArea() {
    Rectangle2D.Double r = super.getDrawingArea();
    if (getPresentationFigure() != null) {
      r.add(getPresentationFigure().getDrawingArea());
    }
    return r;
###
1590, GraphicalCompositeFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 114, 116
6
/**
   * Constructor which creates a GraphicalCompositeFigure with
   * a given graphical figure for presenting it.
   *
   * @param  newPresentationFigure  figure which renders the container
   */
3
  public GraphicalCompositeFigure(Figure newPresentationFigure) {
    super();
    setPresentationFigure(newPresentationFigure);
###
1591, setPresentationFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 236, 247
11
/**
   * Set a figure which renders this BasicCompositeFigure. The presentation
   * tasks for the BasicCompositeFigure are delegated to this presentation
   * figure.
   * 
   * 
   * 
   * 
   * 
   * @param newPresentationFigure  figure takes over the presentation tasks
   */
12
  public void setPresentationFigure(Figure newPresentationFigure) {
    if (this.presentationFigure != null) {
      this.presentationFigure.removeFigureListener(presentationFigureHandler);
      if (getDrawing() != null) {
        this.presentationFigure.removeNotify(getDrawing());
      }
    }
    this.presentationFigure = newPresentationFigure;
    if (this.presentationFigure != null) {
      this.presentationFigure.addFigureListener(presentationFigureHandler);
      if (getDrawing() != null) {
        this.presentationFigure.addNotify(getDrawing());
###
1592, SelectionColorChooserAction, SelectionColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/SelectionColorChooserAction.java, 39, 40
1
/** Creates a new instance. */
2
  public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {
    this(editor, key, null, icon);
###
1593, SelectionColorChooserAction, SelectionColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/SelectionColorChooserAction.java, 35, 36
1
/** Creates a new instance. */
2
  public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {
    this(editor, key, null, null);
###
1594, setBounds, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 164, 176
5
/**
   * Moves the figure. This is the
   * method that subclassers override. Clients usually
   * call displayBox.
   */
13
  public void setBounds(Point2D.Double anchor, Point2D.Double lead) {
    if (getLayouter() == null) {
      super.setBounds(anchor, lead);
      basicSetPresentationFigureBounds(anchor, lead);
    } else {
      Rectangle2D.Double r = getLayouter().layout(this, anchor, lead);
      basicSetPresentationFigureBounds(new Point2D.Double(r.getX(), r.getY()),
          new Point2D.Double(
          Math.max(lead.x, (int) r.getMaxX()),
          Math.max(lead.y, (int) r.getMaxY())
          )
          );
      invalidate();
###
1595, get, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 313, 320
3
/**
   * Gets an attribute from the figure.
   */
8
  @Override
  public <T> T get(AttributeKey<T> key) {
    if (getPresentationFigure() != null) {
      return getPresentationFigure().get(key);
    } else {
      return (! attributes.containsKey(key)) ?
        key.getDefaultValue() :
        key.get(attributes);
###
1596, transform, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 193, 196
4
/**
   * Standard presentation method which is delegated to the encapsulated presentation figure.
   * The presentation figure is moved as well as all contained figures.
   */
4
  public void transform(AffineTransform tx) {
    super.transform(tx);
    if (getPresentationFigure() != null) {
      getPresentationFigure().transform(tx);
###
1597, getBounds, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 123, 125
4
/**
   * Return the logcal display area. This method is delegated to the encapsulated
   * presentation figure.
   */
3
  public Rectangle2D.Double getBounds() {
    if (getPresentationFigure() == null) return super.getBounds();
    return getPresentationFigure().getBounds();
###
1598, applyAttributesTo, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 326, 329
3
/**
   * Applies all attributes of this figure to that figure.
   */
4
  @SuppressWarnings("unchecked")
  protected void applyAttributesTo(Figure that) {
    for (Map.Entry<AttributeKey, Object> entry : attributes.entrySet()) {
      that.set(entry.getKey(), entry.getValue());
###
1599, createHandles, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 217, 222
3
/**
   * Return default handles from the presentation figure.
   */
6
  public Collection<Handle> createHandles(int detailLevel) {
    LinkedList<Handle> handles = new LinkedList<Handle>();
    if (detailLevel == 0) {
    MoveHandle.addMoveHandles(this, handles);
    }
    return handles;
###
1600, getPresentationFigure, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 264, 265
11
/**
   * Get a figure which renders this BasicCompositeFigure. The presentation
   * tasks for the BasicCompositeFigure are delegated to this presentation
   * figure.
   * 
   * 
   * 
   * 
   * 
   * @return figure takes over the presentation tasks
   */
2
  public Figure getPresentationFigure() {
    return presentationFigure;
###
1601, draw, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 203, 205
3
/**
   * Draw the figure. This method is delegated to the encapsulated presentation figure.
   */
3
  public void draw(Graphics2D g) {
    drawPresentationFigure(g);
    super.draw(g);
###
1602, set, GraphicalCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java, 289, 297
5
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
9
  @Override
  public <T> void set(AttributeKey<T> key, T newValue) {
    if (forbiddenAttributes == null
        || ! forbiddenAttributes.contains(key)) {
      if (getPresentationFigure() != null) {
        getPresentationFigure().set(key, newValue);
      }
      super.set(key, newValue);
      Object oldValue = attributes.put(key, newValue);
###
1603, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 77, 78
8
/**
   * Creates a new instance with the specified grid size, 
   * and by 11.25 (in degrees) for rotations.
   * The grid is visible.
   *
   * @param width The width of a grid cell.
   * @param height The height of a grid cell.
   */
2
  public GridConstrainer(double width, double height) {
    this(width, height, Math.PI / 8d, true);
###
1604, getMajorGridSpacing, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 366, 367
3
/**
   * Spacing between major grid lines.
   */
2
  public int getMajorGridSpacing() {
    return majorGridSpacing;
###
1605, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 65, 66
3
/**
   * Creates a new instance with a grid of 1x1.
   */
2
  public GridConstrainer() {
    this(1d, 1d, 0d, false);
###
1606, translatePoint, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 211, 239
3
/**
   * Moves a point to the closest grid point in a direction.
   */
27
  public Point2D.Double translatePoint(Point2D.Double p, TranslationDirection dir) {
    Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());
    switch (dir) {
      case NORTH:
      case NORTH_WEST:
      case NORTH_EAST:
        p.y = p0.y - height;
        break;
      case SOUTH:
      case SOUTH_WEST:
      case SOUTH_EAST:
        p.y = p0.y + height;
        break;
    }
    switch (dir) {
      case WEST:
      case NORTH_WEST:
      case SOUTH_WEST:
        p.x = p0.x - width;
        break;
      case EAST:
      case NORTH_EAST:
      case SOUTH_EAST:
        p.x = p0.x + width;
        break;
    }
    return p;
###
1607, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 100, 107
8
/**
   * Creates a new instance with the specified grid size.
   *
   * @param width The width of a grid cell.
   * @param height The height of a grid cell.
   * @param theta The theta for rotations in radians.
   * @param visible Wether the grid is visible or not.
   */
8
  public GridConstrainer(double width, double height, double theta, boolean visible) {
    if (width <= 0 || height <= 0) {
      throw new IllegalArgumentException("Width or height is <= 0");
    }
    this.width = width;
    this.height = height;
    this.theta = theta;
    this.isVisible = visible;
###
1608, constrainPoint, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 161, 205
9
/**
   * Constrains the placement of a point towards a direction.
   * <p>
   * This method changes the point which is passed as a parameter.
   *
   * @param p A point on the drawing.
   * @param dir A direction.
   * @return Returns the constrained point.
   */
43
  protected Point2D.Double constrainPoint(Point2D.Double p, TranslationDirection dir) {
    Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());
    switch (dir) {
      case NORTH:
      case NORTH_WEST:
      case NORTH_EAST:
        if (p0.y < p.y) {
          p.y = p0.y;
        } else if (p0.y > p.y) {
          p.y = p0.y - height;
        }
        break;
      case SOUTH:
      case SOUTH_WEST:
      case SOUTH_EAST:
        if (p0.y < p.y) {
          p.y = p0.y + height;
        } else if (p0.y > p.y) {
          p.y = p0.y;
        }
        break;
    }
    switch (dir) {
      case WEST:
      case NORTH_WEST:
      case SOUTH_WEST:
        if (p0.x < p.x) {
          p.x = p0.x;
        } else if (p0.x > p.x) {
          p.x = p0.x - width;
        }
        break;
      case EAST:
      case NORTH_EAST:
      case SOUTH_EAST:
        if (p0.x < p.x) {
          p.x = p0.x + width;
        } else if (p0.x > p.x) {
          p.x = p0.x;
        }
        break;
    }
    return p;
###
1609, constrainRectangle, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 270, 303
10
/**
   * Constrains the placement of a rectangle towards a direction.
   * <p>
   * This method changes the location of the rectangle which is passed as a
   * parameter. This method does not change the size of the rectangle.
   *
   * @param r A rectangle on the drawing.
   * @param dir A direction.
   * @return Returns the constrained rectangle.
   */
31
  protected Rectangle2D.Double constrainRectangle(Rectangle2D.Double r, TranslationDirection dir) {
    Point2D.Double p0 = new Point2D.Double(r.x, r.y);
    switch (dir) {
      case NORTH:
      case NORTH_WEST:
      case WEST:
        constrainPoint(p0, dir);
        break;
      case EAST:
      case NORTH_EAST:
        p0.x += r.width;
        constrainPoint(p0, dir);
        p0.x -= r.width;
        break;
      case SOUTH:
      case SOUTH_WEST:
        p0.y += r.height;
        constrainPoint(p0, dir);
        p0.y -= r.height;
        break;
      case SOUTH_EAST:
        p0.y += r.height;
        p0.x += r.width;
        constrainPoint(p0, dir);
        p0.y -= r.height;
        p0.x -= r.width;
        break;
    }
    r.x = p0.x;
    r.y = p0.y;
    return r;
###
1610, GridConstrainer, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 89, 90
8
/**
   * Creates a new instance with the specified grid size.
   * and by 11.25 (in degrees) for rotations.
   *
   * @param width The width of a grid cell.
   * @param height The height of a grid cell.
   * @param visible Wether the grid is visible or not.
   */
2
  public GridConstrainer(double width, double height, boolean visible) {
    this(width, height, Math.PI / 8d, visible);
###
1611, setMajorGridSpacing, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 373, 377
3
/**
   * Spacing between major grid lines.
   */
5
  public void setMajorGridSpacing(int newValue) {
    int oldValue = majorGridSpacing;
    majorGridSpacing = newValue;
    firePropertyChange("majorGridSpacing", oldValue, newValue);
    fireStateChanged();
###
1612, constrainPoint, GridConstrainer, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java, 146, 149
3
/**
   * Constrains a point to the closest grid point in any direction.
   */
4
  public Point2D.Double constrainPoint(Point2D.Double p) {
    p.x = Math.round(p.x / width) * width;
    p.y = Math.round(p.y / height) * height;
    return p;
###
1613, getChildrenFrontToBack, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 183, 186
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
4
  public java.util.List<Figure> getChildrenFrontToBack() {
    return children ==  null ?
      new LinkedList<Figure>() :
      new ReversedList<Figure>(children);
###
1616, transform, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 102, 107
3
/**
   * Transforms the figure.
   */
6
  public void transform(AffineTransform tx) {
    super.transform(tx);
    for (Figure f : children) {
      f.transform(tx);
    }
    invalidate();
###
1617, fireFigureAdded, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 328, 340
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
13
  protected void fireFigureAdded(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null)
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        ((CompositeFigureListener)listeners[i+1]).figureAdded(event);
###
1618, set, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 138, 143
8
/**
   * Sets an attribute of the figure.
   * AttributeKey name and semantics are defined by the class implementing
   * the figure interface.
   */
 --------------
// ATTRIBUTES
 --------------
6
  public <T> void set(AttributeKey<T> key, T newValue) {
    super.set(key, newValue);
    if (isAttributeEnabled(key)) {
      if (children != null) {
        for (Figure child : children) {
          child.set(key, newValue);
###
1619, fireFigureRemoved, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 349, 361
4
/**
   *  Notify all listenerList that have registered interest for
   * notification on this event type.
   */
13
  protected void fireFigureRemoved(Figure f, int zIndex) {
    CompositeFigureEvent event = null;
    // Notify all listeners that have registered interest for
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i] == CompositeFigureListener.class) {
        // Lazily create the event:
        if (event == null)
          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);
        ((CompositeFigureListener)listeners[i+1]).figureRemoved(event);
###
1622, getLayouter, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 271, 272
12
/**
   * Get a Layouter object which encapsulated a layout
   * algorithm for this figure. Typically, a Layouter
   * accesses the child components of this figure and arranges
   * their graphical presentation.
   *
   *
   * @return layout strategy used by this figure
   */
 --------------
// LAYOUT
 --------------
2
  public Layouter getLayouter() {
    return layouter;
###
1623, layout, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 284, 291
6
/**
   * A layout algorithm is used to define how the child components
   * should be laid out in relation to each other. The task for
   * layouting the child components for presentation is delegated
   * to a Layouter which can be plugged in at runtime.
   */
8
  public void layout() {
    if (getLayouter() != null) {
      Rectangle2D.Double bounds = getBounds();
      Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);
      Rectangle2D.Double r = getLayouter().layout(
          this, p, p
          );
      invalidate();
###
1625, draw, LabeledLineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java, 89, 93
3
/**
   * Draw the figure. This method is delegated to the encapsulated presentation figure.
   */
5
  public void draw(Graphics2D g) {
    super.draw(g);
    for (Figure child : children) {
      if (child.isVisible()) {
        child.draw(g);
###
1631, contains, EllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java, 111, 119
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
8
  public boolean contains(Point2D.Double p) {
    Ellipse2D.Double r = (Ellipse2D.Double) ellipse.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this);
    r.x -= grow;
    r.y -= grow;
    r.width += grow * 2;
    r.height += grow * 2;
    return r.contains(p);
###
1632, EllipseFigure, EllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java, 37, 38
4
/**
   * Constructs a new {@code EllipseFigure}, initialized to
   * location (0,&nbsp;0) and size (0,&nbsp;0).
   */
2
  public EllipseFigure() {
    this(0, 0, 0, 0);
###
1634, EllipseFigure, EllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java, 50, 51
9
/**
   * Constructs and initializes an {@code EllipseFigure} from the
   * specified coordinates.
   *
   * @param x the x coordinate of the bounding rectangle
   * @param y the y coordinate of the bounding rectangle
   * @param width the width of the rectangle
   * @param height the height of the rectangle
   */
2
  public EllipseFigure(double x, double y, double width, double height) {
    ellipse = new Ellipse2D.Double(x, y, width, height);
###
1637, mouseReleased, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 125, 137
4
/**
   * MouseListener method for mouseReleased events. If the popup trigger has
   * been activated, then the appropriate hook method is called.
   */
12
  public void mouseReleased(MouseEvent evt) {
    if (popupTimer != null) {
      popupTimer.stop();
      popupTimer = null;
    }
    if (isMousePressedPopupTrigger) {
      isMousePressedPopupTrigger = false;
    } else {
      if (evt.isPopupTrigger()) {
        handlePopupMenu(evt);
      } else {
        super.mouseReleased(evt);
###
1638, handlePopupMenu, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 179, 185
4
/**
   * Hook method which can be overriden by subclasses to provide
   * specialised behaviour in the event of a popup trigger.
   */
7
  protected void handlePopupMenu(MouseEvent evt) {
    Point p = new Point(evt.getX(), evt.getY());
    Figure figure = getView().findFigure(p);
    if (figure != null || drawingActions.size() > 0) {
      showPopupMenu(figure, p, evt.getComponent());
    } else {
      popupMenu = null;
###
1639, DelegationSelectionTool, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 72, 73
1
/** Creates a new instance. */
2
  public DelegationSelectionTool() {
    this(new LinkedList<Action>(), new LinkedList<Action>());
###
1640, DelegationSelectionTool, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 77, 79
1
/** Creates a new instance. */
3
  public DelegationSelectionTool(Collection<Action> drawingActions, Collection<Action> selectionActions) {
    this.drawingActions = drawingActions;
    this.selectionActions = selectionActions;
###
1641, mousePressed, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 94, 117
4
/**
   * MouseListener method for mousePressed events. If the popup trigger has
   * been activated, then the appropriate hook method is called.
   */
22
  public void mousePressed(final MouseEvent evt) {
    if (popupTimer != null) {
      popupTimer.stop();
      popupTimer = null;
    }
    // XXX - When we want to support multiple views, we have to
    //     implement this:
    //setView((DrawingView)e.getSource());
    isMousePressedPopupTrigger = evt.isPopupTrigger();
    if (isMousePressedPopupTrigger) {
      getView().requestFocus();
      handlePopupMenu(evt);
    } else {
      super.mousePressed(evt);
      popupTimer = new javax.swing.Timer(1000, new ActionListener() {
        public void actionPerformed(ActionEvent aevt) {
          handlePopupMenu(evt);
          popupTimer = null;
        }
      });
      popupTimer.setRepeats(false);
      popupTimer.start();
###
1642, handleDoubleClick, DelegationSelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java, 266, 328
4
/**
   * Hook method which can be overriden by subclasses to provide
   * specialised behaviour in the event of a double click.
   */
60
  protected void handleDoubleClick(MouseEvent evt) {
    if (DEBUG) {
      System.out.println("DelegationSelectionTool.handleDoubleClick " + evt);
    }
    DrawingView v = getView();
    Point pos = new Point(evt.getX(), evt.getY());
    Handle handle = v.findHandle(pos);
    if (handle != null) {
      if (DEBUG) {
        System.out.println("DelegationSelectionTool.handleDoubleClick by handle");
      }
      handle.trackDoubleClick(pos, evt.getModifiersEx());
    } else {
      Point2D.Double p = viewToDrawing(pos);
      // Note: The search sequence used here, must be
      // consistent with the search sequence used by the
      // HandleTracker, the SelectAreaTracker and SelectionTool.
      // If possible, continue to work with the current selection
      Figure figure = null;
      if (isSelectBehindEnabled()) {
        for (Figure f : v.getSelectedFigures()) {
          if (f.contains(p)) {
            figure = f;
            break;
          }
        }
      }
      // If the point is not contained in the current selection,
      // search for a figure in the drawing.
      if (figure == null) {
        figure = v.findFigure(pos);
      }
      Figure outerFigure = figure;
      if (figure != null && figure.isSelectable()) {
        if (DEBUG) {
          System.out.println("DelegationSelectionTool.handleDoubleClick by figure");
        }
        Tool figureTool = figure.getTool(p);
        if (figureTool == null) {
          figure = getDrawing().findFigureInside(p);
          if (figure != null) {
            figureTool = figure.getTool(p);
          }
        }
        if (figureTool != null) {
          setTracker(figureTool);
          figureTool.mousePressed(evt);
        } else {
          if (outerFigure.handleMouseClick(p, evt, getView())) {
            v.clearSelection();
            v.addToSelection(outerFigure);
          } else {
            v.clearSelection();
            v.addToSelection(outerFigure);
            v.setHandleDetailLevel(v.getHandleDetailLevel() + 1);
          }
        }
      }
    }
    evt.consume();
###
1644, DefaultHandleTracker, DefaultHandleTracker, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DefaultHandleTracker.java, 64, 66
1
/** Creates a new instance. */
3
  public DefaultHandleTracker(Handle handle) {
    masterHandle = handle;
    multicaster = new HandleMulticaster(handle);
###
1645, ImageTool, ImageTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ImageTool.java, 57, 58
1
/** Creates a new instance. */
2
  public ImageTool(ImageHolderFigure prototype) {
    super(prototype);
###
1646, ImageTool, ImageTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ImageTool.java, 62, 63
1
/** Creates a new instance. */
2
  public ImageTool(ImageHolderFigure prototype, Map<AttributeKey, Object> attributes) {
    super(prototype, attributes);
###
1647, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 144, 145
11
/** Creates a new instance with the specified prototype but without an
   * attribute set. The CreationTool clones this prototype each time a new
   * Figure needs to be created. When a new Figure is created, the
   * CreationTool applies the default attributes from the DrawingEditor to it,
   * and then it applies the attributes to it, that have been supplied in
   * this constructor.
   *
   * @param prototype The prototype used to create a new Figure.
   * @param attributes The CreationTool applies these attributes to the
   * prototype after having applied the default attributes from the DrawingEditor.
   */
2
  public CreationTool(Figure prototype, Map<AttributeKey, Object> attributes) {
    this(prototype, attributes, null);
###
1648, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 158, 165
10
/**
   * Creates a new instance with the specified prototype and attribute set.
   *
   * @param prototype The prototype used to create a new Figure.
   * @param attributes The CreationTool applies these attributes to the
   * prototype after having applied the default attributes from the DrawingEditor.
   * @param name The name parameter is currently not used.
   * @deprecated This constructor might go away, because the name parameter
   * is not used.
   */
8
  public CreationTool(Figure prototype, Map<AttributeKey, Object> attributes, String name) {
    this.prototype = prototype;
    this.prototypeAttributes = attributes;
    if (name == null) {
      ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
      name = labels.getString("edit.createFigure.text");
    }
    this.presentationName = name;
###
1649, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 129, 130
7
/** Creates a new instance with the specified prototype but without an
   * attribute set. The CreationTool clones this prototype each time a new
   *  Figure needs to be created. When a new Figure is created, the
   * CreationTool applies the default attributes from the DrawingEditor to it.
   *
   * @param prototype The prototype used to create a new Figure.
   */
2
  public CreationTool(Figure prototype) {
    this(prototype, null, null);
###
1650, CreationTool, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 98, 99
1
/** Creates a new instance. */
2
  public CreationTool(String prototypeClassName) {
    this(prototypeClassName, null, null);
###
1651, setToolDoneAfterCreation, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 310, 312
5
/**
   * If this is set to false, the CreationTool does not fire toolDone
   * after a new Figure has been created. This allows to create multiple
   * figures consecutively.
   */
3
  public void setToolDoneAfterCreation(boolean newValue) {
    boolean oldValue = isToolDoneAfterCreation;
    isToolDoneAfterCreation = newValue;
###
1652, creationFinished, CreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java, 296, 301
5
/**
   * This method allows subclasses to do perform additonal user interactions
   * after the new figure has been created.
   * The implementation of this class just invokes fireToolDone.
   */
6
  protected void creationFinished(Figure createdFigure) {
    if (createdFigure.isSelectable()) {
      getView().addToSelection(createdFigure);
    }
    if (isToolDoneAfterCreation()) {
      fireToolDone();
###
1653, ImageTransferable, ImageTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/ImageTransferable.java, 44, 45
1
/** Creates a new instance. */
2
  public ImageTransferable(Image image) {
    this.image = image;
###
1654, setUpdateDrawingEditorDefaults, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 242, 243
6
/**
   * Set this to true if you want the attribute editor to update the
   * default values of the drawing editor.
   * 
   * @param newValue
   */
2
  public void setUpdateDrawingEditorDefaults(boolean newValue) {
    isUpdateDrawingEditorDefaults = newValue;
###
1655, setView, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 222, 224
9
/**
   * Attaches the FigureAttributeEditorHandler to the specified DrawingView.
   * <p>
   * If a non-null value is provided, the FigureAttributeEditorHandler listens only
   * to selection changes of the specified view. If a null value is provided,
   * the FigureAttributeEditorHandler listens to all views of the drawing editor.
   *
   * @param newValue a drawing view.
   */
3
  public void setView(DrawingView newValue) {
    this.view = newValue;
    updateActiveView();
###
1656, setDrawingEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 193, 202
9
/**
   * Attaches the FigureAttributeEditorHandler to the specified DrawingEditor.
   * <p>
   * The FigureAttributeEditorHandler listens to view changes and selection
   * changes of the drawing editor and calls setEnabled(boolean) and
   * updateField(Set&lt;Figure&gt;) on the field accordingly.
   *
   * @param newValue a drawing editor.
   */
10
  public void setDrawingEditor(DrawingEditor newValue) {
    DrawingEditor oldValue = drawingEditor;
    if (drawingEditor != null) {
      drawingEditor.removePropertyChangeListener(eventHandler);
    }
    this.drawingEditor = newValue;
    if (drawingEditor != null) {
      drawingEditor.addPropertyChangeListener(new WeakPropertyChangeListener(eventHandler));
    }
    updateActiveView();
###
1657, setAttributeEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 265, 271
3
/**
   * Attaches the FigureAttributeEditorHandler to the specified AttributeEditor.
   */
7
  public void setAttributeEditor(AttributeEditor<T> newValue) {
    if (attributeEditor != null) {
      attributeEditor.removePropertyChangeListener(eventHandler);
    }
    this.attributeEditor = newValue;
    if (attributeEditor != null) {
      attributeEditor.addPropertyChangeListener(eventHandler);
###
1658, getAttributeEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 279, 280
4
/**
   * Returns the AttributeEditor to which this FigureAttributeEditorHandler is
   * attached. 
   */
2
  public AttributeEditor<T> getAttributeEditor() {
    return attributeEditor;
###
1659, getView, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 232, 233
5
/**
   * Returns the DrawingView to which this FigureAttributeEditorHandler is
   * attached. Returns null, if the FigureAttributeEditorHandler is attached
   * to all views of the DrawingEditor.
   */
2
  public DrawingView getView() {
    return view;
###
1660, isUpdateDrawingEditorDefaults, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 250, 251
4
/**
   * Returns true if the attribute editor updates the
   * default values of the drawing editor.
   */
2
  public boolean isUpdateDrawingEditorDefaults() {
    return isUpdateDrawingEditorDefaults;
###
1661, getDrawingEditor, AbstractAttributeEditorHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java, 209, 210
4
/**
   * Returns the DrawingEditor to which this FigureAttributeEditorHandler is
   * attached.
   */
2
  public DrawingEditor getDrawingEditor() {
    return drawingEditor;
###
1662, create, GenericListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java, 104, 138
6
/**
   * Return an instance of a class that implements the interface that contains
   * the declaration for <code>listenerMethod</code>.  In this new class,
   * <code>listenerMethod</code> will apply <code>target.targetMethod</code>
   * to the incoming Event.
   */
35
  public static Object create(
  final Method listenerMethod,
  final Object target,
  final Method targetMethod) {
    /**
     * The implementation of the create method uses the Dynamic Proxy API
     * introduced in JDK 1.3.
     *
     * Create an instance of the DefaultInvoker and override the invoke
     * method to handle the invoking the targetMethod on the target.
     */
    InvocationHandler handler = new DefaultInvoker() {
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        
        // Send all methods except for the targetMethod to
        // the superclass for handling.
        if (listenerMethod.equals(method)) {
          if (targetMethod.getParameterTypes().length == 0) {
            // Special treatment for parameterless target methods:
            return targetMethod.invoke(target, new Object[0]);
          } else {
            // Regular treatment for target methods having the same
            // argument list as the listener method.
            return targetMethod.invoke(target, args);
          }
        } else {
          return super.invoke(proxy, method, args);
        }
      }
    };
    
    Class cls = listenerMethod.getDeclaringClass();
    ClassLoader cl = cls.getClassLoader();
    return Proxy.newProxyInstance(cl, new Class[]{cls}, handler);
###
1663, getListenerMethod, GenericListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java, 202, 218
7
/* Helper methods for "EZ" version of create(): */
 --------------
/**
   * Implementation of the InvocationHandler which handles the basic
   * object methods.
   */
 --------------
17
  private static Method getListenerMethod(Class listenerInterface,
  String listenerMethodName) {
    // given the arguments to create(), find out which listener is desired:
    Method[] m = listenerInterface.getMethods();
    Method result = null;
    for (int i = 0; i < m.length; i++) {
      if (listenerMethodName.equals(m[i].getName())) {
        if (result != null) {
          throw new RuntimeException("ambiguous method: "+m[i]+" vs. "+result);
        }
        result = m[i];
      }
    }
    if (result == null) {
      throw new RuntimeException("no such method "+listenerMethodName+" in "+listenerInterface);
    }
    return result;
###
1664, create, GenericListener, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java, 73, 94
4
/**
   * A convenient version of <code>create(listenerMethod, targetObject, targetMethod)</code>.
   * This version looks up the listener and target Methods, so you don't have to.
   */
22
  public static Object create(
  Class listenerInterface,
  String listenerMethodName,
  Object target,
  String targetMethodName) {
    Method listenerMethod = getListenerMethod(listenerInterface, listenerMethodName);
    
    // Search a target method with the same parameter types as the listener method.
    Method targetMethod =
    getTargetMethod(target, targetMethodName, listenerMethod.getParameterTypes());
    
    // Nothing found? Search a target method with no parameters
    if (targetMethod == null) {
      targetMethod = getTargetMethod(target, targetMethodName, new Class[0]);
    }
    
    // Still nothing found? We give up.
    if (targetMethod == null) {
      throw new RuntimeException("no such method "+targetMethodName+" in "+target.getClass());
    }
    
    return create(listenerMethod, target, targetMethod);
###
1665, JNLPClipboard, JNLPClipboard, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/JNLPClipboard.java, 49, 50
7
/**
   * Creates a new proxy for the specified target object.
   * The target object must have a getContent and a setContent method
   * as specified by the {@code javax.jnlp.ClipboardService} interface.
   *
   * @param target A Clipboard object.
   */
2
  public JNLPClipboard(Object target) {
    this.target = target;
###
1666, NetPanel, NetPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetPanel.java, 50, 115
1
/** Creates new instance. */
66
  public NetPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
     // FIXME - We need a toggle grid action
     // pb.addSeparator();
     // pb.add(new ToggleGridAction(editor));
    
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);
    
    
    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
1667, initComponents, NetPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetPanel.java, 140, 174
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
1670, createToolBars, NetApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplicationModel.java, 130, 156
5
/**
   * Creates toolbars for the application.
   * This class always returns an empty list. Subclasses may return other
   * values.
   */
25
  public java.util.List<JToolBar> createToolBars(Application a, View pr) {
    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.net.Labels");
    NetView p = (NetView) pr;
    DrawingEditor editor;
    if (p == null) {
      editor = getSharedEditor();
    } else {
      editor = p.getDrawingEditor();
    }
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    JToolBar tb;
    tb = new JToolBar();
    addCreationButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.drawToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAttributesButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.attributesToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAlignmentButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.alignmentToolBar.title"));
    list.add(tb);
    return list;
###
1671, initDrawing, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 170, 183
3
/**
   * Configure Drawing object to support copy and paste.
   */
11
  @SuppressWarnings("unchecked")
  private void initDrawing(Drawing d) {
    d.setInputFormats((java.util.List<InputFormat>) Collections.EMPTY_LIST);
    d.setOutputFormats((java.util.List<OutputFormat>) Collections.EMPTY_LIST);
    DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(
        new NetFactory());
    d.addInputFormat(ioFormat);
    d.addInputFormat(new ImageInputFormat(new ImageFigure()));
    d.addInputFormat(new TextInputFormat(new TextFigure()));
    d.addOutputFormat(ioFormat);
    d.addOutputFormat(new ImageOutputFormat());
###
1673, getParameter, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 55, 59
4
/**
   * We override getParameter() to make it work even if we have no Applet
   * context.
   */
5
  public String getParameter(String name) {
    try {
      return super.getParameter(name);
    } catch (NullPointerException e) {
      return null;
###
1674, init, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 70, 156
3
/**
   * Initializes the applet NetApplet
   */
78
  public void init() {
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Set our own popup factory, because the one that comes with Mac OS X
    // creates translucent popups which is not useful for color selection
    // using pop menus.
    try {
      PopupFactory.setSharedInstance(new PopupFactory());
    } catch (Throwable e) {
      // If we can't set the popup factory, we have to use what is there.
    }

    // Display copyright info while we are loading the data
    // ----------------------------------------------------
    Container c = getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
    String[] labels = getAppletInfo().split("\n");//Strings.split(getAppletInfo(), '\n');
    for (int i = 0; i < labels.length; i++) {
      c.add(new JLabel((labels[i].length() == 0) ? " " : labels[i]));
    }
    // We load the data using a worker thread
    // --------------------------------------
    new Worker<Drawing>() {
      protected Drawing construct() throws IOException {
        Drawing result;
        System.out.println("getParameter.datafile:" + getParameter("datafile"));
        if (getParameter("data") != null) {
          NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), new StringReader(getParameter("data")));
          result = (Drawing) domi.readObject(0);
        } else if (getParameter("datafile") != null) {
          URL url = new URL(getDocumentBase(), getParameter("datafile"));
          InputStream in = url.openConnection().getInputStream();
          try {
            NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), in);
            result = (Drawing) domi.readObject(0);
          } finally {
            in.close();
          }
        } else {
          result = null;
        }
        return result;
      }
      @Override
      protected void done(Drawing result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new NetPanel());
        if (result != null) {
          Drawing drawing = (Drawing) result;
          setDrawing(drawing);
        }
      }
      @Override
      protected void failed(Throwable value) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new NetPanel());
        value.printStackTrace();
        getDrawing().add(new TextFigure(value.toString()));
        value.printStackTrace();
      }
      @Override
      protected void finished() {
        Container c = getContentPane();
        initDrawing(getDrawing());
        c.validate();
      }
    }.start();
###
1675, initComponents, NetApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java, 247, 248
5
/** This method is called from within the init() method to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    toolButtonGroup = new javax.swing.ButtonGroup();
###
1676, getOpenChooser, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 203, 228
4
/** Lazily creates a JFileChooser and returns it. */
 --------------
/** Opens a drawing from a file. */
 --------------
25
  private JFileChooser getOpenChooser() {
    if (openChooser == null) {
      openChooser = new JFileChooser();
      Drawing d = svgPanel.getDrawing();
      fileFilterInputFormatMap = new HashMap<javax.swing.filechooser.FileFilter, InputFormat>();
      javax.swing.filechooser.FileFilter firstFF = null;
      for (InputFormat format : d.getInputFormats()) {
        javax.swing.filechooser.FileFilter ff = format.getFileFilter();
        if (firstFF == null) {
          firstFF = ff;
        }
        fileFilterInputFormatMap.put(ff, format);
        openChooser.addChoosableFileFilter(ff);
      }
      openChooser.setFileFilter(firstFF);
      openChooser.addPropertyChangeListener(new PropertyChangeListener() {
        public void propertyChange(PropertyChangeEvent evt) {
          if (evt.getPropertyName().equals("fileFilterChanged")) {
            InputFormat inputFormat = fileFilterInputFormatMap.get(evt.getNewValue());
            openChooser.setAccessory((inputFormat == null) ? null : inputFormat.getInputFormatAccessory());
          }
        }
      });
    }
    return openChooser;
###
1677, getSaveChooser, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 232, 257
4
/** Lazily creates a JFileChooser and returns it. */
 --------------
//GEN-LAST:event_open
 --------------
25
  private JFileChooser getSaveChooser() {
    if (saveChooser == null) {
      saveChooser = new JFileChooser();
      Drawing d = svgPanel.getDrawing();
      fileFilterOutputFormatMap = new HashMap<javax.swing.filechooser.FileFilter, OutputFormat>();
      javax.swing.filechooser.FileFilter firstFF = null;
      for (OutputFormat format : d.getOutputFormats()) {
        javax.swing.filechooser.FileFilter ff = format.getFileFilter();
        if (firstFF == null) {
          firstFF = ff;
        }
        fileFilterOutputFormatMap.put(ff, format);
        saveChooser.addChoosableFileFilter(ff);
      }
      saveChooser.setFileFilter(firstFF);
      saveChooser.addPropertyChangeListener(new PropertyChangeListener() {
        public void propertyChange(PropertyChangeEvent evt) {
          if (evt.getPropertyName().equals("fileFilterChanged")) {
            OutputFormat outputFormat = fileFilterOutputFormatMap.get(evt.getNewValue());
            saveChooser.setAccessory((outputFormat == null) ? null : outputFormat.getOutputFormatAccessory());
          }
        }
      });
    }
    return saveChooser;
###
1679, main, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 263, 267
6
/**
   * @param args the command line arguments
   */
 --------------
/** Saves a drawing to a file. */
 --------------
4
  public static void main(String args[]) {
    java.awt.EventQueue.invokeLater(new Runnable() {
      public void run() {
        new SVGDrawingPanelSample().setVisible(true);
###
1680, SVGDrawingPanelSample, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 59, 61
1
/** Creates new form SVGDrawingPanelSample */
3
  public SVGDrawingPanelSample() {
    initComponents();
    setSize(new Dimension(600, 400));
###
1682, initComponents, SVGDrawingPanelSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java, 69, 98
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
21
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();
    menuBar = new javax.swing.JMenuBar();
    fileMenu = new javax.swing.JMenu();
    openMenuItem = new javax.swing.JMenuItem();
    saveAsMenuItem = new javax.swing.JMenuItem();
    FormListener formListener = new FormListener();
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    getContentPane().add(svgPanel, java.awt.BorderLayout.CENTER);
    fileMenu.setText("File");
    openMenuItem.setText("Open...");
    openMenuItem.addActionListener(formListener);
    fileMenu.add(openMenuItem);
    saveAsMenuItem.setText("Save As...");
    saveAsMenuItem.addActionListener(formListener);
    fileMenu.add(saveAsMenuItem);
    menuBar.add(fileMenu);
    setJMenuBar(menuBar);
    pack();
###
1683, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/Main.java, 27, 47
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //  app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    
    
    DefaultApplicationModel model = new NetApplicationModel();
    model.setName("JHotDraw Net");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2009 (c) by the authors of JHotDraw and all its contributors.\n" +
        "This software is licensed under LGPL and Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.net.NetView");
    app.setModel(model);
    app.launch(args);
###
1684, main, QuickAndDirtyDOMStorableSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/QuickAndDirtyDOMStorableSample.java, 62, 85
1
/** DOM Storable objects must have a non-argument constructor. */
19
  public static void main(String[] args) {
    try {
      // Create a DOMStorable object
      MyObject obj = new MyObject("Hello World");
      System.out.println("The name of the original object is:" + obj.getName());
      // Write the object into a DOM, and then serialize the DOM into a String
      NanoXMLDOMOutput out = new NanoXMLDOMOutput(new QuickAndDirtyDOMFactory());
      out.writeObject(obj);
      StringWriter writer = new StringWriter();
      out.save(writer);
      String serializedString = writer.toString();
      System.out.println("\nThe serialized representation of the object is:\n" + serializedString);
      // Deserialize a DOM from a String, and then read the object from the DOM
      StringReader reader = new StringReader(serializedString);
      NanoXMLDOMInput in = new NanoXMLDOMInput(new QuickAndDirtyDOMFactory(), reader);
      MyObject obj2 = (MyObject) in.readObject();
      System.out.println("\nThe name of the restored object is:" + obj2.getName());
    } catch (IOException ex) {
      Logger.getLogger(QuickAndDirtyDOMStorableSample.class.getName()).log(Level.SEVERE, null, ex);
###
1685, SelectionToolSample, SelectionToolSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SelectionToolSample.java, 57, 98
3
/**
   * Creates a new instance of SelectionToolSample
   */
36
    public SelectionToolSample() {
      LineFigure lf = new LineFigure();
      lf.setBounds(new Point2D.Double(40,40), new Point2D.Double(200,
40));
      // Add all figures to a drawing 
      Drawing drawing = new DefaultDrawing(); 
      drawing.add(lf);
      // Show the drawing 
      JFrame f = new JFrame("UltraMini"); 
      f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
      f.setSize(600,300); 
      DrawingView view = new DefaultDrawingView(); 
      view.setDrawing(drawing);
      f.getContentPane().add(view.getComponent()); 
      // set up the drawing editor
      DrawingEditor editor = new DefaultDrawingEditor();
      editor.add(view);
      
      
      // Activate the following line to see the SelectionTool in full
      // action.
      editor.setTool(new SelectionTool());
      // Activate the following line to only see the SelectAreaTracker in 
      // action.
      //editor.setTool(new SelectAreaTracker());
      
      // Activate the following line to only see the DragTracker in 
      // action.
      //editor.setTool(new DragTracker(lf));
      
      // Activate the following lines to only see the HandleTracker in 
      // action.
      //view.selectAll();
      //editor.setTool(new HandleTracker(view.findHandle(view.drawingToView(lf.getStartPoint()))));
      
      f.show(); 
###
1686, getChooser, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 85, 86
3
/**
   * Returns the URIChooser pane on the sheet.
   */
2
  public URIChooser getChooser() {
    return (URIChooser) pane;
###
1687, getOption, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 97, 98
3
/**
   * Returns the option that the JFileChooser or JOptionPane returned.
   */
2
  public int getOption() {
    return option;
###
1688, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 61, 66
3
/**
   * Creates a new instance.
   */
6
  public SheetEvent(JSheet source, JOptionPane optionPane, int option, Object value, Object inputValue) {
    super(source);
    this.pane = optionPane;
    this.option = option;
    this.value = value;
    this.inputValue = inputValue;
###
1689, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 52, 56
3
/**
   * Creates a new instance.
   */
5
  public SheetEvent(JSheet source, URIChooser chooser, int option, Object value) {
    super(source);
    this.pane = chooser;
    this.option = option;
    this.value = value;
###
1690, getPane, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 73, 74
4
/**
   * Returns the pane on the sheet. This is either a JFileChooser, a URIChooser or a
   * JOptionPane.
   */
2
  public Object getPane() {
    return pane;
###
1691, getFileChooser, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 79, 80
3
/**
   * Returns the JFileChooser pane on the sheet.
   */
2
  public JFileChooser getFileChooser() {
    return (JFileChooser) pane;
###
1692, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 37, 38
3
/**
   * Creates a new instance.
   */
2
  public SheetEvent(JSheet source) {
    super(source);
###
1693, SheetEvent, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 43, 47
3
/**
   * Creates a new instance.
   */
5
  public SheetEvent(JSheet source, JFileChooser fileChooser, int option, Object value) {
    super(source);
    this.pane = fileChooser;
    this.option = option;
    this.value = value;
###
1694, getValue, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 103, 104
3
/**
   * Returns the value that the JFileChooser or JOptionPane returned.
   */
2
  public Object getValue() {
    return value;
###
1695, getOptionPane, SheetEvent, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java, 91, 92
3
/**
   * Returns the JOptionPane pane on the sheet.
   */
2
  public JOptionPane getOptionPane() {
    return (JOptionPane) pane;
###
1696, setFonts, DefaultFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/DefaultFontChooserModel.java, 66, 509
7
/**
   * Sets the fonts of the DefaultFontChooserModel.
   * <p>
   * Fires treeStructureChanged event on the root node.
   * 
   * @param fonts
   */
434
  @SuppressWarnings("unchecked")
  public void setFonts(Font[] fonts) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.gui.Labels");
    // collect families and sort them alphabetically
    ArrayList<FontFamilyNode> families = new ArrayList<FontFamilyNode>();
    HashMap<String, FontFamilyNode> familyMap = new HashMap<String, FontFamilyNode>();
    for (Font f : fonts) {
      String familyName = f.getFamily();
      FontFamilyNode family;
      if (familyMap.containsKey(familyName)) {
        family = familyMap.get(familyName);
      } else {
        family = new FontFamilyNode(familyName);
        familyMap.put(familyName, family);
      }
      family.add(new FontFaceNode(f));
    }
    families.addAll(familyMap.values());
    Collections.sort(families);
    // group families into collections
    root.removeAllChildren();
    root.add(new FontCollectionNode(labels.getString("FontCollection.allFonts"), (ArrayList<FontFamilyNode>) families.clone()));
    // Web-save fonts
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.web"), collectFamiliesNamed(families,
        "Arial",
        "Arial Black",
        "Comic Sans MS",
        "Georgia",
        "Impact",
        "Times New Roman",
        "Trebuchet MS",
        "Verdana",
        "Webdings")));
    /*
    // PDF Fonts
    root.add(
    new FontCollectionNode(labels.getString("FontCollection.pdf"), collectFamiliesNamed(families,
    "Andale Mono",
    "Courier",
    "Helvetica",
    "Symbol",
    "Times",
    "Zapf Dingbats")));
     */
    // Java System fonts
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.system"), collectFamiliesNamed(families,
        "Dialog",
        "DialogInput",
        "Monospaced",
        "SansSerif",
        "Serif")));
    // Serif fonts
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.serif"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Adobe Caslon Pro",
        "Adobe Garamond Pro",
        "American Typewriter",
        "Arno Pro",
        "Baskerville",
        "Baskerville Old Face",
        "Bell MT",
        "Big Caslon",
        "Bodoni SvtyTwo ITC TT",
        "Bodoni SvtyTwo OS ITC TT",
        "Bodoni SvtyTwo SC ITC TT",
        "Book Antiqua",
        "Bookman Old Style",
        "Calisto MT",
        "Chaparral Pro",
        "Century",
        "Century Schoolbook",
        "Cochin",
        "Footlight MT Light",
        "Garamond",
        "Garamond Premier Pro",
        "Georgia",
        "Goudy Old Style",
        "Hoefler Text",
        "Lucida Bright",
        "Lucida Fax",
        "Minion Pro",
        "Palatino",
        "Times",
        "Times New Roman",
        // Fonts on Windows XP:
        "Palatino Linotype",
        "Bitstream Vera Serif Bold",
        "Bodoni MT",
        "Bodoni MT Black",
        "Bodoni MT Condensed",
        "Californian FB",
        "Cambria",
        "Cambria Math",
        "Centaur",
        "Constantia",
        "High Tower Text",
        "Perpetua",
        "Poor Richard",
        "Rockwell Condensed",
        "Slimbach-Black",
        "Slimbach-BlackItalic",
        "Slimbach-Bold",
        "Slimbach-BoldItalic",
        "Slimbach-Book",
        "Slimbach-BookItalic",
        "Slimbach-Medium",
        "Slimbach-MediumItalic",
        "Sylfaen",
        // Fonts on Windows Vista
        "Andalus",
        "Angsana New",
        "AngsanaUPC",
        "Arabic Typesetting",
        "Cambria",
        "Cambria Math",
        "Constantia",
        "DaunPenh",
        "David",
        "DilleniaUPC",
        "EucrosiaUPC",
        "Frank Ruehl",
        "IrisUPC",
        "Iskoola Pota",
        "JasmineUPC",
        "KodchiangUPC",
        "Narkisim")));
    // Sans Serif
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.sansSerif"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Abadi MT Condensed Extra Bold",
        "Abadi MT Condensed Light",
        "Al Bayan",
        "AppleGothic",
        "Arial",
        "Arial Black",
        "Arial Narrow",
        "Arial Rounded MT Bold",
        "Arial Unicode MS",
        "Bell Gothic Std",
        "Blair MdITC TT",
        "Century Gothic",
        "Frutiger",
        "Futura",
        "Geneva",
        "Gill Sans",
        "Gulim",
        "Helvetica",
        "Helvetica Neue",
        "Lucida Grande",
        "Lucida Sans",
        "Microsoft Sans Serif",
        "Myriad Pro",
        "News Gothic",
        "Tahoma",
        "Trebuchet MS",
        "Verdana",
        // Fonts on Windows XP:
        "Franklin Gothic Medium",
        "Lucida Sans Unicode",
        "Agency FB",
        "Berlin Sans FB",
        "Berlin Sans FB Demi Bold",
        "Bitstream Vera Sans Bold",
        "Calibri",
        "Candara",
        "Corbel",
        "Estrangelo Edessa",
        "Eras Bold ITC",
        "Eras Demi ITC",
        "Eras Light ITC",
        "Eras Medium ITC",
        "Franklin Gothic Book",
        "Franklin Gothic Demi",
        "Franklin Gothic Demi Cond",
        "Franklin Gothic Heavy",
        "Franklin Gothic Medium Cond",
        "Gill Sans MT",
        "Gill Sans MT Condensed",
        "Gill Sans MT Ext Condensed Bold",
        "Maiandra GD",
        "MS Reference Sans...",
        "Tw Cen MT",
        "Tw Cen MT Condensed",
        "Tw Cen MT Condensed Extra Bold",
        // Fonts on Windows Vista:
        "Aharoni",
        "Browallia New",
        "BrowalliaUPC",
        "Calibri",
        "Candara",
        "Corbel",
        "Cordia New",
        "CordiaUPC",
        "DokChampa",
        "Dotum",
        "Estrangelo Edessa",
        "Euphemia",
        "Freesia UPC",
        "Gautami",
        "Gisha",
        "Kalinga",
        "Kartika",
        "Levenim MT",
        "LilyUPC",
        "Malgun Gothic",
        "Meiryo",
        "Miriam",
        "Segoe UI")));
    // Scripts 
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.script"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Apple Chancery",
        "Bickham Script Pro",
        "Blackmoor LET",
        "Bradley Hand ITC TT",
        "Brush Script MT",
        "Brush Script Std",
        "Chalkboard",
        "Charlemagne Std",
        "Comic Sans MS",
        "Curlz MT",
        "Edwardian Script ITC",
        "Footlight MT Light",
        "Giddyup Std",
        "Handwriting - Dakota",
        "Harrington",
        "Herculanum",
        "Kokonor",
        "Lithos Pro",
        "Lucida Blackletter",
        "Lucida Calligraphy",
        "Lucida Handwriting",
        "Marker Felt",
        "Matura MT Script Capitals",
        "Mistral",
        "Monotype Corsiva",
        "Party LET",
        "Papyrus",
        "Santa Fe LET",
        "Savoye LET",
        "SchoolHouse Cursive B",
        "SchoolHouse Printed A",
        "Skia",
        "Snell Roundhand",
        "Tekton Pro",
        "Trajan Pro",
        "Zapfino",
        // Fonts on Windows XP
        "Blackadder ITC",
        "Bradley Hand ITC",
        "Chiller",
        "Freestyle Script",
        "French Script MT",
        "Gigi",
        "Harlow Solid Italic",
        "Informal Roman",
        "Juice ITC",
        "Kristen ITC",
        "Kunstler Script",
        "Magneto Bold",
        "Maiandra GD",
        "Old English Text",
        "Palace Script MT",
        "Parchment",
        "Pristina",
        "Rage Italic",
        "Ravie",
        "Script MT Bold",
        "Tempus Sans ITC",
        "Viner Hand ITC",
        "Vivaldi Italic",
        "Vladimir Script",
        // Fonts on Windows Vista
        "Segoe Print",
        "Segoe Script")));
    
    // Monospaced
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.monospaced"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Andale Mono",
        "Courier",
        "Courier New",
        "Letter Gothic Std",
        "Lucida Sans Typewriter",
        "Monaco",
        "OCR A Std",
        "Orator Std",
        "Prestige Elite Std",
        // Fonts on Windows XP:
        "Lucida Console",
        "Bitstream Vera S...",
        "Consolas",
        "OCR A Extended",
        "OCR B",
        // Fonts on Windows Vista
        "Consolas",
        "DotumChe",
        "Miriam Fixed",
        "Rod")));
    
    // Decorative
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.decorative"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Academy Engraved LET",
        "Arial Black",
        "Bank Gothic",
        "Bauhaus 93",
        "Bernard MT Condensed",
        "Birch Std",
        "Blackoak Std",
        "BlairMdITC TT",
        "Bordeaux Roman Bold LET",
        "Braggadocio",
        "Britannic Bold",
        "Capitals",
        "Colonna MT",
        "Cooper Black",
        "Cooper Std",
        "Copperplate",
        "Copperplate Gothic Bold",
        "Copperplate Gothic Light",
        "Cracked",
        "Desdemona",
        "Didot",
        "Eccentric Std",
        "Engravers MT",
        "Eurostile",
        "Gill Sans Ultra Bold",
        "Gloucester MT Extra Condensed",
        "Haettenschweiler",
        "Hobo Std",
        "Impact",
        "Imprint MT Shadow",
        "Jazz LET",
        "Kino MT",
        "Matura MT Script Capitals",
        "Mesquite Std",
        "Modern No. 20",
        "Mona Lisa Solid ITC TT",
        "MS Gothic",
        "Nueva Std",
        "Onyx",
        "Optima",
        "Perpetua Titling MT",
        "Playbill",
        "Poplar Std",
        "PortagoITC TT",
        "Princetown LET",
        "Rockwell",
        "Rockwell Extra Bold",
        "Rosewood Std",
        "Santa Fe LET",
        "Stencil",
        "Stencil Std",
        "Stone Sans ITC TT",
        "Stone Sans OS ITC TT",
        "Stone Sans Sem ITC TT",
        "Stone Sans Sem OS ITCTT",
        "Stone Sans Sem OS ITC TT",
        "Synchro LET",
        "Wide Latin",
        // Fonts on Windows XP
        "Algerian",
        "Bodoni MT Black",
        "Bodoni MT Poster Compressed",
        "Broadway",
        "Castellar",
        "Elephant",
        "Felix Titling",
        "Franklin Gothic Heavy",
        "Gill Sans MT Ext Condensed Bold",
        "Gill Sans Ultra Bold Condensed",
        "Goudy Stout",
        "Jokerman",
        "Juice ITC",
        "Magneto",
        "Magneto Bold",
        "Niagara Engraved",
        "Niagara Solid",
        "Poor Richard",
        "Ravie",
        "Rockwell Condensed",
        "Showcard Gothic",
        "Slimbach-Black",
        "Slimbach-BlackItalic",
        "Snap ITC"
        // Fonts on Windows Vista:
        )));
    root.add(
        new FontCollectionNode(labels.getString("FontCollection.symbols"), collectFamiliesNamed(families,
        // Fonts on Mac OS X 10.5:
        "Apple Symbols",
        "Blackoack Std",
        "Bodoni Ornaments ITC TT",
        "EuropeanPi",
        "Monotype Sorts",
        "MT Extra",
        "Symbol",
        "Type Embellishments One LET",
        "Webdings",
        "Wingdings",
        "Wingdings 2",
        "Wingdings 3",
        "Zapf Dingbats",
        // Fonts on Windows XP
        "Bookshelf Symbol"
        // Fonts on Windows Vista
        )));
    // Collect font families, which are not in one of the other collections
    // (except the collection AllFonts).
    FontCollectionNode others = new FontCollectionNode(labels.getString("FontCollection.other"));
    HashSet<FontFamilyNode> otherFamilySet = new HashSet<FontFamilyNode>();
    otherFamilySet.addAll(families);
    for (int i = 1, n = root.getChildCount(); i < n; i++) {
      FontCollectionNode fcn = (FontCollectionNode) root.getChildAt(i);
      for (FontFamilyNode ffn : fcn.families()) {
        otherFamilySet.remove(ffn);
      }
    }
    ArrayList<FontFamilyNode> otherFamilies = new ArrayList<FontFamilyNode>();
    for (FontFamilyNode ffn : otherFamilySet) {
      otherFamilies.add(ffn.clone());
    }
    Collections.sort(otherFamilies);
    others.addAll(otherFamilies);
    root.add(others);
    fireTreeStructureChanged(this, new TreePath(root));
###
1697, fireTreeNodesChanged, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 85, 99
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node being changed
   * @param path the path to the root node
   * @param childIndices the indices of the changed elements
   * @param children the changed elements
   * @see EventListenerList
   */
15
  protected void fireTreeNodesChanged(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);
###
1698, fireTreeNodesRemoved, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 147, 161
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where elements are being removed
   * @param path the path to the root node
   * @param childIndices the indices of the removed elements
   * @param children the removed elements
   * @see EventListenerList
   */
15
  protected void fireTreeNodesRemoved(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);
###
1699, fireTreeNodesInserted, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 116, 130
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where new elements are being inserted
   * @param path the path to the root node
   * @param childIndices the indices of the new elements
   * @param children the new elements
   * @see EventListenerList
   */
15
  protected void fireTreeNodesInserted(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);
###
1700, fireTreeStructureChanged, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 178, 192
12
/**
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where the tree model has changed
   * @param path the path to the root node
   * @param childIndices the indices of the affected elements
   * @param children the affected elements
   * @see EventListenerList
   */
15
  protected void fireTreeStructureChanged(Object source, Object[] path, 
                    int[] childIndices, 
                    Object[] children) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path, 
                       childIndices, children);
        ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
###
1701, getTreeModelListeners, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 68, 70
13
/**
   * Returns an array of all the tree model listeners
   * registered on this model.
   *
   * @return all of this model's <code>TreeModelListener</code>s
   *   or an empty
   *   array if no tree model listeners are currently registered
   *
   * @see #addTreeModelListener
   * @see #removeTreeModelListener
   *
   * @since 1.4
   */
3
  public TreeModelListener[] getTreeModelListeners() {
    return (TreeModelListener[])listenerList.getListeners(
        TreeModelListener.class);
###
1702, removeTreeModelListener, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 51, 52
9
/**
   * Removes a listener previously added with <B>addTreeModelListener()</B>.
   *
   * @see   #addTreeModelListener
   * @param   l     the listener to remove
   */
 --------------
//  Events
 --------------
2
  public void removeTreeModelListener(TreeModelListener l) {
    listenerList.remove(TreeModelListener.class, l);
###
1703, addTreeModelListener, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 41, 42
6
/**
   * Adds a listener for the TreeModelEvent posted after the tree changes.
   *
   * @see   #removeTreeModelListener
   * @param   l   the listener to add
   */
2
  public void addTreeModelListener(TreeModelListener l) {
    listenerList.add(TreeModelListener.class, l);
###
1704, fireTreeStructureChanged, AbstractFontChooserModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java, 207, 218
10
/*
   * Notifies all listeners that have registered interest for
   * notification on this event type.  The event instance 
   * is lazily created using the parameters passed into 
   * the fire method.
   *
   * @param source the node where the tree model has changed
   * @param path the path to the root node
   * @see EventListenerList
   */
12
  protected void fireTreeStructureChanged(Object source, TreePath path) {
    // Guaranteed to return a non-null array
    Object[] listeners = listenerList.getListenerList();
    TreeModelEvent e = null;
    // Process the listeners last to first, notifying
    // those that are interested in this event
    for (int i = listeners.length-2; i>=0; i-=2) {
      if (listeners[i]==TreeModelListener.class) {
        // Lazily create the event:
        if (e == null)
          e = new TreeModelEvent(source, path);
        ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);
###
1705, PathTool, PathTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/PathTool.java, 46, 47
1
/** Creates a new instance. */
2
  public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {
    this(pathPrototype, bezierPrototype, null);
###
1706, TogglePropertiesPanelAction, TogglePropertiesPanelAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/action/TogglePropertiesPanelAction.java, 33, 37
1
/** Creates a new instance. */
5
  public TogglePropertiesPanelAction(Application app, View view) {
    super(app, view);
    setPropertyName("propertiesPanelVisible");
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.odg.Labels");
    putValue(AbstractAction.NAME, labels.getString("propertiesPanel"));
###
1708, getPropertyDescriptors, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1710, getMethodDescriptors, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1711, getDefaultEventIndex, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1712, getEventSetDescriptors, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1713, getDefaultPropertyIndex, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1716, getBeanDescriptor, ODGPropertiesPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1717, initComponents, ODGPropertiesPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanel.java, 83, 113
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
25
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    linkLabel = new javax.swing.JLabel();
    linkField = new org.jhotdraw.gui.JAttributeTextField();
    opacityLabel = new javax.swing.JLabel();
    opacityField = new org.jhotdraw.gui.JAttributeTextField();
    opacityPopupButton = new org.jhotdraw.gui.JPopupButton();
    setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
    setLayout(new java.awt.GridBagLayout());
    linkLabel.setLabelFor(linkField);
    linkLabel.setText(labels.getString("link")); // NOI18N
    add(linkLabel, new java.awt.GridBagConstraints());
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.weightx = 1.0;
    add(linkField, gridBagConstraints);
    opacityLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/attributeOpacity.png"))); // NOI18N
    opacityLabel.setToolTipText(labels.getString("opacity")); // NOI18N
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
    add(opacityLabel, gridBagConstraints);
    opacityField.setColumns(3);
    add(opacityField, new java.awt.GridBagConstraints());
    opacityPopupButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jhotdraw/draw/action/images/popupIcon.png"))); // NOI18N
    add(opacityPopupButton, new java.awt.GridBagConstraints());
###
1718, ODGPropertiesPanel, ODGPropertiesPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanel.java, 42, 61
1
/** Creates new instance. */
19
  @SuppressWarnings("unchecked")
  public ODGPropertiesPanel() {
    initComponents();
    
    opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);
    opacityPopupButton.add(opacitySlider);
    opacityPopupButton.putClientProperty("JButton.buttonType","toolbar");
    add(opacityPopupButton);
    opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));
    opacityFieldHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacityField, editor);
    opacitySliderHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacitySlider, editor);
    linkFieldHandler = new FigureAttributeEditorHandler<String>(LINK, linkField, editor);
    
    // set fonts
    Font font = getFont().deriveFont(11f);
    for (Component c : getComponents()) {
      c.setFont(font);
    }
    opacitySlider.setFont(font);
###
1719, ODGBezierFigure, ODGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGBezierFigure.java, 40, 41
1
/** Creates a new instance. */
2
  public ODGBezierFigure() {
    this(false);
###
1720, write, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 185, 186
3
/**
   * Writes the view to the specified uri.
   */
2
  public void write(URI f, URIChooser fc) throws IOException {
    new SVGOutputFormat().write(new File(f), view.getDrawing());
###
1721, createDrawing, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 126, 141
3
/**
   * Creates a new Drawing for this view.
   */
16
  protected Drawing createDrawing() {
    Drawing drawing = new ODGDrawing();
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    inputFormats.add(new ODGInputFormat());
    inputFormats.add(new ImageInputFormat(new SVGImageFigure()));
    inputFormats.add(new TextInputFormat(new SVGTextFigure()));
    drawing.setInputFormats(inputFormats);
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    outputFormats.add(new SVGOutputFormat());
    outputFormats.add(new SVGZOutputFormat());
    outputFormats.add(new ImageOutputFormat());
    outputFormats.add(new ImageOutputFormat("JPG", "Joint Photographics Experts Group (JPEG)", "jpg", BufferedImage.TYPE_INT_RGB));
    outputFormats.add(new ImageOutputFormat("BMP", "Windows Bitmap (BMP)", "bmp", BufferedImage.TYPE_BYTE_INDEXED));
    outputFormats.add(new ImageMapOutputFormat());
    drawing.setOutputFormats(outputFormats);
    return drawing;
###
1722, clear, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 271, 286
3
/**
   * Clears the view.
   */
15
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
1723, read, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 192, 223
3
/**
   * Reads the view from the specified uri.
   */
28
  @SuppressWarnings("unchecked")
  @Override
  public void read(URI f, URIChooser fc) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      HashMap<FileFilter, InputFormat> fileFilterInputFormatMap = (HashMap<FileFilter, InputFormat>)((JFileURIChooser) fc).getClientProperty("ffInputFormatMap");
      InputFormat sf = fileFilterInputFormatMap.get(((JFileURIChooser) fc).getFileFilter());
      if (sf == null) {
        sf = drawing.getInputFormats().get(0);
      }
      sf.read(new File(f), drawing, true);
      System.out.println("ODCView read(" + f + ") drawing.childCount=" + drawing.getChildCount());
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(drawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
1724, createPageable, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 147, 148
3
/**
   * Creates a Pageable object for printing the view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
1726, initComponents, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 302, 315
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
10
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    propertiesPanel = new org.jhotdraw.samples.odg.ODGPropertiesPanel();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    add(propertiesPanel, java.awt.BorderLayout.SOUTH);
###
1727, init, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 81, 120
3
/**
   * Initializes the view.
   */
33
  public void init() {
    super.init();
    initComponents();
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
    propertiesPanel.setVisible(preferences.getBoolean("propertiesPanelVisible", false));
    propertiesPanel.setView(view);
###
1728, initActions, ODGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java, 171, 173
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
1730, contains, ODGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java, 118, 120
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
3
  public boolean contains(Point2D.Double p) {
    // XXX - This does not take the stroke width into account!
    return getTransformedShape().contains(p);
###
1731, ODGEllipseFigure, ODGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java, 50, 51
1
/** Creates a new instance. */
2
  public ODGEllipseFigure() {
    this(0, 0, 0, 0);
###
1737, transform, ODGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java, 146, 175
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
30
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        TRANSFORM.setClone(this, tx);
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM, t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT, g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT, g);
      }
    }
    invalidate();
###
1738, CombineAction, CombineAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/action/CombineAction.java, 34, 38
1
/** Creates a new instance. */
4
  public CombineAction(DrawingEditor editor) {
    super(editor, new ODGPathFigure());
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.odg.Labels");
    labels.configureAction(this, ID);
###
1739, createUI, PaletteFormattedTextFieldUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFormattedTextFieldUI.java, 39, 40
6
/**
   * Creates a UI for a JTextField.
   *
   * @param c the text field
   * @return the UI
   */
2
  public static ComponentUI createUI(JComponent c) {
    return new PaletteFormattedTextFieldUI();
###
1740, create, PaletteFormattedTextFieldUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFormattedTextFieldUI.java, 49, 147
6
/**
   * Creates a view (FieldView) based on an element.
   *
   * @param elem the element
   * @return the view
   */
94
  @Override
  public View create(Element elem) {
    /* We create our own view here. This view always uses the
     * text alignment that was specified by the text component. Even
     * then, when the text is longer than in the text component.
     *
     * Draws a wavy line if the value of the field is not valid.
     */
    return new FieldView(elem) {
      /**
       * Adjusts the allocation given to the view
       * to be a suitable allocation for a text field.
       * If the view has been allocated more than the
       * preferred span vertically, the allocation is
       * changed to be centered vertically.  Horizontally
       * the view is adjusted according to the horizontal
       * alignment property set on the associated JTextField
       * (if that is the type of the hosting component).
       *
       * @param a the allocation given to the view, which may need
       *  to be adjusted.
       * @return the allocation that the superclass should use.
       */
      protected Shape adjustAllocationXX(Shape a) {
        if (a != null) {
          Rectangle bounds = a.getBounds();
          int vspan = (int) getPreferredSpan(Y_AXIS);
          int hspan = (int) getPreferredSpan(X_AXIS);
          if (bounds.height != vspan) {
            int slop = bounds.height - vspan;
            bounds.y += slop / 2;
            bounds.height -= slop;
          }
          // horizontal adjustments
          Component c = getContainer();
          if (c instanceof JTextField) {
            JTextField field = (JTextField) c;
            BoundedRangeModel vis = field.getHorizontalVisibility();
            int max = Math.max(hspan, bounds.width);
            int value = vis.getValue();
            int extent = Math.min(max, bounds.width - 1);
            if ((value + extent) > max) {
              value = max - extent;
            }
            vis.setRangeProperties(value, extent, vis.getMinimum(),
                max, false);
            if (hspan < bounds.width) {
              // horizontally align the interior
              int slop = bounds.width - 1 - hspan;
              int align = ((JTextField) c).getHorizontalAlignment();
              if (true /*((JComponent) c).isLeftToRight()*/) {
                if (align == LEADING) {
                  align = LEFT;
                } else if (align == TRAILING) {
                  align = RIGHT;
                }
              } else {
                if (align == LEADING) {
                  align = RIGHT;
                } else if (align == TRAILING) {
                  align = LEFT;
                }
              }
              switch (align) {
                case SwingConstants.CENTER:
                  bounds.x += slop / 2;
                  bounds.width -= slop;
                  break;
                case SwingConstants.RIGHT:
                  bounds.x += slop;
                  bounds.width -= slop;
                  break;
              }
            } else {
              // adjust the allocation to match the bounded range.
              bounds.width = hspan;
              bounds.x -= vis.getValue();
            }
          }
          return bounds;
        }
        return null;
      }
      @Override
      public void paint(Graphics gr, Shape a) {
        Graphics2D g = (Graphics2D) gr;
        JFormattedTextField editor = (JFormattedTextField) getComponent();
        if (!editor.isEditValid()) {
          Rectangle r = (Rectangle) a;
          g.setColor(errorIndicatorForeground);
          g.setStroke(new BasicStroke(2.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3f,3f},0.5f));
          g.draw(new Line2D.Float(r.x, r.y+r.height-0.5f, r.x+r.width-1,r.y+r.height-0.5f));
          }
          super.paint(g, a);
###
1742, PaletteFontChooserPreviewPanel, PaletteFontChooserPreviewPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserPreviewPanel.java, 28, 37
1
/** Creates new form PaletteFontChooserPreviewPanel */
10
  public PaletteFontChooserPreviewPanel() {
    initComponents();
    
    previewLabel.setUI((LabelUI) PaletteLabelUI.createUI(previewLabel));
    previewLabel.setBackground(Color.WHITE);
    previewLabel.setForeground(Color.BLACK);
    previewLabel.setOpaque(true);
    
    setPreferredSize(new Dimension(100,50));
    setMinimumSize(new Dimension(100,50));
###
1743, initComponents, PaletteFontChooserPreviewPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserPreviewPanel.java, 76, 85
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
7
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    previewLabel = new javax.swing.JLabel();
    setLayout(new java.awt.BorderLayout());
    previewLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    add(previewLabel, java.awt.BorderLayout.CENTER);
###
1744, installUI, PaletteFontChooserUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java, 95, 98
25
/**
   * Configures the specified component appropriate for the look and feel.
   * This method is invoked when the <code>ComponentUI</code> instance is being installed
   * as the UI delegate on the specified component.  This method should
   * completely configure the component for the look and feel,
   * including the following:
   * <ol>
   * <li>Install any default property values for color, fonts, borders,
   *   icons, opacity, etc. on the component.  Whenever possible, 
   *   property values initialized by the client program should <i>not</i> 
   *   be overridden.
   * <li>Install a <code>LayoutManager</code> on the component if necessary.
   * <li>Create/add any required sub-components to the component.
   * <li>Create/install event listeners on the component.
   * <li>Create/install a <code>PropertyChangeListener</code> on the component in order
   *   to detect and respond to component property changes appropriately.
   * <li>Install keyboard UI (mnemonics, traversal, etc.) on the component.
   * <li>Initialize any appropriate instance data.
   * </ol>
   * @param c the component where this UI delegate is being installed
   *
   * @see #uninstallUI
   * @see javax.swing.JComponent#setUI
   * @see javax.swing.JComponent#updateUI
   */
4
  @Override
  public void installUI(JComponent c) {
    installComponents(fontChooser);
    installListeners(fontChooser);
###
1745, createUI, PaletteFontChooserUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java, 65, 67
10
/**
   * Returns an instance of the UI delegate for the specified component.
   * Each subclass must provide its own static <code>createUI</code>
   * method that returns an instance of that UI delegate subclass.
   * If the UI delegate subclass is stateless, it may return an instance
   * that is shared by multiple components.  If the UI delegate is
   * stateful, then it should return a new instance per component.
   * The default implementation of this method throws an error, as it
   * should never be invoked.
   */
3
  public static ComponentUI createUI(JComponent c) {
    PaletteFontChooserUI ui = new PaletteFontChooserUI((JFontChooser) c);
    return ui;
###
1746, uninstallUI, PaletteFontChooserUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java, 160, 162
25
/**
   * Reverses configuration which was done on the specified component during
   * <code>installUI</code>.  This method is invoked when this 
   * <code>UIComponent</code> instance is being removed as the UI delegate 
   * for the specified component.  This method should undo the
   * configuration performed in <code>installUI</code>, being careful to 
   * leave the <code>JComponent</code> instance in a clean state (no 
   * extraneous listeners, look-and-feel-specific property objects, etc.).
   * This should include the following:
   * <ol>
   * <li>Remove any UI-set borders from the component.
   * <li>Remove any UI-set layout managers on the component.
   * <li>Remove any UI-added sub-components from the component.
   * <li>Remove any UI-added event/property listeners from the component.
   * <li>Remove any UI-installed keyboard UI from the component.
   * <li>Nullify any allocated instance data objects to allow for GC.
   * </ol>
   * @param c the component from which this UI delegate is being removed;
   *      this argument is often ignored,
   *      but might be used if the UI object is stateless
   *      and shared by multiple components
   *
   * @see #installUI
   * @see javax.swing.JComponent#updateUI
   */
3
  public void uninstallUI(JComponent c) {
    uninstallListeners(fontChooser);
    uninstallComponents(fontChooser);
###
1747, TextCreationTool, TextCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java, 73, 74
1
/** Creates a new instance. */
2
  public TextCreationTool(TextHolderFigure prototype, Map<AttributeKey,Object> attributes) {
    super(prototype, attributes);
###
1748, TextCreationTool, TextCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java, 69, 70
1
/** Creates a new instance. */
2
  public TextCreationTool(TextHolderFigure prototype) {
    super(prototype);
###
1749, mousePressed, TextCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java, 85, 133
3
/**
   * Creates a new figure at the location where the mouse was pressed.
   */
46
  @Override
  public void mousePressed(MouseEvent e) {
    TextHolderFigure textHolder = null;
    // Note: The search sequence used here, must be
    // consistent with the search sequence used by the
    // HandleTracker, SelectAreaTracker, DelegationSelectionTool, SelectionTool.
    // If possible, continue to work with the current selection
    DrawingView v = getView();
    Point2D.Double p = v.viewToDrawing(e.getPoint());
    Figure pressedFigure = null;
    if (true /*isSelectBehindEnabled()*/) {
      for (Figure f : v.getSelectedFigures()) {
        if (f.contains(p)) {
          pressedFigure = f;
          break;
        }
      }
    }
    // If the point is not contained in the current selection,
    // search for a figure in the drawing.
    if (pressedFigure == null) {
      pressedFigure = getDrawing().findFigureInside(p);
    }
    if (pressedFigure instanceof TextHolderFigure) {
      textHolder = ((TextHolderFigure) pressedFigure).getLabelFor();
        textHolder = null;
    }
    if (textHolder != null) {
      beginEdit(textHolder);
      updateCursor(getView(), e.getPoint());
          return;
    }
    if (typingTarget != null) {
      endEdit();
      if (isToolDoneAfterCreation()) {
        fireToolDone();
      }
    } else {
      super.mousePressed(e);
      // update view so the created figure is drawn before the floating text
      // figure is overlaid. 
      textHolder = (TextHolderFigure)getCreatedFigure();
      getView().clearSelection();
      getView().addToSelection(textHolder);
      beginEdit(textHolder);
      updateCursor(getView(), e.getPoint());
###
1750, setRubberbandColor, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 106, 107
6
/**
   * Sets the rubberband color for the tool. Setting this to null, disables
   * the rubberband.
   *
   * @param c Rubberband color or null.
   */
2
  public void setRubberbandColor(Color c) {
    rubberbandColor = c;
###
1751, mousePressed, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 120, 164
4
/**
   * Creates a new figure at the mouse location.
   * If editing is in progress, this finishes editing.
   */
40
  @Override
  public void mousePressed(MouseEvent e) {
    TextHolderFigure textHolder = null;
    // Note: The search sequence used here, must be
    // consistent with the search sequence used by the
    // HandleTracker, SelectAreaTracker, DelegationSelectionTool, SelectionTool.
    // If possible, continue to work with the current selection
    DrawingView v = getView();
    Point2D.Double p = v.viewToDrawing(e.getPoint());
    Figure pressedFigure = null;
    if (true /*isSelectBehindEnabled()*/) {
      for (Figure f : v.getSelectedFigures()) {
        if (f.contains(p)) {
          pressedFigure = f;
          break;
        }
      }
    }
    // If the point is not contained in the current selection,
    // search for a figure in the drawing.
    if (pressedFigure == null) {
      pressedFigure = getDrawing().findFigureInside(p);
    }
    // 
    if (pressedFigure instanceof TextHolderFigure) {
      textHolder = (TextHolderFigure) pressedFigure;
        textHolder = null;
    }
    if (textHolder != null) {
      createdFigure = null;
      beginEdit(textHolder);
      return;
    }
    if (typingTarget != null) {
      endEdit();
      if (isToolDoneAfterCreation()) {
        fireToolDone();
      }
    } else {
      super.mousePressed(e);
###
1752, creationFinished, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 173, 177
5
/**
   * This method allows subclasses to do perform additonal user interactions
   * after the new figure has been created.
   * The implementation of this class just invokes fireToolDone.
   */
5
  @Override
  protected void creationFinished(Figure createdFigure) {
    getView().clearSelection();
    getView().addToSelection(createdFigure);
    beginEdit((TextHolderFigure) createdFigure);
###
1753, TextAreaCreationTool, TextAreaCreationTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java, 92, 93
1
/** Creates a new instance. */
2
  public TextAreaCreationTool(TextHolderFigure prototype) {
    super(prototype);
###
1755, PaletteFontChooserSelectionPanel, PaletteFontChooserSelectionPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserSelectionPanel.java, 30, 41
1
/** Creates new form FontChooserPanel */
12
  public PaletteFontChooserSelectionPanel() {
     labels = ResourceBundleUtil.getBundle("org.jhotdraw.gui.Labels");
    initComponents();
    collectionList.setModel(new DefaultListModel());
    familyList.setModel(new DefaultListModel());
    faceList.setModel(new DefaultListModel());
    
    // Customiziation of Quaqua Look and Feel: Set small scroll bars
    Font smallSystemFont = new Font("Dialog", Font.PLAIN, 11);
    collectionsScrollPane.setFont(smallSystemFont);
    familiesScrollPane.setFont(smallSystemFont);
    facesScrollPane.setFont(smallSystemFont);
###
1756, initComponents, PaletteFontChooserSelectionPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserSelectionPanel.java, 59, 141
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
63
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    collectionsPanel = new javax.swing.JPanel();
    collectionsScrollPane = new javax.swing.JScrollPane();
    collectionList = new javax.swing.JList();
    collectionsLabel = new javax.swing.JLabel();
    familiesPanel = new javax.swing.JPanel();
    familiesScrollPane = new javax.swing.JScrollPane();
    familyList = new javax.swing.JList();
    familyLabel = new javax.swing.JLabel();
    facesPanel = new javax.swing.JPanel();
    facesScrollPane = new javax.swing.JScrollPane();
    faceList = new javax.swing.JList();
    faceLabel = new javax.swing.JLabel();
    setBorder(javax.swing.BorderFactory.createEmptyBorder(3, 3, 3, 3));
    setLayout(new java.awt.GridBagLayout());
    collectionsPanel.setPreferredSize(new java.awt.Dimension(80, 200));
    collectionsPanel.setLayout(new java.awt.BorderLayout());
    collectionsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    collectionList.setFont(collectionList.getFont().deriveFont((float)11));
    collectionsScrollPane.setViewportView(collectionList);
    collectionsPanel.add(collectionsScrollPane, java.awt.BorderLayout.CENTER);
    collectionsLabel.setFont(collectionsLabel.getFont().deriveFont((float)11));
    collectionsLabel.setText(labels.getString("FontCollection.collections")); // NOI18N
    collectionsPanel.add(collectionsLabel, java.awt.BorderLayout.PAGE_START);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 0.3;
    gridBagConstraints.weighty = 1.0;
    add(collectionsPanel, gridBagConstraints);
    familiesPanel.setPreferredSize(new java.awt.Dimension(140, 200));
    familiesPanel.setLayout(new java.awt.BorderLayout());
    familiesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    familyList.setFont(familyList.getFont().deriveFont((float)11));
    familiesScrollPane.setViewportView(familyList);
    familiesPanel.add(familiesScrollPane, java.awt.BorderLayout.CENTER);
    familyLabel.setFont(familyLabel.getFont().deriveFont((float)11));
    familyLabel.setText(labels.getString("FontCollection.family")); // NOI18N
    familiesPanel.add(familyLabel, java.awt.BorderLayout.PAGE_START);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 0.4;
    gridBagConstraints.weighty = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
    add(familiesPanel, gridBagConstraints);
    facesPanel.setPreferredSize(new java.awt.Dimension(80, 200));
    facesPanel.setLayout(new java.awt.BorderLayout());
    facesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
    facesScrollPane.setPreferredSize(new java.awt.Dimension(130, 240));
    faceList.setFont(faceList.getFont().deriveFont((float)11));
    facesScrollPane.setViewportView(faceList);
    facesPanel.add(facesScrollPane, java.awt.BorderLayout.CENTER);
    faceLabel.setFont(faceLabel.getFont().deriveFont((float)11));
    faceLabel.setText(labels.getString("FontCollection.typeface")); // NOI18N
    facesPanel.add(faceLabel, java.awt.BorderLayout.PAGE_START);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 0.3;
    gridBagConstraints.weighty = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);
    add(facesPanel, gridBagConstraints);
###
1757, layoutCL, PaletteLabelUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java, 137, 157
7
/**
   * Forwards the call to SwingUtilities.layoutCompoundLabel().
   * This method is here so that a subclass could do Label specific
   * layout and to shorten the method name a little.
   *
   * @see SwingUtilities#layoutCompoundLabel
   */
21
  protected String layoutCL(
      JLabel label,
      FontMetrics fontMetrics,
      String text,
      Icon icon,
      Rectangle viewR,
      Rectangle iconR,
      Rectangle textR) {
    return SwingUtilities.layoutCompoundLabel(
        (JComponent) label,
        fontMetrics,
        text,
        icon,
        label.getVerticalAlignment(),
        label.getHorizontalAlignment(),
        label.getVerticalTextPosition(),
        label.getHorizontalTextPosition(),
        viewR,
        iconR,
        textR,
        label.getIconTextGap());
###
1758, createUI, PaletteLabelUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java, 49, 50
9
/**
   * Preferred spacing between labels and other components.
   * Pixels from colon and associated controls (RadioButton,
   * CheckBox)
   * /
   * private final static Insets associatedRegularSpacing = new Insets(8,8,8,8);
   * private final static Insets associatedSmallSpacing = new Insets(6,6,6,6);
   * private final static Insets associatedMiniSpacing = new Insets(5,5,5,5);
   */
2
  public static ComponentUI createUI(JComponent c) {
    return labelUI;
###
1759, paintDisabledText, PaletteLabelUI, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java, 97, 104
6
/**
   * Paint label with disabled text color.
   *
   * @see #paint
   * @see #paintEnabledText
   */
6
  protected void paintDisabledText(JLabel l, Graphics g, String s, int textX, int textY) {
    Color c = UIManager.getColor("Label.disabledForeground");
    g.setColor((c != null) ? c : l.getForeground());
    int accChar = -1; //l.getDisplayedMnemonicIndex();
    PaletteUtilities.drawString(g, s, accChar,
        textX, textY);
###
1760, MultiIcon, MultiIcon, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/MultiIcon.java, 57, 59
6
/**
   * Creates a new instance from an array of icons.
   * All icons must have the same dimensions.
   * If an icon is null, an icon is derived for the state from the
   * other icons.
   */
3
  public MultiIcon(Icon[] icons) {
    this.icons = icons;
    generateMissingIcons();
###
1761, MultiIcon, MultiIcon, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/MultiIcon.java, 68, 75
6
/**
   * Creates a new instance from an array of images.
   * All icons must have the same dimensions.
   * If an icon is null, an icon is derived for the state from the
   * other icons.
   */
8
  public MultiIcon(Image[] images) {
    this.icons = new Icon[images.length];
    for (int i=0, n = icons.length; i < n; i++) {
      if (images[i] != null) {
        icons[i] = new ImageIcon(images[i]);
      }
    }
    generateMissingIcons();
###
1762, add, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 247, 248
10
/**
   * Convenience method for adding a control point with a single
   * coordinate C0.
   */
 --------------
/**
     * This mask is used to describe which control points in addition to
     * C0 are in effect.
     */
 --------------
2
  public void add(Point2D.Double c0) {
    add(new Node(0, c0, c0, c0));
###
1763, toGeneralPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 311, 383
1
/** Converts the BezierPath into a Path2D.Double. */
70
  public Path2D.Double toGeneralPath() {
    Path2D.Double gp = new Path2D.Double();
    gp.setWindingRule(windingRule);
    if (size() == 0) {
      gp.moveTo(0, 0);
      gp.lineTo(0, 0 + 1);
    } else if (size() == 1) {
      Node current = get(0);
      gp.moveTo(current.x[0], current.y[0]);
      gp.lineTo(current.x[0], current.y[0] + 1);
    } else {
      Node previous;
      Node current;
      previous = current = get(0);
      gp.moveTo(current.x[0], current.y[0]);
      for (int i = 1, n = size(); i < n; i++) {
        previous = current;
        current = get(i);
        if ((previous.mask & C2_MASK) == 0) {
          if ((current.mask & C1_MASK) == 0) {
            gp.lineTo(
                current.x[0], current.y[0]);
          } else {
            gp.quadTo(
                current.x[1], current.y[1],
                current.x[0], current.y[0]);
          }
        } else {
          if ((current.mask & C1_MASK) == 0) {
            gp.quadTo(
                previous.x[2], previous.y[2],
                current.x[0], current.y[0]);
          } else {
            gp.curveTo(
                previous.x[2], previous.y[2],
                current.x[1], current.y[1],
                current.x[0], current.y[0]);
          }
        }
      }
      if (isClosed) {
        if (size() > 1) {
          previous = get(size() - 1);
          current = get(0);
          if ((previous.mask & C2_MASK) == 0) {
            if ((current.mask & C1_MASK) == 0) {
              gp.lineTo(
                  current.x[0], current.y[0]);
            } else {
              gp.quadTo(
                  current.x[1], current.y[1],
                  current.x[0], current.y[0]);
            }
          } else {
            if ((current.mask & C1_MASK) == 0) {
              gp.quadTo(
                  previous.x[2], previous.y[2],
                  current.x[0], current.y[0]);
            } else {
              gp.curveTo(
                  previous.x[2], previous.y[2],
                  current.x[1], current.y[1],
                  current.x[0], current.y[0]);
            }
          }
        }
        gp.closePath();
      }
    }
    return gp;
###
1764, toPolygonArray, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1259, 1264
4
/**
   * Creates a polygon array of the bezier path.
   * @return Point array.
   */
6
  public Point2D.Double[] toPolygonArray() {
    Point2D.Double[] points = new Point2D.Double[size()];
    for (int i = 0, n = size(); i < n; i++) {
      points[i] = new Point2D.Double(get(i).x[0], get(i).y[0]);
    }
    return points;
###
1765, indexOfOutermostNode, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 790, 807
72
/**
   * Return the index of the control point that is furthest from the center
   **/
 --------------
/*
    Point2D.Double ctr = getCenter();
    // Chopped point
    double cx = -1;
    double cy = -1;
    double len = Double.MAX_VALUE;
    // Try for points along edge
    validatePath();
    PathIterator i = generalPath.getPathIterator(new AffineTransform(), 1);
    double[] coords = new double[6];
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    i.next();
    for (; ! i.isDone(); i.next()) {
    i.currentSegment(coords);
    Point2D.Double chop = Geom.intersect(
    prevX, prevY,
    coords[0], coords[1],
    p.x, p.y,
    ctr.x, ctr.y
    );
    if (chop != null) {
    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
    if (cl < len) {
    len = cl;
    cx = chop.x;
    cy = chop.y;
    }
    }
    prevX = coords[0];
    prevY = coords[1];
    }
    //
    if (isClosed() && size() > 1) {
    Node first = get(0);
    Node last = get(size() - 1);
    Point2D.Double chop = Geom.intersect(
    first.x[0], first.y[0],
    last.x[0], last.y[0],
    p.x, p.y,
    ctr.x, ctr.y
    );
    if (chop != null) {
    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);
    if (cl < len) {
    len = cl;
    cx = chop.x;
    cy = chop.y;
    }
    }
    }

    // if none found, pick closest vertex
    if (len == Double.MAX_VALUE) {
    for (int j = 0, n = size(); j < n; j++) {
    Node cp = get(j);
    double l = Geom.length2(cp.x[0], cp.y[0], p.x, p.y);
    if (l < len) {
    len = l;
    cx = cp.x[0];
    cy = cp.y[0];
    }
    }
    }
    return new Point2D.Double(cx, cy);
     */
 --------------
17
  public int indexOfOutermostNode() {
    if (outer == -1) {
      Point2D.Double ctr = getCenter();
      outer = 0;
      double dist = 0;
      for (int i = 0, n = size(); i < n; i++) {
        Node cp = get(i);
        double d = Geom.length2(ctr.x, ctr.y,
            cp.x[0],
            cp.y[0]);
        if (d > dist) {
          dist = d;
          outer = i;
        }
      }
    }
    return outer;
###
1766, get, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 285, 289
3
/**
   * Convenience method for getting a single coordinate of a control point.
   */
5
  public Point2D.Double get(int index, int coord) {
    Node c = get(index);
    return new Point2D.Double(
        c.x[coord],
        c.y[coord]);
###
1767, getLengthOfPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 870, 884
5
/**
   * Returns the length of the path.
   *
   * @param flatness the flatness used to approximate the length.
   */
15
  public double getLengthOfPath(double flatness) {
    double len = 0;
    PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);
    double[] coords = new double[6];
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    i.next();
    for (; !i.isDone(); i.next()) {
      i.currentSegment(coords);
      len += Geom.length(prevX, prevY, coords[0], coords[1]);
      prevX = coords[0];
      prevY = coords[1];
    }
    return len;
###
1768, transform, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 663, 674
4
/**
   * Transforms the BezierPath.
   * @param tx the transformation.
   */
12
  public void transform(AffineTransform tx) {
    Point2D.Double p = new Point2D.Double();
    for (Node cp : this) {
      for (int i = 0; i < 3; i++) {
        p.x = cp.x[i];
        p.y = cp.y[i];
        tx.transform(p, p);
        cp.x[i] = p.x;
        cp.y[i] = p.y;
      }
    }
    invalidatePath();
###
1769, set, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 276, 279
9
/**
   * Convenience method for changing a single coordinate of a control point.
   */
 --------------
/** This is a hint for editing tools. If this is set to true,
     * the editing tools shall keep all control points on the same
     * line.
     */
 --------------
4
  public void set(int index, int coord, Point2D.Double p) {
    Node c = get(index);
    c.x[coord] = p.x;
    c.y[coord] = p.y;
###
1770, add, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 259, 260
7
/**
   * Convenience method for adding a control point with three
   * coordinates C0, C1 and C2 with a mask.
   */
 --------------
/** Control point x coordinates. */
 --------------
2
  public void add(int mask, Point2D.Double c0, Point2D.Double c1, Point2D.Double c2) {
    add(new Node(mask, c0, c1, c2));
###
1771, getRelativePositionOnPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 895, 945
8
/**
   * Returns the relative position of the specified point on the path.
   *
   * @param flatness the flatness used to approximate the length.
   *
   * @return relative position on path, this is a number between 0 and 1.
   * Returns -1, if the point is not on the path.
   */
50
  public double getRelativePositionOnPath(Point2D.Double find, double flatness) {
    // XXX - This method works only for straight lines!
    double len = getLengthOfPath(flatness);
    double relativeLen = 0d;
    Node v1, v2;
    BezierPath tempPath = new BezierPath();
    Node t1, t2;
    tempPath.add(t1 = new Node());
    tempPath.add(t2 = new Node());
    for (int i = 0, n = size() - 1; i < n; i++) {
      v1 = get(i);
      v2 = get(i + 1);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        } else {
          relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        } else {
          relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);
        }
      }
    }
    if (isClosed && size() > 1) {
      v1 = get(size() - 1);
      v2 = get(0);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, flatness)) {
          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);
          return relativeLen / len;
        }
      }
    }
    return -1;
###
1772, clone, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 651, 656
1
/** Creates a deep copy of the BezierPath. */
6
  public BezierPath clone() {
    BezierPath that = (BezierPath) super.clone();
    for (int i = 0, n = this.size(); i < n; i++) {
      that.set(i, (Node) this.get(i).clone());
    }
    return that;
###
1774, arcTo, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1117, 1251
28
/**
   * Adds an elliptical arc, defined by two radii, an angle from the
   * x-axis, a flag to choose the large arc or not, a flag to
   * indicate if we increase or decrease the angles and the final
   * point of the arc.
   * <p>
   * As specified in http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
   * <p>
   * The implementation of this method has been derived from
   * Apache Batik class org.apache.batik.ext.awt.geom.ExtendedGeneralPath#computArc
   *
   * @param rx the x radius of the ellipse
   * @param ry the y radius of the ellipse
   *
   * @param xAxisRotation the angle from the x-axis of the current
   * coordinate system to the x-axis of the ellipse in degrees.
   *
   * @param largeArcFlag the large arc flag. If true the arc
   * spanning less than or equal to 180 degrees is chosen, otherwise
   * the arc spanning greater than 180 degrees is chosen
   *
   * @param sweepFlag the sweep flag. If true the line joining
   * center to arc sweeps through decreasing angles otherwise it
   * sweeps through increasing angles
   *
   * @param x the absolute x coordinate of the final point of the arc.
   * @param y the absolute y coordinate of the final point of the arc.
   */
122
  public void arcTo(double rx, double ry,
      double xAxisRotation,
      boolean largeArcFlag, boolean sweepFlag,
      double x, double y) {

    // Ensure radii are valid
    if (rx == 0 || ry == 0) {
      lineTo(x, y);
      return;
    }
    // Get the current (x, y) coordinates of the path
    Node lastPoint = get(size() - 1);
    double x0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.x[2] : lastPoint.x[0];
    double y0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.y[2] : lastPoint.y[0];
    if (x0 == x && y0 == y) {
      // If the endpoints (x, y) and (x0, y0) are identical, then this
      // is equivalent to omitting the elliptical arc segment entirely.
      return;
    }
    // Compute the half distance between the current and the final point
    double dx2 = (x0 - x) / 2d;
    double dy2 = (y0 - y) / 2d;
    // Convert angle from degrees to radians
    double angle = Math.toRadians(xAxisRotation);
    double cosAngle = Math.cos(angle);
    double sinAngle = Math.sin(angle);
    //
    // Step 1 : Compute (x1, y1)
    //
    double x1 = (cosAngle * dx2 + sinAngle * dy2);
    double y1 = (-sinAngle * dx2 + cosAngle * dy2);
    // Ensure radii are large enough
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    double Prx = rx * rx;
    double Pry = ry * ry;
    double Px1 = x1 * x1;
    double Py1 = y1 * y1;
    // check that radii are large enough
    double radiiCheck = Px1 / Prx + Py1 / Pry;
    if (radiiCheck > 1) {
      rx = Math.sqrt(radiiCheck) * rx;
      ry = Math.sqrt(radiiCheck) * ry;
      Prx = rx * rx;
      Pry = ry * ry;
    }
    //
    // Step 2 : Compute (cx1, cy1)
    //
    double sign = (largeArcFlag == sweepFlag) ? -1 : 1;
    double sq = ((Prx * Pry) - (Prx * Py1) - (Pry * Px1)) / ((Prx * Py1) + (Pry * Px1));
    sq = (sq < 0) ? 0 : sq;
    double coef = (sign * Math.sqrt(sq));
    double cx1 = coef * ((rx * y1) / ry);
    double cy1 = coef * -((ry * x1) / rx);
    //
    // Step 3 : Compute (cx, cy) from (cx1, cy1)
    //
    double sx2 = (x0 + x) / 2.0;
    double sy2 = (y0 + y) / 2.0;
    double cx = sx2 + (cosAngle * cx1 - sinAngle * cy1);
    double cy = sy2 + (sinAngle * cx1 + cosAngle * cy1);
    //
    // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle)
    //
    double ux = (x1 - cx1) / rx;
    double uy = (y1 - cy1) / ry;
    double vx = (-x1 - cx1) / rx;
    double vy = (-y1 - cy1) / ry;
    double p, n;
    // Compute the angle start
    n = Math.sqrt((ux * ux) + (uy * uy));
    p = ux; // (1 * ux) + (0 * uy)
    sign = (uy < 0) ? -1d : 1d;
    double angleStart = Math.toDegrees(sign * Math.acos(p / n));
    // Compute the angle extent
    n = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
    p = ux * vx + uy * vy;
    sign = (ux * vy - uy * vx < 0) ? -1d : 1d;
    double angleExtent = Math.toDegrees(sign * Math.acos(p / n));
    if (!sweepFlag && angleExtent > 0) {
      angleExtent -= 360f;
    } else if (sweepFlag && angleExtent < 0) {
      angleExtent += 360f;
    }
    angleExtent %= 360f;
    angleStart %= 360f;
    //
    // We can now build the resulting Arc2D in double precision
    //
    Arc2D.Double arc = new Arc2D.Double(
        cx - rx, cy - ry,
        rx * 2d, ry * 2d,
        -angleStart, -angleExtent,
        Arc2D.OPEN);
    // Create a path iterator of the rotated arc
    PathIterator i = arc.getPathIterator(
        AffineTransform.getRotateInstance(
        angle, arc.getCenterX(), arc.getCenterY()));
    // Add the segments to the bezier path
    double[] coords = new double[6];
    i.next(); // skip first moveto
    while (!i.isDone()) {
      int type = i.currentSegment(coords);
      switch (type) {
        case PathIterator.SEG_CLOSE:
          // ignore
          break;
        case PathIterator.SEG_CUBICTO:
          curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);
          break;
        case PathIterator.SEG_LINETO:
          lineTo(coords[0], coords[1]);
          break;
        case PathIterator.SEG_MOVETO:
          // ignore
          break;
        case PathIterator.SEG_QUADTO:
          quadTo(coords[0], coords[1], coords[2], coords[3]);
          break;
      }
      i.next();
###
1775, chop, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 709, 711
5
/**
   * Returns a point on the edge of the bezier path which crosses the line
   * from the center of the bezier path to the specified point.
   * If no edge crosses the line, the nearest C0 control point is returned.
   */
3
  public Point2D.Double chop(Point2D.Double p) {
    validatePath();
    return Geom.chop(generalPath, p);
###
1776, setWindingRule, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1271, 1275
4
/**
   * Sets winding rule for filling the bezier path.
   * @param newValue Must be Path2D.Double.WIND_EVEN_ODD or Path2D.Double.WIND_NON_ZERO.
   */
5
  public void setWindingRule(int newValue) {
    if (newValue != windingRule) {
      invalidatePath();
      int oldValue = windingRule;
      this.windingRule = newValue;
###
1777, validatePath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 304, 306
3
/**
   * Recomputes the BezierPath, if it is invalid.
   */
3
  public void validatePath() {
    if (generalPath == null) {
      generalPath = toGeneralPath();
###
1778, findSegment, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 953, 993
5
/**
   * Gets the segment of the polyline that is hit by
   * the given Point2D.Double.
   * @return the index of the segment or -1 if no segment was hit.
   */
40
  public int findSegment(Point2D.Double find, double tolerance) {
    // XXX - This works only for straight lines!
    Node v1, v2;
    BezierPath tempPath = new BezierPath();
    Node t1, t2;
    tempPath.add(t1 = new Node());
    tempPath.add(t2 = new Node());
    for (int i = 0, n = size() - 1; i < n; i++) {
      v1 = get(i);
      v2 = get(i + 1);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {
          return i;
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, tolerance)) {
          return i;
        }
      }
    }
    if (isClosed && size() > 1) {
      v1 = get(size() - 1);
      v2 = get(0);
      if (v1.mask == 0 && v2.mask == 0) {
        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {
          return size() - 1;
        }
      } else {
        t1.setTo(v1);
        t2.setTo(v2);
        tempPath.invalidatePath();
        if (tempPath.outlineContains(find, tolerance)) {
          return size() - 1;
        }
      }
    }
    return -1;
###
1779, getPointOnPath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 817, 862
7
/**
   * Returns a relative point on the path.
   * Where 0 is the start point of the path and 1 is the end point of the
   * path.
   *
   * @param relative a value between 0 and 1.
   */
44
  public Point2D.Double getPointOnPath(double relative, double flatness) {
    // This method works only for straight lines
    if (size() == 0) {
      return null;
    } else if (size() == 1) {
      return get(0).getControlPoint(0);
    }
    if (relative <= 0) {
      return get(0).getControlPoint(0);
    } else if (relative >= 1) {
      return get(size() - 1).getControlPoint(0);
    }
    validatePath();
    // Compute the relative point on the path
    double len = getLengthOfPath(flatness);
    double relativeLen = len * relative;
    double pos = 0;
    double[] coords = new double[6];
    PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);
    int type = i.currentSegment(coords);
    double prevX = coords[0];
    double prevY = coords[1];
    i.next();
    for (; !i.isDone(); i.next()) {
      i.currentSegment(coords);
      double segLen = Geom.length(prevX, prevY, coords[0], coords[1]);
      if (pos + segLen >= relativeLen) {
        //if (true) return new Point2D.Double(coords[0], coords[1]);
        // Compute the relative Point2D.Double on the line
        /*
        return new Point2D.Double(
        prevX * pos / len + coords[0] * (pos + segLen) / len,
        prevY * pos / len + coords[1] * (pos + segLen) / len
        );*/
        double factor = (relativeLen - pos) / segLen;
        return new Point2D.Double(
            prevX * (1 - factor) + coords[0] * factor,
            prevY * (1 - factor) + coords[1] * factor);
      }
      pos += segLen;
      prevX = coords[0];
      prevY = coords[1];
    }
    throw new InternalError("We should never get here");
###
1780, joinSegments, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1001, 1009
5
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the bezier path.
   * @return the index of the joined segment or -1 if no segment was joined.
   */
9
  public int joinSegments(Point2D.Double join, double tolerance) {
    for (int i = 0; i < size(); i++) {
      Node p = get(i);
      if (Geom.length(p.x[0], p.y[0], join.x, join.y) < tolerance) {
        remove(i);
        return i;
      }
    }
    return -1;
###
1781, outlineContains, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 400, 401
7
/**
   * Returns true, if the outline of this bezier path contains the specified
   * point.
   *
   * @param p The point to be tested.
   * @param tolerance The tolerance for the test.
   */
2
  public boolean outlineContains(Point2D.Double p, double tolerance) {
    return Shapes.outlineContains(this, p, tolerance);
###
1782, getCenter, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 692, 701
3
/**
   * Returns the point at the center of the bezier path.
   */
9
  public Point2D.Double getCenter() {
    double sx = 0;
    double sy = 0;
    for (Node p : this) {
      sx += p.x[0];
      sy += p.y[0];
    }
    int n = size();
    return new Point2D.Double(sx / n, sy / n);
###
1783, splitSegment, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 1016, 1037
4
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   */
22
  public int splitSegment(Point2D.Double split, double tolerance) {
    int i = findSegment(split, tolerance);
    int nextI = (i + 1) % size();
    if (i != -1) {
      if ((get(i).mask & C2_MASK) == C2_MASK
          && (get(nextI).mask & C1_MASK) == 0) {
        // quadto
        add(i + 1, new Node(C2_MASK, split, split, split));
      } else if ((get(i).mask & C2_MASK) == 0
          && (get(nextI).mask & C1_MASK) == C1_MASK) {
        // quadto
        add(i + 1, new Node(C1_MASK, split, split, split));
      } else if ((get(i).mask & C2_MASK) == C2_MASK
          && (get(nextI).mask & C1_MASK) == C1_MASK) {
        // cubicto
        add(i + 1, new Node(C1_MASK | C2_MASK, split, split, split));
      } else {
        // lineto
        add(i + 1, new Node(split));
      }
    }
    return i + 1;
###
1785, addAll, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 267, 269
7
/**
   * Convenience method for adding multiple control points with a single
   * coordinate C0.
   */
 --------------
/** Control point y coordinates. */
 --------------
3
  public void addAll(Collection<Point2D.Double> points) {
    for (Point2D.Double c0 : points) {
      add(new Node(0, c0, c0, c0));
###
1786, invalidatePath, BezierPath, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java, 295, 298
3
/**
   * This must be called after the BezierPath has been changed.
   */
4
  public void invalidatePath() {
    generalPath = null;
    bounds = null;
    outer = -1;
###
1787, mousePressed, TextAreaEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaEditingTool.java, 81, 85
4
/**
   * Creates a new figure at the mouse location.
   * If editing is in progress, this finishes editing.
   */
5
  @Override
  public void mousePressed(MouseEvent e) {
    if (typingTarget != null) {
      beginEdit(typingTarget);
      updateCursor(getView(), e.getPoint());
###
1788, TextAreaEditingTool, TextAreaEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaEditingTool.java, 67, 68
1
/** Creates a new instance. */
2
  public TextAreaEditingTool(TextHolderFigure typingTarget) {
    this.typingTarget = typingTarget;
###
1789, mousePressed, TextEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextEditingTool.java, 70, 74
3
/**
   * If the pressed figure is a TextHolderFigure it can be edited.
   */
5
  @Override
  public void mousePressed(MouseEvent e) {
    if (typingTarget != null) {
      beginEdit(typingTarget);
      updateCursor(getView(), e.getPoint());
###
1790, TextEditingTool, TextEditingTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextEditingTool.java, 57, 58
1
/** Creates a new instance. */
2
  public TextEditingTool(TextHolderFigure typingTarget) {
    this.typingTarget = typingTarget;
###
1791, reparameterize, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 559, 568
10
/**
   * Given set of points and their parameterization, try to find
   * a better parameterization.
   *
   * @param d  Array of digitized points.
   * @param first Indice of first point of region in d.
   * @param last Indice of last point of region in d.
   * @param u Current parameter values.
   * @param bezCurve Current fitted curve.
   */
9
  private static double[] reparameterize(ArrayList<Point2D.Double> d, int first, int last, double[] u, Point2D.Double[] bezCurve) {
    int nPts = last - first + 1;
    int i;
    double[] uPrime; /*  New parameter values  */
    uPrime = new double[nPts];
    for (i = first; i <= last; i++) {
      uPrime[i - first] = newtonRaphsonRootFind(bezCurve, d.get(i), u[i - first]);
    }
    return (uPrime);
###
1792, fitBezierPath, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 65, 66
9
/**
   * Fits a bezier path to the specified list of digitized points.
   * <p>
   * This is a convenience method for calling fitCubicSegments(List<Point2D.Double>, double);
   * 
   * @param digitizedPoints digited points.
   * @param error the maximal allowed error between the bezier path and the
   * digitized points. 
   */
2
  public static BezierPath fitBezierPath(Point2D.Double[] digitizedPoints, double error) {
    return fitBezierPath(Arrays.asList(digitizedPoints), error);
###
1793, fitBezierPath, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 146, 151
9
/**
   * Fits a bezier path to the specified list of digitized points.
   * <p>
   * This is a convenience method for calling fitCubicSegments(List<Point2D.Double>, double);
   * 
   * @param digitizedPoints digited points.
   * @param error the maximal allowed error between the bezier path and the
   * digitized points. 
   */
6
  public static BezierPath fitBezierPath(BezierPath digitizedPoints, double error) {
    ArrayList<Point2D.Double> d = new ArrayList<Point2D.Double>(digitizedPoints.size());
    for (BezierPath.Node n : digitizedPoints) {
      d.add(new Point2D.Double(n.x[0], n.y[0]));
    }
    return fitBezierPath(d, error);
###
1794, v2Length, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 762, 763
3
/**
   * Returns length of input vector.
   */
2
  private static double v2Length(Point2D.Double a) {
    return Math.sqrt(v2SquaredLength(a));
###
1795, reduceNoise, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 332, 350
15
/**
   * Reduces noise from the digitized points, by applying an approximation
   * of a gaussian filter to the data.
   * <p>
   * The filter does the following for each point P, with weight 0.5:
   * <p>
   * x[i] = 0.5*x[i] + 0.25*x[i-1] + 0.25*x[i+1];
   * y[i] = 0.5*y[i] + 0.25*y[i-1] + 0.25*y[i+1];
   * 
   * 
   * 
   * @param digitizedPoints Digitized points
   * @param weight Weight of the current point
   * @return Digitized points with reduced noise.
   */
19
  public static ArrayList<Point2D.Double> reduceNoise(java.util.List<Point2D.Double> digitizedPoints, double weight) {
    java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
    if (digitizedPoints.size() > 0) {
      Point2D.Double prev = digitizedPoints.get(0);
      cleaned.add(prev);
      double pnWeight = (1d - weight) / 2d; // weight of previous and next
      for (int i = 1, n = digitizedPoints.size() - 1; i < n; i++) {
        Point2D.Double cur = digitizedPoints.get(i);
        Point2D.Double next = digitizedPoints.get(i + 1);
        cleaned.add(new Point2D.Double(
            cur.x * weight + pnWeight * prev.x + pnWeight * next.x,
            cur.y * weight + pnWeight * prev.y + pnWeight * next.y));
        prev = cur;
      }
      if (digitizedPoints.size() > 1) {
        cleaned.add(digitizedPoints.get(digitizedPoints.size() - 1));
      }
    }
    return cleaned;
###
1796, chordLengthParameterize, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 530, 546
8
/**
   * Assign parameter values to digitized points
   * using relative distances between points.
   *
   * @param d Digitized points.
   * @param first Indice of first point of region in d.
   * @param last Indice of last point of region in d.
   */
13
  private static double[] chordLengthParameterize(ArrayList<Point2D.Double> d, int first, int last) {
    int i;
    double[] u;  /*  Parameterization    */
    u = new double[last - first + 1];
    u[0] = 0.0;
    for (i = first + 1; i <= last; i++) {
      u[i - first] = u[i - first - 1] +
          v2DistanceBetween2Points(d.get(i), d.get(i - 1));
    }
    for (i = first + 1; i <= last; i++) {
      u[i - first] = u[i - first] / u[last - first];
    }
    return (u);
###
1797, fitCubic, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 367, 451
14
/**
   * Fit one or multiple subsequent cubic bezier curves to a (sub)set of 
   * digitized points. The digitized points represent a smooth curve without
   * corners.
   *
   * @param d  Array of digitized points. Must not contain subsequent 
   * coincident points.
   * @param first Indice of first point in d.
   * @param last Indice of last point in d.
   * @param tHat1 Unit tangent vectors at start point.
   * @param tHat2 Unit tanget vector at end point.
   * @param errorSquared User-defined errorSquared squared.
   * @param bezierPath Path to which the bezier curve segments are added.
   */
75
  private static void fitCubic(ArrayList<Point2D.Double> d, int first, int last,
      Point2D.Double tHat1, Point2D.Double tHat2,
      double errorSquared, BezierPath bezierPath) {
    Point2D.Double[] bezCurve; /*Control points of fitted Bezier curve*/
    double[] u;    /*  Parameter values for point  */
    double maxError;  /*  Maximum fitting errorSquared   */
    int[] splitPoint = new int[1]; /*  Point to split point set at.
    This is an array of size one, because we need it as an input/output parameter.
     */
    int nPts;    /*  Number of points in subset  */
    double iterationError; /* Error below which you try iterating  */
    int maxIterations = 4; /*  Max times to try iterating  */
    Point2D.Double tHatCenter = new Point2D.Double(); /* Unit tangent vector at splitPoint */
    int i;
    // clone unit tangent vectors, so that we can alter their coordinates
    // without affecting the input values.
    tHat1 = (Point2D.Double) tHat1.clone();
    tHat2 = (Point2D.Double) tHat2.clone();
    iterationError = errorSquared * errorSquared;
    nPts = last - first + 1;
    /*  Use heuristic if region only has two points in it */
    if (nPts == 2) {
      double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;
      bezCurve = new Point2D.Double[4];
      for (i = 0; i < bezCurve.length; i++) {
        bezCurve[i] = new Point2D.Double();
      }
      bezCurve[0] = d.get(first);
      bezCurve[3] = d.get(last);
      v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);
      v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);
      bezierPath.curveTo(
          bezCurve[1].x, bezCurve[1].y,
          bezCurve[2].x, bezCurve[2].y,
          bezCurve[3].x, bezCurve[3].y);
      return;
    }
    /*  Parameterize points, and attempt to fit curve */
    u = chordLengthParameterize(d, first, last);
    bezCurve = generateBezier(d, first, last, u, tHat1, tHat2);
    /*  Find max deviation of points to fitted curve */
    maxError = computeMaxError(d, first, last, bezCurve, u, splitPoint);
    if (maxError < errorSquared) {
      addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);
      return;
    }

    /*  If errorSquared not too large, try some reparameterization  */
    /*  and iteration */
    if (maxError < iterationError) {
      double[] uPrime;  /*  Improved parameter values */
      for (i = 0; i < maxIterations; i++) {
        uPrime = reparameterize(d, first, last, u, bezCurve);
        bezCurve = generateBezier(d, first, last, uPrime, tHat1, tHat2);
        maxError = computeMaxError(d, first, last, bezCurve, uPrime, splitPoint);
        if (maxError < errorSquared) {
          addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);
          return;
        }
        u = uPrime;
      }
    }
    /* Fitting failed -- split at max errorSquared point and fit recursively */
    tHatCenter = computeCenterTangent(d, splitPoint[0]);
    if (first < splitPoint[0]) {
      fitCubic(d, first, splitPoint[0], tHat1, tHatCenter, errorSquared, bezierPath);
    } else {
      bezierPath.lineTo(d.get(splitPoint[0]).x, d.get(splitPoint[0]).y);
     //   System.err.println("Can't split any further " + first + ".." + splitPoint[0]);
    }
    v2Negate(tHatCenter);
    if (splitPoint[0] < last) {
      fitCubic(d, splitPoint[0], last, tHatCenter, tHat2, errorSquared, bezierPath);
    } else {
      bezierPath.lineTo(d.get(last).x, d.get(last).y);
###
1798, computeCenterTangent, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 510, 519
6
/**
   * Approximate unit tangents at "center" of digitized curve.
   *
   * @param d Digitized points.
   * @param center Index to "center" end of region.
   */
9
  private static Point2D.Double computeCenterTangent(ArrayList<Point2D.Double> d, int center) {
    Point2D.Double V1 = new Point2D.Double(), V2 = new Point2D.Double(),
        tHatCenter = new Point2D.Double();
    V1 = v2SubII(d.get(center - 1), d.get(center));
    V2 = v2SubII(d.get(center), d.get(center + 1));
    tHatCenter.x = (V1.x + V2.x) / 2.0;
    tHatCenter.y = (V1.y + V2.y) / 2.0;
    tHatCenter = v2Normalize(tHatCenter);
    return tHatCenter;
###
1799, v2SubII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 830, 834
7
/**
   * Subtract Vector a from Vector b.
   * 
   * @param a Vector a - the value is not changed by this method
   * @param b Vector b - the value is not changed by this method
   * @return Vector a subtracted by Vector v.
   */
5
  private static Point2D.Double v2SubII(Point2D.Double a, Point2D.Double b) {
    Point2D.Double c = new Point2D.Double();
    c.x = a.x - b.x;
    c.y = a.y - b.y;
    return (c);
###
1800, v2Normalize, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 813, 820
3
/**
   * Normalizes the input vector and returns it.
   */
7
  private static Point2D.Double v2Normalize(Point2D.Double v) {
    double len = v2Length(v);
    if (len != 0.0) {
      v.x /= len;
      v.y /= len;
    }
    return v;
###
1801, bezierII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 686, 706
7
/**
   * Evaluate a Bezier curve at a particular parameter value.
   *
   * @param degree  The degree of the bezier curve.
   * @param V  Array of control points.
   * @param t  Parametric value to find point for.
   */
18
  private static Point2D.Double bezierII(int degree, Point2D.Double[] V, double t) {
    int i, j;
    Point2D.Double q; /* Point on curve at parameter t  */
    Point2D.Double[] vTemp; /* Local copy of control points    */
    /* Copy array  */
    vTemp = new Point2D.Double[degree + 1];
    for (i = 0; i <= degree; i++) {
      vTemp[i] = (Point2D.Double) V[i].clone();
    }
    /* Triangle computation  */
    for (i = 1; i <= degree; i++) {
      for (j = 0; j <= degree - i; j++) {
        vTemp[j].x = (1.0 - t) * vTemp[j].x + t * vTemp[j + 1].x;
        vTemp[j].y = (1.0 - t) * vTemp[j].y + t * vTemp[j + 1].y;
      }
    }
    q = vTemp[0];
    return q;
###
1802, v2DistanceBetween2Points, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 719, 720
3
/**
   * Return the distance between two points
   */
2
  private static double v2DistanceBetween2Points(Point2D.Double a, Point2D.Double b) {
    return Math.sqrt(v2SquaredDistanceBetween2Points(a, b));
###
1804, v2Scale, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 737, 744
5
/**
   * Scales the input vector to the new length and returns it.
   * <p>
   * This method alters the value of the input point!
   */
7
  private static Point2D.Double v2Scale(Point2D.Double v, double newlen) {
    double len = v2Length(v);
    if (len != 0.0) {
      v.x *= newlen / len;
      v.y *= newlen / len;
    }
    return v;
###
1805, findCorners, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 264, 314
9
/**
   * Finds corners in the provided point list, and returns their indices.
   * 
   * @param digitizedPoints List of digitized points.
   * @param minAngle Minimal angle for corner points
   * @param minDistance Minimal distance between a point and adjacent points
   * for corner detection
   * @return list of corner indices.
   */
45
  public static ArrayList<Integer> findCorners(java.util.List<Point2D.Double> digitizedPoints, double minAngle, double minDistance) {
    ArrayList<Integer> cornerIndices = new ArrayList<Integer>();
    double squaredDistance = minDistance * minDistance;
    int previousCorner = -1;
    double previousCornerAngle = 0;
    for (int i = 1, n = digitizedPoints.size(); i < n - 1; i++) {
      Point2D.Double p = digitizedPoints.get(i);
      // search for a preceding point for corner detection
      Point2D.Double prev = null;
      boolean intersectsPreviousCorner = false;
      for (int j = i - 1; j >= 0; j--) {
        if (j == previousCorner || v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {
          prev = digitizedPoints.get(j);
          intersectsPreviousCorner = j < previousCorner;
          break;
        }
      }
      if (prev == null) {
        continue;
      }
      // search for a succeeding point for corner detection
      Point2D.Double next = null;
      for (int j = i + 1; j < n; j++) {
        if (v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {
          next = digitizedPoints.get(j);
          break;
        }
      }
      if (next == null) {
        continue;
      }
      double aPrev = Math.atan2(prev.y - p.y, prev.x - p.x);
      double aNext = Math.atan2(next.y - p.y, next.x - p.x);
      double angle = Math.abs(aPrev - aNext);
      if (angle < Math.PI - minAngle || angle > Math.PI + minAngle) {
        if (intersectsPreviousCorner) {
          cornerIndices.set(cornerIndices.size() - 1, i);
        } else {
          cornerIndices.add(i);
        }
        previousCorner = i;
        previousCornerAngle = angle;
      }
    }
    return cornerIndices;
###
1806, v2SquaredDistanceBetween2Points, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 726, 729
3
/**
   * Return the distance between two points
   */
4
  private static double v2SquaredDistanceBetween2Points(Point2D.Double a, Point2D.Double b) {
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return (dx * dx) + (dy * dy);
###
1807, computeRightTangent, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 497, 501
6
/**
   * Approximate unit tangents at "right" endpoint of digitized curve.
   *
   * @param d Digitized points.
   * @param end Index to "right" end of region.
   */
5
  private static Point2D.Double computeRightTangent(ArrayList<Point2D.Double> d, int end) {
    Point2D.Double tHat2 = new Point2D.Double();
    tHat2 = v2SubII(d.get(end - 1), d.get(end));
    tHat2 = v2Normalize(tHat2);
    return tHat2;
###
1808, v2Negate, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 797, 800
3
/**
   * Negates the input vector and returns it.
   */
4
  private static Point2D.Double v2Negate(Point2D.Double v) {
    v.x = -v.x;
    v.y = -v.y;
    return v;
###
1809, addCurveTo, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 462, 474
6
/**
   * Adds the curve to the bezier path.
   * 
   * @param bezCurve
   * @param bezierPath
   */
12
  private static void addCurveTo(Point2D.Double[] bezCurve, BezierPath bezierPath, double errorSquared, boolean connectsCorners) {
    BezierPath.Node lastNode = bezierPath.get(bezierPath.size() - 1);
    double error = Math.sqrt(errorSquared);
    if (connectsCorners && Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[1].x, bezCurve[1].y, error) &&
        Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[2].x, bezCurve[2].y, error)) {
      bezierPath.lineTo(
          bezCurve[3].x, bezCurve[3].y);
    } else {
      bezierPath.curveTo(
          bezCurve[1].x, bezCurve[1].y,
          bezCurve[2].x, bezCurve[2].y,
          bezCurve[3].x, bezCurve[3].y);
###
1810, splitAtCorners, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 238, 252
13
/**
   * Splits the digitized points into multiple segments at each corner point.
   * <p>
   * Corner points are both contained as the last point of a segment and
   * the first point of a subsequent segment.
   * 
   * @param digitizedPoints Digitized points 
   * @param maxAngle maximal angle in radians between the current point and its
   * predecessor and successor up to which the point does not break the
   * digitized list into segments. Recommended value 44 = 44 * 180d / Math.PI
   * @return Segments of digitized points, each segment having less than maximal
   * angle between points.
   */
13
  public static ArrayList<ArrayList<Point2D.Double>> splitAtCorners(java.util.List<Point2D.Double> digitizedPoints, double maxAngle, double minDistance) {
    ArrayList<Integer> cornerIndices = findCorners(digitizedPoints, maxAngle, minDistance);
    ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>(cornerIndices.size() + 1);
    if (cornerIndices.size() == 0) {
      segments.add(new ArrayList<Point2D.Double>(digitizedPoints));
    } else {
      segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(0, cornerIndices.get(0) + 1)));
      for (int i = 1; i < cornerIndices.size(); i++) {
        segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(i - 1), cornerIndices.get(i) + 1)));
      }
      segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(cornerIndices.size() - 1), digitizedPoints.size())));
    }
    return segments;
###
1811, v2Dot, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 806, 807
3
/**
   * Return the dot product of vectors a and b.
   */
2
  private static double v2Dot(Point2D.Double a, Point2D.Double b) {
    return (a.x * b.x) + (a.y * b.y);
###
1812, computeLeftTangent, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 484, 488
6
/**
   * Approximate unit tangents at "left" endpoint of digitized curve.
   *
   * @param d Digitized points.
   * @param end Index to "left" end of region.
   */
5
  private static Point2D.Double computeLeftTangent(ArrayList<Point2D.Double> d, int end) {
    Point2D.Double tHat1 = new Point2D.Double();
    tHat1 = v2SubII(d.get(end + 1), d.get(end));
    tHat1 = v2Normalize(tHat1);
    return tHat1;
###
1813, v2AddII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 787, 791
3
/**
   * Return vector sum = a+b.
   */
5
  private static Point2D.Double v2AddII(Point2D.Double a, Point2D.Double b) {
    Point2D.Double c = new Point2D.Double();
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c;
###
1814, generateBezier, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 660, 676
11
/**
   * Use least-squares method to find Bezier control points for region.
   *
   * @param d  Array of digitized points.
   * @param first Indice of first point in d.
   * @param last Indice of last point in d.
   * @param uPrime Parameter values for region .
   * @param tHat1 Unit tangent vectors at start point.
   * @param tHat2 Unit tanget vector at end point.
   * @return A cubic bezier curve consisting of 4 control points.
   */
14
  private static Point2D.Double[] generateBezier(ArrayList<Point2D.Double> d, int first, int last, double[] uPrime, Point2D.Double tHat1, Point2D.Double tHat2) {
    Point2D.Double[] bezCurve;
    bezCurve = new Point2D.Double[4];
    for (int i = 0; i < bezCurve.length; i++) {
      bezCurve[i] = new Point2D.Double();
    }

    /*  Use the Wu/Barsky heuristic*/
    double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;
    bezCurve[0] = d.get(first);
    bezCurve[3] = d.get(last);
    v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);
    v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);
    return (bezCurve);
###
1815, removeCoincidentPoints, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 210, 222
13
/**
   * Removes sequences of coincident points.
   * <p>
   * The purpose of this method, is to clean up a list of digitized points
   * for later processing using method {@link #splitAtCorners}.
   * <p>
   * Use this method only, if you know that the digitized points contain no
   * quantization errors - which is never the case, unless you want to debug
   * the curve fitting algorithm of this class.
   * 
   * @param digitizedPoints Digitized points
   * @return Digitized points without subsequent duplicates.
   */
13
  private static ArrayList<Point2D.Double> removeCoincidentPoints(java.util.List<Point2D.Double> digitizedPoints) {
    java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
    if (digitizedPoints.size() > 0) {
      Point2D.Double prev = digitizedPoints.get(0);
      cleaned.add(prev);
      for (Point2D.Double p : digitizedPoints) {
        if (!prev.equals(p)) {
          cleaned.add(p);
          prev = p;
        }
      }
    }
    return cleaned;
###
1816, v2SquaredLength, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 769, 770
3
/**
   * Returns squared length of input vector.
   */
2
  private static double v2SquaredLength(Point2D.Double a) {
    return (a.x * a.x) + (a.y * a.y);
###
1817, fitBezierPath, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 76, 134
7
/**
   * Fits a bezier path to the specified list of digitized points.
   * 
   * @param digitizedPoints digited points.
   * @param error the maximal allowed error between the bezier path and the
   * digitized points. 
   */
55
  public static BezierPath fitBezierPath(java.util.List<Point2D.Double> digitizedPoints, double error) {
    // Split into segments at corners
    ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>();
    segments = splitAtCorners(digitizedPoints, 77 / 180d * Math.PI, error * error);
    
    // Clean up the data in the segments
    for (int i = 0, n = segments.size(); i < n; i++) {
      ArrayList<Point2D.Double> seg = segments.get(i);
      seg = removeClosePoints(seg, error * 2);
      seg = reduceNoise(seg, 0.8);
      segments.set(i, seg);
    }

    // Create fitted bezier path
    BezierPath fittedPath = new BezierPath();

    // Quickly deal with empty dataset
    boolean isEmpty = false;
    for (ArrayList<Point2D.Double> seg : segments) {
      if (seg.isEmpty()) {
        isEmpty = false;
        break;
      }
    }
    if (!isEmpty) {
      // Process each segment of digitized points
      double errorSquared = error * error;
      for (ArrayList<Point2D.Double> seg : segments) {
        switch (seg.size()) {
          case 0:
            break;
          case 1:
            fittedPath.add(new BezierPath.Node(seg.get(0)));
            break;
          case 2:
            if (fittedPath.isEmpty()) {
              fittedPath.add(new BezierPath.Node(seg.get(0)));
            }
            fittedPath.lineTo(seg.get(1).x, seg.get(1).y);
            break;
          default:
            if (fittedPath.isEmpty()) {
              fittedPath.add(new BezierPath.Node(seg.get(0)));
            }
            /*  Unit tangent vectors at endpoints */
            Point2D.Double tHat1 = new Point2D.Double();
            Point2D.Double tHat2 = new Point2D.Double();
            tHat1 = computeLeftTangent(seg, 0);
            tHat2 = computeRightTangent(seg, seg.size() - 1);
            fitCubic(seg, 0, seg.size() - 1, tHat1, tHat2, errorSquared, fittedPath);
            break;
        }
      }
    }
    return fittedPath;
###
1818, v2ScaleIII, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 752, 756
5
/**
   * Scales the input vector by the specified factor and returns it.
   * <p>
   * This method alters the value of the input point!
   */
5
  private static Point2D.Double v2ScaleIII(Point2D.Double v, double s) {
    Point2D.Double result = new Point2D.Double();
    result.x = v.x * s;
    result.y = v.y * s;
    return result;
###
1819, computeMaxError, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 628, 646
12
/**
   * Find the maximum squared distance of digitized points
   * to fitted curve.
   *
   * @param d Digitized points.
   * @param first Indice of first point of region in d.
   * @param last Indice of last point of region in d.
   * @param bezCurve Fitted Bezier curve
   * @param u Parameterization of points*
   * @param splitPoint Point of maximum error (input/output parameter, must be
   * an array of 1)
   */
18
  private static double computeMaxError(ArrayList<Point2D.Double> d, int first, int last, Point2D.Double[] bezCurve, double[] u, int[] splitPoint) {
    int i;
    double maxDist;    /*  Maximum error */
    double dist;    /*  Current error */
    Point2D.Double P = new Point2D.Double(); /*  Point on curve */
    Point2D.Double v = new Point2D.Double(); /*  Vector from point to curve */
    splitPoint[0] = (last - first + 1) / 2;
    maxDist = 0.0;
    for (i = first + 1; i < last; i++) {
      P = bezierII(3, bezCurve, u[i - first]);
      v = v2SubII(P, d.get(i));
      dist = v2SquaredLength(v);
      if (dist >= maxDist) {
        maxDist = dist;
        splitPoint[0] = i;
      }
    }
    return (maxDist);
###
1820, removeClosePoints, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 173, 193
19
/**
   * Removes points which are closer together than the specified minimal 
   * distance.
   * <p>
   * The minimal distance should be chosen dependent on the size and resolution of the
   * display device, and on the sampling rate. A good value for mouse input
   * on a display with 100% Zoom factor is 2.
   * <p>
   * The purpose of this method, is to remove points, which add no additional
   * information about the shape of the curve from the list of digitized points.
   * <p>
   * The cleaned up set of digitized points gives better results, when used
   * as input for method {@link #splitAtCorners}.
   * 
   * @param digitizedPoints Digitized points
   * @param minDistance minimal distance between two points. If minDistance is
   * 0, this method only removes sequences of coincident points. 
   * @return Digitized points with a minimal distance.
   */
20
  public static ArrayList<Point2D.Double> removeClosePoints(java.util.List<Point2D.Double> digitizedPoints, double minDistance) {
    if (minDistance == 0) {
      return removeCoincidentPoints(digitizedPoints);
    } else {
      double squaredDistance = minDistance * minDistance;
      java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();
      if (digitizedPoints.size() > 0) {
        Point2D.Double prev = digitizedPoints.get(0);
        cleaned.add(prev);
        for (Point2D.Double p : digitizedPoints) {
          if (v2SquaredDistanceBetween2Points(prev, p) > squaredDistance) {
            cleaned.add(p);
            prev = p;
          }
        }
        if (!prev.equals(digitizedPoints.get(digitizedPoints.size() - 1))) {
          cleaned.set(cleaned.size() - 1, digitizedPoints.get(digitizedPoints.size() - 1));
        }
      }
      return cleaned;
###
1821, v2Add, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 778, 781
5
/**
   * Return vector sum c = a+b.
   * <p>
   * This method alters the value of c.
   */
4
  private static Point2D.Double v2Add(Point2D.Double a, Point2D.Double b, Point2D.Double c) {
    c.x = a.x + b.x;
    c.y = a.y + b.y;
    return c;
###
1822, newtonRaphsonRootFind, Bezier, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java, 578, 613
7
/**
   * Use Newton-Raphson iteration to find better root.
   *
   * @param Q  Current fitted bezier curve.
   * @param P  Digitized point.
   * @param u  Parameter value vor P.
   */
30
  private static double newtonRaphsonRootFind(Point2D.Double[] Q, Point2D.Double P, double u) {
    double numerator, denominator;
    Point2D.Double[] Q1 = new Point2D.Double[3], Q2 = new Point2D.Double[2];  /*  Q' and Q''      */
    Point2D.Double Q_u = new Point2D.Double(), Q1_u = new Point2D.Double(), Q2_u = new Point2D.Double(); /*u evaluated at Q, Q', & Q''  */
    double uPrime;    /*  Improved u  */
    int i;
    /* Compute Q(u)  */
    Q_u = bezierII(3, Q, u);
    /* Generate control vertices for Q'  */
    for (i = 0; i <= 2; i++) {
      Q1[i] = new Point2D.Double(
          (Q[i + 1].x - Q[i].x) * 3.0,
          (Q[i + 1].y - Q[i].y) * 3.0);
    }
    /* Generate control vertices for Q'' */
    for (i = 0; i <= 1; i++) {
      Q2[i] = new Point2D.Double(
          (Q1[i + 1].x - Q1[i].x) * 2.0,
          (Q1[i + 1].y - Q1[i].y) * 2.0);
    }
    /* Compute Q'(u) and Q''(u)  */
    Q1_u = bezierII(2, Q1, u);
    Q2_u = bezierII(1, Q2, u);
    /* Compute f(u)/f'(u) */
    numerator = (Q_u.x - P.x) * (Q1_u.x) + (Q_u.y - P.y) * (Q1_u.y);
    denominator = (Q1_u.x) * (Q1_u.x) + (Q1_u.y) * (Q1_u.y) +
        (Q_u.x - P.x) * (Q2_u.x) + (Q_u.y - P.y) * (Q2_u.y);
    /* u = u - f(u)/f'(u) */
    uPrime = u - (numerator / denominator);
    return (uPrime);
###
1823, isDone, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 80, 81
4
/**
   * Tests if there are more points to read.
   * @return true if there are more points to read
   */
2
  public boolean isDone() {
    return (index >= path.size() + (path.isClosed() ? 2 : 0));
###
1824, getWindingRule, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 72, 73
6
/**
   * Return the winding rule for determining the interior of the
   * path.
   * @see PathIterator#WIND_EVEN_ODD
   * @see PathIterator#WIND_NON_ZERO
   */
2
  public int getWindingRule() {
    return path.getWindingRule();
###
1825, currentSegment, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 113, 210
18
/**
   * Returns the coordinates and type of the current path segment in
   * the iteration.
   * The return value is the path segment type:
   * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
   * A float array of length 6 must be passed in and may be used to
   * store the coordinates of the point(s).
   * Each point is stored as a pair of float x,y coordinates.
   * SEG_MOVETO and SEG_LINETO types will return one point,
   * SEG_QUADTO will return two points,
   * SEG_CUBICTO will return 3 points
   * and SEG_CLOSE will not return any points.
   * @see PathIterator#SEG_MOVETO
   * @see PathIterator#SEG_LINETO
   * @see PathIterator#SEG_QUADTO
   * @see PathIterator#SEG_CUBICTO
   * @see PathIterator#SEG_CLOSE
   */
98
  public int currentSegment(float[] coords) {
    int numCoords = 0;
    int type = 0;
    if (index == path.size()) {
      // We only get here for closed paths
      if (path.size() > 1) {
        BezierPath.Node previous = path.get(path.size() - 1);
        BezierPath.Node current = path.get(0);
        
        if ((previous.mask & BezierPath.C2_MASK) == 0) {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 1;
            type = SEG_LINETO;
            coords[0] = (float) current.x[0];
            coords[1] = (float) current.y[0];
          } else {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = (float) current.x[1];
            coords[1] = (float) current.y[1];
            coords[2] = (float) current.x[0];
            coords[3] = (float) current.y[0];
          }
        } else {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = (float) previous.x[2];
            coords[1] = (float) previous.y[2];
            coords[2] = (float) current.x[0];
            coords[3] = (float) current.y[0];
          } else {
            numCoords = 3;
            type = SEG_CUBICTO;
            coords[0] = (float) previous.x[2];
            coords[1] = (float) previous.y[2];
            coords[2] = (float) current.x[1];
            coords[3] = (float) current.y[1];
            coords[4] = (float) current.x[0];
            coords[5] = (float) current.y[0];
          }
        }
      }
    } else if (index > path.size()) {
      // We only get here for closed paths
      return SEG_CLOSE;
    } else if (index == 0) {
      BezierPath.Node current = path.get(index);
      coords[0] = (float) current.x[0];
      coords[1] = (float) current.y[0];
      numCoords = 1;
      type = SEG_MOVETO;
      
    } else if (index < path.size()) {
      BezierPath.Node current = path.get(index);
      BezierPath.Node previous = path.get(index - 1);
      
      if ((previous.mask & BezierPath.C2_MASK) == 0) {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 1;
          type = SEG_LINETO;
          coords[0] = (float) current.x[0];
          coords[1] = (float) current.y[0];
          
        } else {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = (float) current.x[1];
          coords[1] = (float) current.y[1];
          coords[2] = (float) current.x[0];
          coords[3] = (float) current.y[0];
        }
      } else {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = (float) previous.x[2];
          coords[1] = (float) previous.y[2];
          coords[2] = (float) current.x[0];
          coords[3] = (float) current.y[0];
        } else {
          numCoords = 3;
          type = SEG_CUBICTO;
          coords[0] = (float) previous.x[2];
          coords[1] = (float) previous.y[2];
          coords[2] = (float) current.x[1];
          coords[3] = (float) current.y[1];
          coords[4] = (float) current.x[0];
          coords[5] = (float) current.y[0];
        }
      }
    }
    
    
    if (affine != null) {
      affine.transform(coords, 0, coords, 0, numCoords);
    }
    return type;
###
1826, next, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 89, 91
5
/**
   * Moves the iterator to the next segment of the path forwards
   * along the primary direction of traversal as long as there are
   * more points in that direction.
   */
3
  public void next() {
    if (! isDone()) {
      index++;
###
1827, BezierPathIterator, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 61, 63
5
/**
   * Constructs an iterator given a BezierPath and an optional
   * AffineTransform.
   * @see BezierPath#getPathIterator
   */
3
  public BezierPathIterator(BezierPath path, AffineTransform at) {
    this.path = path;
    this.affine = at;
###
1828, currentSegment, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 231, 330
18
/**
   * Returns the coordinates and type of the current path segment in
   * the iteration.
   * The return value is the path segment type:
   * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
   * A double array of length 6 must be passed in and may be used to
   * store the coordinates of the point(s).
   * Each point is stored as a pair of double x,y coordinates.
   * SEG_MOVETO and SEG_LINETO types will return one point,
   * SEG_QUADTO will return two points,
   * SEG_CUBICTO will return 3 points
   * and SEG_CLOSE will not return any points.
   * @see PathIterator#SEG_MOVETO
   * @see PathIterator#SEG_LINETO
   * @see PathIterator#SEG_QUADTO
   * @see PathIterator#SEG_CUBICTO
   * @see PathIterator#SEG_CLOSE
   */
100
  public int currentSegment(double[] coords) {
    int numCoords = 0;
    int type = 0;
    if (index == path.size()) {
      // We only get here for closed paths
      if (path.size() > 1) {
        BezierPath.Node previous = path.get(path.size() - 1);
        BezierPath.Node current = path.get(0);
        
        if ((previous.mask & BezierPath.C2_MASK) == 0) {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 1;
            type = SEG_LINETO;
            coords[0] = current.x[0];
            coords[1] = current.y[0];
          } else {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = current.x[1];
            coords[1] = current.y[1];
            coords[2] = current.x[0];
            coords[3] = current.y[0];
          }
        } else {
          if ((current.mask & BezierPath.C1_MASK) == 0) {
            numCoords = 2;
            type = SEG_QUADTO;
            coords[0] = previous.x[2];
            coords[1] = previous.y[2];
            coords[2] = current.x[0];
            coords[3] = current.y[0];
          } else {
            numCoords = 3;
            type = SEG_CUBICTO;
            coords[0] = previous.x[2];
            coords[1] = previous.y[2];
            coords[2] = current.x[1];
            coords[3] = current.y[1];
            coords[4] = current.x[0];
            coords[5] = current.y[0];
          }
        }
      }
    } else if (index > path.size()) {
      // We only get here for closed paths
      return SEG_CLOSE;
    } else if (index == 0) {
      BezierPath.Node current = path.get(index);
      coords[0] = current.x[0];
      coords[1] = current.y[0];
      numCoords = 1;
      type = SEG_MOVETO;
      
    } else if (index < path.size()) {
      BezierPath.Node current = path.get(index);
      BezierPath.Node previous = path.get(index - 1);
      
      if ((previous.mask & BezierPath.C2_MASK) == 0) {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 1;
          type = SEG_LINETO;
          coords[0] = current.x[0];
          coords[1] = current.y[0];
          
        } else {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = current.x[1];
          coords[1] = current.y[1];
          coords[2] = current.x[0];
          coords[3] = current.y[0];
        }
      } else {
        if ((current.mask & BezierPath.C1_MASK) == 0) {
          numCoords = 2;
          type = SEG_QUADTO;
          coords[0] = previous.x[2];
          coords[1] = previous.y[2];
          coords[2] = current.x[0];
          coords[3] = current.y[0];
        } else {
          numCoords = 3;
          type = SEG_CUBICTO;
          coords[0] = previous.x[2];
          coords[1] = previous.y[2];
          coords[2] = current.x[1];
          coords[3] = current.y[1];
          coords[4] = current.x[0];
          coords[5] = current.y[0];
        }
      }
    }
    
    
    if (affine != null) {
      affine.transform(coords, 0, coords, 0, numCoords);
    } else {
      System.arraycopy(coords, 0, coords, 0, numCoords);
    }
    return type;
###
1829, BezierPathIterator, BezierPathIterator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java, 52, 53
4
/**
   * Constructs an iterator given a BezierPath.
   * @see BezierPath#getPathIterator
   */
2
  public BezierPathIterator(BezierPath path) {
    this(path, null);
###
1830, getConvexHullPolygon, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 40, 45
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points as a polygon object.
   */
6
  public static Polygon getConvexHullPolygon(List<Point> points) {
    Polygon convexHull = new Polygon();
    for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {
      convexHull.addPoint(p.x, p.y);
    }
    return convexHull;
###
1831, getConvexHullPath2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 54, 59
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points as a Polygon2D object.
   */
6
  public static Polygon2D.Double getConvexHullPath2D(List<Point2D.Double> points) {
    Polygon2D.Double convexHull = new Polygon2D.Double();
    for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {
      convexHull.add(p);
    }
    return convexHull;
###
1832, getConvexHull2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 114, 115
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
2
  public static List<Point2D.Double> getConvexHull2D(List<Point2D.Double> points) {
    return Arrays.asList(getConvexHull2D(points.toArray(new Point2D.Double[points.size()])));
###
1833, getConvexHull, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 124, 169
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
40
  public static Point[] getConvexHull(Point[] points) {
    // Quickly return if no work is needed
    if (points.length < 3) {
      return points.clone();
    }
    // Sort points from left to right O(n log n)
    Point[] sorted = points.clone();
    Arrays.sort(sorted, new Comparator<Point>() {
      public int compare(Point o1, Point o2) {
        int v = o1.x - o2.x;
        return (v == 0) ? o1.y - o2.y : v;
      }
    });
    Point[] hull = new Point[sorted.length + 2];
    // Process upper part of convex hull O(n)
    int upper = 0; // Number of points in upper part of convex hull
    hull[upper++] = sorted[0];
    hull[upper++] = sorted[1];
    for (int i = 2; i < sorted.length; i++) {
      hull[upper++] = sorted[i];
      while (upper > 2 && !isRightTurn(hull[upper - 3], hull[upper - 2], hull[upper - 1])) {
        hull[upper - 2] = hull[upper - 1];
        upper--;
      }
    }
    // Process lower part of convex hull O(n)
    int lower = upper; // (lower - number + 1) = number of points in the lower part of the convex hull
    hull[lower++] = sorted[sorted.length - 2];
    for (int i = sorted.length - 3; i >= 0; i--) {
      hull[lower++] = sorted[i];
      while (lower - upper > 1 && !isRightTurn(hull[lower - 3], hull[lower - 2], hull[lower - 1])) {
        hull[lower - 2] = hull[lower - 1];
        lower--;
      }
    }
    lower -= 1;
    // Reduce array
    Point[] convexHull = new Point[lower];
    System.arraycopy(hull, 0, convexHull, 0, lower);
    return convexHull;
###
1834, getConvexHull2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 195, 242
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
43
  public static Point2D.Double[] getConvexHull2D(Point2D.Double[] points) {
    // Quickly return if no work is needed
    if (points.length < 3) {
      return points.clone();
    }
    // Sort points from left to right O(n log n)
    Point2D.Double[] sorted = points.clone();
    Arrays.sort(sorted, new Comparator<Point2D.Double>() {
      public int compare(Point2D.Double o1, Point2D.Double o2) {
        double v = o1.x - o2.x;
        if (v == 0) {
          v = o1.y - o2.y;
        }
        return (v > 0) ? 1 : ((v < 0) ? -1 : 0);
      }
    });
    Point2D.Double[] hull = new Point2D.Double[sorted.length + 2];
    // Process upper part of convex hull O(n)
    int upper = 0; // Number of points in upper part of convex hull
    hull[upper++] = sorted[0];
    hull[upper++] = sorted[1];
    for (int i = 2; i < sorted.length; i++) {
      hull[upper++] = sorted[i];
      while (upper > 2 && !isRightTurn2D(hull[upper - 3], hull[upper - 2], hull[upper - 1])) {
        hull[upper - 2] = hull[upper - 1];
        upper--;
      }
    }
    // Process lower part of convex hull O(n)
    int lower = upper; // (lower - number + 1) = number of points in the lower part of the convex hull
    hull[lower++] = sorted[sorted.length - 2];
    for (int i = sorted.length - 3; i >= 0; i--) {
      hull[lower++] = sorted[i];
      while (lower - upper > 1 && !isRightTurn2D(hull[lower - 3], hull[lower - 2], hull[lower - 1])) {
        hull[lower - 2] = hull[lower - 1];
        lower--;
      }
    }
    lower -= 1;
    // Reduce array
    Point2D.Double[] convexHull = new Point2D.Double[lower];
    System.arraycopy(hull, 0, convexHull, 0, lower);
    return convexHull;
###
1835, getConvexHull, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 104, 105
6
/**
   * Computes the convex hull from a set of points.
   *
   * @param points
   * @return convex hull of the points
   */
2
  public static List<Point> getConvexHull(List<Point> points) {
    return Arrays.asList(getConvexHull(points.toArray(new Point[points.size()])));
###
1836, isRightTurn2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 253, 260
8
/**
   * Returns true, if the three given points make a right turn.
   *
   * @param p1 first point
   * @param p2 second point
   * @param p3 third point
   * @return true if right turn.
   */
8
  public static boolean isRightTurn2D(Point.Double p1, Point.Double p2, Point.Double p3) {
    if (p1.equals(p2)||p2.equals(p3)) {
      // no right turn if points are at same location
      return false;
    }
    
    double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);
    return val > 0;
###
1837, isRightTurn, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 180, 186
8
/**
   * Returns true, if the three given points make a right turn.
   * 
   * @param p1 first point
   * @param p2 second point
   * @param p3 third point
   * @return true if right turn.
   */
7
  public static boolean isRightTurn(Point p1, Point p2, Point p3) {
    if (p1.equals(p2)||p2.equals(p3)) {
      // no right turn if points are at same location
      return false;
    }
    double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);
    return val > 0;
###
1838, getConvexHullPath2D, ConvexHull, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java, 68, 95
6
/**
   * Computes the convex hull from a shape.
   *
   * @param shape an arbitray shape
   * @return convex hull of the points as a Polygon2D object.
   */
27
  public static Polygon2D.Double getConvexHullPath2D(Shape shape) {
    List<Point2D.Double> points = new LinkedList<Point2D.Double>();
    double[] coords = new double[6];
    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {
      switch (i.currentSegment(coords)) {
        case PathIterator.SEG_CLOSE:
          break;
        case PathIterator.SEG_MOVETO:
        case PathIterator.SEG_LINETO:
          points.add(new Point2D.Double(coords[0], coords[1]));
          break;
        case PathIterator.SEG_QUADTO:
          points.add(new Point2D.Double(coords[0], coords[1]));
          points.add(new Point2D.Double(coords[2], coords[3]));
          break;
        case PathIterator.SEG_CUBICTO:
          points.add(new Point2D.Double(coords[0], coords[1]));
          points.add(new Point2D.Double(coords[2], coords[3]));
          points.add(new Point2D.Double(coords[4], coords[5]));
          break;
      }
    }
    Polygon2D.Double convexHull = new Polygon2D.Double();
    for (Point2D.Double p : getConvexHull2D(points.toArray(new Point2D.Double[points.size()]))) {
      convexHull.add(p);
    }
    return convexHull;
###
1839, setDragTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 364, 365
4
/**
   * Method to set a {@code DragTracker}. If you specify null, the
   * {@code SelectionTool} uses the {@code DefaultDragTracker}.
   */
2
  public void setDragTracker(DragTracker newValue) {
    dragTracker = newValue;
###
1840, setHandleTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 348, 349
4
/**
   * Method to set a {@code HandleTracker}. If you specify null, the
   * {@code SelectionTool} uses the {@code DefaultHandleTracker}.
   */
2
  public void setHandleTracker(HandleTracker newValue) {
    handleTracker = newValue;
###
1841, setSelectAreaTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 356, 357
4
/**
   * Method to set a {@code SelectAreaTracker}. If you specify null, the
   * {@code SelectionTool} uses the {@code DefaultSelectAreaTracker}.
   */
2
  public void setSelectAreaTracker(SelectAreaTracker newValue) {
    selectAreaTracker = newValue;
###
1842, setSelectBehindEnabled, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 142, 145
6
/**
   * Sets the selectBehindEnabled property.
   * This is a bound property.
   *
   * @param newValue The new value.
   */
4
  public void setSelectBehindEnabled(boolean newValue) {
    boolean oldValue = isSelectBehindEnabled;
    isSelectBehindEnabled = newValue;
    firePropertyChange(SELECT_BEHIND_ENABLED_PROPERTY, oldValue, newValue);
###
1843, getHandleTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 313, 318
4
/**
   * Method to get a {@code HandleTracker} which handles user interaction
   * for the specified handle.
   */
6
  protected HandleTracker getHandleTracker(Handle handle) {
    if (handleTracker == null) {
      handleTracker = new DefaultHandleTracker();
    }
    handleTracker.setHandles(handle, getView().getCompatibleHandles(handle));
    return handleTracker;
###
1844, getDragTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 325, 330
4
/**
   * Method to get a {@code DragTracker} which handles user interaction
   * for dragging the specified figure.
   */
6
  protected DragTracker getDragTracker(Figure f) {
    if (dragTracker == null) {
      dragTracker = new DefaultDragTracker();
    }
    dragTracker.setDraggedFigure(f);
    return dragTracker;
###
1845, SelectionTool, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 130, 133
1
/** Creates a new instance. */
4
  public SelectionTool() {
    tracker = getSelectAreaTracker();
    trackerHandler = new TrackerHandler();
    tracker.addToolListener(trackerHandler);
###
1846, isSelectBehindEnabled, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 154, 155
6
/**
   * Returns the value of the selectBehindEnabled property.
   * This is a bound property.
   *
   * @return The property value.
   */
2
  public boolean isSelectBehindEnabled() {
    return isSelectBehindEnabled;
###
1847, getSelectAreaTracker, SelectionTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java, 337, 341
4
/**
   * Method to get a {@code SelectAreaTracker} which handles user interaction
   * for selecting an area on the drawing.
   */
5
  protected SelectAreaTracker getSelectAreaTracker() {
    if (selectAreaTracker == null) {
      selectAreaTracker = new DefaultSelectAreaTracker();
    }
    return selectAreaTracker;
###
1861, main, DefaultDOMStorableSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/DefaultDOMStorableSample.java, 62, 89
1
/** DOM Storable objects must have a non-argument constructor. */
22
  public static void main(String[] args) {
    try {
      // Set up the DefaultDOMFactory
      DefaultDOMFactory factory = new DefaultDOMFactory();
      factory.addStorableClass("MyElementName", MyObject.class);
      // Create a DOMStorable object
      MyObject obj = new MyObject("Hello World");
      System.out.println("The name of the original object is:" + obj.getName());
      // Write the object into a DOM, and then serialize the DOM into a String
      NanoXMLDOMOutput out = new NanoXMLDOMOutput(factory);
      out.writeObject(obj);
      StringWriter writer = new StringWriter();
      out.save(writer);
      String serializedString = writer.toString();
      System.out.println("\nThe serialized representation of the object is:\n" + serializedString);
      // Deserialize a DOM from a String, and then read the object from the DOM
      StringReader reader = new StringReader(serializedString);
      NanoXMLDOMInput in = new NanoXMLDOMInput(factory, reader);
      MyObject obj2 = (MyObject) in.readObject();
      System.out.println("\nThe name of the restored object is:" + obj2.getName());
    } catch (IOException ex) {
      Logger.getLogger(DefaultDOMStorableSample.class.getName()).log(Level.SEVERE, null, ex);
###
1862, main, MovableChildFiguresSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/MovableChildFiguresSample.java, 73, 102
3
/**
     * Return default handles from the presentation figure.
     */
27
  public static void main(String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        // Create a simple drawing consisting of three
        // text areas and an elbow connection.
        LabeledEllipseFigure ta = new LabeledEllipseFigure();
        ta.setBounds(new Point2D.Double(10, 10), new Point2D.Double(100, 100));
        LabeledEllipseFigure tb = new LabeledEllipseFigure();
        tb.setBounds(new Point2D.Double(220, 120), new Point2D.Double(310, 210));
        LabeledEllipseFigure tc = new LabeledEllipseFigure();
        tc.setBounds(new Point2D.Double(220, 10), new Point2D.Double(310, 100));
        Drawing drawing = new DefaultDrawing();
        drawing.add(ta);
        drawing.add(tb);
        drawing.add(tc);
        // Create a frame with a drawing view and a drawing editor
        JFrame f = new JFrame("My Drawing");
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.setSize(400, 300);
        DrawingView view = new DefaultDrawingView();
        view.setDrawing(drawing);
        f.add(view.getComponent());
        f.add(new JLabel("Press space bar to toggle handles."), BorderLayout.SOUTH);
        DrawingEditor editor = new DefaultDrawingEditor();
        editor.add(view);
        editor.setTool(new DelegationSelectionTool());
        f.setVisible(true);
###
1863, createDrawing, MultiEditorSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/MultiEditorSample.java, 103, 109
6
/**
   * Creates a drawing with input and output formats, so that drawing figures
   * can be copied and pasted between drawing views.
   * 
   * @return a drawing
   */
7
  private static Drawing createDrawing() {
    // Create a default drawing with
    // input/output formats for basic clipboard support.
    DefaultDrawing drawing = new DefaultDrawing();
    drawing.addInputFormat(new SerializationInputOutputFormat());
    drawing.addOutputFormat(new SerializationInputOutputFormat());
    return drawing;
###
1864, createDrawing, DnDMultiEditorSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/DnDMultiEditorSample.java, 110, 117
6
/**
   * Creates a drawing with input and output formats, so that drawing figures
   * can be copied and pasted between drawing views.
   * 
   * @return a drawing
   */
8
  private static Drawing createDrawing() {
    // Create a default drawing with
    // input/output formats for basic clipboard support.
    DefaultDrawing drawing = new DefaultDrawing();
    drawing.addInputFormat(new SerializationInputOutputFormat());
    drawing.addOutputFormat(new SerializationInputOutputFormat());
    drawing.addOutputFormat(new ImageOutputFormat());
    return drawing;
###
1865, read, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 172, 207
3
/**
   * Reads the view from the specified uri.
   */
33
  public void read(URI f, URIChooser fc) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      boolean success = false;
        for (InputFormat sfi : drawing.getInputFormats()) {
            try {
              sfi.read(new File(f), drawing, true);
              success = true;
              break;
            } catch (Exception e) {
            // try with the next input format
            }
          }
      if (!success) {
        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
        throw new IOException(labels.getFormatted("file.open.unsupportedFileFormat.message", URIUtil.getName(f)));
      }
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(drawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
1866, write, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 163, 166
3
/**
   * Writes the view to the specified uri.
   */
4
  public void write(URI f, URIChooser fc) throws IOException {
    Drawing drawing = view.getDrawing();
    OutputFormat outputFormat = drawing.getOutputFormats().get(0);
    outputFormat.write(new File(f), drawing);
###
1868, getEditor, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 228, 229
3
/**
   * Gets the drawing editor of the view.
   */
2
  public DrawingEditor getEditor() {
    return editor;
###
1869, setEditor, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 215, 221
3
/**
   * Sets a drawing editor for the view.
   */
7
  public void setEditor(DrawingEditor newValue) {
    if (editor != null) {
      editor.remove(view);
    }
    editor = newValue;
    if (editor != null) {
      editor.add(view);
###
1870, initComponents, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 264, 275
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
8
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
###
1871, init, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 79, 114
3
/**
   * Initializes the view.
   */
36
  public void init() {
    super.init();
    
    initComponents();
    
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0,0,0,0));
    
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
###
1872, initActions, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 151, 153
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
1873, createPageable, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 142, 143
3
/**
   * Creates a Pageable object for printing the view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
1874, clear, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 235, 249
3
/**
   * Clears the view.
   */
15
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
1875, createDrawing, DrawView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java, 120, 135
3
/**
   * Creates a new Drawing for this view.
   */
16
  protected Drawing createDrawing() {
    Drawing drawing = new QuadTreeDrawing();
    DOMStorableInputOutputFormat ioFormat =
        new DOMStorableInputOutputFormat(new DrawFigureFactory());
    
    drawing.addInputFormat(ioFormat);
    ImageFigure prototype = new ImageFigure();
    drawing.addInputFormat(new ImageInputFormat(prototype));
    drawing.addInputFormat(new TextInputFormat(new TextFigure()));
    TextAreaFigure taf = new TextAreaFigure();
    taf.setBounds(new Point2D.Double(10,10), new Point2D.Double(60,40));
    drawing.addInputFormat(new TextInputFormat(taf));
    
    drawing.addOutputFormat(ioFormat);
    drawing.addOutputFormat(new ImageOutputFormat());
    return drawing;
###
1876, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/Main.java, 28, 49
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    ResourceBundleUtil.setVerbose(true);
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    
    DrawApplicationModel model = new DrawApplicationModel();
    model.setName("JHotDraw Draw");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2009 (c) by the authors of JHotDraw and all its contributors.\n" +
        "This software is licensed under LGPL or Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.draw.DrawView");
    app.setModel(model);
    app.launch(args);
###
1877, AnimationSample, AnimationSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/AnimationSample.java, 33, 56
1
/** Creates new form AnimationSample */
22
  public AnimationSample() {
    initComponents();
    DefaultDrawingView view = new DefaultDrawingView();
    view.setDrawingDoubleBuffered(false);
    add(view);
    setSize(400, 400);
    Drawing d = new DefaultDrawing();
    d.set(CANVAS_FILL_COLOR, new Color(0x76a9d2));
    final EllipseFigure ellipse = new EllipseFigure(160, 160, 80, 80);
    ellipse.set(STROKE_WIDTH, 7d);
    d.add(ellipse);
    view.setDrawing(d);
    Timer t = new Timer(10, new ActionListener() {
      public void actionPerformed(ActionEvent e) {
        double alpha = 2d * Math.PI * (System.currentTimeMillis() % 1000) / 1000d;
        ellipse.willChange();
        ellipse.setBounds(new Rectangle2D.Double(160 + Math.sin(alpha) * 100, 160 + Math.cos(alpha) * 100, 80, 80));
        ellipse.changed();
      }
    });
    t.setRepeats(true);
    t.start();
###
1878, initComponents, AnimationSample, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/AnimationSample.java, 64, 70
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
5
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
    pack();
###
1879, FontChooserMain, FontChooserMain, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/font/FontChooserMain.java, 29, 31
1
/** Creates new form FontChooserMain */
3
  public FontChooserMain() {
    initComponents();
    add(new JFontChooser());
###
1880, initComponents, FontChooserMain, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/font/FontChooserMain.java, 56, 60
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
4
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    setLayout(new java.awt.BorderLayout());
###
1881, getEventSetDescriptors, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1882, getPropertyDescriptors, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1883, getDefaultPropertyIndex, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1886, getBeanDescriptor, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1888, getDefaultEventIndex, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1889, getMethodDescriptors, DrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java, 127, 128
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1891, initComponents, DrawLiveConnectApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawLiveConnectApplet.java, 206, 228
5
/** This method is called from within the init() method to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
16
  private void initComponents() {//GEN-BEGIN:initComponents
    toolButtonGroup = new javax.swing.ButtonGroup();
    drawingPanel = new org.jhotdraw.samples.draw.DrawingPanel();
    jToolBar1 = new javax.swing.JToolBar();
    loadButton = new javax.swing.JButton();
    saveButton = new javax.swing.JButton();
    FormListener formListener = new FormListener();
    getContentPane().add(drawingPanel, java.awt.BorderLayout.CENTER);
    jToolBar1.setFloatable(false);
    loadButton.setText("Laden");
    loadButton.addActionListener(formListener);
    jToolBar1.add(loadButton);
    saveButton.setText("Speichern");
    saveButton.addActionListener(formListener);
    jToolBar1.add(saveButton);
    getContentPane().add(jToolBar1, java.awt.BorderLayout.SOUTH);
###
1893, init, DrawLiveConnectApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawLiveConnectApplet.java, 41, 136
1
/** Initializes the applet DrawApplet */
86
  public void init() {
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Display copyright info while we are loading the data
    // ----------------------------------------------------
    Container c = getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
    String[] lines = getAppletInfo().split("\n");//Strings.split(getAppletInfo(), '\n');
    for (int i = 0; i < lines.length; i++) {
      c.add(new JLabel(lines[i]));
    }
    // We load the data using a worker thread
    // --------------------------------------
    new Worker<Drawing>() {
      protected Drawing construct() throws IOException {
        Drawing result;
        if (getParameter("data") != null && getParameter("data").length() > 0) {
          NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), new StringReader(getParameter("data")));
          result = (Drawing) domi.readObject(0);
        } else if (getParameter("datafile") != null) {
          InputStream in = null;
          try {
            URL url = new URL(getDocumentBase(), getParameter("datafile"));
            in = url.openConnection().getInputStream();
            NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), in);
            result = (Drawing) domi.readObject(0);
          } finally {
            if (in != null) {
              in.close();
            }
          }
        } else {
          result = null;
        }
        return result;
      }
      protected void done(Drawing result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        initComponents();
        if (result != null) {
          setDrawing(result);
        }
      }
      @Override
      protected void failed(Throwable result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        initComponents();
        getDrawing().add(new TextFigure(result.toString()));
        result.printStackTrace();
      }
      protected void finished() {
        Container c = getContentPane();
        boolean isLiveConnect;
        try {
          Class.forName("netscape.javascript.JSObject");
          isLiveConnect = true;
        } catch (Throwable t) {
          isLiveConnect = false;
        }
        loadButton.setEnabled(isLiveConnect && getParameter("dataread") != null);
        saveButton.setEnabled(isLiveConnect && getParameter("datawrite") != null);
        if (isLiveConnect) {
          String methodName = getParameter("dataread");
          if (methodName.indexOf('(') > 0) {
            methodName = methodName.substring(0, methodName.indexOf('(') - 1);
          }
          JSObject win = JSObject.getWindow(DrawLiveConnectApplet.this);
          Object data = win.call(methodName, new Object[0]);
          if (data instanceof String) {
            setData((String) data);
          }
        }
        c.validate();
      }
    }.start();
###
1894, initComponents, BezierDemo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/BezierDemo.java, 286, 417
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
119
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    jPanel1 = new javax.swing.JPanel();
    toleranceLabel = new javax.swing.JLabel();
    zoomSlider = new javax.swing.JSlider();
    showDigitizedCheck = new javax.swing.JCheckBox();
    showPreprocessedCheck = new javax.swing.JCheckBox();
    showPolylineCheck = new javax.swing.JCheckBox();
    showBezierCheck = new javax.swing.JCheckBox();
    showControlsCheck = new javax.swing.JCheckBox();
    eraseButton = new javax.swing.JButton();
    dumpButton = new javax.swing.JButton();
    setLayout(new java.awt.BorderLayout());
    jPanel1.setBorder(javax.swing.BorderFactory.createEmptyBorder(12, 20, 20, 20));
    jPanel1.setLayout(new java.awt.GridBagLayout());
    toleranceLabel.setText("Zoom:");
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(toleranceLabel, gridBagConstraints);
    zoomSlider.setMaximum(800);
    zoomSlider.setMinimum(100);
    zoomSlider.addChangeListener(new javax.swing.event.ChangeListener() {
      public void stateChanged(javax.swing.event.ChangeEvent evt) {
        zoomChanged(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.weightx = 1.0;
    jPanel1.add(zoomSlider, gridBagConstraints);
    showDigitizedCheck.setText("Show Source Points");
    showDigitizedCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(showDigitizedCheck, gridBagConstraints);
    showPreprocessedCheck.setText("Show Preprocessed Points");
    showPreprocessedCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(showPreprocessedCheck, gridBagConstraints);
    showPolylineCheck.setSelected(true);
    showPolylineCheck.setText("Show Polyline");
    showPolylineCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.insets = new java.awt.Insets(0, 20, 0, 0);
    jPanel1.add(showPolylineCheck, gridBagConstraints);
    showBezierCheck.setSelected(true);
    showBezierCheck.setText("Show Bezier Path");
    showBezierCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.insets = new java.awt.Insets(0, 20, 0, 0);
    jPanel1.add(showBezierCheck, gridBagConstraints);
    showControlsCheck.setText("Show Bezier Controls");
    showControlsCheck.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        checkboxPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridwidth = 2;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(showControlsCheck, gridBagConstraints);
    eraseButton.setText("Erase");
    eraseButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        eraseButtonActionPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 2;
    gridBagConstraints.gridy = 4;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    jPanel1.add(eraseButton, gridBagConstraints);
    dumpButton.setText("Dump");
    dumpButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        dumpButtonActionPerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 3;
    gridBagConstraints.gridy = 4;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);
    jPanel1.add(dumpButton, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.NORTH);
###
1897, BezierDemo, BezierDemo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/mini/BezierDemo.java, 233, 249
1
/** Creates new form BezierDemo */
16
  public BezierDemo() {
    initComponents();
    canvas = new Canvas();
    canvas.setOpaque(true);
    canvas.setBackground(Color.WHITE);
    canvas.addMouseListener(handler);
    canvas.addMouseMotionListener(handler);
    add(canvas, BorderLayout.CENTER);
    Point2D.Double[] d = { //  Digitized points 
    };   
    BezierPath digi = new BezierPath();
    digi.addAll(Arrays.asList(d));
    Example ex = new Example();
    examples.add(ex);
    ex.digitized = digi;
    ex.error = 2d;
###
1900, initComponents, DrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanel.java, 157, 191
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
1901, DrawingPanel, DrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanel.java, 64, 129
1
/** Creates new instance. */
62
  public DrawingPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
    // FIXME - We need a toggle grid action!
    // pb.addSeparator();
    // pb.add(new ToggleGridAction(editor));
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);

    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
1903, initComponents, MessagePanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/MessagePanel.java, 77, 106
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    iconLabel = new javax.swing.JLabel();
    messageLabel = new javax.swing.JLabel();
    closeButton = new javax.swing.JButton();
    setBackground(new java.awt.Color(255, 255, 255));
    setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));
    setLayout(new java.awt.GridBagLayout());
    add(iconLabel, new java.awt.GridBagConstraints());
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
    add(messageLabel, gridBagConstraints);
    closeButton.setText(labels.getString("messagePanel.close.text")); // NOI18N
    closeButton.setActionCommand("close");
    closeButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        closePerformed(evt);
      }
    });
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 1;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHEAST;
    gridBagConstraints.insets = new java.awt.Insets(10, 10, 0, 0);
    add(closeButton, gridBagConstraints);
###
1904, MessagePanel, MessagePanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/MessagePanel.java, 38, 39
1
/** Creates new instance. */
2
  public MessagePanel() {
    this(null, null);
###
1906, getPropertyDescriptors, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1907, getDefaultEventIndex, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1908, getEventSetDescriptors, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1909, getDefaultPropertyIndex, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1913, getMethodDescriptors, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1914, getBeanDescriptor, SummaryToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1915, initComponents, SummaryToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBar.java, 71, 85
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
11
  private void initComponents() {
    summaryLabel = new javax.swing.JLabel();
    summaryField = new javax.swing.JTextField();
    setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    setFloatable(false);
    setOpaque(false);
    summaryLabel.setFont(new java.awt.Font("Dialog", 0, 11));
    summaryLabel.setText(labels.getString("summary")); // NOI18N
    add(summaryLabel);
    summaryField.setFont(new java.awt.Font("DialogInput", 0, 11));
    add(summaryField);
###
1916, SummaryToolBar, SummaryToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBar.java, 46, 58
1
/** Creates new instance. */
13
  public SummaryToolBar() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    initComponents();
    
    GridBagLayout layout = new GridBagLayout();
    setLayout(layout);
    
    GridBagConstraints gbc;
    gbc = new GridBagConstraints();
    gbc.insets = new Insets(0,10,0,0);
    gbc.weightx = 1d;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    layout.setConstraints(summaryField, gbc);
###
1917, getBeanDescriptor, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1920, getPropertyDescriptors, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1921, getDefaultPropertyIndex, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1922, getEventSetDescriptors, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1923, getMethodDescriptors, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1924, getDefaultEventIndex, ToolsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1926, ProgressIndicator, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 31, 32
1
/** Creates new instance. */
2
  public ProgressIndicator() {
    this(null, null);
###
1927, getMinimum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 95, 96
6
/**
   * Returns the minimum value -- the lower end of the progress value.
   *
   * @return an int representing the minimum value
   * @see #setMinimum
   */
2
  public int getMinimum() {
    return progressModel.getMinimum();
###
1928, setMaximum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 136, 137
6
/**
   * Specifies the maximum value.
   *
   * @param m  an int specifying the maximum value
   * @see #getMaximum
   */
2
  public void setMaximum(int m) {
    progressModel.setMaximum(m);
###
1929, getMaximum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 125, 126
6
/**
   * Returns the maximum value -- the higher end of the progress value.
   *
   * @return an int representing the maximum value
   * @see #setMaximum
   */
2
  public int getMaximum() {
    return progressModel.getMaximum();
###
1930, setMinimum, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 106, 107
6
/**
   * Specifies the minimum value.
   *
   * @param m  an int specifying the minimum value
   * @see #getMinimum
   */
2
  public void setMinimum(int m) {
    progressModel.setMinimum(m);
###
1931, ProgressIndicator, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 41, 54
1
/** Creates new instance. */
14
  public ProgressIndicator(
      String message,
      String note,
      int min,
      int max,
      boolean indeterminate) {
    initComponents();
    
    messageLabel.setFont(messageLabel.getFont().deriveFont(Font.BOLD));
    progressModel = new DefaultBoundedRangeModel(0, 0, min, max);
    progressBar.setModel(progressModel);
    setMessage(message);
    setNote(note);
    setIndeterminate(indeterminate);
###
1932, initComponents, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 154, 178
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
21
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    messageLabel = new javax.swing.JLabel();
    noteLabel = new javax.swing.JLabel();
    progressBar = new javax.swing.JProgressBar();
    setBackground(new java.awt.Color(255, 255, 255));
    setLayout(new java.awt.GridBagLayout());
    messageLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    add(messageLabel, gridBagConstraints);
    noteLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
    add(noteLabel, gridBagConstraints);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
    add(progressBar, gridBagConstraints);
###
1933, setProgress, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 115, 116
5
/**
   * Indicate the progress of the operation being monitored.
   * @param nv an int specifying the current value, between the
   *    maximum and minimum specified for this component
   */
2
  public void setProgress(int nv) {
    progressModel.setValue(nv);
###
1934, ProgressIndicator, ProgressIndicator, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java, 35, 38
1
/** Creates new instance. */
4
  public ProgressIndicator(
      String message,
      String note) {
    this(message, note, 0, 100, true);
###
1936, getDefaultEventIndex, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
1939, getMethodDescriptors, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
1940, getDefaultPropertyIndex, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
1941, getPropertyDescriptors, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
1942, getEventSetDescriptors, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
1943, getBeanDescriptor, StrokeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
1945, ODGRectRadiusHandle, ODGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectRadiusHandle.java, 40, 41
1
/** Creates a new instance. */
2
  public ODGRectRadiusHandle(Figure owner) {
    super(owner);
###
1946, draw, ODGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectRadiusHandle.java, 47, 48
3
/**
   * Draws this handle.
   */
2
  public void draw(Graphics2D g) {
    drawDiamond(g, Color.yellow, Color.black);
###
1947, StrokeToolBar, StrokeToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBar.java, 45, 48
1
/** Creates new instance. */
4
  public StrokeToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString("stroke.toolbar"));
    setDisclosureStateCount(3);
###
1948, ToolsToolBar, ToolsToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBar.java, 45, 47
1
/** Creates new instance. */
3
  public ToolsToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString("tools.toolbar"));
###
1949, getInsets, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 338, 341
3
/**
   * Returns the insets used to draw text.
   */
4
  public Insets2D.Double getInsets() {
    double sw = Math.ceil(get(STROKE_WIDTH) / 2);
    Insets2D.Double insets = new Insets2D.Double(4, 4, 4, 4);
    return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);
###
1950, drawParagraph, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 151, 280
16
/**
   * Draws or measures a paragraph of text at the specified y location and
   * the bounds of the paragraph.
   *
   * @param g Graphics object. This parameter is null, if we want to
   *  measure the size of the paragraph.
   * @param styledText the text of the paragraph.
   * @param verticalPos the top bound of the paragraph
   * @param maxVerticalPos the bottom bound of the paragraph
   * @param leftMargin the left bound of the paragraph
   * @param rightMargin the right bound of the paragraph
   * @param tabStops an array with tab stops
   * @param tabCount the number of entries in tabStops which contain actual
   *    values
   * @return Returns the actual bounds of the paragraph.
   */
109
  private Rectangle2D.Double drawParagraph(Graphics2D g, AttributedCharacterIterator styledText,
      float verticalPos, float maxVerticalPos, float leftMargin, float rightMargin, float[] tabStops, int tabCount) {
    // This method is based on the code sample given
    // in the class comment of java.awt.font.LineBreakMeasurer, 
    // assume styledText is an AttributedCharacterIterator, and the number
    // of tabs in styledText is tabCount
    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);
    int[] tabLocations = new int[tabCount + 1];
    int i = 0;
    for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {
      if (c == '\t') {
        tabLocations[i++] = styledText.getIndex();
      }
    }
    tabLocations[tabCount] = styledText.getEndIndex() - 1;
    // Now tabLocations has an entry for every tab's offset in
    // the text.  For convenience, the last entry is tabLocations
    // is the offset of the last character in the text.
    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());
    int currentTab = 0;
    while (measurer.getPosition() < styledText.getEndIndex() &&
        verticalPos <= maxVerticalPos) {
      // Lay out and draw each line.  All segments on a line
      // must be computed before any drawing can occur, since
      // we must know the largest ascent on the line.
      // TextLayouts are computed and stored in a List;
      // their horizontal positions are stored in a parallel
      // List.
      // lineContainsText is true after first segment is drawn
      boolean lineContainsText = false;
      boolean lineComplete = false;
      float maxAscent = 0, maxDescent = 0;
      float horizontalPos = leftMargin;
      LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();
      LinkedList<Float> penPositions = new LinkedList<Float>();
      int first = layouts.size();
      while (!lineComplete && verticalPos <= maxVerticalPos) {
        float wrappingWidth = rightMargin - horizontalPos;
        TextLayout layout = null;
        layout =
            measurer.nextLayout(wrappingWidth,
            tabLocations[currentTab] + 1,
            lineContainsText);
        // layout can be null if lineContainsText is true
        if (layout != null) {
          layouts.add(layout);
          penPositions.add(horizontalPos);
          horizontalPos += layout.getAdvance();
          maxAscent = Math.max(maxAscent, layout.getAscent());
          maxDescent = Math.max(maxDescent,
              layout.getDescent() + layout.getLeading());
        } else {
          lineComplete = true;
        }
        lineContainsText = true;
        if (measurer.getPosition() == tabLocations[currentTab] + 1) {
          currentTab++;
        }
        if (measurer.getPosition() == styledText.getEndIndex()) {
          lineComplete = true;
        } else if (tabStops.length == 0 || horizontalPos >= tabStops[tabStops.length - 1]) {
          lineComplete = true;
        }
        if (!lineComplete) {
          // move to next tab stop
          int j;
          for (j = 0; horizontalPos >= tabStops[j]; j++) {
          }
          horizontalPos = tabStops[j];
        }
      }
      // If there is only one layout element on the line, and we are
      // drawing, then honor alignemnt
      if (first == layouts.size() - 1 && g != null) {
        switch (get(TEXT_ALIGNMENT)) {
          case TRAILING:
            penPositions.set(first, rightMargin - layouts.get(first).getVisibleAdvance() - 1);
            break;
          case CENTER:
            penPositions.set(first, (rightMargin - 1 - leftMargin - layouts.get(first).getVisibleAdvance()) / 2 + leftMargin);
            break;
          case BLOCK:
            // not supported
            break;
          case LEADING:
          default:
            break;
        }
      }

      verticalPos += maxAscent;
      Iterator<TextLayout> layoutEnum = layouts.iterator();
      Iterator<Float> positionEnum = penPositions.iterator();
      // now iterate through layouts and draw them
      while (layoutEnum.hasNext()) {
        TextLayout nextLayout = layoutEnum.next();
        float nextPosition = positionEnum.next();
        if (g != null) {
          nextLayout.draw(g, nextPosition, verticalPos);
        }
        Rectangle2D layoutBounds = nextLayout.getBounds();
        paragraphBounds.add(new Rectangle2D.Double(layoutBounds.getX() + nextPosition,
            layoutBounds.getY() + verticalPos,
            layoutBounds.getWidth(),
            layoutBounds.getHeight()));
      }
      verticalPos += maxDescent;
    }
    return paragraphBounds;
###
1951, TextAreaFigure, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 74, 76
1
/** Creates a new instance. */
3
  public TextAreaFigure() {
    this(ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels").
        getString("TextFigure.defaultText"));
###
1952, getText, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 331, 332
3
/**
   * Gets the text shown by the text figure.
   */
2
  public String getText() {
    return (String) get(TEXT);
###
1953, setText, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 355, 356
3
/**
   * Sets the text shown by the text figure.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
1954, getTool, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 396, 401
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
6
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextAreaEditingTool tool = new TextAreaEditingTool(this);
      return tool;
    }
    return null;
###
1961, getPreferredTextSize, TextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java, 474, 508
10
/**
   * Returns the preferred text size of the TextAreaFigure.
   * <p>
   * If you want to use this method to determine the bounds of the TextAreaFigure,
   * you need to add the insets of the TextAreaFigure to the size.
   * 
   * @param maxWidth the maximal width to use. Specify Double.MAX_VALUE
   * if you want the width to be unlimited.
   * @return width and height needed to lay out the text.
   */
33
  public Dimension2DDouble getPreferredTextSize(double maxWidth) {
    Rectangle2D.Double textRect = new Rectangle2D.Double();
    if (getText() != null) {
      Font font = getFont();
      boolean isUnderlined = get(FONT_UNDERLINE);
      float leftMargin = 0;
      float rightMargin = (float) maxWidth - 1;
      float verticalPos = 0;
      float maxVerticalPos = Float.MAX_VALUE;
      if (leftMargin < rightMargin) {
        float tabWidth = (float) (getTabSize() * font.getStringBounds("m", getFontRenderContext()).getWidth());
        float[] tabStops = new float[(int) (textRect.width / tabWidth)];
        for (int i = 0; i < tabStops.length; i++) {
          tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));
        }
        String[] paragraphs = getText().split("\n");//Strings.split(getText(), '\n');
        for (int i = 0; i < paragraphs.length; i++) {
          if (paragraphs[i].length() == 0) {
            paragraphs[i] = " ";
          }
          AttributedString as = new AttributedString(paragraphs[i]);
          as.addAttribute(TextAttribute.FONT, font);
          if (isUnderlined) {
            as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);
          }
          int tabCount = paragraphs[i].split("\t").length - 1;
          Rectangle2D.Double paragraphBounds = drawParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);
          verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);
          textRect.add(paragraphBounds);
        }
      }
    }
    return new Dimension2DDouble(-Math.min(textRect.x, 0) + textRect.width, -Math.min(textRect.y, 0) + textRect.height);
###
1962, readCustomShapeElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 445, 461
7
/** A <draw:custom-shape> represents a shape that is capable of rendering
   * complex figures. It is offering font work and extrusion functiona-
   * lity. A custom shape may have a geometry that influences its shape.
   * This geometry may be visualized in office application user
   * interfaces, for instance by displaying interaction handles, that
   * provide a simple way to modify the geometry.
   */
14
  private ODGFigure readCustomShapeElement(IXMLElement elem)
      throws IOException {
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    Map<AttributeKey, Object> a = styles.getAttributes(styleName, "graphic");
    Rectangle2D.Double figureBounds = new Rectangle2D.Double(
        toLength(elem.getAttribute("x", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("y", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("width", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("height", SVG_NAMESPACE, "0"), 1));
    ODGFigure figure = null;
    for (IXMLElement child : elem.getChildrenNamed("enhanced-geometry", DRAWING_NAMESPACE)) {
      figure = readEnhancedGeometryElement(child, a, figureBounds);
    }
    return figure;
###
1963, createPolylineFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 579, 591
3
/**
   * Creates a Polyline figure.
   */
13
  private ODGFigure createPolylineFigure(
      Point2D.Double[] points,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    ODGBezierFigure bezier = new ODGBezierFigure();
    for (Point2D.Double p : points) {
      bezier.addNode(new BezierPath.Node(p.x, p.y));
    }
    figure.removeAllChildren();
    figure.add(bezier);
    figure.setAttributes(a);
    return figure;
###
1964, toLength, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 892, 922
4
/**
   * Returns a value as a length.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
29
  private double toLength(String str, double percentFactor) throws IOException {
    double scaleFactor = 1d;
    if (str == null || str.length() == 0) {
      return 0d;
    }
    if (str.endsWith("%")) {
      str = str.substring(0, str.length() - 1);
      scaleFactor = percentFactor;
    } else if (str.endsWith("px")) {
      str = str.substring(0, str.length() - 2);
    } else if (str.endsWith("pt")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 1.25;
    } else if (str.endsWith("pc")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 15;
    } else if (str.endsWith("mm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 3.543307;
    } else if (str.endsWith("cm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 35.43307;
    } else if (str.endsWith("in")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 90;
    } else {
      scaleFactor = 1d;
    }
    return Double.parseDouble(str) * scaleFactor;
###
1965, readAllBytes, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 100, 107
3
/**
   * Reads all bytes from the InputStreams until EOF is reached.
   */
8
  private byte[] readAllBytes(InputStream in) throws IOException {
    ByteArrayOutputStream tmp = new ByteArrayOutputStream();
    byte[] buf = new byte[512];
    for (int len; -1 != (len = in.read(buf));) {
      tmp.write(buf, 0, len);
    }
    tmp.close();
    return tmp.toByteArray();
###
1966, createPolygonFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 597, 610
3
/**
   * Creates a Polygon figure.
   */
14
  private ODGFigure createPolygonFigure(
      Point2D.Double[] points,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    ODGBezierFigure bezier = new ODGBezierFigure();
    for (Point2D.Double p : points) {
      bezier.addNode(new BezierPath.Node(p.x, p.y));
    }
    bezier.setClosed(true);
    figure.removeAllChildren();
    figure.add(bezier);
    figure.setAttributes(a);
    return figure;
###
1967, readPolygonElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 784, 801
20
/**
   * The &lt;draw:polygon&gt; element represents a polygon. A polygon is a
   * closed put of straight lines.
   * Some implementations may ignore the size attribute, and instead determine
   * the size of a shape exclusively from the shape data (i.e., polygon vertices).
   * <p>
   * The attributes that may be associated with the &lt;draw:polygon&gt; element
   * are:
   *  Position, Size, View box, Style, Layer, Z-Index, ID, Caption ID and
   * Transformation  see section 9.2.15
   *  Text anchor, table background, draw end position  see section 9.2.16
   *  Points  see section 9.2.3
   * The elements that may be contained in the &lt;draw:polygon&gt; element are:
   *  Title (short accessible name)  see section 9.2.20.
   *  Long description (in support of accessibility)  see section 9.2.20.
   *  Event listeners  see section 9.2.21.
   *  Glue points  see section 9.2.19.
   *  Text  see section 9.2.17.
   *
   */
15
  private ODGFigure readPolygonElement(IXMLElement elem)
      throws IOException {
    AffineTransform viewBoxTransform = readViewBoxTransform(elem);
    String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute("points", DRAWING_NAMESPACE, null));
    Point2D.Double[] points = new Point2D.Double[coords.length / 2];
    for (int i = 0; i < coords.length; i += 2) {
      Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));
      points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);
    }
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    a.putAll(styles.getAttributes(styleName, "graphic"));
    readCommonDrawingShapeAttributes(elem, a);
    ODGFigure f = createPolygonFigure(points, a);
    return f;
###
1968, sort, QuadTreeCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java, 87, 95
3
/**
   * Implementation note: Sorting can not be done for orphaned children.
   */
9
  public java.util.List<Figure> sort(Collection<Figure> c) {
    ensureSorted();
    ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());
    for (Figure f : children) {
      if (c.contains(f)) {
        sorted.add(f);
      }
    }
    return sorted;
###
1969, QuadTreeCompositeFigure, QuadTreeCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java, 46, 47
1
/** Creates a new instance. */
2
  public QuadTreeCompositeFigure() {
    figureHandler = createFigureHandler();
###
1970, getFiguresFrontToBack, QuadTreeCompositeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java, 131, 133
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
3
  public java.util.List<Figure> getFiguresFrontToBack() {
    ensureSorted();
    return new ReversedList<Figure>(children);
###
1971, toEnhancedPath, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 968, 1199
23
/**
   * Returns a value as a EnhancedPath array.
   *
   * The draw:enhanced-path attribute specifies a path similar to the svg:d attribute of the
   * <svg:path> element. Instructions such as moveto, lineto, arcto and other instructions
   * together with its parameter are describing the geometry of a shape which can be filled and or
   * stroked. Relative commands are not supported.
   * The syntax of draw:enhanced-path attribute is as follows:
   *  Instructions are expressed as one character (e.g., a moveto is expressed as an M).
   *  A prefix notation is being used, that means that each command is followed by its parameter.
   *  Superfluous white space and separators such as commas can be eliminated. (e.g., M 10 10
   * L 20 20 L 30 20 can also be written: M10 10L20 20L30 20
   *  If the command is repeated multiple times, only the first command is required. (e.g., M 10 10
   * L 20 20 L 30 20 can also be expressed as followed M 10 10 L 20 20 30 20
   *  Floats can be used, therefore the only allowable decimal point is a dot (.)
   * The above mentioned rules are the same as specified for the <svg:path> element.
   * A parameter can also have one of the following enhancements:
   *  A ? is used to mark the beginning of a formula name. The result of the element's
   * draw:formula attribute is used as parameter value in this case.
   *  If $ is preceding a integer value, the value is indexing a draw:modifiers attribute. The
   * corresponding modifier value is used as parameter value then.
   *
   */
216
  private EnhancedPath toEnhancedPath(String str) throws IOException {
    if (DEBUG) {
      System.out.println("ODGInputFormat toEnhancedPath " + str);
    }
    EnhancedPath path = null;
    Object x, y;
    Object x1, y1, x2, y2, x3, y3;
    StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
    tt.resetSyntax();
    tt.parseNumbers();
    tt.parseExponents();
    tt.parsePlusAsNumber();
    tt.whitespaceChars(0, ' ');
    tt.whitespaceChars(',', ',');

    char nextCommand = 'M';
    char command = 'M';
    Commands:
    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
      if (tt.ttype > 0) {
        command = (char) tt.ttype;
      } else {
        command = nextCommand;
        tt.pushBack();
      }
      nextCommand = command;
      switch (command) {
        case 'M':
          // moveto (x y)+
          // Start a new sub-path at the given (x,y)
          // coordinate. If a moveto is followed by multiple
          // pairs of coordinates, they are treated as lineto.
          if (path == null) {
            path = new EnhancedPath();
          }
          // path.setFilled(isFilled);
          //path.setStroked(isStroked);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.moveTo(x, y);
          nextCommand = 'L';
          break;
        case 'L':
          // lineto (x y)+
          // Draws a line from the current point to (x, y). If
          // multiple coordinate pairs are following, they
          // are all interpreted as lineto.
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.lineTo(x, y);
          break;
        case 'C':
          // curveto (x1 y1 x2 y2 x y)+
          // Draws a cubic Bezier curve from the current
          // point to (x,y) using (x1,y1) as the control point
          // at the beginning of the curve and (x2,y2) as
          // the control point at the end of the curve.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.curveTo(x1, y1, x2, y2, x, y);
          break;
        case 'Z':
          // closepath
          // Close the current sub-path by drawing a
          // straight line from the current point to current
          // sub-path's initial point.
          path.close();
          break;
        case 'N':
          // endpath
          // Ends the current put of sub-paths. The sub-
          // paths will be filled by using the even-odd
          // filling rule. Other following subpaths will be
          // filled independently.
          break;
        case 'F':
          // nofill
          // Specifies that the current put of sub-paths
          // won't be filled.
          break;
        case 'S':
          // nostroke
          // Specifies that the current put of sub-paths
          // won't be stroked.
          break;
        case 'T':
          // angle-ellipseto (x y w h t0 t1) +
          // Draws a segment of an ellipse. The ellipse is specified
          // by the center(x, y), the size(w, h) and the start-angle
          // t0 and end-angle t1.
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          path.ellipseTo(x, y, x1, y1, x2, y2);
          break;
        case 'U':
          // angle-ellipse (x y w h t0 t1) +
          // The same as the T command, except that a implied moveto
          // to the starting point is done.
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          path.moveTo(x1, y1);
          path.ellipseTo(x, y, x1, y1, x2, y2);
          break;
        case 'A':
          // arcto (x1 y1 x2 y2 x3 y3 x y) +
          // (x1, y1) and (x2, y2) is defining the bounding
          // box of a ellipse. A line is then drawn from the
          // current point to the start angle of the arc that is
          // specified by the radial vector of point (x3, y3)
          // and then counter clockwise to the end-angle
          // that is specified by point (x4, y4).
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.arcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'B':
          // arc (x1 y1 x2 y2 x3 y3 x y) +
          // The same as the A command, except that a
          // implied moveto to the starting point is done.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.moveTo(x1, y1);
          path.arcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'W':
          // clockwisearcto (x1 y1 x2 y2 x3 y3 x y) +
          // The same as the A command except, that the arc is drawn
          // clockwise.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'V':
          // clockwisearc (x1 y1 x2 y2 x3 y3 x y)+
          // The same as the A command, except that a implied moveto
          // to the starting point is done and the arc is drawn
          // clockwise.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x2 = nextEnhancedCoordinate(tt, str);
          y2 = nextEnhancedCoordinate(tt, str);
          x3 = nextEnhancedCoordinate(tt, str);
          y3 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.moveTo(x1, y1);
          path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);
          break;
        case 'X':
          // elliptical-quadrantx (x y) +
          // Draws a quarter ellipse, whose initial segment is
          // tangential to the x-axis, is drawn from the
          // current point to (x, y).
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.quadrantXTo(x, y);
          break;
        case 'Y':
          // elliptical-quadranty (x y) +
          // Draws a quarter ellipse, whose initial segment is
          // tangential to the y-axis, is drawn from the
          // current point to(x, y).
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.quadrantYTo(x, y);
          break;
        case 'Q':
          // quadratic-curveto(x1 y1 x y)+
          // Draws a quadratic Bezier curve from the current point
          // to(x, y) using(x1, y1) as the control point. (x, y)
          // becomes the new current point at the end of the command.
          x1 = nextEnhancedCoordinate(tt, str);
          y1 = nextEnhancedCoordinate(tt, str);
          x = nextEnhancedCoordinate(tt, str);
          y = nextEnhancedCoordinate(tt, str);
          path.quadTo(x1, y1, x, y);
          break;
        default:
          if (DEBUG) {
            System.out.println("ODGInputFormat.toEnhancedPath aborting after illegal path command: " + command + " found in path " + str);
          }
          break Commands;
        //throw new IOException("Illegal command: "+command);
      }
    }
    return path;
###
1972, createLineFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 566, 573
3
/**
   * Creates a Line figure.
   */
8
  private ODGFigure createLineFigure(
      Point2D.Double p1, Point2D.Double p2,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    figure.setBounds(p1, p2);
    figure.setAttributes(a);
    return figure;
###
1973, readPolylineElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 822, 839
18
/**
   * The &lt;draw:polyline&gt; element represents a polyline drawing shape.
   * Some implementations may ignore the size attribute, and instead determine the size of a shape
   * exclusively from the shape data (i.e., polygon vertices).
   * <p>
   * The attributes that may be associated with the &lt;draw:polyline&gt;
   * element are:
   *  Position, Size, View box, Style, Layer, Z-Index, ID, Caption ID and Transformation  see
   * section 9.2.15
   *  Text anchor, table background, draw end position  see section 9.2.16
   *  Points
   * The elements that may be contained in the &lt;draw:polyline&gt; element are:
   *  Title (short accessible name)  see section 9.2.20.
   *  Long description (in support of accessibility)  see section 9.2.20.
   *  Event listeners  see section 9.2.21.
   *  Glue points  see section 9.2.19.
   *  Text  see section 9.2.17.
   */
15
  private ODGFigure readPolylineElement(IXMLElement elem)
      throws IOException {
    AffineTransform viewBoxTransform = readViewBoxTransform(elem);
    String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute("points", DRAWING_NAMESPACE, null));
    Point2D.Double[] points = new Point2D.Double[coords.length / 2];
    for (int i = 0; i < coords.length; i += 2) {
      Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));
      points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);
    }
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    a.putAll(styles.getAttributes(styleName, "graphic"));
    readCommonDrawingShapeAttributes(elem, a);
    ODGFigure f = createPolylineFigure(points, a);
    return f;
###
1974, readLineElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 729, 743
18
/**
   * The &lt;draw:line&gt; element represents a line.
   * <p>
   * The attributes that may be associated with the &lt;draw:line&gt; element
   * are:
   *  Style, Layer, Z-Index, ID, Caption ID and Transformation  see section
   * 9.2.15.
   *  Text anchor, table background, draw end position see section 9.2.16.
   *  Start point
   *  End point
   * <p>
   * The elements that may be contained in the &lt;draw:line&gt; element are:
   *  Title (short accessible name)  see section 9.2.20.
   *  Long description (in support of accessibility)  see section 9.2.20.
   *  Event listeners  see section 9.2.21.
   *  Glue points  see section 9.2.19.
   *  Text  see section 9.2.17.
   */
12
  private ODGFigure readLineElement(IXMLElement elem)
      throws IOException {
    Point2D.Double p1 = new Point2D.Double(
        toLength(elem.getAttribute("x1", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("y1", SVG_NAMESPACE, "0"), 1));
    Point2D.Double p2 = new Point2D.Double(
        toLength(elem.getAttribute("x2", SVG_NAMESPACE, "0"), 1),
        toLength(elem.getAttribute("y2", SVG_NAMESPACE, "0"), 1));
    String styleName = elem.getAttribute("style-name", DRAWING_NAMESPACE, null);
    Map<AttributeKey, Object> a = styles.getAttributes(styleName, "graphic");
    ODGFigure f = createLineFigure(p1, p2, a);
    return f;
###
1975, toNumber, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 884, 885
4
/**
   * Returns a value as a number.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeNumber
   */
2
  private double toNumber(String str) throws IOException {
    return toLength(str, 100);
###
1976, createPathFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 616, 628
3
/**
   * Creates a Path figure.
   */
13
  private ODGFigure createPathFigure(
      BezierPath[] paths,
      Map<AttributeKey, Object> a)
      throws IOException {
    ODGPathFigure figure = new ODGPathFigure();
    figure.removeAllChildren();
    for (BezierPath p : paths) {
      ODGBezierFigure bezier = new ODGBezierFigure();
      bezier.setBezierPath(p);
      figure.add(bezier);
    }
    figure.setAttributes(a);
    return figure;
###
1977, createGroupFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 684, 687
3
/**
   * Creates a ODGGroupFigure.
   */
4
  private CompositeFigure createGroupFigure()
      throws IOException {
    ODGGroupFigure figure = new ODGGroupFigure();
    return figure;
###
1978, readDrawingElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 226, 273
3
/**
   * Reads an ODG "office:drawing" element.
   */
44
  private void readDrawingElement(IXMLElement elem)
      throws IOException {
    /*
    2.3.2Drawing Documents
    The content of drawing document consists of a sequence of draw pages.
    <define name="office-body-content" combine="choice">
    <element name="office:drawing">
    <ref name="office-drawing-attlist"/>
    <ref name="office-drawing-content-prelude"/>
    <ref name="office-drawing-content-main"/>
    <ref name="office-drawing-content-epilogue"/>
    </element>
    </define>
    <define name="office-drawing-attlist">
    <empty/>
    </define>
    Drawing Document Content Model
    The drawing document prelude may contain text declarations only. To allow office applications to
    implement functionality that usually is available in spreadsheets for drawing documents, it may
    also contain elements that implement enhanced table features. See also section 2.3.4.
    <define name="office-drawing-content-prelude">
    <ref name="text-decls"/>
    <ref name="table-decls"/>
    </define>
    The main document content contains a sequence of draw pages.
    <define name="office-drawing-content-main">
    <zeroOrMore>
    <ref name="draw-page"/>
    </zeroOrMore>
    </define>
    There are no drawing documents specific epilogue elements, but the epilogue may contain
    elements that implement enhanced table features. See also section 2.3.4.
    <define name="office-drawing-content-epilogue">
    <ref name="table-functions"/>
    </define>
     */
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        if (child.getNamespace() == null ||
            child.getNamespace().equals(DRAWING_NAMESPACE)) {
          String name = child.getName();
          if (name.equals("page")) {
            readPageElement(child);
###
1979, createEnhancedGeometryEllipseFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 542, 548
3
/**
   * Creates a Ellipse figure.
   */
7
  private ODGFigure createEnhancedGeometryEllipseFigure(
      Rectangle2D.Double bounds, Map<AttributeKey, Object> a)
      throws IOException {
    ODGEllipseFigure figure = new ODGEllipseFigure();
    figure.setBounds(bounds);
    figure.setAttributes(a);
    return figure;
###
1981, createEnhancedGeometryRectangleFigure, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 554, 560
3
/**
   * Creates a Rect figure.
   */
7
  private ODGFigure createEnhancedGeometryRectangleFigure(
      Rectangle2D.Double bounds, Map<AttributeKey, Object> a)
      throws IOException {
    ODGRectFigure figure = new ODGRectFigure();
    figure.setBounds(bounds);
    figure.setAttributes(a);
    return figure;
###
1982, readPageElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 283, 340
3
/**
   * Reads an ODG "draw:page" element.
   */
58
  private void readPageElement(IXMLElement elem)
      throws IOException {
    /* 9.1.4Drawing Pages
     *
    The element <draw:page> is a container for content in a drawing or presentation document.
    Drawing pages are used for the following:
     Forms (see section 11.1)
     Drawings (see section 9.2)
     Frames (see section 9.3)
     Presentation Animations (see section 9.7)
     Presentation Notes (see section 9.1.5)
     *
    A master page must be assigned to each drawing page.
     *
    <define name="draw-page">
    <element name="draw:page">
    <ref name="common-presentation-header-footer-attlist"/>
    <ref name="draw-page-attlist"/>
    <optional>
    <ref name="office-forms"/>
    </optional>
    <zeroOrMore>
    <ref name="shape"/>
    </zeroOrMore>
    <optional>
    <choice>
    <ref name="presentation-animations"/>
    <ref name="animation-element"/>
    </choice>
    </optional>
    <optional>
    <ref name="presentation-notes"/>
    </optional>
    </element>
    </define>
     *
    The attributes that may be associated with the <draw:page> element are:
     Page name
     Page style
     Master page
     Presentation page layout
     Header declaration
     Footer declaration
     Date and time declaration
     ID
     *
    The elements that my be included in the <draw:page> element are:
     Forms
     Shapes
     Animations
     Presentation notes
     */
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        ODGFigure figure = readElement(child);
        if (figure != null) {
          figures.add(figure);
###
1983, getFigureDrawingArea, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 131, 148
3
/**
   * Gets the drawing area without taking the decorator into account.
   */
18
  protected Rectangle2D.Double getFigureDrawingArea() {
    if (getText() == null) {
      return getBounds();
    } else {
      TextLayout layout = getTextLayout();
      Rectangle2D.Double r = new Rectangle2D.Double(
          origin.x, origin.y, layout.getAdvance(), layout.getAscent());
      Rectangle2D lBounds = layout.getBounds();
      if (!lBounds.isEmpty() && !Double.isNaN(lBounds.getX())) {
        r.add(new Rectangle2D.Double(
            lBounds.getX() + origin.x,
            (lBounds.getY() + origin.y + layout.getAscent()),
            lBounds.getWidth(),
            lBounds.getHeight()));
      }
      // grow by two pixels to take antialiasing into account
      Geom.grow(r, 2d, 2d);
      return r;
###
1984, setText, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 175, 176
5
/**
   * Sets the text shown by the text figure.
   * This is a convenience method for calling willChange,
   * AttribuTEXT.basicSet, changed.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
1985, readElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 349, 425
3
/**
   * Reads an ODG element.
   */
77
  private ODGFigure readElement(IXMLElement elem)
      throws IOException {
    /*
    Drawing Shapes
    This section describes drawing shapes that might occur within all kind of applications.
    <define name="shape">
    <choice>
    <ref name="draw-rect"/>
    <ref name="draw-line"/>
    <ref name="draw-polyline"/>
    <ref name="draw-polygon"/>
    <ref name="draw-regular-polygon"/>
    <ref name="draw-path"/>
    <ref name="draw-circle"/>
    <ref name="draw-ellipse"/>
    <ref name="draw-g"/>
    <ref name="draw-page-thumbnail"/>
    <ref name="draw-frame"/>
    <ref name="draw-measure"/>
    <ref name="draw-caption"/>
    <ref name="draw-connector"/>
    <ref name="draw-control"/>
    <ref name="dr3d-scene"/>
    <ref name="draw-custom-shape"/>
    </choice>
    </define>
     */
    ODGFigure f = null;
    if (elem.getNamespace() == null ||
        elem.getNamespace().equals(DRAWING_NAMESPACE)) {
      String name = elem.getName();
      if (name.equals("caption")) {
        f = readCaptionElement(elem);
      } else if (name.equals("circle")) {
        f = readCircleElement(elem);
      } else if (name.equals("connector")) {
        f = readCircleElement(elem);
      } else if (name.equals("custom-shape")) {
        f = readCustomShapeElement(elem);
      } else if (name.equals("ellipse")) {
        f = readEllipseElement(elem);
      } else if (name.equals("frame")) {
        f = readFrameElement(elem);
      } else if (name.equals("g")) {
        f = readGElement(elem);
      } else if (name.equals("line")) {
        f = readLineElement(elem);
      } else if (name.equals("measure")) {
        f = readMeasureElement(elem);
      } else if (name.equals("path")) {
        f = readPathElement(elem);
      } else if (name.equals("polygon")) {
        f = readPolygonElement(elem);
      } else if (name.equals("polyline")) {
        f = readPolylineElement(elem);
      } else if (name.equals("rect")) {
        f = readRectElement(elem);
      } else if (name.equals("regularPolygon")) {
        f = readRegularPolygonElement(elem);
      } else {
        if (DEBUG) {
          System.out.println("ODGInputFormat.readElement(" + elem + ") not implemented.");
        }
      }
    }
    if (f != null) {
      if (f.isEmpty()) {
        if (DEBUG) {
          System.out.println("ODGInputFormat.readElement():null - discarded empty figure " + f);
        }
        return null;
      }
      if (DEBUG) {
        System.out.println("ODGInputFormat.readElement():" + f + ".");
      }
    }
    return f;
###
1988, TextFigure, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 53, 55
1
/** Creates a new instance. */
3
  public TextFigure() {
    this(ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels").
        getString("TextFigure.defaultText"));
###
1989, getTabSize, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 187, 188
3
/**
   * Gets the number of characters used to expand tabs.
   */
2
  public int getTabSize() {
    return 8;
###
1990, getTool, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 251, 257
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
7
  @Override
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextEditingTool t = new TextEditingTool(this);
      return t;
    }
    return null;
###
1991, getText, TextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java, 166, 167
3
/**
   * Gets the text shown by the text figure.
   */
2
  public String getText() {
    return get(TEXT);
###
1993, contains, RectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RectangleFigure.java, 70, 74
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
5
  public boolean contains(Point2D.Double p) {
    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this) + 1d;
    Geom.grow(r, grow, grow);
    return r.contains(p);
###
1995, RectangleFigure, RectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RectangleFigure.java, 32, 33
1
/** Creates a new instance. */
2
  public RectangleFigure() {
    this(0, 0, 0, 0);
###
1997, LineFigure, LineFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineFigure.java, 35, 38
1
/** Creates a new instance. */
4
  public LineFigure() {
    addNode(new BezierPath.Node(new Point2D.Double(0,0)));
    addNode(new BezierPath.Node(new Point2D.Double(0,0)));
    setConnectable(false);
###
1998, toPath, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 1424, 1863
7
/**
   * Returns a value as a BezierPath array.
   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF
   *
   * Also supports elliptical arc commands 'a' and 'A' as specified in
   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
   */
409
  private BezierPath[] toPath(String str) throws IOException {
    LinkedList<BezierPath> paths = new LinkedList<BezierPath>();
    BezierPath path = null;
    Point2D.Double p = new Point2D.Double();
    Point2D.Double c1 = new Point2D.Double();
    Point2D.Double c2 = new Point2D.Double();
    StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
    tt.resetSyntax();
    tt.parseNumbers();
    tt.parseExponents();
    tt.parsePlusAsNumber();
    tt.whitespaceChars(0, ' ');
    tt.whitespaceChars(',', ',');

    char nextCommand = 'M';
    char command = 'M';
    Commands:
    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
      if (tt.ttype > 0) {
        command = (char) tt.ttype;
      } else {
        command = nextCommand;
        tt.pushBack();
      }
      BezierPath.Node node;
      switch (command) {
        case 'M':
          // absolute-moveto x y
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'm':
          // relative-moveto dx dy
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'Z':
        case 'z':
          // close path
          p.x = path.get(0).x[0];
          p.y = path.get(0).y[0];
          // If the last point and the first point are the same, we
          // can merge them
          if (path.size() > 1) {
            BezierPath.Node first = path.get(0);
            BezierPath.Node last = path.get(path.size() - 1);
            if (first.x[0] == last.x[0] &&
                first.y[0] == last.y[0]) {
              if ((last.mask & BezierPath.C1_MASK) != 0) {
                first.mask |= BezierPath.C1_MASK;
                first.x[1] = last.x[1];
                first.y[1] = last.y[1];
              }
              path.remove(path.size() - 1);
            }
          }
          path.setClosed(true);
          break;
        case 'L':
          // absolute-lineto x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'l':
          // relative-lineto dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'H':
          // absolute-horizontal-lineto x
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'H' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'H';
          break;
        case 'h':
          // relative-horizontal-lineto dx
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'h' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'h';
          break;
        case 'V':
          // absolute-vertical-lineto y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'V' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'V';
          break;
        case 'v':
          // relative-vertical-lineto dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'v' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'v';
          break;
        case 'C':
          // absolute-curveto x1 y1 x2 y2 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'C';
          break;
        case 'c':
          // relative-curveto dx1 dy1 dx2 dy2 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'c';
          break;
        case 'S':
          // absolute-shorthand-curveto x2 y2 x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'S';
          break;
        case 's':
          // relative-shorthand-curveto dx2 dy2 dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 's';
          break;
        case 'Q':
          // absolute-quadto x1 y1 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'Q';
          break;
        case 'q':
          // relative-quadto dx1 dy1 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'q';
          break;
        case 'T':
          // absolute-shorthand-quadto x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'T';
          break;
        case 't':
          // relative-shorthand-quadto dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 's';
          break;

        case 'A': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'A';
          break;
        }
        case 'a': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'a';
          break;
        }
        default:
          if (DEBUG) {
            System.out.println("SVGInputFormat.toPath aborting after illegal path command: " + command + " found in path " + str);
          }
          break Commands;
        //throw new IOException("Illegal command: "+command);
      }
    }
    if (path != null) {
      paths.add(path);
    }
    return paths.toArray(new BezierPath[paths.size()]);
###
1999, setArc, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 126, 128
1
/** Convenience method for setting both the arc width and the arc height. */
3
  public void setArc(double width, double height) {
    setArcWidth(width);
    setArcHeight(height);
###
2000, contains, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 134, 143
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
10
  public boolean contains(Point2D.Double p) {
    RoundRectangle2D.Double r = (RoundRectangle2D.Double) roundrect.clone();
    double grow = AttributeKeys.getPerpendicularHitGrowth(this);
    r.x -= grow;
    r.y -= grow;
    r.width += grow * 2;
    r.height += grow * 2;
    r.arcwidth += grow * 2;
    r.archeight += grow * 2;
    return r.contains(p);
###
2001, setArcHeight, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 119, 122
1
/** Sets the arc height. */
4
  public void setArcHeight(double newValue) {
    double oldValue = roundrect.archeight;
    roundrect.archeight = newValue;
    firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);
###
2002, setArcWidth, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 113, 116
1
/** Sets the arc width. */
4
  public void setArcWidth(double newValue) {
    double oldValue = roundrect.arcwidth;
    roundrect.arcwidth = newValue;
    firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);
###
2004, RoundRectangleFigure, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 50, 51
1
/** Creates a new instance. */
2
  public RoundRectangleFigure() {
    this(0, 0, 0, 0);
###
2005, readFiguresFromDocumentContent, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 154, 220
4
/**
   * Reads figures from the content.xml file of an ODG open document drawing
   * document.
   */
61
  @SuppressWarnings("unchecked")
  public void readFiguresFromDocumentContent(InputStream in, Drawing drawing, boolean replace) throws IOException {
    this.figures = new LinkedList<Figure>();
    IXMLParser parser;
    try {
      parser = XMLParserFactory.createDefaultXMLParser();
    } catch (Exception ex) {
      InternalError e = new InternalError("Unable to instantiate NanoXML Parser");
      e.initCause(ex);
      throw e;
    }
    IXMLReader reader = new StdXMLReader(in);
    parser.setReader(reader);
    try {
      document = (IXMLElement) parser.parse();
    } catch (XMLException ex) {
      IOException e = new IOException(ex.getMessage());
      e.initCause(ex);
      throw e;
    }
    if (styles == null) {
      styles = new ODGStylesReader();
    }
    styles.read(document);

    // Search for the first 'office:drawing' element in the XML document
    // in preorder sequence
    IXMLElement drawingElem = document;
    Stack<Iterator> stack = new Stack<Iterator>();
    LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();
    ll.add(document);
    stack.push(ll.iterator());
    while (!stack.empty() && stack.peek().hasNext()) {
      Iterator<IXMLElement> iter = stack.peek();
      IXMLElement node = iter.next();
      Iterator<IXMLElement> children = node.getChildren().iterator();
      if (!iter.hasNext()) {
        stack.pop();
      }
      if (children.hasNext()) {
        stack.push(children);
      }
      if (node.getName() != null &&
          node.getName().equals("drawing") &&
          (node.getNamespace() == null ||
          node.getNamespace().equals(OFFICE_NAMESPACE))) {
        drawingElem = node;
        break;
      }
    }
    if (drawingElem.getName() == null ||
        !drawingElem.getName().equals("drawing") ||
        (drawingElem.getNamespace() != null &&
        !drawingElem.getNamespace().equals(OFFICE_NAMESPACE))) {
      throw new IOException("'office:drawing' element expected: " + drawingElem.getName());
    }
    readDrawingElement(drawingElem);
    if (replace) {
      drawing.removeAllChildren();
    }
    drawing.addAll(figures);
###
2006, transform, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 157, 162
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
6
  public void transform(AffineTransform tx) {
    Point2D.Double anchor = getStartPoint();
    Point2D.Double lead = getEndPoint();
    setBounds(
        (Point2D.Double) tx.transform(anchor, anchor),
        (Point2D.Double) tx.transform(lead, lead));
###
2007, getArcWidth, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 103, 104
1
/** Gets the arc width. */
2
  public double getArcWidth() {
    return roundrect.arcwidth;
###
2008, readFrameElement, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 674, 678
43
/**
   * Reads a &lt;draw:frame&gt; element from the specified
   * XML element.
   * <p>
   * A frame is a rectangular container where that contains enhanced content
   * like text boxes, images or objects. Frames are very similar to regular
   * drawing shapes, but support some features that are not available for
   * regular drawing shapes, like contours, image maps and hyperlinks. In
   * particular, a frame allows to have multiple renditions of an object. That
   * is, a frame may for instance contain an object as well as an image. In
   * this case, the application may choose the content that it supports best.
   * If the application supports the object type contained in the frame, it
   * probably will render the object. If it does not support the object, it
   * will render the image.
   * <p>
   * In general, an application must not render more than one of the content
   * elements contained in a frame. The order of content elements dictates
   * the document author's preference for rendering, with the first child
   * being the most preferred. This means that applications should render the
   * first child element that it supports. A frame must contain at least one
   * content element. The inclusion of multiple content elements is optional.
   * Application may preserve the content elements they don't render, but
   * don't have to.
   * <p>
   * Within text documents, frames are also used to position content outside
   * the default text flow of a document.
   * <p>
   * Frames can contain:
   *  Text boxes
   *  Objects represented either in the OpenDocument format or in a object
   *    specific binary format
   *  Images
   *  Applets
   *  Plug-ins
   *  Floating frames
   * <p>
   * Like the formatting properties of drawing shapes, frame formatting
   * properties are stored in styles belonging to the graphic family. The way
   * a frame is contained in a document also is the same as for drawing shapes.
   *
   *
   * @param elem A &lt;frame&gt; element.
   */
5
  private ODGFigure readFrameElement(IXMLElement elem) throws IOException {
    if (DEBUG) {
      System.out.println("ODGInputFormat.readFrameElement(" + elem + ") not implemented.");
    }
    return null;
###
2010, toWSOrCommaSeparatedArray, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 871, 876
5
/**
   * Returns a value as a String array.
   * The values are separated by whitespace or by commas with optional white
   * space.
   */
6
  public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {
    String[] result = str.split("(\\s*,\\s*|\\s+)");
    if (result.length == 1 && result[0].equals("")) {
      return new String[0];
    } else {
      return result;
###
2014, getArcHeight, RoundRectangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java, 108, 109
1
/** Gets the arc height. */
2
  public double getArcHeight() {
    return roundrect.archeight;
###
2015, toTransform, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 1300, 1414
18
/** Converts an ODG draw:transform attribute value into an AffineTransform.
   * <p>
   * The draw:transform attribute specifies a list of transformations that can be applied to a
   * drawing shape.
   * The value of this attribute is a list of transform definitions, which are applied to the drawing shape
   * in the order in which they are listed. The transform definitions in the list must be separated by a
   * white space and/or a comma. The types of transform definitions available include:
   *  matrix(<a> <b> <c> <d> <e> <f>), which specifies a transformation in the form of a
   * transformation matrix of six values. matrix(a,b,c,d,e,f) is the equivalent of applying the
   * transformation matrix [a b c d e f].
   *  translate(<tx> [<ty>]), which specifies a translation by tx and ty.
   *  scale(<sx> [<sy>]), which specifies a scale operation by sx and sy. If <sy> is not
   * provided, it is assumed to be equal to <sx>.
   *  rotate(<rotate-angle>), which specifies a rotation by <rotate-angle> about the
   * origin of the shapes coordinate system.
   *  skewX(<skew-angle>), which specifies a skew transformation along the X axis.
   *  skewY(<skew-angle>), which specifies a skew transformation along the Y axis.
   */
105
  public static AffineTransform toTransform(String str) throws IOException {
    AffineTransform t = new AffineTransform();
    AffineTransform t2 = new AffineTransform();
    if (str != null) {
      StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
      tt.resetSyntax();
      tt.wordChars('a', 'z');
      tt.wordChars('A', 'Z');
      tt.wordChars(128 + 32, 255);
      tt.whitespaceChars(0, ' ');
      tt.whitespaceChars(',', ',');
      tt.parseNumbers();
      tt.parseExponents();
      while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
        if (tt.ttype != StreamPosTokenizer.TT_WORD) {
          throw new IOException("Illegal transform " + str);
        }
        String type = tt.sval;
        if (tt.nextToken() != '(') {
          throw new IOException("'(' not found in transform " + str);
        }
        if (type.equals("matrix")) {
          double[] m = new double[6];
          for (int i = 0; i < 6; i++) {
            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
              throw new IOException("Matrix value " + i + " not found in transform " + str + " token:" + tt.ttype + " " + tt.sval);
            }
            m[i] = tt.nval;
          }
          t.preConcatenate(new AffineTransform(m));
        } else if (type.equals("translate")) {
          double tx, ty;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-translation value not found in transform " + str);
          }
          tx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {
            tx *= toUnitFactor(tt.sval);
          } else {
            tt.pushBack();
          }
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            ty = tt.nval;
            if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {
              ty *= toUnitFactor(tt.sval);
            } else {
              tt.pushBack();
            }
          } else {
            tt.pushBack();
            ty = 0;
          }
          t2.setToIdentity();
          t2.translate(tx, ty);
          t.preConcatenate(t2);
        } else if (type.equals("scale")) {
          double sx, sy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-scale value not found in transform " + str);
          }
          sx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            sy = tt.nval;
          } else {
            tt.pushBack();
            sy = sx;
          }
          t2.setToIdentity();
          t2.scale(sx, sy);
          t.preConcatenate(t2);
        } else if (type.equals("rotate")) {
          double angle, cx, cy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Angle value not found in transform " + str);
          }
          angle = tt.nval;
          t2.setToIdentity();
          t2.rotate(-angle);
          t.preConcatenate(t2);

        } else if (type.equals("skewX")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.preConcatenate(new AffineTransform(
              1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));
        } else if (type.equals("skewY")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.preConcatenate(new AffineTransform(
              1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));
        } else {
          throw new IOException("Unknown transform " + type + " in " + str);
        }
        if (tt.nextToken() != ')') {
          throw new IOException("')' not found in transform " + str);
        }
      }
    }
    return t;
###
2016, nextEnhancedCoordinate, ODGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java, 1207, 1234
5
/**
   * Retrieves an enhanced coordinate from the specified tokenizer.
   * An enhanced coordinate can be a double, or a '?' followed by a
   * formula name, or a '$' followed by an index to a modifier.
   */
28
  private Object nextEnhancedCoordinate(StreamPosTokenizer tt, String str) throws IOException {
    switch (tt.nextToken()) {
      case '?': {
        StringBuilder buf = new StringBuilder();
        buf.append('?');
        int ch = tt.nextChar();
        for (; ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9';
            ch = tt.nextChar()) {
          buf.append((char) ch);
        }
        tt.pushCharBack(ch);
        return buf.toString();
      }
      case '$': {
        StringBuilder buf = new StringBuilder();
        buf.append('$');
        int ch = tt.nextChar();
        for (; ch >= '0' && ch <= '9';
            ch = tt.nextChar()) {
          buf.append((char) ch);
        }
        tt.pushCharBack(ch);
        return buf.toString();
      }
      case StreamPosTokenizer.TT_NUMBER:
        return tt.nval;
      default:
        throw new IOException("coordinate missing at position" + tt.getStartPosition() + " in " + str);
###
2017, handleMouseClick, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 405, 435
3
/**
   * Handles a mouse click.
   */
29
  @Override
  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {
    if (getLiner() == null &&
        evt.getClickCount() == 2) {
      willChange();
      final int index = splitSegment(p, (float) (5f / view.getScaleFactor()));
      if (index != -1) {
        final BezierPath.Node newNode = getNode(index);
        fireUndoableEditHappened(new AbstractUndoableEdit() {
          @Override
          public void redo() throws CannotRedoException {
            super.redo();
            willChange();
            addNode(index, newNode);
            changed();
          }
          @Override
          public void undo() throws CannotUndoException {
            super.undo();
            willChange();
            removeNode(index);
            changed();
          }
        });
        changed();
        return true;
      }
    }
    return false;
###
2019, addNotify, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 277, 283
6
/**
   * This method is invoked, when the Figure is being removed from a Drawing.
   * This method invokes handleConnect, if the Figure is connected.
   *
   * @see #handleConnect
   */
6
  @Override
  public void addNotify(Drawing drawing) {
    super.addNotify(drawing);
    if (getStartConnector() != null && getEndConnector() != null) {
      handleConnect(getStartConnector(), getEndConnector());
      updateConnection();
###
2021, transform, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 101, 104
4
/**
   * Ensures that a connection is updated if the connection
   * was moved.
   */
4
  @Override
  public void transform(AffineTransform tx) {
    super.transform(tx);
    updateConnection(); // make sure that we are still connected
###
2022, createHandles, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 114, 132
5
/**
   * Gets the handles of the figure. It returns the normal
   * PolylineHandles but adds ChangeConnectionHandles at the
   * start and end.
   */
19
  @Override
  public Collection<Handle> createHandles(int detailLevel) {
    ArrayList<Handle> handles = new ArrayList<Handle>(getNodeCount());
    switch (detailLevel) {
      case -1: // Mouse hover handles
        handles.add(new BezierOutlineHandle(this, true));
        break;
      case 0:
        handles.add(new BezierOutlineHandle(this));
        if (getLiner() == null) {
          for (int i = 1, n = getNodeCount() - 1; i < n; i++) {
            handles.add(new BezierNodeHandle(this, i));
          }
        }
        handles.add(new ConnectionStartHandle(this));
        handles.add(new ConnectionEndHandle(this));
        break;
    }
    return handles;
###
2024, removeNotify, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 293, 306
9
/**
   * This method is invoked, when the Figure is being removed from a Drawing.
   * This method invokes handleDisconnect, if the Figure is connected.
   *
   * @see #handleDisconnect
   */
 --------------
// SHAPE AND BOUNDS
 --------------
14
  @Override
  public void removeNotify(Drawing drawing) {
    if (getStartConnector() != null && getEndConnector() != null) {
      handleDisconnect(getStartConnector(), getEndConnector());
    }
    // Note: we do not set the connectors to null here, because we
    // need them when we are added back to a drawing again. For example,
    // when an undo is performed, after the LineConnection has been
    // deleted.
    /*
    setStartConnector(null);
    setEndConnector(null);
     */
    super.removeNotify(drawing);
###
2027, setConnectable, LineConnectionFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java, 140, 142
4
/**
   * 
   * ConnectionFigures cannot be connected and always sets connectable to false.
   */
3
  @Override
  public void setConnectable(boolean newValue) {
    super.setConnectable(false);
###
2028, transform, ODGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java, 176, 204
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
29
  public void transform(AffineTransform tx) {
    invalidateTransformedShape();
    if (get(TRANSFORM) != null ||
        //        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM, (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM, t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT, g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT, g);
###
2029, ODGRectFigure, ODGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java, 48, 49
1
/** Creates a new instance. */
2
  public ODGRectFigure() {
    this(0, 0, 0, 0);
###
2030, contains, ODGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java, 132, 133
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2036, sort, QuadTreeDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java, 74, 82
3
/**
   * Implementation note: Sorting can not be done for orphaned children.
   */
9
  public java.util.List<Figure> sort(Collection<? extends Figure> c) {
    ensureSorted();
    ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());
    for (Figure f : children) {
      if (c.contains(f)) {
        sorted.add(f);
      }
    }
    return sorted;
###
2037, ensureSorted, QuadTreeDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java, 268, 271
3
/**
   * Ensures that the children are sorted in z-order sequence.
   */
4
  private void ensureSorted() {
    if (needsSorting) {
      Collections.sort(children, FigureLayerComparator.INSTANCE);
      needsSorting = false;
###
2040, getFiguresFrontToBack, QuadTreeDrawing, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java, 118, 120
4
/**
   * Returns an iterator to iterate in
   * Z-order front to back over the children.
   */
3
  public java.util.List<Figure> getFiguresFrontToBack() {
    ensureSorted();
    return new ReversedList<Figure>(children);
###
2041, ODGPathFigure, ODGPathFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGPathFigure.java, 57, 59
1
/** Creates a new instance. */
3
  public ODGPathFigure() {
    add(new ODGBezierFigure());
    ODGAttributeKeys.setDefaults(this);
###
2044, AlignAction, AlignAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AlignAction.java, 36, 37
1
/** Creates a new instance. */
2
  public AlignAction(DrawingEditor editor) {
    super(editor);
###
2058, AbstractDrawingViewAction, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 79, 80
3
/**
   * Creates a view action which acts on the current view of the editor.
   */
2
  public AbstractDrawingViewAction(DrawingEditor editor) {
    setEditor(editor);
###
2059, dispose, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 139, 140
3
/** Frees all resources held by this object, so that it can be garbage
   * collected.
   */
2
  public void dispose() {
    setEditor(null);
###
2060, setUpdateEnabledState, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 152, 165
9
/** By default, the enabled state of this action is updated to reflect
   * the enabled state of the active {@code DrawingView}.
   * Since this is not always necessary, and since many listening actions
   * may considerably slow down the drawing editor, you can switch this
   * behavior off here.
   *
   * @param newValue Specify false to prevent automatic updating of the
   * enabled state.
   */
14
  public void setUpdateEnabledState(boolean newValue) {
    // Note: eventHandler != null yields true, if we are currently updating
    // the enabled state.
    if (eventHandler != null != newValue) {
      if (newValue) {
        eventHandler = new EventHandler();
        registerEventHandler();
      } else {
        unregisterEventHandler();
        eventHandler = null;
      }
    }
    if (newValue) {
      updateEnabledState();
###
2062, unregisterEventHandler, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 179, 188
3
/** Unregisters the event handler from the drawing editor and the
   * active drawing view.
   */
10
  private void unregisterEventHandler() {
    if (editor != null) {
      editor.removePropertyChangeListener(eventHandler);
    }
    if (activeView != null) {
      activeView.removePropertyChangeListener(eventHandler);
      activeView = null;
    }
    if (specificView != null) {
      specificView.removePropertyChangeListener(eventHandler);
###
2063, AbstractDrawingViewAction, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 86, 88
3
/**
   * Creates a view action which acts on the specified view.
   */
3
  public AbstractDrawingViewAction(DrawingView view) {
    this.specificView = view;
    registerEventHandler();
###
2064, isUpdatEnabledState, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 172, 173
3
/** Returns true, if this action automatically updates its enabled
   * state to reflect the enabled state of the active {@code DrawingView}.
   */
2
  public boolean isUpdatEnabledState() {
    return eventHandler != null;
###
2065, updateEnabledState, AbstractDrawingViewAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java, 122, 126
4
/** Updates the enabled state of this action to reflect the enabled state
   * of the active {@code DrawingView}. If no drawing view is active, this
   * action is disabled.
   */
5
  public void updateEnabledState() {
    if (getView() != null) {
      setEnabled(getView().isEnabled());
    } else {
      setEnabled(false);
###
2066, AttributeToggler, AttributeToggler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeToggler.java, 45, 46
1
/** Creates a new instance. */
2
  public AttributeToggler(DrawingEditor editor, AttributeKey<T> key, T value1, T value2) {
    this(editor, key, value1, value2, null);
###
2068, TriangleFigure, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 50, 51
1
/** Creates a new instance. */
2
  public TriangleFigure() {
    this(0, 0, 0, 0);
###
2069, contains, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 183, 194
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
12
  public boolean contains(Point2D.Double p) {
    Shape triangle = getBezierPath();
    
    double grow = AttributeKeys.getPerpendicularHitGrowth(this);
    if (grow != 0d) {
      GrowStroke gs = new GrowStroke((float) grow,
          (float) (AttributeKeys.getStrokeTotalWidth(this) *
          get(STROKE_MITER_LIMIT))
          );
      triangle =gs.createStrokedShape(triangle);
    }
    return triangle.contains(p);
###
2070, findCompatibleConnector, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 81, 82
7
/**
   * Returns a compatible connector.
   * By default a {@link org.jhotdraw.draw.connector.ChopTriangleConnector} is returned.
   */
 --------------
// SHAPE AND BOUNDS
 --------------
2
  public Connector findCompatibleConnector(Connector c, boolean isStartConnector) {
    return new ChopTriangleConnector(this);
###
2071, findConnector, TriangleFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java, 74, 75
4
/**
   * Returns the Figures connector for the specified location.
   * By default a {@link org.jhotdraw.draw.connector.ChopTriangleConnector} is returned.
   */
2
  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {
    return new ChopTriangleConnector(this);
###
2072, ApplyAttributesAction, ApplyAttributesAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ApplyAttributesAction.java, 36, 39
1
/** Creates a new instance. */
4
  public ApplyAttributesAction(DrawingEditor editor) {
    super(editor);
    labels.configureAction(this, "edit.applyAttributes");
    setEnabled(true);
###
2073, AttributeAction, AttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java, 41, 42
1
/** Creates a new instance. */
2
  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {
    this(editor, key, value, null, icon);
###
2074, AttributeAction, AttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java, 36, 37
1
/** Creates a new instance. */
2
  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value) {
    this(editor, key, value, null, null);
###
2075, AttributeAction, AttributeAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java, 46, 47
1
/** Creates a new instance. */
2
  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, String name) {
    this(editor, key, value, name, null);
###
2076, updateEnabledState, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 99, 104
4
/** Updates the enabled state of this action to reflect the enabled state
   * of the active {@code DrawingView}. If no drawing view is active, this
   * action is disabled.
   */
6
  protected void updateEnabledState() {
    if (getView() != null) {
      setEnabled(getView().isEnabled() &&
          getView().getSelectionCount() > 0);
    } else {
      setEnabled(false);
###
2077, setUpdateEnabledState, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 148, 161
9
/** By default, the enabled state of this action is updated to reflect
   * the enabled state of the active {@code DrawingView}.
   * Since this is not always necessary, and since many listening actions
   * may considerably slow down the drawing editor, you can switch this
   * behavior off here.
   *
   * @param newValue Specify false to prevent automatic updating of the
   * enabled state.
   */
14
  public void setUpdateEnabledState(boolean newValue) {
    // Note: eventHandler != null yields true, if we are currently updating
    // the enabled state.
    if (eventHandler != null != newValue) {
      if (newValue) {
        eventHandler = new EventHandler();
        registerEventHandler();
      } else {
        unregisterEventHandler();
        eventHandler = null;
      }
    }
    if (newValue) {
      updateEnabledState();
###
2078, isUpdatEnabledState, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 168, 169
3
/** Returns true, if this action automatically updates its enabled
   * state to reflect the enabled state of the active {@code DrawingView}.
   */
2
  public boolean isUpdatEnabledState() {
    return eventHandler != null;
###
2079, AbstractSelectedAction, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 90, 92
3
/** Creates an action which acts on the selected figures on the current view
   * of the specified editor.
   */
3
  public AbstractSelectedAction(DrawingEditor editor) {
    setEditor(editor);
    updateEnabledState();
###
2080, unregisterEventHandler, AbstractSelectedAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java, 175, 182
3
/** Unregisters the event handler from the drawing editor and the
   * active drawing view.
   */
8
  private void unregisterEventHandler() {
    if (editor != null) {
      editor.removePropertyChangeListener(eventHandler);
    }
    if (activeView != null) {
      activeView.removeFigureSelectionListener(eventHandler);
      activeView.removePropertyChangeListener(eventHandler);
      activeView = null;
###
2081, unregisterEventHandler, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 131, 133
3
/** Unregisters the event handler from the drawing editor and the
   * active drawing view.
   */
3
  private void unregisterEventHandler() {
    if (editor != null) {
      editor.removePropertyChangeListener(eventHandler);
###
2082, AbstractDrawingEditorAction, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 56, 57
1
/** Creates a new instance. */
2
  public AbstractDrawingEditorAction(DrawingEditor editor) {
    setEditor(editor);
###
2083, fireUndoableEditHappened, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 91, 92
4
/** Updates the enabled state of this action to reflect the enabled state
   * of the active {@code DrawingView}. If no drawing view is active, this
   * action is disabled.
   */
2
  protected void fireUndoableEditHappened(UndoableEdit edit) {
    getDrawing().fireUndoableEditHappened(edit);
###
2084, setUpdateEnabledState, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 104, 117
9
/** By default, the enabled state of this action is updated to reflect
   * the enabled state of the active {@code DrawingView}.
   * Since this is not always necessary, and since many listening actions
   * may considerably slow down the drawing editor, you can switch this
   * behavior off here.
   *
   * @param newValue Specify false to prevent automatic updating of the
   * enabled state.
   */
14
  public void setUpdateEnabledState(boolean newValue) {
    // Note: eventHandler != null yields true, if we are currently updating
    // the enabled state.
    if (eventHandler != null != newValue) {
      if (newValue) {
        eventHandler = new EventHandler();
        registerEventHandler();
      } else {
        unregisterEventHandler();
        eventHandler = null;
      }
    }
    if (newValue) {
      updateEnabledState();
###
2085, isUpdatEnabledState, AbstractDrawingEditorAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java, 124, 125
3
/** Returns true, if this action automatically updates its enabled
   * state to reflect the enabled state of the active {@code DrawingView}.
   */
2
  public boolean isUpdatEnabledState() {
    return eventHandler != null;
###
2088, getEventSetDescriptors, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2089, getBeanDescriptor, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2090, getMethodDescriptors, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2091, getPropertyDescriptors, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2093, getDefaultPropertyIndex, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2094, getDefaultEventIndex, AlignToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2095, getID, AbstractToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBar.java, 54, 55
7
/** This should be an abstract method, but the NetBeans GUI builder
   * doesn't support abstract beans.
   * @return The ID used to retrieve labels and store user preferences.
   */
 --------------
// prefs is null, because we are not permitted to read preferences
 --------------
2
  protected String getID() {
    return "";
###
2096, AbstractToolBar, AbstractToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBar.java, 41, 45
1
/** Creates new form. */
5
  public AbstractToolBar() {
    initComponents();
    try {
      prefs = PreferencesUtil.userNodeForPackage(getClass());
    } catch (SecurityException e) {
###
2099, getDefaultPropertyIndex, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2100, getDefaultEventIndex, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2103, getPropertyDescriptors, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2104, getEventSetDescriptors, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2106, getMethodDescriptors, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2107, getBeanDescriptor, CanvasToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2108, SVGImageFigure, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 70, 71
1
/** Creates a new instance. */
2
  public SVGImageFigure() {
    this(0, 0, 0, 0);
###
2109, AlignToolBar, AlignToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBar.java, 37, 39
1
/** Creates new instance. */
3
  public AlignToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
###
2111, initComponents, AlignToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBar.java, 144, 146
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    setOpaque(false);
###
2114, transform, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 199, 215
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
17
  public void transform(AffineTransform tx) {
    invalidateTransformedShape();
    if (get(TRANSFORM) != null ||
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM, (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM, t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
###
2115, contains, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 159, 160
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2117, getBufferedImage, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 389, 402
4
/**
   * Gets the buffered image. If necessary, this method creates the buffered
   * image from the image data.
   */
14
  public BufferedImage getBufferedImage() {
    if (bufferedImage == null && imageData != null) {
      //System.out.println("recreateing bufferedImage");
      try {
        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));
      } catch (Throwable e) {
        e.printStackTrace();
        // If we can't create a buffered image from the image data,
        // there is no use to keep the image data and try again, so
        // we drop the image data.
        imageData = null;
      }
    }
    return bufferedImage;
###
2118, setImage, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 356, 360
11
/**
   * Sets the image.
   *
   * @param imageData The image data. If this is null, a buffered image must
   * be provided.
   * @param bufferedImage An image constructed from the imageData. If this
   * is null, imageData must be provided.
   */
 --------------
// COMPOSITE FIGURES
 --------------
5
  public void setImage(byte[] imageData, BufferedImage bufferedImage) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = bufferedImage;
    changed();
###
2119, getImageData, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 409, 424
4
/**
   * Gets the image data. If necessary, this method creates the image
   * data from the buffered image.
   */
16
  public byte[] getImageData() {
    if (bufferedImage != null && imageData == null) {
      try {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ImageIO.write(bufferedImage, "PNG", bout);
        bout.close();
        imageData = bout.toByteArray();
      } catch (IOException e) {
        e.printStackTrace();
        // If we can't create image data from the buffered image,
        // there is no use to keep the buffered image and try again, so
        // we drop the buffered image.
        bufferedImage = null;
      }
    }
    return imageData;
###
2122, setImageData, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 367, 371
4
/**
   * Sets the image data.
   * This clears the buffered image.
   */
5
  public void setImageData(byte[] imageData) {
    willChange();
    this.imageData = imageData;
    this.bufferedImage = null;
    changed();
###
2125, getMethodDescriptors, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2126, setBufferedImage, SVGImageFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java, 378, 382
4
/**
   * Sets the buffered image.
   * This clears the image data.
   */
5
  public void setBufferedImage(BufferedImage image) {
    willChange();
    this.imageData = null;
    this.bufferedImage = image;
    changed();
###
2127, getBeanDescriptor, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2128, getPropertyDescriptors, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2129, getDefaultEventIndex, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2130, getEventSetDescriptors, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2131, getDefaultPropertyIndex, AbstractToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2132, SVGEllipseFigure, SVGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java, 49, 50
1
/** Creates a new instance. */
2
  public SVGEllipseFigure() {
    this(0, 0, 0, 0);
###
2134, contains, SVGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java, 112, 113
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2137, transform, SVGEllipseFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java, 153, 182
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
30
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        TRANSFORM.setClone(this, tx);
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
      }
    }
    invalidate();
###
2139, CanvasToolBar, CanvasToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBar.java, 41, 44
1
/** Creates new instance. */
4
  public CanvasToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2140, getDefaultPropertyIndex, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2141, getPropertyDescriptors, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2142, getDefaultEventIndex, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2143, getMethodDescriptors, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2146, getBeanDescriptor, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2148, contains, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 200, 201
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
2
  public boolean contains(Point2D.Double p) {
    return getHitShape().contains(p);
###
2149, getEventSetDescriptors, ArrangeToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java, 117, 118
8
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */

2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2150, getArcWidth, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 141, 142
1
/** Gets the arc width. */
2
  public double getArcWidth() {
    return roundrect.arcwidth;
###
2151, setArcHeight, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 158, 161
1
/** Sets the arc height. */
4
  public void setArcHeight(double newValue) {
    double oldValue = roundrect.archeight;
    roundrect.archeight = newValue;
    firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);
###
2152, SVGRectFigure, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 68, 69
1
/** Creates a new instance. */
2
  public SVGRectFigure() {
    this(0, 0, 0, 0);
###
2153, transform, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 250, 278
4
/**
   * Transforms the figure.
   * @param tx The transformation.
   */
29
  public void transform(AffineTransform tx) {
    invalidateTransformedShape();
    if (get(TRANSFORM) != null ||
        //        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {
        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM,  (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
###
2154, getArcHeight, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 146, 147
1
/** Gets the arc height. */
2
  public double getArcHeight() {
    return roundrect.archeight;
###
2155, getMethodDescriptors, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2156, setArc, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 165, 167
1
/** Convenience method for setting both the arc width and the arc height. */
3
  public void setArc(double width, double height) {
    setArcWidth(width);
    setArcHeight(height);
###
2157, getBeanDescriptor, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2159, getDefaultPropertyIndex, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2163, getPropertyDescriptors, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2165, getEventSetDescriptors, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2166, setArcWidth, SVGRectFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java, 152, 155
1
/** Sets the arc width. */
4
  public void setArcWidth(double newValue) {
    double oldValue = roundrect.arcwidth;
    roundrect.arcwidth = newValue;
    firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);
###
2167, getDefaultEventIndex, ActionsToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2169, ArrangeToolBar, ArrangeToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBar.java, 37, 39
1
/** Creates new instance. */
3
  public ArrangeToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
###
2170, initComponents, ArrangeToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBar.java, 117, 119
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    setOpaque(false);
###
2172, ActionsToolBar, ActionsToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBar.java, 50, 52
1
/** Creates new instance. */
3
  public ActionsToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
###
2173, getTool, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 505, 510
4
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
6
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextAreaEditingTool tool = new TextAreaEditingTool(this);
      return tool;
    }
    return null;
###
2174, appendParagraph, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 191, 304
17
/**
   * Appends a paragraph of text at the specified y location and returns
   * the bounds of the paragraph.
   * 
   *
   * @param shape Shape to which to add the glyphs of the paragraph. This 
   * parameter is null, if we only want to measure the size of the paragraph.
   * @param styledText the text of the paragraph.
   * @param verticalPos the top bound of the paragraph
   * @param maxVerticalPos the bottom bound of the paragraph
   * @param leftMargin the left bound of the paragraph
   * @param rightMargin the right bound of the paragraph
   * @param tabStops an array with tab stops
   * @param tabCount the number of entries in tabStops which contain actual
   *    values
   * @return Returns the actual bounds of the paragraph.
   */
95
  private Rectangle2D.Double appendParagraph(Path2D.Double shape,
      AttributedCharacterIterator styledText,
      float verticalPos, float maxVerticalPos,
      float leftMargin, float rightMargin,
      float[] tabStops, int tabCount) {
    // assume styledText is an AttributedCharacterIterator, and the number
    // of tabs in styledText is tabCount
    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);
    int[] tabLocations = new int[tabCount + 1];
    int i = 0;
    for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {
      if (c == '\t') {
        tabLocations[i++] = styledText.getIndex();
      }
    }
    tabLocations[tabCount] = styledText.getEndIndex() - 1;
    // Now tabLocations has an entry for every tab's offset in
    // the text.  For convenience, the last entry is tabLocations
    // is the offset of the last character in the text.
    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());
    int currentTab = 0;
    while (measurer.getPosition() < styledText.getEndIndex()) {
      // Lay out and draw each line.  All segments on a line
      // must be computed before any drawing can occur, since
      // we must know the largest ascent on the line.
      // TextLayouts are computed and stored in a List;
      // their horizontal positions are stored in a parallel
      // List.
      // lineContainsText is true after first segment is drawn
      boolean lineContainsText = false;
      boolean lineComplete = false;
      float maxAscent = 0, maxDescent = 0;
      float horizontalPos = leftMargin;
      LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();
      LinkedList<Float> penPositions = new LinkedList<Float>();
      while (!lineComplete) {
        float wrappingWidth = rightMargin - horizontalPos;
        TextLayout layout = null;
        layout =
            measurer.nextLayout(wrappingWidth,
            tabLocations[currentTab] + 1,
            lineContainsText);
        // layout can be null if lineContainsText is true
        if (layout != null) {
          layouts.add(layout);
          penPositions.add(horizontalPos);
          horizontalPos += layout.getAdvance();
          maxAscent = Math.max(maxAscent, layout.getAscent());
          maxDescent = Math.max(maxDescent,
              layout.getDescent() + layout.getLeading());
        } else {
          lineComplete = true;
        }
        lineContainsText = true;
        if (measurer.getPosition() == tabLocations[currentTab] + 1) {
          currentTab++;
        }
        if (measurer.getPosition() == styledText.getEndIndex()) {
          lineComplete = true;
        } else if (tabStops.length == 0 || horizontalPos >= tabStops[tabStops.length - 1]) {
          lineComplete = true;
        }
        if (!lineComplete) {
          // move to next tab stop
          int j;
          for (j = 0; horizontalPos >= tabStops[j]; j++) {
          }
          horizontalPos = tabStops[j];
        }
      }
      verticalPos += maxAscent;
      if (verticalPos > maxVerticalPos) {
        break;
      }
      Iterator<TextLayout> layoutEnum = layouts.iterator();
      Iterator<Float> positionEnum = penPositions.iterator();
      // now iterate through layouts and draw them
      while (layoutEnum.hasNext()) {
        TextLayout nextLayout = layoutEnum.next();
        float nextPosition = positionEnum.next();
        AffineTransform tx = new AffineTransform();
        tx.translate(nextPosition, verticalPos);
        if (shape != null) {
          Shape outline = nextLayout.getOutline(tx);
          shape.append(outline, false);
        }
        Rectangle2D layoutBounds = nextLayout.getBounds();
        paragraphBounds.add(new Rectangle2D.Double(layoutBounds.getX() + nextPosition,
            layoutBounds.getY() + verticalPos,
            layoutBounds.getWidth(),
            layoutBounds.getHeight()));
      }
      verticalPos += maxDescent;
    }
    return paragraphBounds;
###
2176, contains, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 109, 119
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
10
  public boolean contains(Point2D.Double p) {
    if (get(TRANSFORM) != null) {
      try {
        p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        ex.printStackTrace();
      }
    }
    Rectangle2D r = getTextShape().getBounds2D();
    return r.isEmpty() ? getBounds().contains(p) : r.contains(p);
###
2180, transform, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 320, 351
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
32
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        (tx.getType() &
        (AffineTransform.TYPE_TRANSLATION /*| AffineTransform.TYPE_MASK_SCALE*/)) !=
        tx.getType()) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM,  (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      Point2D.Double anchor = getStartPoint();
      Point2D.Double lead = getEndPoint();
      setBounds(
          (Point2D.Double) tx.transform(anchor, anchor),
          (Point2D.Double) tx.transform(lead, lead));
      if (get(FILL_GRADIENT) != null &&
          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
      }
    }
    invalidate();
###
2181, SVGTextAreaFigure, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 60, 61
1
/** Creates a new instance. */
2
  public SVGTextAreaFigure() {
    this("Text");
###
2182, getPreferredTextSize, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 550, 586
10
/**
   * Returns the preferred text size of the TextAreaFigure.
   * <p>
   * If you want to use this method to determine the bounds of the TextAreaFigure,
   * you need to add the insets of the TextAreaFigure to the size.
   * 
   * @param maxWidth the maximal width to use. Specify Double.MAX_VALUE
   * if you want the width to be unlimited.
   * @return width and height needed to lay out the text.
   */
35
  public Dimension2DDouble getPreferredTextSize(double maxWidth) {
    Rectangle2D.Double textRect = new Rectangle2D.Double();
    if (getText() != null) {
      Font font = getFont();
      boolean isUnderlined = get(FONT_UNDERLINE);
      float leftMargin = 0;
      float rightMargin = (float) maxWidth - 1;
      float verticalPos = 0;
      float maxVerticalPos = Float.MAX_VALUE;
      if (leftMargin < rightMargin) {
        float tabWidth = (float) (getTabSize() * font.getStringBounds("m", getFontRenderContext()).getWidth());
        float[] tabStops = new float[(int) (textRect.width / tabWidth)];
        for (int i = 0; i < tabStops.length; i++) {
          tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));
        }
        if (getText() != null) {
          String[] paragraphs = getText().split("\n");//Strings.split(getText(), '\n');
          for (int i = 0; i < paragraphs.length; i++) {
            if (paragraphs[i].length() == 0) {
              paragraphs[i] = " ";
            }
            AttributedString as = new AttributedString(paragraphs[i]);
            as.addAttribute(TextAttribute.FONT, font);
            if (isUnderlined) {
              as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);
            }
            int tabCount = paragraphs[i].split("\t").length - 1;
            Rectangle2D.Double paragraphBounds = appendParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);
            verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);
            textRect.add(paragraphBounds);
          }
        }
      }
    }
    return new Dimension2DDouble(Math.abs(textRect.x) + textRect.width, Math.abs(textRect.y) + textRect.height);
###
2183, getInsets, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 404, 407
3
/**
   * Returns the insets used to draw text.
   */
4
  public Insets2D.Double getInsets() {
    double sw = (get(STROKE_COLOR) == null) ? 0 : Math.ceil(get(STROKE_WIDTH) / 2);
    Insets2D.Double insets = new Insets2D.Double(0, 0, 0, 0);
    return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);
###
2184, setText, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 397, 398
3
/**
   * Sets the text shown by the text figure.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
2185, isEmpty, SVGTextAreaFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java, 520, 521
3
/**
   * Gets the text shown by the text figure.
   */
2
  public boolean isEmpty() {
    return getText() == null || getText().length() == 0;
###
2187, SVGPathOutlineHandle, SVGPathOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathOutlineHandle.java, 38, 39
1
/** Creates a new instance. */
2
  public SVGPathOutlineHandle(SVGPathFigure owner) {
    this(owner, false);
###
2188, SVGPathFigure, SVGPathFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathFigure.java, 57, 59
1
/** Creates a new instance. */
3
  public SVGPathFigure() {
    add(new SVGBezierFigure());
    SVGAttributeKeys.setDefaults(this);
###
2189, handleMouseClick, SVGPathFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathFigure.java, 455, 468
3
/**
   * Handles a mouse click.
   */
14
  @Override
  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {
    if (evt.getClickCount() == 2 && view.getHandleDetailLevel() % 2 == 0) {
      for (Figure child : getChildren()) {
        SVGBezierFigure bf = (SVGBezierFigure) child;
        int index = bf.findSegment(p, 5f / view.getScaleFactor());
        if (index != -1) {
          bf.handleMouseClick(p, evt, view);
          evt.consume();
          return true;
        }
      }
    }
    return false;
###
2192, draw, SVGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectRadiusHandle.java, 49, 58
3
/**
   * Draws this handle.
   */
10
  @Override
  public void draw(Graphics2D g) {
    if (getEditor().getTool().supportsHandleInteraction()) {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));
    } else {
      drawDiamond(g,
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),
          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));
###
2193, SVGRectRadiusHandle, SVGRectRadiusHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectRadiusHandle.java, 42, 43
1
/** Creates a new instance. */
2
  public SVGRectRadiusHandle(Figure owner) {
    super(owner);
###
2195, contains, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 170, 178
3
/**
   * Checks if a Point2D.Double is inside the figure.
   */
9
  public boolean contains(Point2D.Double p) {
    if (get(TRANSFORM) != null) {
      try {
        p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        ex.printStackTrace();
      }
    }
    return getTextShape().getBounds2D().contains(p);
###
2197, SVGTextFigure, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 71, 72
1
/** Creates a new instance. */
2
  public SVGTextFigure() {
    this("Text");
###
2199, setText, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 309, 310
3
/**
   * Sets the text shown by the text figure.
   */
2
  public void setText(String newText) {
    set(TEXT, newText);
###
2200, getTool, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 415, 421
7
/**
   * Returns a specialized tool for the given coordinate.
   * <p>Returns null, if no specialized tool is available.
   */
 --------------
// EDITING
 --------------
7
  @Override
  public Tool getTool(Point2D.Double p) {
    if (isEditable() && contains(p)) {
      TextEditingTool tool = new TextEditingTool(this);
      return tool;
    }
    return null;
###
2202, getText, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 291, 292
3
/**
   * Gets the text shown by the text figure.
   */
2
  public String getText() {
    return (String) get(TEXT);
###
2203, transform, SVGTextFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java, 233, 260
5
/**
   * Transforms the figure.
   *
   * @param tx the transformation.
   */
28
  public void transform(AffineTransform tx) {
    if (get(TRANSFORM) != null ||
        tx.getType() != (tx.getType() & AffineTransform.TYPE_TRANSLATION)) {
      if (get(TRANSFORM) == null) {
        set(TRANSFORM,  (AffineTransform) tx.clone());
      } else {
        AffineTransform t = TRANSFORM.getClone(this);
        t.preConcatenate(tx);
        set(TRANSFORM,  t);
      }
    } else {
      for (int i=0; i < coordinates.length; i++) {
        tx.transform(coordinates[i], coordinates[i]);
      }
      if (get(FILL_GRADIENT) != null &&
          ! get(FILL_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = FILL_GRADIENT.getClone(this);
        g.transform(tx);
        set(FILL_GRADIENT,  g);
      }
      if (get(STROKE_GRADIENT) != null &&
          ! get(STROKE_GRADIENT).isRelativeToFigureBounds()) {
        Gradient g = STROKE_GRADIENT.getClone(this);
        g.transform(tx);
        set(STROKE_GRADIENT,  g);
      }
    }
    invalidate();
###
2205, SVGGroupFigure, SVGGroupFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGGroupFigure.java, 40, 41
1
/** Creates a new instance. */
2
  public SVGGroupFigure() {
    SVGAttributeKeys.setDefaults(this);
###
2206, EditGridPanel, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 36, 70
1
/** Creates new instance. */
33
  public EditGridPanel() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    widthField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 1000, 1));
    heightField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 1000, 1));
    thetaField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 180, 1));
    constrainer = new GridConstrainer(10, 10);
    
    widthField.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals("value")) {
          if (evt.getNewValue() != null) {
            constrainer.setWidth((Double) evt.getNewValue());
          }
        }
      }
    });
    
    heightField.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals("value")) {
          if (evt.getNewValue() != null) {
            constrainer.setHeight((Double) evt.getNewValue());
          }
        }
      }
    });
    
    thetaField.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        if (evt.getPropertyName().equals("value")) {
          if (evt.getNewValue() != null) {
            constrainer.setTheta((Double) evt.getNewValue() * Math.PI / 180d);
###
2207, getConstrainer, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 95, 96
5
/**
   * Returns the GridConstrainer currently being edited by this panel.
   * 
   * @return The GridConstrainer.
   */
2
  public GridConstrainer getConstrainer() {
    return constrainer;
###
2208, initComponents, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 105, 158
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
46
  private void initComponents() {
    widthLabel = new javax.swing.JLabel();
    heightLabel = new javax.swing.JLabel();
    widthField = new org.jhotdraw.gui.JLifeFormattedTextField();
    heightField = new org.jhotdraw.gui.JLifeFormattedTextField();
    thetaLabel = new javax.swing.JLabel();
    thetaField = new org.jhotdraw.gui.JLifeFormattedTextField();
    widthLabel.setText(labels.getString("view.grid.width.text")); // NOI18N
    heightLabel.setText(labels.getString("view.grid.height.text")); // NOI18N
    widthField.setColumns(5);
    heightField.setColumns(5);
    thetaLabel.setText(labels.getString("view.grid.theta.text")); // NOI18N
    thetaField.setColumns(5);
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(heightLabel, javax.swing.GroupLayout.Alignment.TRAILING)
          .addComponent(widthLabel, javax.swing.GroupLayout.Alignment.TRAILING)
          .addComponent(thetaLabel, javax.swing.GroupLayout.Alignment.TRAILING))
        .addGap(4, 4, 4)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
          .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addContainerGap(67, Short.MAX_VALUE))
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(widthLabel)
          .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(heightLabel)
          .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
          .addComponent(thetaLabel)
          .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
###
2209, setConstrainer, EditGridPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java, 83, 87
5
/**
   * Sets the GridConstrainer to be edited by this panel.
   * 
   * @param newValue The GridConstrainer.
   */
5
  public void setConstrainer(GridConstrainer newValue) {
    constrainer = newValue;
    widthField.setValue(constrainer.getWidth());
    heightField.setValue(constrainer.getHeight());
    thetaField.setValue(constrainer.getTheta() * 180d / Math.PI);
###
2210, IncreaseHandleDetailLevelAction, IncreaseHandleDetailLevelAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/IncreaseHandleDetailLevelAction.java, 28, 30
1
/** Creates a new instance. */
3
  public IncreaseHandleDetailLevelAction(DrawingEditor editor) {
    super(editor);
    labels.configureAction(this, ID);
###
2211, EditorColorChooserAction, EditorColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java, 42, 43
1
/** Creates a new instance. */
2
  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {
    this(editor, key, null, icon);
###
2212, EditorColorChooserAction, EditorColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java, 37, 38
1
/** Creates a new instance. */
2
  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {
    this(editor, key, null, null);
###
2213, EditorColorChooserAction, EditorColorChooserAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java, 47, 48
1
/** Creates a new instance. */
2
  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, String name) {
    this(editor, key, name, null);
###
2214, GroupAction, GroupAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/GroupAction.java, 39, 40
1
/** Creates a new instance. */
2
  public GroupAction(DrawingEditor editor) {
    this(editor, new GroupFigure(), true);
###
2215, FontChooserHandler, FontChooserHandler, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/FontChooserHandler.java, 41, 49
1
/** Creates a new instance. */
8
  public FontChooserHandler(DrawingEditor editor, AttributeKey<Font> key, JFontChooser fontChooser, JPopupMenu popupMenu) {
    super(editor);
    this.key = key;
    this.fontChooser = fontChooser;
    this.popupMenu = popupMenu;
    fontChooser.addActionListener(this);
    fontChooser.addPropertyChangeListener(this);
    updateEnabledState();
###
2216, getBorderInsets, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 112, 113
4
/**
   * Returns the insets of the border.
   * @param c the component for which this border insets value applies
   */
2
  public Insets getBorderInsets(Component c) {
    return (Insets) borderInsets.clone();
###
2217, paintBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 127, 246
10
/**
   * Paints the bevel image for the specified component with the
   * specified position and size.
   * @param c the component for which this border is being painted
   * @param gr the paint graphics
   * @param x the x position of the painted border
   * @param y the y position of the painted border
   * @param width the width of the painted border
   * @param height the height of the painted border
   */
120
  public void paintBorder(Component c, Graphics gr, int x, int y, int width, int height) {
    if (image == null) return;
    
    // Cast Graphics to Graphics2D
    Graphics2D g = (Graphics2D) gr;
    
    // Set some variables for easy access of insets and image size
    int top = imageInsets.top;
    int left = imageInsets.left;
    int bottom = imageInsets.bottom;
    int right = imageInsets.right;
    int imgWidth = image.getWidth();
    int imgHeight = image.getHeight();
    
    
    // Optimisation: Draw image directly if it fits into the component
    if (fillContentArea) {
      if (width == imgWidth && height == imgHeight) {
        g.drawImage(image, x, y, c);
        return;
      }
    }
    
    // Optimisation: Remove insets, if image width or image height fits
    if (width == imgWidth) {
      left = imgWidth;
      right = 0;
    }
    if (height == imgHeight) {
      top = imgHeight;
      bottom = 0;
    }
    
    // Adjust insets if component is too small
    if (width < left + right) {
      left = Math.min(left, width / 2); //Math.max(0, left + (width - left - right) / 2);
      right = width - left;
    }
    if (height < top + bottom) {
      top = Math.min(top, height / 2); //Math.max(0, top + (height - top - bottom) / 2);
      bottom = height - top;
    }
    
    // Draw the Leads
    if (top > 0 && left > 0) {
      g.drawImage(
      image,
      x, y, x + left, y + top,
      0, 0, left, top,
      c
      );
    }
    if (top > 0 && right > 0) {
      //g.fillRect(x+width-right, y, x+width, y+top);
      g.drawImage(
      image,
      x + width - right, y, x + width, y + top,
      imgWidth - right, 0, imgWidth, top,
      c
      );
    }
    if (bottom > 0 && left > 0) {
      g.drawImage(
      image,
      x, y + height - bottom, x + left, y + height,
      0, imgHeight - bottom, left, imgHeight,
      c
      );
    }
    if (bottom > 0 && right > 0) {
      g.drawImage(
      image,
      x + width - right, y + height - bottom, x + width, y + height,
      imgWidth - right, imgHeight - bottom, imgWidth, imgHeight,
      c
      );
    }
    
    // Draw the edges
    BufferedImage subImg = null;
    TexturePaint paint;
    
    // North
    if (top > 0 && left + right < width) {
      subImg = image.getSubimage(left, 0, imgWidth - right - left, top);
      paint = new TexturePaint(subImg, new Rectangle(x+left, y, imgWidth - left - right, top));
      g.setPaint(paint);
      g.fillRect(x+left, y, width - left - right, top);
    }
    // South
    if (bottom > 0 && left + right < width) {
      subImg = image.getSubimage(left, imgHeight - bottom, imgWidth - right - left, bottom);
      paint = new TexturePaint(subImg, new Rectangle(x+left, y + height - bottom, imgWidth - left - right, bottom));
      g.setPaint(paint);
      g.fillRect(x+left, y + height - bottom, width - left - right, bottom);
    }
    // West
    if (left > 0 && top + bottom < height) {
      subImg = image.getSubimage(0, top, left, imgHeight - top - bottom);
      paint = new TexturePaint(subImg, new Rectangle(x, y+top, left, imgHeight - top - bottom));
      g.setPaint(paint);
      g.fillRect(x, y+top, left, height - top - bottom);
    }
    // East
    if (right > 0 && top + bottom < height) {
      subImg = image.getSubimage(imgWidth - right, top, right, imgHeight - top - bottom);
      paint = new TexturePaint(subImg, new Rectangle(x+width-right, y + top, right, imgHeight - top - bottom));
      g.setPaint(paint);
      g.fillRect(x+width-right, y + top, right, height - top - bottom);
    }
    
    // Fill the center
    if (fillContentArea) {
      g.setColor(Color.yellow);
      if (left + right < width
      && top + bottom < height) {
        subImg = image.getSubimage(left, top, imgWidth - right - left, imgHeight - top - bottom);
        paint = new TexturePaint(subImg, new Rectangle(x + left, y + top, imgWidth - right - left, imgHeight - top - bottom));
        g.setPaint(paint);
        g.fillRect(x+left, y + top, width - right - left, height - top - bottom);
###
2218, ImageBevelBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 73, 74
4
/**
   * Creates a new instance with the given image and insets.
   * The image has different insets than the border.
   */
2
  public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets) {
    this(img, imageInsets, borderInsets, true);
###
2219, ImageBevelBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 80, 97
4
/**
   * Creates a new instance with the given image and insets.
   * The image has different insets than the border.
   */
18
  public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets, boolean fillContentArea) {
    if (img instanceof BufferedImage) {
      this.image = (BufferedImage) img;
    } else {
      Frame f = new Frame();
      f.pack();
      MediaTracker t = new MediaTracker(f);
      t.addImage(img, 0);
      try { t.waitForAll(); } catch (InterruptedException e) {}
      image = new BufferedImage(img.getWidth(f), img.getHeight(f), BufferedImage.TYPE_INT_ARGB);
      Graphics2D imgGraphics = image.createGraphics();
      imgGraphics.drawImage(img, 0, 0, f);
      imgGraphics.dispose();
      f.dispose();
    }
    this.imageInsets = imageInsets;
    this.borderInsets = borderInsets;
    this.fillContentArea = fillContentArea;
###
2220, ImageBevelBorder, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 65, 66
4
/**
   * Creates a new instance with the given image and insets.
   * The image has the same insets as the border.
   */
2
  public ImageBevelBorder(Image img, Insets borderInsets) {
    this(img, borderInsets, borderInsets, true);
###
2221, isBorderOpaque, ImageBevelBorder, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java, 104, 105
4
/**
   * Returns true if the border is opaque.
   * This implementation always returns false.
   */
2
  public boolean isBorderOpaque() {
    return false;
###
2222, getRedoAction, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 200, 201
3
/**
   * Gets the redo action for use as a Redo menu item.
   */
2
  public Action getRedoAction() {
    return redoAction;
###
2223, UndoRedoManager, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 128, 131
6
/** Creates new UndoRedoManager */
 --------------
/**
   * Redo Action for use in a menu bar.
   */
 --------------
4
  public UndoRedoManager() {
    getLabels();
    undoAction = new UndoAction();
    redoAction = new RedoAction();
###
2224, updateActions, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 209, 232
4
/**
   * Updates the properties of the UndoAction
   * and of the RedoAction.
   */
24
  private void updateActions() {
    String label;
    if (DEBUG) System.out.println("UndoRedoManager@"+hashCode()+".updateActions "+
        editToBeUndone()
        +" canUndo="+canUndo()+" canRedo="+canRedo());
    if (canUndo()) {
      undoAction.setEnabled(true);
      label = getUndoPresentationName();
    } else {
      undoAction.setEnabled(false);
      label = labels.getString("edit.undo.text");
    }
    undoAction.putValue(Action.NAME, label);
    undoAction.putValue(Action.SHORT_DESCRIPTION, label);
    
    if (canRedo()) {
      redoAction.setEnabled(true);
      label = getRedoPresentationName();
    } else {
      redoAction.setEnabled(false);
      label = labels.getString("edit.redo.text");
    }
    redoAction.putValue(Action.NAME, label);
    redoAction.putValue(Action.SHORT_DESCRIPTION, label);
###
2225, discardAllEdits, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 141, 144
8
/**
   * Discards all edits.
   */
 --------------
/**
     * Invoked when an action occurs.
     */
 --------------
4
  public void discardAllEdits() {
    super.discardAllEdits();
    updateActions();
    setHasSignificantEdits(false);
###
2226, addEdit, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 177, 188
16
/**
   * If inProgress, inserts anEdit at indexOfNextAdd, and removes
   * any old edits that were at indexOfNextAdd or later. The die
   * method is called on each edit that is removed is sent, in the
   * reverse of the order the edits were added. Updates
   * indexOfNextAdd.
   *
   * <p>If not inProgress, acts as a CompoundEdit</p>
   *
   * <p>Regardless of inProgress, if undoOrRedoInProgress,
   * calls die on each edit that is sent.</p>
   *
   *
   * @see CompoundEdit#end
   * @see CompoundEdit#addEdit
   */
12
  public boolean addEdit(UndoableEdit anEdit) {
    if (DEBUG) System.out.println("UndoRedoManager@"+hashCode()+".add "+anEdit);
    if (undoOrRedoInProgress) {
      anEdit.die();
      return true;
    }
    boolean success = super.addEdit(anEdit);
    updateActions();
    if (success && anEdit.isSignificant() && editToBeUndone() == anEdit) {
      setHasSignificantEdits(true);
    }
    return success;
###
2227, undo, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 240, 247
5
/**
   * Undoes the last edit event.
   * The UndoRedoManager ignores all incoming UndoableEdit events,
   * while undo is in progress.
   */
8
  public void undo()
  throws CannotUndoException {
    undoOrRedoInProgress = true;
    try {
      super.undo();
    } finally {
      undoOrRedoInProgress = false;
      updateActions();
###
2228, hasSignificantEdits, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 157, 158
4
/**
   * Returns true if at least one significant UndoableEdit
   * has been added since the last call to discardAllEdits.
   */
2
  public boolean hasSignificantEdits() {
    return hasSignificantEdits;
###
2229, getUndoAction, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 193, 194
3
/**
   * Gets the undo action for use as an Undo menu item.
   */
2
  public Action getUndoAction() {
    return undoAction;
###
2230, redo, UndoRedoManager, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java, 256, 263
5
/**
   * Redoes the last undone edit event.
   * The UndoRedoManager ignores all incoming UndoableEdit events,
   * while redo is in progress.
   */
8
  public void redo()
  throws CannotUndoException {
    undoOrRedoInProgress = true;
    try {
      super.redo();
    } finally {
      undoOrRedoInProgress = false;
      updateActions();
###
2231, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 66, 67
7
/**
   * Creates a new {@code CompositeEdit} which uses the specified significance.
   * <p>
   * The presentation name is used from CompoundEdit#getPresentationName().
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public CompositeEdit(boolean isSignificant) {
    this.isSignificant = isSignificant;
###
2232, addEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 134, 141
12
/**
   * If this edit is inProgress, accepts anEdit and returns
   * true.
   *
   * <p>The last edit added to this CompositeEdit is given a
   * chance to addEdit(anEdit). If it refuses (returns false), anEdit is
   * given a chance to replaceEdit the last edit. If anEdit returns
   * false here, it is added to edits.</p>
   *
   * <p>If the CompositeEdit is added to itself, then method end()
   * is called, and true is returned.</p>
   */
8
  public boolean addEdit(UndoableEdit anEdit) {
    if (anEdit == this) {
        end();
      return true;
    } else if (isInProgress() && (anEdit instanceof CompositeEdit)) {
      return true;
    } else {
      return super.addEdit(anEdit);
###
2233, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 77, 79
8
/**
   * Creates a new {@code CompositeEdit} which uses the specified
   * presentation name.
   * <p>
   * If the presentation name is null, then CompoundEdit.getPresentatioName
   * is used.
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeEdit(String presentationName) {
    this.presentationName = presentationName;
    isSignificant = true;
###
2234, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 89, 91
8
/**
   * Creates a new {@code CompositeEdit} which uses the given presentation name
   * and significance.
   * <p>
   * If the presentation name is null, then CompoundEdit.getPresentatioName
   * is used.
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
3
  public CompositeEdit(String presentationName, boolean isSignificant) {
    this.presentationName = presentationName;
    this.isSignificant = isSignificant;
###
2235, getRedoPresentationName, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 118, 119
6
/**
   * Returns the redo presentation name.
   * If the presentation name is null, then CompoundEdit.getRedoPresentationName
   * is returned.
   * @see javax.swing.undo.CompoundEdit#getRedoPresentationName()
   */
2
  public String getRedoPresentationName() {
    return ((presentationName != null) ? UndoRedoManager.getLabels().getString("edit.redo.text")+" "+presentationName : super.getRedoPresentationName());
###
2236, getPresentationName, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 100, 101
6
/**
   * Returns the presentation name.
   * If the presentation name is null, then CompoundEdit.getPresentatioName
   * is returned.
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public String getPresentationName() {
    return (presentationName != null) ? presentationName : super.getPresentationName();
###
2237, getUndoPresentationName, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 109, 110
6
/**
   * Returns the undo presentation name.
   * If the presentation name is null, then CompoundEdit.getUndoPresentationName
   * is returned.
   * @see javax.swing.undo.CompoundEdit#getUndoPresentationName()
   */
2
  public String getUndoPresentationName() {
    return ((presentationName != null) ? UndoRedoManager.getLabels().getString("edit.undo.text")+" "+presentationName : super.getUndoPresentationName());
###
2238, CompositeEdit, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 56, 57
6
/**
   * Creates a new {@code CompositeEdit} which uses CompoundEdit#getPresentationName()
   * and is significant..
   *
   * @see javax.swing.undo.CompoundEdit#getPresentationName()
   */
2
  public CompositeEdit() {
    isSignificant = true;
###
2239, isSignificant, CompositeEdit, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java, 150, 151
5
/**
   * Returns false if this edit is insignificant - for example one
   * that maintains the user's selection, but does not change
   * any model state.
   */
2
  public boolean isSignificant() {
    return (isSignificant) ? super.isSignificant() : false;
###
2240, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 188, 198
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return  The value returned by the getter method or the default value.
   */
11
  public static int invokeGetter(Object obj, String methodName, int defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return ((Integer) result).intValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2241, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 327, 336
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, float newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Float.TYPE} );
      return method.invoke(obj, new Object[] { new Float(newValue)});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2242, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 291, 300
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, boolean newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Boolean.TYPE} );
       return method.invoke(obj, new Object[] { new Boolean(newValue)});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2243, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 309, 318
6
/**
   * Invokes the specified method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, int newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Integer.TYPE} );
      return method.invoke(obj, new Object[] { new Integer(newValue)});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2244, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 409, 412
6
/**
   * Invokes the specified method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName, boolean newValue) {
    try {
       invoke(obj, methodName, newValue);
    } catch (NoSuchMethodException e) {
###
2245, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 396, 399
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName, float newValue) {
    try {
      invoke(obj, methodName, newValue);
    } catch (NoSuchMethodException e) {
###
2246, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 383, 386
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName) {
    try {
       invoke(obj, methodName);
    } catch (NoSuchMethodException e) {
###
2247, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 363, 374
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
12
  public static Object invoke(Object obj, String methodName, Class[] clazz, Object... newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  clazz );
      return method.invoke(obj, newValue);
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      InternalError error = new InternalError(e.getMessage());
      error.initCause((e.getCause() != null) ? e.getCause() : e);
      throw error;
###
2248, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 169, 176
11
/**
   * Invokes the specified parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @param types The parameter types.
   * @param values The parameter values.
   * @param defaultValue The default value.
   * @return The return value of the method or the default value if the method
   * does not exist or is not accessible.
   */
8
  public static Object invokeStatic(String clazz, String methodName,
  Class[] types, Object[] values, Object defaultValue) {
    try {
      return invokeStatic(Class.forName(clazz), methodName, types, values);
    } catch (ClassNotFoundException e) {
      return defaultValue;
    } catch (NoSuchMethodException e) {
      return defaultValue;
###
2249, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 251, 261
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return The value returned by the getter method or the default value.
   */
11
  public static Object invokeGetter(Object obj, String methodName, Object defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return result;
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2250, invokeStaticGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 272, 282
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param clazz The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return The value returned by the getter method or the default value.
   */
11
  public static boolean invokeStaticGetter(Class clazz, String methodName, boolean defaultValue) {
    try {
      Method method =  clazz.getMethod(methodName,  new Class[0]);
      Object result = method.invoke(null, new Object[0]);
      return ((Boolean) result).booleanValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2251, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 65, 75
9
/**
   * Invokes the specified accessible method with a string parameter if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param stringParameter The String parameter
   * @return The return value of the method or METHOD_NOT_FOUND.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
11
  public static Object invoke(Object obj, String methodName, String stringParameter)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { String.class });
      Object result = method.invoke(obj, new Object[] { stringParameter });
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2252, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 43, 53
9
/**
   * Invokes the specified accessible parameterless method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not
   * accessible.
   */
11
  public static Object invoke(Object obj, String methodName)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2253, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 209, 219
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return  The value returned by the getter method or the default value.
   */
11
  public static long invokeGetter(Object obj, String methodName, long defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return ((Long) result).longValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2254, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 126, 136
10
/**
   * Invokes the specified parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @param types The parameter types.
   * @param values The parameter values.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
11
  public static Object invokeStatic(Class clazz, String methodName, Class[] types, Object[] values)
  throws NoSuchMethodException {
    try {
      Method method =  clazz.getMethod(methodName,  types);
      Object result = method.invoke(null, values);
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2256, invokeIfExists, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 422, 425
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
4
  public static void invokeIfExists(Object obj, String methodName, Class clazz, Object newValue) {
    try {
       invoke(obj, methodName, clazz, newValue);
    } catch (NoSuchMethodException e) {
###
2257, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 108, 113
8
/**
   * Invokes the specified accessible parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
6
  public static Object invokeStatic(String clazz, String methodName)
  throws NoSuchMethodException {
    try {
      return invokeStatic(Class.forName(clazz), methodName);
    } catch (ClassNotFoundException e) {
      throw new NoSuchMethodException("class "+clazz+" not found");
###
2258, invokeIfExistsWithEnum, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 436, 448
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
13
  public static void invokeIfExistsWithEnum(Object obj, String methodName, String enumClassName, String enumValueName) {
    try {
      Class enumClass = Class.forName(enumClassName);
      Object enumValue = invokeStatic("java.lang.Enum", "valueOf", new Class[] {Class.class, String.class},
          new Object[] {enumClass, enumValueName}
      );
      invoke(obj, methodName, enumClass, enumValue);
    } catch (ClassNotFoundException e) {
      // ignore
      e.printStackTrace();
    } catch (NoSuchMethodException e) {
      // ignore
      e.printStackTrace();
###
2259, invoke, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 345, 354
6
/**
   * Invokes the specified setter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   */
10
  public static Object invoke(Object obj, String methodName, Class clazz, Object newValue)
  throws NoSuchMethodException {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[] { clazz } );
      return method.invoke(obj, new Object[] { newValue});
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2260, invokeGetter, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 230, 240
8
/**
   * Invokes the specified getter method if it exists.
   *
   * @param obj The object on which to invoke the method.
   * @param methodName The name of the method.
   * @param defaultValue This value is returned, if the method does not exist.
   * @return The value returned by the getter method or the default value.
   */
11
  public static boolean invokeGetter(Object obj, String methodName, boolean defaultValue) {
    try {
      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);
      Object result = method.invoke(obj, new Object[0]);
      return ((Boolean) result).booleanValue();
    } catch (NoSuchMethodException e) {
      return defaultValue;
    } catch (IllegalAccessException e) {
      return defaultValue;
    } catch (InvocationTargetException e) {
      return defaultValue;
###
2261, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 149, 155
10
/**
   * Invokes the specified parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @param types The parameter types.
   * @param values The parameter values.
   * @return The return value of the method.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
7
  public static Object invokeStatic(String clazz, String methodName,
  Class[] types, Object[] values)
  throws NoSuchMethodException {
    try {
      return invokeStatic(Class.forName(clazz), methodName, types, values);
    } catch (ClassNotFoundException e) {
      throw new NoSuchMethodException("class "+clazz+" not found");
###
2262, invokeStatic, Methods, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java, 87, 97
8
/**
   * Invokes the specified accessible parameterless method if it exists.
   *
   * @param clazz The class on which to invoke the method.
   * @param methodName The name of the method.
   * @return The return value of the method or METHOD_NOT_FOUND.
   * @return NoSuchMethodException if the method does not exist or is not accessible.
   */
11
  public static Object invokeStatic(Class clazz, String methodName)
  throws NoSuchMethodException {
    try {
      Method method =  clazz.getMethod(methodName,  new Class[0]);
      Object result = method.invoke(null, new Object[0]);
      return result;
    } catch (IllegalAccessException e) {
      throw new NoSuchMethodException(methodName+" is not accessible");
    } catch (InvocationTargetException e) {
      // The method is not supposed to throw exceptions
      throw new InternalError(e.getMessage());
###
2264, split, Images, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Images.java, 171, 189
3
/**
   * Splits an image into count subimages.
   */
18
  public static BufferedImage[] split(Image image, int count, boolean isHorizontal) {
    BufferedImage src = Images.toBufferedImage(image);
    if (count == 1) {
      return new BufferedImage[]{src};
    }
    BufferedImage[] parts = new BufferedImage[count];
    for (int i = 0; i < count; i++) {
      if (isHorizontal) {
        parts[i] = src.getSubimage(
            src.getWidth() / count * i, 0,
            src.getWidth() / count, src.getHeight());
      } else {
        parts[i] = src.getSubimage(
            0, src.getHeight() / count * i,
            src.getWidth(), src.getHeight() / count);
      }
    }
    return parts;
###
2265, toBufferedImage, Images, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Images.java, 55, 70
7
/**
   * Converts an Image to BufferedImage. If the Image is already a
   * BufferedImage, the same image is returned.
   * 
   * @param rImg An Image.
   * @return A BufferedImage.
   */
16
  public static BufferedImage toBufferedImage(RenderedImage rImg) {
    BufferedImage image;
    if (rImg instanceof BufferedImage) {
      image = (BufferedImage) rImg;
    } else {
      Raster r = rImg.getData();
      WritableRaster wr = WritableRaster.createWritableRaster(
          r.getSampleModel(), null);
      rImg.copyData(wr);
      image = new BufferedImage(
          rImg.getColorModel(),
          wr,
          rImg.getColorModel().isAlphaPremultiplied(),
          null);
    }
    return image;
###
2266, hasAlpha, Images, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/Images.java, 148, 165
6
/**
   * This method returns true if the specified image has transparent pixels
   *
   * Code taken from the Java Developers Almanac 1.4
   * http://javaalmanac.com/egs/java.awt.image/HasAlpha.html
   */
16
  public static boolean hasAlpha(Image image) {
    // If buffered image, the color model is readily available
    if (image instanceof BufferedImage) {
      BufferedImage bimage = (BufferedImage) image;
      return bimage.getColorModel().hasAlpha();
    }
    // Use a pixel grabber to retrieve the image's color model;
    // grabbing a single pixel is usually sufficient
    PixelGrabber pg = new PixelGrabber(image, 0, 0, 1, 1, false);
    try {
      pg.grabPixels();
    } catch (InterruptedException e) {
    }
    // Get the image's color model
    ColorModel cm = pg.getColorModel();
    return cm.hasAlpha();
###
2270, ResourceBundleUtil, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 108, 111
4
/**
   * Creates a new ResouceBundleUtil which wraps
   * the provided resource bundle.
   */
4
  public ResourceBundleUtil(String baseName, Locale locale) {
    this.locale = locale;
    this.baseName = baseName;
    this.resource = ResourceBundle.getBundle(baseName, locale);
###
2271, getMnemonic, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 309, 311
8
/**
   * Get a Mnemonic from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property.
   * @return The first char of the value of the property.
   *      Returns '\0' if the property is missing.
   */
3
  public char getMnemonic(String key) {
    String s = getStringRecursive(key);
    return (s == null || s.length() == 0) ? '\0' : s.charAt(0);
###
2272, getString, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 130, 141
8
/**
   * Get a String from the ResourceBundle.
   * <br>Convenience method to save casting.
   *
   * @param key The key of the property.
   * @return The value of the property. Returns the key
   *      if the property is missing.
   */
12
  public String getString(String key) {
    try {
      String value = getStringRecursive(key);
      // System.out.println("ResourceBundleUtil "+baseName+" get("+key+"):"+value);
      return value;
    } catch (MissingResourceException e) {
      // System.out.println("ResourceBundleUtil "+baseName+" get("+key+"):***MISSING***");
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + "\" not found.");
        //e.printStackTrace();
      }
      return key;
###
2273, getAcceleratorProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 402, 415
8
/**
   * Gets a KeyStroke for a JavaBeans "accelerator" property from the ResourceBundle.
   * <BR>Convenience method.
   *
   * @param key The key of the property. This method adds ".accelerator" to the key.
   * @return <code>javax.swing.KeyStroke.getKeyStroke(value)</code>.
   *      Returns null if the property is missing.
   */
14
  public KeyStroke getAcceleratorProperty(String key) {
    KeyStroke ks = null;
    try {
      String s;
      s = getStringRecursive(key + ".accelerator");
      ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".accelerator\" not found.");
        //e.printStackTrace();
      }
    } catch (NoSuchElementException e) {
    }
    return ks;
###
2274, removePropertyNameModifier, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 533, 534
3
/**
   * Removes a property name modifier.
   */
2
  public static void removePropertyNameModifier(String name) {
    propertyNameModifiers.remove(name);
###
2275, getMnemonicProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 322, 333
8
/**
   * Gets a char for a JavaBeans "mnemonic" property from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property. This method appends ".mnemonic" to the key.
   * @return The first char of the value of the property.
   *      Returns '\0' if the property is missing.
   */
12
  public char getMnemonicProperty(String key) {
    String s;
    try {
      s = getStringRecursive(key + ".mnemonic");
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".mnemonic\" not found.");
        //e.printStackTrace();
      }
      s = null;
    }
    return (s == null || s.length() == 0) ? '\0' : s.charAt(0);
###
2276, putPropertyNameModifier, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 526, 527
6
/**
   * Puts a property name modifier along with a fallback chain.
   *
   * @param name The name of the modifier.
   * @param fallbackChain The fallback chain of the modifier.
   */
2
  public static void putPropertyNameModifier(String name, String... fallbackChain) {
    propertyNameModifiers.put(name, fallbackChain);
###
2277, getIconProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 279, 297
8
/**
   * Get an image icon from the ResourceBundle.
   * <br>Convenience method .
   *
   * @param key The key of the property. This method appends ".icon" to the key.
   * @return The value of the property. Returns null
   *      if the property is missing.
   */
17
  public ImageIcon getIconProperty(String key, Class baseClass) {
    try {
      String rsrcName = getStringRecursive(key + ".icon");
      if (rsrcName.equals("")) {
        return null;
      }
      URL url = baseClass.getResource(rsrcName);
      if (isVerbose && url == null) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "].getIconProperty \"" + key + ".icon\" resource:" + rsrcName + " not found.");
      }
      return (url == null) ? null : new ImageIcon(url);
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "].getIconProperty \"" + key + ".icon\" not found.");
        //e.printStackTrace();
      }
      return null;
###
2278, format, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 246, 248
6
/**
   * Returns a formatted string using java.util.Formatter().
   * @param key
   * @param arguments
   * @return formatted String
   */
3
  public String format(String key, Object... arguments) {
    //return String.format(resource.getLocale(), getString(key), arguments);
    return new Formatter(resource.getLocale()).format(getString(key), arguments).toString();
###
2279, getBundle, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 423, 425
5
/**
   * Get the appropriate ResourceBundle subclass.
   *
   * @see java.util.ResourceBundle
   */
3
  public static ResourceBundleUtil getBundle(String baseName)
      throws MissingResourceException {
    return getBundle(baseName, LocaleUtil.getDefault());
###
2280, getBundle, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 500, 504
5
/**
   * Get the appropriate ResourceBundle subclass.
   *
   * @see java.util.ResourceBundle
   */
5
  public static ResourceBundleUtil getBundle(String baseName, Locale locale)
      throws MissingResourceException {
    ResourceBundleUtil r;
    r = new ResourceBundleUtil(baseName, locale);
    return r;
###
2281, getWrappedBundle, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 118, 119
4
/**
   * Returns the wrapped resource bundle.
   * @return The wrapped resource bundle.
   */
2
  public ResourceBundle getWrappedBundle() {
    return resource;
###
2282, getToolTipTextProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 343, 352
7
/**
   * Get a String for a JavaBeans "toolTipText" property from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property. This method appends ".toolTipText" to the key.
   * @return The ToolTip. Returns null if no tooltip is defined.
   */
10
  public String getToolTipTextProperty(String key) {
    try {
      String value = getStringRecursive(key + ".toolTipText");
      return value;
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".toolTipText\" not found.");
        //e.printStackTrace();
      }
      return null;
###
2283, getTextProperty, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 363, 372
7
/**
   * Get a String for a JavaBeans "text" property from the ResourceBundle.
   * <br>Convenience method.
   *
   * @param key The key of the property. This method appends ".text" to the key.
   * @return The ToolTip. Returns null if no tooltip is defined.
   */
10
  public String getTextProperty(String key) {
    try {
      String value = getStringRecursive(key + ".text");
      return value;
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + ".text\" not found.");
        //e.printStackTrace();
      }
      return null;
###
2284, initComponents, ODGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanel.java, 190, 223
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
26
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
2285, getStringRecursive, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 151, 203
6
/**
   * Recursive part of the getString method.
   *
   * @param key
   * @throws java.util.MissingResourceException
   */
47
  private String getStringRecursive(String key) throws MissingResourceException {
    String value = resource.getString(key);
    // Substitute placeholders in the value
    for (int p1 = value.indexOf("${"); p1 != -1; p1 = value.indexOf("${")) {
      int p2 = value.indexOf('}', p1 + 2);
      if (p2 == -1) {
        break;
      }
      String placeholderKey = value.substring(p1 + 2, p2);
      String placeholderFormat;
      int p3 = placeholderKey.indexOf(',');
      if (p3 != -1) {
        placeholderFormat = placeholderKey.substring(p3 + 1);
        placeholderKey = placeholderKey.substring(0, p3);
      } else {
        placeholderFormat = "string";
      }
      ArrayList<String> fallbackKeys = new ArrayList<String>();
      generateFallbackKeys(placeholderKey, fallbackKeys);
      String placeholderValue = null;
      for (String fk : fallbackKeys) {
        try {
          placeholderValue = getStringRecursive(fk);
          break;
        } catch (MissingResourceException e) {
        }
      }
      if (placeholderValue == null) {
        throw new MissingResourceException("\""+key+"\" not found in "+baseName, baseName, key);
      }
      // Do post-processing depending on placeholder format 
      if (placeholderFormat.equals("accelerator")) {
        // Localize the keywords shift, control, ctrl, meta, alt, altGraph
        StringBuilder b = new StringBuilder();
        for (String s : placeholderValue.split(" ")) {
          if (acceleratorKeys.contains(s)) {
            b.append(getString("accelerator." + s));
          } else {
            b.append(s);
          }
        }
        placeholderValue = b.toString();
      }
      // Insert placeholder value into value
      value = value.substring(0, p1) + placeholderValue + value.substring(p2 + 1);
    }
    return value;
###
2286, getKeyStroke, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 384, 391
8
/**
   * Get a KeyStroke from the ResourceBundle.
   * <BR>Convenience method.
   *
   * @param key The key of the property.
   * @return <code>javax.swing.KeyStroke.getKeyStroke(value)</code>.
   *      Returns null if the property is missing.
   */
8
  public KeyStroke getKeyStroke(String key) {
    KeyStroke ks = null;
    try {
      String s = getStringRecursive(key);
      ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);
    } catch (NoSuchElementException e) {
    }
    return ks;
###
2287, readObject, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 538, 542
1
/** Read object from ObjectInputStream and re-establish ResourceBundle. */
5
  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
    // our "pseudo-constructor"
    in.defaultReadObject();
    // re-establish the "resource" variable
    this.resource = ResourceBundle.getBundle(baseName, locale);
###
2288, generateFallbackKeys, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 210, 225
4
/**
   * Generates fallback keys by processing all property name modifiers
   * in the key.
   */
16
  private void generateFallbackKeys(String key, ArrayList<String> fallbackKeys) {
    int p1 = key.indexOf("[$");
    if (p1 == -1) {
      fallbackKeys.add(key);
    } else {
      int p2 = key.indexOf(']', p1 + 2);
      if (p2 == -1) {
        return;
      }
      String modifierKey = key.substring(p1 + 2, p2);
      String[] modifierValues = propertyNameModifiers.get(modifierKey);
      if (modifierValues == null) {
        modifierValues = new String[]{"default"};
      }
      for (String mv : modifierValues) {
        generateFallbackKeys(key.substring(0, p1) + mv + key.substring(p2 + 1), fallbackKeys);
###
2289, ODGDrawingPanel, ODGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanel.java, 51, 116
1
/** Creates new instance. */
66
  public ODGDrawingPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
     // FIXME - We need a toggle grid action
     // pb.addSeparator();
     // pb.add(new ToggleGridAction(editor));
    
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);
    
    
    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
2290, getInteger, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 259, 267
8
/**
   * Get an Integer from the ResourceBundle.
   * <br>Convenience method to save casting.
   *
   * @param key The key of the property.
   * @return The value of the property. Returns -1
   *      if the property is missing.
   */
9
  public Integer getInteger(String key) {
    try {
      return Integer.valueOf(getStringRecursive(key));
    } catch (MissingResourceException e) {
      if (isVerbose) {
        System.err.println("Warning ResourceBundleUtil[" + baseName + "] \"" + key + "\" not found.");
        //e.printStackTrace();
      }
      return new Integer(-1);
###
2291, getFormatted, ResourceBundleUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java, 236, 237
6
/**
   * Returns a formatted string using javax.text.MessageFormat.
   * @param key
   * @param arguments
   * @return formatted String
   */
2
  public String getFormatted(String key, Object... arguments) {
    return MessageFormat.format(getString(key), arguments);
###
2293, createToolBars, ODGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java, 175, 200
3
/**
   * Creates toolbars for the application.
   */
24
  public java.util.List<JToolBar> createToolBars(Application a, View pr) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    ODGView p = (ODGView) pr;
    DrawingEditor editor;
    if (p == null) {
      editor = getSharedEditor();
    } else {
      editor = p.getEditor();
    }
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    JToolBar tb;
    tb = new JToolBar();
    addCreationButtonsTo(tb, editor);
    tb.setName(labels.getString("window.drawToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    addAttributesButtonsTo(tb, editor);
    tb.setName(labels.getString("window.attributesToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAlignmentButtonsTo(tb, editor);
    tb.setName(labels.getString("window.alignmentToolBar.title"));
    list.add(tb);
    return list;
###
2294, addAttributesButtonsTo, ODGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java, 130, 144
3
/**
   * Creates toolbar buttons and adds them to the specified JToolBar
   */
13
  private void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JButton b;
    b = bar.add(new PickAttributesAction(editor));
    b.setFocusable(false);
    b = bar.add(new ApplyAttributesAction(editor));
    b.setFocusable(false);
    bar.addSeparator();
    addColorButtonsTo(bar, editor);
    bar.addSeparator();
    addStrokeButtonsTo(bar, editor);
    bar.addSeparator();
    ButtonFactory.addFontButtonsTo(bar, editor);
###
2295, ODGApplicationModel, ODGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java, 64, 65
1
/** Creates a new instance. */
2
  public ODGApplicationModel() {
    setViewClass(ODGView.class);
###
2296, NodeFigure, NodeFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/figures/NodeFigure.java, 47, 54
1
/** Creates a new instance. */
8
  public NodeFigure() {
    RectangleFigure rf = new RectangleFigure();
    setDecorator(rf);
    createConnectors();
    set(DECORATOR_INSETS, new Insets2D.Double(6, 10, 6, 10));
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.net.Labels");
    setText(labels.getString("nodeDefaultName"));
    setAttributeEnabled(DECORATOR_INSETS, false);
###
2300, userNodeForPackage, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 245, 259
5
/** Gets the user node for the package of the class if
   * permitted, gets a proxy otherwise.
   *
   * @return user node or a proxy.
   */
14
  public static Preferences userNodeForPackage(Class<?> c) {
    if (userNodes != null) {
      if (!userNodes.containsKey(c.getPackage())) {
        userNodes.put(c.getPackage(), new PreferencesUtil(false));
      }
      return userNodes.get(c.getPackage());
    }
    try {
      return Preferences.userNodeForPackage(c);
    } catch (Throwable t) {
      if (userNodes == null) {
        userNodes = new HashMap<Package, Preferences>();
      }
      return userNodeForPackage(c);
###
2305, systemNodeForPackage, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 221, 236
5
/** Gets the system node for the package of the class if
   * permitted, gets a proxy otherwise.
   *
   * @return system node or a proxy.
   */
15
  public static Preferences systemNodeForPackage(Class<?> c) {
    if (systemNodes != null) {
      if (!systemNodes.containsKey(c.getPackage())) {
        systemNodes.put(c.getPackage(), new PreferencesUtil(false));
      }
      return systemNodes.get(c.getPackage());
    }

    try {
      return Preferences.systemNodeForPackage(c);
    } catch (Throwable t) {
      if (systemNodes == null) {
        systemNodes = new HashMap<Package, Preferences>();
      }
      return systemNodeForPackage(c);
###
2306, installToolBarPrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 482, 483
9
/**
   * Installs a toolbar preferences handler.
   * On first run, sets the toolbar to BorderLayout.TOP.
   * On subsequent runs, set the toolbar to the last BorderLayout location.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param toolbar The JToolBar for which to track preferences.
   */
2
  public static void installToolBarPrefsHandler(final Preferences prefs, final String name, JToolBar toolbar) {
    new ToolBarPrefsHandler(toolbar, name, prefs);
###
2307, installPalettePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 367, 368
11
/**
   * Installs a palette preferences handler.
   * On first run, sets the palette to its preferred location at the top left
   * corner of the screen.
   * On subsequent runs, sets the palette the last location where
   * the user had placed it before.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   */
2
  public static void installPalettePrefsHandler(final Preferences prefs, final String name, Window window) {
    installPalettePrefsHandler(prefs, name, window, 0);
###
2308, installInternalFramePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 432, 467
11
/**
   * Installs an intenal frame preferences handler.
   * On first run, sets the frame to its preferred size at the top left
   * corner of the desktop pane.
   * On subsequent runs, sets the frame the last size and location where
   * the user had placed it before.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   */
29
  public static void installInternalFramePrefsHandler(final Preferences prefs, final String name, JInternalFrame window, JDesktopPane desktop) {
    Rectangle screenBounds = desktop.getBounds();
    screenBounds.setLocation(0, 0);
    Insets screenInsets = desktop.getInsets();
    screenBounds.x += screenInsets.left;
    screenBounds.y += screenInsets.top;
    screenBounds.width -= screenInsets.left + screenInsets.right;
    screenBounds.height -= screenInsets.top + screenInsets.bottom;
    Dimension preferredSize = window.getPreferredSize();
    Dimension minSize = window.getMinimumSize();
    Rectangle bounds = new Rectangle(
        prefs.getInt(name + ".x", 0),
        prefs.getInt(name + ".y", 0),
        Math.max(minSize.width, prefs.getInt(name + ".width", preferredSize.width)),
        Math.max(minSize.height, prefs.getInt(name + ".height", preferredSize.height)));
    if (!screenBounds.contains(bounds)) {
      bounds.x = screenBounds.x + (screenBounds.width - bounds.width) / 2;
      bounds.y = screenBounds.y + (screenBounds.height - bounds.height) / 2;
      Rectangle.intersect(screenBounds, bounds, bounds);
    }
    window.setBounds(bounds);
    window.addComponentListener(new ComponentAdapter() {
      public void componentMoved(ComponentEvent evt) {
        prefs.putInt(name + ".x", evt.getComponent().getX());
        prefs.putInt(name + ".y", evt.getComponent().getY());
      }
      public void componentResized(ComponentEvent evt) {
        prefs.putInt(name + ".width", evt.getComponent().getWidth());
        prefs.putInt(name + ".height", evt.getComponent().getHeight());
###
2311, installFramePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 285, 286
14
/**
   * Installs a frame preferences handler.
   * On first run, sets the window to its preferred size at the top left
   * corner of the screen.
   * On subsequent runs, sets the window the last size and location where
   * the user had placed it before.
   * <p>
   * If no preferences are stored yet for this window, a default size
   * of 400 x 300 pixels is used.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   */
2
  public static void installFramePrefsHandler(final Preferences prefs, final String name, Window window) {
    installFramePrefsHandler(prefs, name, window, new Dimension(400, 300));
###
2312, clear, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 239, 253
3
/**
   * Clears the view.
   */
15
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
2313, initActions, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 173, 175
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
2314, installFramePrefsHandler, PreferencesUtil, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java, 302, 350
13
/**
   * Installs a frame preferences handler.
   * On first run, sets the window to its preferred size at the top left
   * corner of the screen.
   * On subsequent runs, sets the window the last size and location where
   * the user had placed it before.
   *
   * @param prefs Preferences for storing/retrieving preferences values.
   * @param name Base name of the preference.
   * @param window The window for which to track preferences.
   * @param defaultSize This size is used when no prefences are stored yet for this window.
   *
   */
44
  public static void installFramePrefsHandler(final Preferences prefs, final String name, Window window, Dimension defaultSize) {
    GraphicsConfiguration conf = window.getGraphicsConfiguration();
    Rectangle screenBounds = conf.getBounds();
    Insets screenInsets = window.getToolkit().getScreenInsets(conf);
    screenBounds.x += screenInsets.left;
    screenBounds.y += screenInsets.top;
    screenBounds.width -= screenInsets.left + screenInsets.right;
    screenBounds.height -= screenInsets.top + screenInsets.bottom;
    window.pack();
    Dimension preferredSize = window.getPreferredSize();
    boolean resizable = true;
    if (window instanceof Frame) {
      resizable = ((Frame) window).isResizable();
    } else if (window instanceof Dialog) {
      resizable = ((Dialog) window).isResizable();
    }
    Rectangle bounds;
    if (resizable) {
      bounds = new Rectangle(
          prefs.getInt(name + ".x", 0),
          prefs.getInt(name + ".y", 0),
          Math.max(defaultSize.width, prefs.getInt(name + ".width", preferredSize.width)),
          Math.max(defaultSize.height, prefs.getInt(name + ".height", preferredSize.height)));
    } else {
      bounds = new Rectangle(
          prefs.getInt(name + ".x", 0),
          prefs.getInt(name + ".y", 0),
          window.getWidth(), window.getHeight());
    }
    if (!screenBounds.contains(bounds)) {
      bounds.x = screenBounds.x + (screenBounds.width - bounds.width) / 2;
      bounds.y = screenBounds.y + (screenBounds.height - bounds.height) / 2;
      Rectangle.intersect(screenBounds, bounds, bounds);
    }
    window.setBounds(bounds);
    window.addComponentListener(
        new ComponentAdapter() {
          public void componentMoved(ComponentEvent evt) {
            prefs.putInt(name + ".x", evt.getComponent().getX());
            prefs.putInt(name + ".y", evt.getComponent().getY());
          }
          public void componentResized(ComponentEvent evt) {
            prefs.putInt(name + ".width", evt.getComponent().getWidth());
            prefs.putInt(name + ".height", evt.getComponent().getHeight());
###
2315, read, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 194, 212
3
/**
   * Reads the view from the specified uri.
   */
19
  public void read(URI f, URIChooser chooser) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      InputFormat inputFormat = drawing.getInputFormats().get(0);
      inputFormat.read(new File(f), drawing, true);
      SwingUtilities.invokeAndWait(new Runnable() { public void run() {
        view.getDrawing().removeUndoableEditListener(undo);
        view.setDrawing(drawing);
        view.getDrawing().addUndoableEditListener(undo);
        undo.discardAllEdits();
      }});
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
###
2316, write, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 185, 188
3
/**
   * Writes the view to the specified uri.
   */
4
  public void write(URI f, URIChooser chooser) throws IOException {
      Drawing drawing = view.getDrawing();
      OutputFormat outputFormat = drawing.getOutputFormats().get(0);
      outputFormat.write(new File(f), drawing);
###
2317, NetView, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 71, 114
3
/**
   * Creates a new view.
   */
44
  public NetView() {
    initComponents();
    
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0,0,0,0));
    
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    toggleGridButton = pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style","placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin",new Insets(0,0,0,0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
    
    toggleGridButton.setSelected(preferences.getBoolean("view.gridVisible", false));
    view.setScaleFactor(preferences.getDouble("view.scaleFactor", 1d));
    
    view.addPropertyChangeListener(new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        String name = evt.getPropertyName();
        if (name.equals("scaleFactor")) {
          preferences.putDouble("view.scaleFactor", (Double) evt.getNewValue());
          firePropertyChange("scaleFactor", evt.getOldValue(), evt.getNewValue());
###
2318, createPageable, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 145, 146
3
/**
   * Creates a Pageable object for printing the view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
2319, initComponents, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 268, 279
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
8
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
###
2320, setDrawingEditor, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 219, 225
3
/**
   * Sets a drawing editor for the view.
   */
7
  public void setDrawingEditor(DrawingEditor newValue) {
    if (editor != null) {
      editor.remove(view);
    }
    editor = newValue;
    if (editor != null) {
      editor.add(view);
###
2321, createDrawing, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 132, 140
3
/**
   * Creates a new Drawing for this view.
   */
9
  protected Drawing createDrawing() {
    DefaultDrawing drawing = new DefaultDrawing();
    DOMStorableInputOutputFormat ioFormat =
        new DOMStorableInputOutputFormat(new NetFactory());
    drawing.addInputFormat(ioFormat);
    drawing.addInputFormat(new TextInputFormat(new NodeFigure()));
    drawing.addOutputFormat(ioFormat);
    drawing.addOutputFormat(new ImageOutputFormat());
    return drawing;
###
2322, getDrawingEditor, NetView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java, 232, 233
3
/**
   * Gets the drawing editor of the view.
   */
2
  public DrawingEditor getDrawingEditor() {
    return editor;
###
2324, getDefaultPropertyIndex, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2325, getMethodDescriptors, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2326, getPropertyDescriptors, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2327, getBeanDescriptor, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2329, getEventSetDescriptors, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2332, getDefaultEventIndex, FontToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2333, getMethodDescriptors, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 121, 122
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2334, getPropertyDescriptors, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 99, 100
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2340, getBeanDescriptor, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 83, 84
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2343, getDefaultEventIndex, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 144, 145
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2344, getDefaultPropertyIndex, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 133, 134
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2345, getEventSetDescriptors, ODGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java, 110, 111
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2346, getStrokePaint, ODGAttributeKeys, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java, 119, 132
5
/**
   * Gets the stroke paint for the specified figure based on the attributes
   * STROKE_GRADIENT, STROKE_OPACITY, STROKE_PAINT and the bounds of the figure.
   * Returns null if the figure is not filled.
   */
14
  public static Paint getStrokePaint(Figure f) {
    double opacity = f.get(STROKE_OPACITY);
    if (f.get(STROKE_GRADIENT) != null) {
      return f.get(STROKE_GRADIENT).getPaint(f, opacity);
    }
    Color color = f.get(STROKE_COLOR);
    if (color != null) {
      if (opacity != 1) {
        color = new Color(
            (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,
            true);
      }
    }
    return color;
###
2347, getFillPaint, ODGAttributeKeys, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java, 99, 112
5
/**
   * Gets the fill paint for the specified figure based on the attributes
   * FILL_GRADIENT, FILL_OPACITY, FILL_PAINT and the bounds of the figure.
   * Returns null if the figure is not filled.
   */
14
  public static Paint getFillPaint(Figure f) {
    double opacity = f.get(FILL_OPACITY);
    if (f.get(FILL_GRADIENT) != null) {
      return f.get(FILL_GRADIENT).getPaint(f, opacity);
    }
    Color color = f.get(FILL_COLOR);
    if (color != null) {
      if (opacity != 1) {
        color = new Color(
            (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,
            true);
      }
    }
    return color;
###
2348, setDefaults, ODGAttributeKeys, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java, 143, 157
1
/** Sets ODG default values. */
15
  public static void setDefaults(Figure f) {
    // Fill properties
    f.set(FILL_COLOR, Color.black);
    f.set(WINDING_RULE, WindingRule.NON_ZERO);
    
    // Stroke properties
    f.set(STROKE_COLOR, null);
    f.set(STROKE_WIDTH, 1d);
    f.set(STROKE_CAP, BasicStroke.CAP_BUTT);
    f.set(STROKE_JOIN, BasicStroke.JOIN_MITER);
    f.set(STROKE_MITER_LIMIT, 4d);
    f.set(IS_STROKE_MITER_LIMIT_FACTOR, false);
    f.set(STROKE_DASHES, null);
    f.set(STROKE_DASH_PHASE, 0d);
    f.set(IS_STROKE_DASH_FACTOR, false);
###
2351, getDefaultEventIndex, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 156, 158
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
3
  @Override
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2352, getDefaultPropertyIndex, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 144, 146
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
3
  @Override
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2355, getPropertyDescriptors, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 107, 109
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
3
  @Override
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2356, getEventSetDescriptors, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 119, 121
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2357, getMethodDescriptors, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 131, 133
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2358, getBeanDescriptor, FigureToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java, 90, 92
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
3
  @Override
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2359, LinkToolBar, LinkToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBar.java, 44, 47
1
/** Creates new instance. */
4
  public LinkToolBar() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2360, getMethodDescriptors, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2361, getBeanDescriptor, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2363, getPropertyDescriptors, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2364, getEventSetDescriptors, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2366, getDefaultEventIndex, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2368, getDefaultPropertyIndex, FillToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2369, getDefaultPropertyIndex, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 144, 146
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
3
  @Override
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2371, getPropertyDescriptors, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 107, 109
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
3
  @Override
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2373, getBeanDescriptor, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 90, 92
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
3
  @Override
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2375, getMethodDescriptors, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 131, 133
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2376, getDefaultEventIndex, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 156, 158
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
3
  @Override
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2377, getEventSetDescriptors, LinkToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java, 119, 121
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
3
  @Override
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2378, FontToolBar, FontToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBar.java, 51, 55
1
/** Creates new instance. */
5
  public FontToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString("font.toolbar"));
    JFontChooser.loadAllFonts();
    setDisclosureStateCount(3);
###
2379, FillToolBar, FillToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBar.java, 45, 48
1
/** Creates new instance. */
4
  public FillToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2380, FigureToolBar, FigureToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBar.java, 43, 46
1
/** Creates new instance. */
4
  public FigureToolBar() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2381, save, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 89, 96
3
/**
   * Writes the contents of the DOMOutput into the specified writer.
   */
8
  public void save(Writer out) throws IOException {
    if (doctype != null) {
      out.write("<!DOCTYPE ");
      out.write(doctype);
      out.write(">\n");
    }
    XMLWriter writer = new XMLWriter(out);
    writer.write((XMLElement) document.getChildren().get(0));
###
2383, save, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 81, 84
3
/**
   * Writes the contents of the DOMOutput into the specified output stream.
   */
4
  public void save(OutputStream out) throws IOException {
    Writer w = new OutputStreamWriter(out, "UTF8");
    save(w);
    w.flush();
###
2384, NanoXMLDOMOutput, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 69, 75
1
/** Creates a new instance. */
7
  public NanoXMLDOMOutput(DOMFactory factory) {
    this.factory = factory;
    objectids = new HashMap<Object,String>();
    document = new XMLElement();//new HashMap(), false, false);
    current = document;
    stack = new Stack<XMLElement>();
    stack.push(current);
###
2385, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 158, 160
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
3
  public void addAttribute(String name, String value) {
    if (value != null) {
      current.setAttribute(name, value);
###
2386, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 187, 191
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, double value) {
    // Remove the awkard .0 at the end of each number
    String str = Double.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    current.setAttribute(name, str);
###
2387, closeElement, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 134, 135
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
2
  public void closeElement() {
    current = (XMLElement) stack.pop();
###
2388, addText, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 147, 152
7
/**
   * Adds a text to current element of the DOM Document.
   * Note: Multiple consecutives texts will be merged.
   */
 --------------
// NanoXML does not support comments
 --------------
6
  public void addText(String text) {
    String old = current.getContent();
    if (old == null) {
      current.setContent(text);
    } else {
      current.setContent(old+text);
###
2389, openElement, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 121, 126
9
/**
   * Puts a new element into the DOM Document.
   * The new element is added as a child to the current element in the DOM
   * document. Then it becomes the current element.
   * The element must be closed using closeElement.
   */
 --------------
//((XMLElement) document.getChildren().get(0)).print(out);
 --------------
6
  public void openElement(String tagName) {
    XMLElement newElement = new XMLElement();//new HashMap(), false, false);
    newElement.setName(tagName);
    current.addChild(newElement);
    stack.push(current);
    current = newElement;
###
2390, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 166, 167
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, int value) {
    current.setAttribute(name, Integer.toString(value));
###
2391, print, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 101, 110
3
/**
   * Prints the contents of the DOMOutput into the specified print writer.
   */
10
  public void print(PrintWriter out) {
    XMLWriter writer = new XMLWriter(out);
    
    try {
      // writer.write(document);
      writer.write((XMLElement) document.getChildren().get(0), true);
    } catch (IOException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
2392, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 178, 182
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, float value) {
    // Remove the awkard .0 at the end of each number
    String str = Float.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    current.setAttribute(name, str);
###
2393, addAttribute, NanoXMLDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java, 172, 173
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, boolean value) {
    current.setAttribute(name, new Boolean(value).toString());
###
2411, addEnumClass, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 56, 58
3
/**
   * Adds an Enum class to the DOMFactory.
   */
3
  public void addEnumClass(String name, Class c) {
    enumClassToNameMap.put(c, name);
    nameToEnumClassMap.put(name, c);
###
2412, addEnum, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 63, 72
3
/**
   * Adds an Enum value to the DOMFactory.
   */
10
  public void addEnum(String value, Enum e) {
    enumToValueMap.put(e, value);
    Set<Enum> enums;
    if (valueToEnumMap.containsKey(value)) {
      enums = valueToEnumMap.get(value);
    } else {
      enums = new HashSet<Enum>();
      valueToEnumMap.put(value, enums);
    }
    enums.add(e);
###
2413, addStorableClass, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 41, 43
3
/**
   * Adds a DOMStorable class to the DOMFactory.
   */
3
  public void addStorableClass(String name, Class c) {
    nameToPrototypeMap.put(name, c);
    classToNameMap.put(c, name);
###
2414, addStorable, DefaultDOMFactory, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java, 48, 50
3
/**
   * Adds a DOMStorable prototype to the DOMFactory.
   */
3
  public void addStorable(String name, DOMStorable prototype) {
    nameToPrototypeMap.put(name, prototype);
    classToNameMap.put(prototype.getClass(), name);
###
2415, getElementCount, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 197, 207
4
/**
   * Returns the number of child elements with the specified tag name
   * of the current element.
   */
11
  public int getElementCount(String tagName) {
    int count = 0;
    NodeList list = current.getChildNodes();
    for (int i=0; i < list.getLength(); i++) {
      Node node = list.item(i);
      if ((node instanceof Element)
      && ((Element) node).getTagName().equals(tagName)) {
        count++;
      }
    }
    return count;
###
2416, readObject, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 283, 284
3
/**
   * Reads an object from the current element.
   */
2
  public Object readObject() throws IOException {
    return readObject(0);
###
2417, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 173, 175
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public boolean getAttribute(String name, boolean defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();
###
2418, getElementCount, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 182, 191
3
/**
   * Returns the number of child elements of the current element.
   */
10
  public int getElementCount() {
    int count = 0;
    NodeList list = current.getChildNodes();
    for (int i=0; i < list.getLength(); i++) {
      Node node = list.item(i);
      if ((node instanceof Element)) {
        count++;
      }
    }
    return count;
###
2419, openElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 231, 243
3
/**
   * Opens the last element with the specified name and makes it the current node.
   */
13
  public void openElement(String tagName) {
    int count = 0;
    NodeList list = current.getChildNodes();
    int len = list.getLength();
    for (int i=0; i < len; i++) {
      Node node = list.item(i);
      if ((node instanceof Element)
      && ((Element) node).getTagName().equals(tagName)) {
        current = node;
        return;
      }
    }
    throw new IllegalArgumentException("element not found:"+tagName);
###
2420, getBuilder, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 64, 79
4
/**
   * Lazily create the document builder and keep a reference to it for
   * performance improvement.
   */
16
  protected static DocumentBuilder getBuilder() throws IOException {
    if (documentBuilder == null) {
      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
      factory.setNamespaceAware(true);
      factory.setValidating(false);
      factory.setXIncludeAware(false);
      try {
        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
        documentBuilder = factory.newDocumentBuilder();
      } catch (Exception ex) {
        InternalError error = new InternalError("Unable to create DocumentBuilder");
        error.initCause(ex);
        throw error;
      }
    }
    return documentBuilder;
###
2421, openElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 213, 222
3
/**
   * Opens the element with the specified index and makes it the current node.
   */
10
  public void openElement(int index) {
    int count = 0;
    NodeList list = current.getChildNodes();
    int len = list.getLength();
    for (int i=0; i < len; i++) {
      Node node = list.item(i);
      if ((node instanceof Element)) {
        if (count++ == index) {
          current = node;
          return;
###
2422, getText, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 127, 133
3
/**
   * Gets the text of the current element of the DOM Document.
   */
7
  public String getText(String defaultValue) {
    if (current.getChildNodes().getLength() == 0) return defaultValue;
    
    StringBuilder buf = new StringBuilder();
    getText(current, buf);
    
    return buf.toString();
###
2423, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 166, 168
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public double getAttribute(String name, double defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : Double.parseDouble(value);
###
2424, getInheritedAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 146, 154
4
/**
   * Gets an attribute of the current element of the DOM Document and of
   * all parent DOM elements.
   */
9
  public java.util.List<String> getInheritedAttribute(String name) {
    LinkedList<String> values = new LinkedList<String>();
    Node node = current;
    while (node != null) {
      String value = (String) ((Element) node).getAttribute(name);
      values.addFirst(value);
      node = node.getParentNode();
    }
    return values;
###
2425, readObject, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 289, 353
3
/**
   * Reads an object from the current element.
   */
65
  public Object readObject(int index) throws IOException {
    openElement(index);
    Object o;
    
    String tagName = getTagName();
    if (tagName.equals("null")) {
      o =  null;
    } else if (tagName.equals("string")) {
      o = getText();
    } else if (tagName.equals("int")) {
      o = Integer.decode(getText());
    } else if (tagName.equals("long")) {
      o = Long.decode(getText());
    } else if (tagName.equals("float")) {
      o = new Float(Float.parseFloat(getText()));
    } else if (tagName.equals("double")) {
      o = new Double(Double.parseDouble(getText()));
    } else if (tagName.equals("boolean")) {
      o = Boolean.valueOf(getText());
    } else if (tagName.equals("color")) {
      o = new Color(getAttribute("rgba",0xff));
    } else if (tagName.equals("intArray")) {
      int[] a = new int[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Integer) readObject(i)).intValue();
      }
      o = a;
    } else if (tagName.equals("floatArray")) {
      float[] a = new float[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Float) readObject(i)).floatValue();
      }
      o = a;
    } else if (tagName.equals("doubleArray")) {
      double[] a = new double[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Double) readObject(i)).doubleValue();
      }
      o = a;
    } else if (tagName.equals("font")) {
      o = new Font(getAttribute("name", "Dialog"), getAttribute("style", 0), getAttribute("size", 0));
    } else if (tagName.equals("enum")) {
      o = factory.createEnum(getAttribute("type",(String)null), getText());
    } else {
      String ref = getAttribute("ref", null);
      String id = getAttribute("id", ref);
      
      // Keep track of objects which have an ID
      if (id == null) {
        o = factory.create(getTagName());
      } else if (idobjects.containsKey(id)) {
        o = idobjects.get(id);
      } else {
        o = factory.create(getTagName());
        idobjects.put(id, o);
      }
      if (ref == null) {
        if (o instanceof DOMStorable) {
          ((DOMStorable) o).read(this);
        }
      }
    }
    
    closeElement();
    return o;
###
2426, getText, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 121, 122
3
/**
   * Gets the text of the current element of the DOM Document.
   */
2
  public String getText() {
    return getText(null);
###
2427, getTagName, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 108, 109
3
/**
   * Returns the tag name of the current element.
   */
2
  public String getTagName() {
    return ((Element) current).getTagName();
###
2428, closeElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 272, 277
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
6
  public void closeElement() {
    /*
    if (! ((Element) current).getTagName().equals(tagName)) {
      throw new IllegalArgumentException("Attempt to close wrong element:"+tagName +"!="+((Element) current).getTagName());
    }*/
    current = current.getParentNode();
###
2429, openElement, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 249, 263
4
/**
   * Opens the element with the specified name and index and makes it the
   * current node.
   */
15
  public void openElement(String tagName, int index) {
    int count = 0;
    NodeList list = current.getChildNodes();
    int len = list.getLength();
    for (int i=0; i < len; i++) {
      Node node = list.item(i);
      if ((node instanceof Element)
      && ((Element) node).getTagName().equals(tagName)) {
        if (count++ == index) {
          current = node;
          return;
        }
      }
    }
    throw new IllegalArgumentException("no such child "+tagName+"["+index+"]");
###
2430, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 159, 161
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public int getAttribute(String name, int defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();
###
2431, getAttribute, JavaxDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java, 114, 116
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public String getAttribute(String name, String defaultValue) {
    String value = ((Element) current).getAttribute(name);
    return (value.length() == 0) ? defaultValue : value;
###
2432, JavaxDOMOutput, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 68, 69
1
/** Creates a new instance. */
2
  public JavaxDOMOutput(DOMFactory factory) throws IOException {
    this.factory = factory;
###
2433, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 178, 179
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, boolean value) {
    ((Element) current).setAttribute(name, Boolean.toString(value));
###
2434, addText, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 158, 159
4
/**
   * Adds a text to current element of the DOM Document.
   * Note: Multiple consecutives texts will be merged.
   */
2
  public void addText(String text) {
    current.appendChild(document.createTextNode(text));
###
2435, addComment, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 151, 152
3
/**
   * Adds a comment to the current element of the DOM Document.
   */
2
  public void addComment(String comment) {
    current.appendChild(document.createComment(comment));
###
2436, save, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 107, 120
3
/**
   * Writes the contents of the DOMOutput into the specified output stream.
   */
14
  public void save(Writer out) throws IOException {
    reset();
    try {
      if (doctype != null) {
        out.write("<!DOCTYPE ");
        out.write(doctype);
        out.write(">\n");
      }
      Transformer t = TransformerFactory.newInstance().newTransformer();
      t.transform(new DOMSource(document), new StreamResult(out));
    } catch (TransformerException e) {
      IOException error = new IOException(e.getMessage());
      error.initCause(e);
      throw error;
###
2437, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 193, 197
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, double value) {
    // Remove the awkard .0 at the end of each number
    String str = Double.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    ((Element) current).setAttribute(name, str);
###
2438, closeElement, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 141, 146
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
6
  public void closeElement() {
    /*
    if (! ((Element) current).getName().equals(tagName)) {
      throw new IllegalArgumentException("Attempt to close wrong element:"+tagName +"!="+((Element) current).getName());
    }*/
    current = current.getParentNode();
###
2439, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 164, 166
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
3
  public void addAttribute(String name, String value) {
    if (value != null) {
      ((Element) current).setAttribute(name, value);
###
2440, openElement, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 130, 133
6
/**
   * Puts a new element into the DOM Document.
   * The new element is added as a child to the current element in the DOM
   * document. Then it becomes the current element.
   * The element must be closed using closeElement.
   */
4
  public void openElement(String tagName) {
    Element newElement = document.createElement(tagName);
    current.appendChild(newElement);
    current = newElement;
###
2441, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 172, 173
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
2
  public void addAttribute(String name, int value) {
    ((Element) current).setAttribute(name, Integer.toString(value));
###
2442, save, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 86, 101
3
/**
   * Writes the contents of the DOMOutput into the specified output stream.
   */
16
  public void save(OutputStream out) throws IOException {
    reset();
    try {
      if (doctype != null) {
        OutputStreamWriter w = new OutputStreamWriter(out, "UTF8");
        w.write("<!DOCTYPE ");
        w.write(doctype);
        w.write(">\n");
        w.flush();
      }
      Transformer t = TransformerFactory.newInstance().newTransformer();
      t.transform(new DOMSource(document), new StreamResult(out));
    } catch (TransformerException e) {
      IOException error = new IOException(e.getMessage());
      error.initCause(e);
      throw error;
###
2443, addAttribute, JavaxDOMOutput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java, 184, 188
3
/**
   * Adds an attribute to current element of the DOM Document.
   */
5
  public void addAttribute(String name, float value) {
    // Remove the awkard .0 at the end of each number
    String str = Float.toString(value);
    if (str.endsWith(".0")) str = str.substring(0, str.length() - 2);
    ((Element) current).setAttribute(name, str);
###
2463, getText, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 114, 115
3
/**
   * Gets the text of the current element of the DOM Document.
   */
2
  public String getText() {
    return getText(null);
###
2464, getInheritedAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 101, 109
4
/**
   * Gets an attribute of the current element of the DOM Document and of
   * all parent DOM elements.
   */
9
  public java.util.List<String> getInheritedAttribute(String name) {
    LinkedList<String> values = new LinkedList<String>();
    for (XMLElement node: stack) {
      String value = (String) node.getAttribute(name);
      values.add(value);
    }
    String value = (String) current.getAttribute(name);
    values.add(value);
    return values;
###
2465, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 141, 143
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public boolean getAttribute(String name, boolean defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();
###
2466, openElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 197, 210
4
/**
   * Opens the element with the specified name and index and makes it the
   * current node.
   */
14
  public void openElement(String tagName, int index) throws IOException {
    int count = 0;
    ArrayList list = current.getChildren();
    for (int i=0; i < list.size(); i++) {
      XMLElement node = (XMLElement) list.get(i);
      if (node.getName().equals(tagName)) {
        if (count++ == index) {
          stack.push(current);
          current = node;
          return;
        }
      }
    }
    throw new IOException("no such element:"+tagName+" at index:"+index);
###
2467, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 127, 129
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public int getAttribute(String name, int defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();
###
2468, openElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 181, 191
3
/**
   * Opens the last element with the specified name and makes it the current node.
   */
11
  public void openElement(String tagName) throws IOException {
    ArrayList list = current.getChildren();
    for (int i=0; i < list.size(); i++) {
      XMLElement node = (XMLElement) list.get(i);
      if (node.getName().equals(tagName)) {
        stack.push(current);
        current = node;
        return;
      }
    }
    throw new IOException("no such element:"+tagName);
###
2469, getTagName, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 87, 88
3
/**
   * Returns the tag name of the current element.
   */
2
  public String getTagName() {
    return current.getName();
###
2470, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 93, 95
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public String getAttribute(String name, String defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : value;
###
2471, getElementCount, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 157, 166
4
/**
   * Returns the number of child elements with the specified tag name
   * of the current element.
   */
10
  public int getElementCount(String tagName) {
    int count = 0;
    ArrayList list = current.getChildren();
    for (int i=0; i < list.size(); i++) {
      XMLElement node = (XMLElement) list.get(i);
      if (node.getName().equals(tagName)) {
        count++;
      }
    }
    return count;
###
2472, openElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 172, 175
3
/**
   * Opens the element with the specified index and makes it the current node.
   */
4
  public void openElement(int index) {
    stack.push(current);
    ArrayList list = current.getChildren();
    current = (XMLElement) list.get(index);
###
2473, getText, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 120, 122
3
/**
   * Gets the text of the current element of the DOM Document.
   */
3
  public String getText(String defaultValue) {
    String value = current.getContent();
    return (value == null) ? defaultValue : value;
###
2474, readObject, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 232, 297
3
/**
   * Reads an object from the current element.
   */
66
  public Object readObject(int index) throws IOException {
    openElement(index);
    Object o;
    
    String tagName = getTagName();
    if (tagName.equals("null")) {
      o =  null;
    } else if (tagName.equals("string")) {
      o = getText();
    } else if (tagName.equals("int")) {
      o = Integer.decode(getText());
    } else if (tagName.equals("long")) {
      o = Long.decode(getText());
    } else if (tagName.equals("float")) {
      o = new Float(Float.parseFloat(getText()));
    } else if (tagName.equals("double")) {
      o = new Double(Double.parseDouble(getText()));
    } else if (tagName.equals("boolean")) {
      o = Boolean.valueOf(getText());
    } else if (tagName.equals("color")) {
      o = new Color(getAttribute("rgba",0xff));
    } else if (tagName.equals("intArray")) {
      int[] a = new int[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Integer) readObject(i)).intValue();
      }
      o = a;
    } else if (tagName.equals("floatArray")) {
      float[] a = new float[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Float) readObject(i)).floatValue();
      }
      o = a;
    } else if (tagName.equals("doubleArray")) {
      double[] a = new double[getElementCount()];
      for (int i=0; i < a.length; i++) {
        a[i] = ((Double) readObject(i)).doubleValue();
      }
      o = a;
    } else if (tagName.equals("font")) {
      o = new Font(getAttribute("name", "Dialog"), getAttribute("style", 0), getAttribute("size", 0));
    } else if (tagName.equals("enum")) {
      o = factory.createEnum(getAttribute("type",(String)null), getText());
    } else {
      String ref = getAttribute("ref", null);
      String id = getAttribute("id", ref);
      
      // Keep track of objects which have an ID
      if (id == null) {
        o = factory.create(getTagName());
      } else if (idobjects.containsKey(id)) {
        o = idobjects.get(id);
      } else {
        o = factory.create(getTagName());
        idobjects.put(id, o);
      }
      
      if (ref == null) {
        if (o instanceof DOMStorable) {
          ((DOMStorable) o).read(this);
        }
      }
    }
    
    closeElement();
    return o;
###
2475, closeElement, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 219, 220
6
/**
   * Closes the current element of the DOM Document.
   * The parent of the current element becomes the current element.
   * @exception IllegalArgumentException if the provided tagName does
   * not match the tag name of the element.
   */
2
  public void closeElement() {
    current = (XMLElement) stack.pop();
###
2476, getElementCount, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 150, 151
3
/**
   * Returns the number of child elements of the current element.
   */
2
  public int getElementCount() {
    return current.getChildrenCount();
###
2477, getAttribute, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 134, 136
3
/**
   * Gets an attribute of the current element of the DOM Document.
   */
3
  public double getAttribute(String name, double defaultValue) {
    String value = (String) current.getAttribute(name);
    return (value == null || value.length() == 0) ? defaultValue : Double.parseDouble(value);
###
2478, readObject, NanoXMLDOMInput, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java, 226, 227
3
/**
   * Reads an object from the current element.
   */
2
  public Object readObject() throws IOException {
    return readObject(0);
###
2479, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 356, 360
9
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments
   * @param raw_cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   * @see #setCookies
   */
5
  public InputStream post(String raw_cookies, Map parameters) throws IOException {
  setCookies(raw_cookies);
  postCookies();
  setParameters(parameters);
  return doPost();
###
2480, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 215, 228
7
/**
   * adds a file parameter to the request
   * @param name parameter name
   * @param filename the name of the file
   * @param is input stream to read the contents of the file from
   * @throws IOException
   */
14
  public void setParameter(String name, String filename, InputStream is) throws IOException {
  boundary();
  writeName(name);
  write("; filename=\"");
  write(filename);
  write('"');
  newline();
  write("Content-Type: ");
  String type = URLConnection.guessContentTypeFromName(filename);
  if (type == null) type = "application/octet-stream";
  writeln(type);
  newline();
  pipe(is, _os);
  newline();
###
2481, ClientHttpRequest, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 80, 85
6
/**
   * Creates a new multipart POST HTTP request on a freshly opened URLConnection
   *
   * @param connection an already open URL connection
   * @throws IOException
   */
6
  public ClientHttpRequest(URLConnection connection) throws IOException {
  this._connection = connection;
  connection.setDoOutput(true);
  connection.setDoInput(true);
  connection.setRequestProperty("Content-Type",
                  "multipart/form-data; boundary=" + boundary);
###
2482, PertPanel, PertPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertPanel.java, 51, 116
1
/** Creates new instance. */
66
  public PertPanel() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    initComponents();
    undoManager = new UndoRedoManager();
    editor = new DefaultDrawingEditor();
    editor.add(view);
    
    addCreationButtonsTo(creationToolbar, editor);
    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);
    
    JPopupButton pb = new JPopupButton();
    pb.setItemFont(UIManager.getFont("MenuItem.font"));
    labels.configureToolBarButton(pb, "actions");
    pb.add(new DuplicateAction());
    pb.addSeparator();
    pb.add(new GroupAction(editor));
    pb.add(new UngroupAction(editor));
    pb.addSeparator();
    pb.add(new BringToFrontAction(editor));
    pb.add(new SendToBackAction(editor));
    pb.addSeparator();
    pb.add(new CutAction());
    pb.add(new CopyAction());
    pb.add(new PasteAction());
    pb.add(new SelectAllAction());
    pb.add(new SelectSameAction(editor));
    pb.addSeparator();
    pb.add(undoManager.getUndoAction());
    pb.add(undoManager.getRedoAction());
     // FIXME - We need a toggle grid action
     // pb.addSeparator();
     // pb.add(new ToggleGridAction(editor));
    
    JMenu m = new JMenu(labels.getString("view.zoomFactor.text"));
    JRadioButtonMenuItem rbmi;
    ButtonGroup group = new ButtonGroup();
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));
    rbmi.setSelected(true);
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));
    group.add(rbmi);
    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));
    group.add(rbmi);
    pb.add(m);
    pb.setFocusable(false);
    creationToolbar.addSeparator();
    creationToolbar.add(pb);
    
    
    DefaultDrawing drawing = new DefaultDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
###
2483, setParameters, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 274, 277
5
/**
   * adds parameters to the request
   * @param parameters array of parameter names and values (parameters[2*i] is a name, parameters[2*i + 1] is a value); if a value is a file, the file is uploaded, otherwise it is stringified and sent in the request
   * @throws IOException
   */
4
  public void setParameters(Object[] parameters) throws IOException {
  if (parameters != null) {
    for (int i = 0; i < parameters.length - 1; i += 2) {
    setParameter(parameters[i].toString(), parameters[i + 1]);
###
2484, setCookies, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 150, 152
5
/**
   * adds cookies to the request
   * @param cookies the cookie "name-to-value" map
   * @throws IOException
   */
3
  public void setCookies(Map<String,String> cookies) throws IOException {
  if (cookies == null) return;
  this._cookies.putAll(cookies);
###
2485, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 387, 390
8
/**
   * post the POST request to the server, with the specified parameter
   * @param name parameter name
   * @param value parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
4
  public InputStream post(String name, Object value) throws IOException {
  postCookies();
  setParameter(name, value);
  return doPost();
###
2487, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 444, 450
14
/**
   * post the POST request to the server, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @param name3 third parameter name
   * @param value3 third parameter value
   * @param name4 fourth parameter name
   * @param value4 fourth parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
7
  public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3, String name4, Object value4) throws IOException {
  postCookies();
  setParameter(name1, value1);
  setParameter(name2, value2);
  setParameter(name3, value3);
  setParameter(name4, value4);
  return doPost();
###
2488, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 484, 485
9
/**
   * posts a new request to specified URL, with cookies and parameters that are passed in the argument
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setCookies
   * @see #setParameters
   */
2
  public static InputStream post(URL url, Map<String,String> cookies, Map parameters) throws IOException {
  return new ClientHttpRequest(url).post(cookies, parameters);
###
2489, initComponents, PertPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertPanel.java, 141, 175
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
27
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    jPanel1 = new javax.swing.JPanel();
    creationToolbar = new javax.swing.JToolBar();
    attributesToolbar = new javax.swing.JToolBar();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    jPanel1.setLayout(new java.awt.GridBagLayout());
    creationToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 0;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(creationToolbar, gridBagConstraints);
    attributesToolbar.setFloatable(false);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.gridx = 0;
    gridBagConstraints.gridy = 1;
    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
    jPanel1.add(attributesToolbar, gridBagConstraints);
    add(jPanel1, java.awt.BorderLayout.SOUTH);
###
2490, setParameters, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 260, 264
5
/**
   * adds parameters to the request
   * @param parameters "name-to-value" map of parameters; if a value is a file, the file is uploaded, otherwise it is stringified and sent in the request
   * @throws IOException
   */
5
  public void setParameters(Map parameters) throws IOException {
  if (parameters != null) {
    for (Iterator i = parameters.entrySet().iterator(); i.hasNext();) {
    Map.Entry entry = (Map.Entry)i.next();
    setParameter(entry.getKey().toString(), entry.getValue());
###
2491, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 237, 238
6
/**
   * adds a file parameter to the request
   * @param name parameter name
   * @param file the file to upload
   * @throws IOException
   */
2
  public void setParameter(String name, File file) throws IOException {
  setParameter(name, file.getPath(), new FileInputStream(file));
###
2492, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 460, 461
7
/**
   * posts a new request to specified URL, with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
2
  public static InputStream post(URL url, Map parameters) throws IOException {
  return new ClientHttpRequest(url).post(parameters);
###
2493, ClientHttpRequest, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 104, 105
6
/**
   * Creates a new multipart POST HTTP request for a specified URL string
   *
   * @param urlString the string representation of the URL to send request to
   * @throws IOException
   */
2
  public ClientHttpRequest(String urlString) throws IOException {
  this(new URL(urlString));
###
2494, setCookie, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 141, 142
6
/**
   * adds a cookie to the requst
   * @param name cookie name
   * @param value cookie value
   * @throws IOException
   */
2
  public void setCookie(String name, String value) throws IOException {
    _cookies.put(name, value);
###
2495, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/Main.java, 30, 50
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //  app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    
    
    DefaultApplicationModel model = new PertApplicationModel();
    model.setName("JHotDraw Pert");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2010 (c) by the authors of JHotDraw and all its contributors.\n" +
        "This software is licensed under LGPL and Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.pert.PertView");
    app.setModel(model);
    app.launch(args);
###
2497, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 403, 407
10
/**
   * post the POST request to the server, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
5
  public InputStream post(String name1, Object value1, String name2, Object value2) throws IOException {
  postCookies();
  setParameter(name1, value1);
  setParameter(name2, value2);
  return doPost();
###
2498, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 312, 315
7
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
4
  public InputStream post(Map parameters) throws IOException {
  postCookies();
  setParameters(parameters);
  return doPost();
###
2499, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 247, 251
6
/**
   * adds a parameter to the request; if the parameter is a File, the file is uploaded, otherwise the string value of the parameter is passed in the request
   * @param name parameter name
   * @param object parameter value, a File or anything else that can be stringified
   * @throws IOException
   */
5
  public void setParameter(String name, Object object) throws IOException {
  if (object instanceof File) {
    setParameter(name, (File) object);
  } else {
    setParameter(name, object.toString());
###
2500, doPost, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 287, 292
5
/**
   * posts the requests to the server, with all the cookies and parameters that were added
   * @return input stream with the server response
   * @throws IOException
   */
5
  private InputStream doPost() throws IOException {
  boundary();
  writeln("--");
  _os.close();
  return _connection.getInputStream();
###
2501, setCookies, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 130, 132
5
/**
   * adds a cookie to the requst
   * @param rawCookies A string with raw cookie data.
   * @throws IOException
   */
3
  public void setCookies(String rawCookies) throws IOException {
  this._rawCookies = (rawCookies == null) ? "" : rawCookies;
  _cookies.clear();
###
2502, DependencyFigure, DependencyFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java, 32, 41
1
/** Creates a new instance. */
10
  public DependencyFigure() {
    set(STROKE_COLOR, new Color(0x000099));
    set(STROKE_WIDTH, 1d);
    set(END_DECORATION, new ArrowTip());
    
    setAttributeEnabled(END_DECORATION, false);
    setAttributeEnabled(START_DECORATION, false);
    setAttributeEnabled(STROKE_DASHES, false);
    setAttributeEnabled(FONT_ITALIC, false);
    setAttributeEnabled(FONT_UNDERLINE, false);
###
2503, setParameter, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 180, 190
6
/**
   * adds a string parameter to the request
   * @param name parameter name
   * @param value parameter value
   * @throws IOException
   */
11
  public void setParameter(String name, String value) throws IOException {
    if (name == null) {
      throw new InvalidParameterException("setParameter("+name+","+value+") name must not be null");
    }
    if (value == null) {
      throw new InvalidParameterException("setParameter("+name+","+value+") value must not be null");
    }
  boundary();
  writeName(name);
  newline(); newline();
  writeln(value);
###
2504, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 372, 376
9
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   * @see #setCookies
   */
5
  public InputStream post(String[] cookies, Object[] parameters) throws IOException {
  setCookies(cookies);
  postCookies();
  setParameters(parameters);
  return doPost();
###
2505, canConnect, DependencyFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java, 48, 64
4
/**
   * Checks if two figures can be connected. Implement this method
   * to constrain the allowed connections between figures.
   */
17
   @Override public boolean canConnect(Connector start, Connector end) {
    if ((start.getOwner() instanceof TaskFigure)
    && (end.getOwner() instanceof TaskFigure)) {
      
      TaskFigure sf = (TaskFigure) start.getOwner();
      TaskFigure ef = (TaskFigure) end.getOwner();
      
      // Disallow multiple connections to same dependent
      if (ef.getPredecessors().contains(sf)) {
        return false;
      }
      
      // Disallow cyclic connections
      return ! sf.isDependentOf(ef);
    }
    
    return false;
###
2506, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 300, 302
5
/**
   * posts the requests to the server, with all the cookies and parameters that were added
   * @return input stream with the server response
   * @throws IOException
   */
3
  public InputStream post() throws IOException {
      postCookies();
    return doPost();
###
2507, setCookies, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 160, 163
5
/**
   * adds cookies to the request
   * @param cookies array of cookie names and values (cookies[2*i] is a name, cookies[2*i + 1] is a value)
   * @throws IOException
   */
4
  public void setCookies(String[] cookies) throws IOException {
  if (cookies == null) return;
  for (int i = 0; i < cookies.length - 1; i+=2) {
    setCookie(cookies[i], cookies[i+1]);
###
2508, handleDisconnect, DependencyFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java, 75, 80
4
/**
   * Handles the disconnection of a connection.
   * Override this method to handle this event.
   */
6
  @Override protected void handleDisconnect(Connector start, Connector end) {
    TaskFigure sf = (TaskFigure) start.getOwner();
    TaskFigure ef = (TaskFigure) end.getOwner();
    
    sf.removeDependency(this);
    ef.removeDependency(this);
###
2509, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 340, 344
9
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   * @see #setCookies
   */
5
  public InputStream post(Map<String,String> cookies, Map parameters) throws IOException {
  setCookies(cookies);
  postCookies();
  setParameters(parameters);
  return doPost();
###
2510, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 422, 427
12
/**
   * post the POST request to the server, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @param name3 third parameter name
   * @param value3 third parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
6
  public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {
  postCookies();
  setParameter(name1, value1);
  setParameter(name2, value2);
  setParameter(name3, value3);
  return doPost();
###
2511, ClientHttpRequest, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 94, 95
6
/**
   * Creates a new multipart POST HTTP request for a specified URL
   *
   * @param url the URL to send request to
   * @throws IOException
   */
2
  public ClientHttpRequest(URL url) throws IOException {
  this(url.openConnection());
###
2512, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 498, 499
10
/**
   * posts a new request to specified URL, with cookies and parameters that are passed in the argument
   * @param url post URL
   * @param cookies request cookies
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setCookies
   * @see #setParameters
   */
2
  public static InputStream post(URL url, String[] cookies, Object[] parameters) throws IOException {
  return new ClientHttpRequest(url).post(cookies, parameters);
###
2513, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 471, 472
7
/**
   * posts a new request to specified URL, with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
2
  public static InputStream post(URL url, Object[] parameters) throws IOException {
  return new ClientHttpRequest(url).post(parameters);
###
2514, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 541, 542
12
/**
   * post the POST request to specified URL, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @param name3 third parameter name
   * @param value3 third parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
2
  public static InputStream post(URL url, String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {
  return new ClientHttpRequest(url).post(name1, value1, name2, value2, name3, value3);
###
2515, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 325, 328
7
/**
   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with parameters that are passed in the argument
   * @param parameters request parameters
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameters
   */
4
  public InputStream post(Object[] parameters) throws IOException {
  postCookies();
  setParameters(parameters);
  return doPost();
###
2516, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 511, 512
9
/**
   * post the POST request specified URL, with the specified parameter
   * @param url post URL
   * @param name1 parameter name
   * @param value1 parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
2
  public static InputStream post(URL url, String name1, Object value1) throws IOException {
  return new ClientHttpRequest(url).post(name1, value1);
###
2517, post, ClientHttpRequest, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java, 525, 526
10
/**
   * post the POST request to specified URL, with the specified parameters
   * @param name1 first parameter name
   * @param value1 first parameter value
   * @param name2 second parameter name
   * @param value2 second parameter value
   * @return input stream with the server response
   * @throws IOException
   * @see #setParameter
   */
2
  public static InputStream post(URL url, String name1, Object value1, String name2, Object value2) throws IOException {
  return new ClientHttpRequest(url).post(name1, value1, name2, value2);
###
2518, getParameter, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 51, 55
4
/**
   * We override getParameter() to make it work even if we have no Applet
   * context.
   */
5
  public String getParameter(String name) {
    try {
      return super.getParameter(name);
    } catch (NullPointerException e) {
      return null;
###
2519, init, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 66, 153
3
/**
   * Initializes the applet PertApplet
   */
79
  public void init() {
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Set our own popup factory, because the one that comes with Mac OS X
    // creates translucent popups which is not useful for color selection
    // using pop menus.
    try {
      PopupFactory.setSharedInstance(new PopupFactory());
    } catch (Throwable e) {
      // If we can't set the popup factory, we have to use what is there.
    }

    // Display copyright info while we are loading the data
    // ----------------------------------------------------
    Container c = getContentPane();
    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));
    String[] labels = getAppletInfo().split("\n");//Strings.split(getAppletInfo(), '\n');
    for (int i = 0; i < labels.length; i++) {
      c.add(new JLabel((labels[i].length() == 0) ? " " : labels[i]));
    }
    // We load the data using a worker thread
    // --------------------------------------
    new Worker<Drawing>() {
      public Drawing construct() throws IOException {
        Drawing result;
        System.out.println("getParameter.datafile:" + getParameter("datafile"));
        if (getParameter("data") != null) {
          NanoXMLDOMInput domi = new NanoXMLDOMInput(new PertFactory(), new StringReader(getParameter("data")));
          result = (Drawing) domi.readObject(0);
        } else if (getParameter("datafile") != null) {
          URL url = new URL(getDocumentBase(), getParameter("datafile"));
          InputStream in = url.openConnection().getInputStream();
          try {
            NanoXMLDOMInput domi = new NanoXMLDOMInput(new PertFactory(), in);
            result = (Drawing) domi.readObject(0);
          } finally {
            in.close();
          }
        } else {
          result = null;
        }
        return result;
      }
      @Override
      protected void done(Drawing result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new PertPanel());
        initComponents();
        if (result != null) {
          setDrawing(result);
        }
      }
      @Override
      protected void failed(Throwable value) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingPanel = new PertPanel());
        value.printStackTrace();
        initComponents();
        getDrawing().add(new TextFigure(value.toString()));
        value.printStackTrace();
      }
      @Override
      protected void finished() {
        Container c = getContentPane();
        initDrawing(getDrawing());
        c.validate();
      }
    }.start();
###
2520, initDrawing, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 167, 179
3
/**
   * Configure Drawing object to support copy and paste.
   */
10
  private void initDrawing(Drawing d) {
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(
        new PertFactory());
    inputFormats.add(ioFormat);
    outputFormats.add(ioFormat);
    outputFormats.add(new ImageOutputFormat());
    d.setInputFormats(inputFormats);
    d.setOutputFormats(outputFormats);
###
2522, initComponents, PertApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java, 243, 244
5
/** This method is called from within the init() method to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
2
  private void initComponents() {
    toolButtonGroup = new javax.swing.ButtonGroup();
###
2523, TaskFigure, TaskFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java, 84, 136
1
/** Creates a new instance. */
41
  public TaskFigure() {
    super(new RectangleFigure());
    setLayouter(new VerticalLayouter());
    RectangleFigure nameCompartmentPF = new RectangleFigure();
    nameCompartmentPF.set(STROKE_COLOR, null);
    nameCompartmentPF.setAttributeEnabled(STROKE_COLOR, false);
    nameCompartmentPF.set(FILL_COLOR, null);
    nameCompartmentPF.setAttributeEnabled(FILL_COLOR, false);
    ListFigure nameCompartment = new ListFigure(nameCompartmentPF);
    ListFigure attributeCompartment = new ListFigure();
    SeparatorLineFigure separator1 = new SeparatorLineFigure();
    applyAttributes(getPresentationFigure());
    add(nameCompartment);
    add(separator1);
    add(attributeCompartment);
    Insets2D.Double insets = new Insets2D.Double(4, 8, 4, 8);
    nameCompartment.set(LAYOUT_INSETS, insets);
    attributeCompartment.set(LAYOUT_INSETS, insets);
    TextFigure nameFigure;
    nameCompartment.add(nameFigure = new TextFigure());
    nameFigure.set(FONT_BOLD, true);
    nameFigure.setAttributeEnabled(FONT_BOLD, false);
    TextFigure durationFigure;
    attributeCompartment.add(durationFigure = new TextFigure());
    durationFigure.set(FONT_BOLD, true);
    durationFigure.setText("0");
    durationFigure.setAttributeEnabled(FONT_BOLD, false);
    TextFigure startTimeFigure;
    attributeCompartment.add(startTimeFigure = new TextFigure());
    startTimeFigure.setEditable(false);
    startTimeFigure.setText("0");
    startTimeFigure.setAttributeEnabled(FONT_BOLD, false);
    applyAttributes(this);
    setAttributeEnabled(STROKE_DASHES, false);
    ResourceBundleUtil labels =
        ResourceBundleUtil.getBundle("org.jhotdraw.samples.pert.Labels");
    setName(labels.getString("pert.task.defaultName"));
    setDuration(0);
    dependencies = new HashSet<DependencyFigure>();
    nameFigure.addFigureListener(new NameAdapter(this));
    durationFigure.addFigureListener(new DurationAdapter(this));
###
2524, writeRectAttributes, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 268, 299
6
/**
   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
   * <code>nohref</code> Attribute for the specified figure and rectangle.
   *
   * @return Returns true, if the rect is inside of the image bounds.
   */
29
  private boolean writeRectAttributes(IXMLElement elem, SVGFigure f, Rectangle2D.Double rect) {
    AffineTransform t = TRANSFORM.getClone(f);
    if (t == null) {
      t = drawingTransform;
    } else {
      t.preConcatenate(drawingTransform);
    }
    if ((t.getType() &
        (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==
        t.getType()) {
      Point2D.Double start = new Point2D.Double(rect.x, rect.y);
      Point2D.Double end = new Point2D.Double(rect.x + rect.width, rect.y + rect.height);
      t.transform(start, start);
      t.transform(end, end);
      Rectangle r = new Rectangle(
          (int) Math.min(start.x, end.x),
          (int) Math.min(start.y, end.y),
          (int) Math.abs(start.x - end.x),
          (int) Math.abs(start.y - end.y));
      elem.setAttribute("shape", "rect");
      elem.setAttribute("coords",
          r.x + "," +
          r.y + "," +
          (r.x + r.width) + "," +
          (r.y + r.height));
      writeHrefAttribute(elem, f);
      return bounds.intersects(r);
    } else {
      return writePolyAttributes(elem, f, (Shape) rect);
###
2525, getSuccessors, TaskFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java, 307, 315
4
/**
   * Returns dependent PertTasks which are directly connected via a
   * PertDependency to this TaskFigure.
   */
8
  public List<TaskFigure> getSuccessors() {
    LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();
    for (DependencyFigure c : getDependencies()) {
      if (c.getStartFigure() == this) {
        list.add((TaskFigure) c.getEndFigure());
      }
    }
    return list;
###
2527, getPredecessors, TaskFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java, 322, 330
4
/**
   * Returns predecessor PertTasks which are directly connected via a
   * PertDependency to this TaskFigure.
   */
8
  public List<TaskFigure> getPredecessors() {
    LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();
    for (DependencyFigure c : getDependencies()) {
      if (c.getEndFigure() == this) {
        list.add((TaskFigure) c.getStartFigure());
      }
    }
    return list;
###
2528, writePolyAttributes, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 324, 369
6
/**
   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
   * <code>nohref</code> Attribute for the specified figure and shape.
   *
   * @return Returns true, if the polygon is inside of the image bounds.
   */
45
  private boolean writePolyAttributes(IXMLElement elem, SVGFigure f, Shape shape) {
    AffineTransform t = TRANSFORM.getClone(f);
    if (t == null) {
      t = drawingTransform;
    } else {
      t.preConcatenate(drawingTransform);
    }
    StringBuilder buf = new StringBuilder();
    float[] coords = new float[6];
    Path2D.Double path = new Path2D.Double();
    for (PathIterator i = shape.getPathIterator(t, 1.5f);
        !i.isDone(); i.next()) {
      switch (i.currentSegment(coords)) {
        case PathIterator.SEG_MOVETO:
          if (buf.length() != 0) {
            throw new IllegalArgumentException("Illegal shape " + shape);
          }
          if (buf.length() != 0) {
            buf.append(',');
          }
          buf.append((int) coords[0]);
          buf.append(',');
          buf.append((int) coords[1]);
          path.moveTo(coords[0], coords[1]);
          break;
        case PathIterator.SEG_LINETO:
          if (buf.length() != 0) {
            buf.append(',');
          }
          buf.append((int) coords[0]);
          buf.append(',');
          buf.append((int) coords[1]);
          path.lineTo(coords[0], coords[1]);
          break;
        case PathIterator.SEG_CLOSE:
          path.closePath();
          break;
        default:
          throw new InternalError("Illegal segment type " + i.currentSegment(coords));
      }
    }
    elem.setAttribute("shape", "poly");
    elem.setAttribute("coords", buf.toString());
    writeHrefAttribute(elem, f);
    return path.intersects(new Rectangle2D.Float(bounds.x, bounds.y, bounds.width, bounds.height));
###
2529, write, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 108, 143
7
/**
   * Writes the figures to the specified output stream.
   * This method applies the specified drawingTransform to the drawing, and draws
   * it on an image of the specified getChildCount.
   * 
   * All other write methods delegate their work to here.
   */
30
  public void write(OutputStream out, java.util.List<Figure> figures,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    this.drawingTransform = (drawingTransform == null) ? new AffineTransform() : drawingTransform;
    this.bounds = (imageSize == null) ? new Rectangle(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE) : new Rectangle(0, 0, imageSize.width, imageSize.height);
    XMLElement document = new XMLElement("map");
    // Note: Image map elements need to be written from front to back
    for (Figure f : new ReversedList<Figure>(figures)) {
      writeElement(document, f);
    }
    // Strip AREA elements with "nohref" attributes from the end of the
    // map
    if (!isIncludeNohref) {
      for (int i = document.getChildrenCount() - 1; i >= 0; i--) {
        XMLElement child = (XMLElement) document.getChildAtIndex(i);
        if (child.hasAttribute("nohref")) {
          document.removeChildAtIndex(i);
        }
      }
    }

    // Write XML content
    PrintWriter writer = new PrintWriter(
        new OutputStreamWriter(out, "UTF-8"));
    //new XMLWriter(writer).write(document);
    for (Object o : document.getChildren()) {
      XMLElement child = (XMLElement) o;
      new XMLWriter(writer).write(child);
    }
    // Flush writer
    writer.flush();
###
2530, write, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 96, 98
5
/**
   * Writes the drawing to the specified output stream.
   * This method applies the specified drawingTransform to the drawing, and draws
   * it on an image of the specified getChildCount.
   */
3
  public void write(OutputStream out, Drawing drawing,
      AffineTransform drawingTransform, Dimension imageSize) throws IOException {
    write(out, drawing.getChildren(), drawingTransform, imageSize);
###
2531, writeCircleAttributes, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 228, 258
6
/**
   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
   * <code>nohref</code> Attribute for the specified figure and ellipse.
   *
   * @return Returns true, if the circle is inside of the image bounds.
   */
28
  private boolean writeCircleAttributes(IXMLElement elem, SVGFigure f, Ellipse2D.Double ellipse) {
    AffineTransform t = TRANSFORM.getClone(f);
    if (t == null) {
      t = drawingTransform;
    } else {
      t.preConcatenate(drawingTransform);
    }
    if ((t.getType() &
        (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==
        t.getType() &&
        ellipse.width == ellipse.height) {
      Point2D.Double start = new Point2D.Double(ellipse.x, ellipse.y);
      Point2D.Double end = new Point2D.Double(ellipse.x + ellipse.width, ellipse.y + ellipse.height);
      t.transform(start, start);
      t.transform(end, end);
      ellipse.x = Math.min(start.x, end.x);
      ellipse.y = Math.min(start.y, end.y);
      ellipse.width = Math.abs(start.x - end.x);
      ellipse.height = Math.abs(start.y - end.y);
      elem.setAttribute("shape", "circle");
      elem.setAttribute("coords",
          (int) (ellipse.x + ellipse.width / 2d) + "," +
          (int) (ellipse.y + ellipse.height / 2d) + "," +
          (int) (ellipse.width / 2d));
      writeHrefAttribute(elem, f);
      return bounds.intersects(ellipse.getBounds());
    } else {
      return writePolyAttributes(elem, f, (Shape) ellipse);
###
2532, write, ImageMapOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java, 149, 168
3
/**
   * All other write methods delegate their work to here.
   */
17
  public void write(OutputStream out, java.util.List<Figure> figures) throws IOException {
    Rectangle2D.Double drawingRect = null;
    for (Figure f : figures) {
      if (drawingRect == null) {
        drawingRect = f.getBounds();
      } else {
        drawingRect.add(f.getBounds());
      }
    }
    AffineTransform drawingTransform = new AffineTransform();
    drawingTransform.translate(
        -Math.min(0, drawingRect.x),
        -Math.min(0, drawingRect.y));
    write(out, figures, drawingTransform,
        new Dimension(
        (int) (Math.abs(drawingRect.x) + drawingRect.width),
        (int) (Math.abs(drawingRect.y) + drawingRect.height)));
###
2534, getDefaultPropertyIndex, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 140, 141
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2535, getPropertyDescriptors, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 106, 107
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2536, getMethodDescriptors, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 128, 129
7
/**
   * Gets the bean's <code>MethodDescriptor</code>s.
   *
   * @return  An array of MethodDescriptors describing the methods
   * implemented by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public MethodDescriptor[] getMethodDescriptors() {
    return getMdescriptor();
###
2537, getBeanDescriptor, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 90, 91
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2538, readMasterPageElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 562, 564
11
/**
   * Reads a &lt;style:master-page&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;page-layout&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
 --------------
//if (DEBUG) System.out.println("ODGStylesReader unsupported <"+elem.getName()+"> element.");
 --------------
3
  private void readMasterPageElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2540, getEventSetDescriptors, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 117, 118
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2543, readStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 441, 442
9
/**
   * Reads a &lt;styles&gt; element from the specified
   * XML element.
   * <p>
   * The styles element contains common styles.
   *
   *
   * @param elem A &lt;styles&gt; element.
   */
2
  private void readStylesElement(IXMLElement elem) throws IOException {
    readStylesChildren(elem, commonStyles);
###
2544, getDefaultEventIndex, ViewToolBarBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java, 151, 152
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2545, readMasterStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 534, 535
9
/**
   * Reads a &lt;master-styles&gt; element from the specified
   * XML element.
   * <p>
   * The master-styles element contains master styles.
   *
   *
   * @param elem A &lt;master-styles&gt; element.
   */
2
  private void readMasterStylesElement(IXMLElement elem) throws IOException {
    readStylesChildren(elem, masterStyles);
###
2546, read, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 165, 174
8
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * XML element.
   *
   *
   * @param root A &lt;document&gt; element or a
   * &lt;document-styles&gt; element.
   */
10
  public void read(IXMLElement root) throws IOException {
    String name = root.getName();
    String ns = root.getNamespace();
    if (name.equals("document-content") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
      readDocumentContentElement(root);
    } else if (name.equals("document-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
      readDocumentStylesElement(root);
    } else {
      if (DEBUG) {
        System.out.println("ODGStylesReader unsupported root element " + root);
###
2547, readGraphicPropertiesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 316, 368
7
/**
   * Reads a &lt;style:graphic-properties&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;style:graphic-properties&gt; element.
   */
50
  private void readGraphicPropertiesElement(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
    // The attribute draw:stroke specifies the style of the stroke on the current object. The value
    // none means that no stroke is drawn, and the value solid means that a solid stroke is drawn. If
    // the value is dash, the stroke referenced by the draw:stroke-dash property is drawn.
    if (elem.hasAttribute("stroke", DRAWING_NAMESPACE)) {
      STROKE_STYLE.put(a, (StrokeStyle) elem.getAttribute("stroke", DRAWING_NAMESPACE, STROKE_STYLES, null));
    }
    // The attribute svg:stroke-width specifies the width of the stroke on
    // the current object.
    if (elem.hasAttribute("stroke-width", SVG_NAMESPACE)) {
      STROKE_WIDTH.put(a, toLength(elem.getAttribute("stroke-width", SVG_NAMESPACE, null)));
    }
    // The attribute svg:stroke-color specifies the color of the stroke on
    // the current object.
    if (elem.hasAttribute("stroke-color", SVG_NAMESPACE)) {
      STROKE_COLOR.put(a, toColor(elem.getAttribute("stroke-color", SVG_NAMESPACE, null)));
    }
    // FIXME read draw:marker-start-width, draw:marker-start-center, draw:marker-end-width,
    // draw:marker-end-centre
    // The attribute draw:fill specifies the fill style for a graphic
    // object. Graphic objects that are not closed, such as a path without a
    // closepath at the end, will not be filled. The fill operation does not
    // automatically close all open subpaths by connecting the last point of
    // the subpath with the first point of the subpath before painting the
    // fill. The attribute has the following values:
    //   none:   the drawing object is not filled.
    //   solid:  the drawing object is filled with color specified by the
    //        draw:fill-color attribute.
    //   bitmap:   the drawing object is filled with the bitmap specified
    //        by the draw:fill-image-name attribute.
    //   gradient: the drawing object is filled with the gradient specified
    //        by the draw:fill-gradient-name attribute.
    //   hatch:  the drawing object is filled with the hatch specified by
    //        the draw:fill-hatch-name attribute.
    if (elem.hasAttribute("fill", DRAWING_NAMESPACE)) {
      FILL_STYLE.put(a, (FillStyle) elem.getAttribute("fill", DRAWING_NAMESPACE, FILL_STYLES, null));
    }
    // The attribute draw:fill-color specifies the color of the fill for a
    // graphic object. It is used only if the draw:fill attribute has the
    // value solid.
    if (elem.hasAttribute("fill-color", DRAWING_NAMESPACE)) {
      FILL_COLOR.put(a, toColor(elem.getAttribute("fill-color", DRAWING_NAMESPACE, null)));
    }
    // FIXME read fo:padding-top, fo:padding-bottom, fo:padding-left,
    // fo:padding-right
    // FIXME read draw:shadow, draw:shadow-offset-x, draw:shadow-offset-y,
    // draw:shadow-color
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
###
2548, readListStyleElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 519, 521
8
/**
   * Reads a &lt;text:list-style&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;list-style&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
3
  private void readListStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2549, read, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 112, 117
8
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * XML file.
   *
   *
   * @param file A XML file with a &lt;document&gt; root element
   * or with a &lt;document-styles&gt; root element.
   */
6
  public void read(File file) throws IOException {
    BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));
    try {
      read(in);
    } finally {
      in.close();
###
2551, readLayerSetElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 505, 507
8
/**
   * Reads a &lt;draw:layer-put&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;layer-put&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
3
  private void readLayerSetElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2552, ODGStylesReader, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 76, 77
1
/** Creates a new instance. */
2
  public ODGStylesReader() {
    reset();
###
2553, readDrawingPagePropertiesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 303, 305
7
/**
   * Reads a &lt;style:drawing-page-properties&gt; element from the specified
   * XML element.
   * <p>
   *
   * @param elem A &lt;style:drawing-page-properties&gt; element.
   */
3
  private void readDrawingPagePropertiesElement(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> element.");
###
2554, read, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 129, 148
8
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * input stream.
   *
   *
   * @param in A input stream with a &lt;document&gt; root element
   * or with a &lt;document-styles&gt; root element.
   */
20
  public void read(InputStream in) throws IOException {
    IXMLParser parser;
    try {
      parser = XMLParserFactory.createDefaultXMLParser();
    } catch (Exception ex) {
      InternalError e = new InternalError("Unable to instantiate NanoXML Parser");
      e.initCause(ex);
      throw e;
    }
    IXMLReader reader = new StdXMLReader(in);
    parser.setReader(reader);
    IXMLElement document;
    try {
      document = (IXMLElement) parser.parse();
    } catch (XMLException ex) {
      IOException e = new IOException(ex.getMessage());
      e.initCause(ex);
      throw e;
    }
    read(document);
###
2555, toLength, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 627, 652
9
/**
   * Returns a value as a length.
   *
   * &lt;define name="length"&gt;
   * &lt;data type="string"&gt;
   * &lt;param name="pattern"&gt;-?([0-9]+(\.[0-9]*)?|\.[0-9]+)((cm)|(mm)|(in)|
   * (pt)|(pc)|(px))&lt;/param&gt;
   *
   */
24
  private double toLength(String str) throws IOException {
    double scaleFactor = 1d;
    if (str == null || str.length() == 0) {
      return 0d;
    }
    if (str.endsWith("cm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 35.43307;
    } else if (str.endsWith("mm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 3.543307;
    } else if (str.endsWith("in")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 90;
    } else if (str.endsWith("pt")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 1.25;
    } else if (str.endsWith("pc")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 15;
    } else if (str.endsWith("px")) {
      str = str.substring(0, str.length() - 2);
    }
    return Double.parseDouble(str) * scaleFactor;
###
2557, readDocumentContentElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 240, 257
6
/**
   * Reads a &lt;document-content&gt; element from the specified
   * XML element.
   *
   * @param elem A &lt;document-content&gt; element.
   */
17
  private void readDocumentContentElement(IXMLElement elem) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader <" + elem.getName() + " ...>");
    }
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
      if (name.equals("automatic-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readAutomaticStylesElement(child);
      } else if (name.equals("master-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readStylesElement(child);
      } else if (name.equals("styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readStylesElement(child);
      }
    }
    if (DEBUG) {
      System.out.println("ODGStylesReader </" + elem.getName() + ">");
###
2558, readDefaultStyleElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 197, 227
18
/**
   * Reads a &lt;default-style&gt; element from the specified
   * XML element.
   * <p>
   * A default style specifies default formatting properties for a certain
   * style family. These defaults are used if a formatting property is neither
   * specified by an automatic nor a common style. Default styles exist for
   * all style families that are represented by the &lt;style:style&gt;
   * element specified in section 14.1.
   * Default styles are represented by the &lt;style:default-style&gt;
   * element. The only attribute supported by this element is style:family.
   * Its meaning equals the one of the same attribute for the
   * &lt;style:style&gt; element, and the same properties child elements are
   * supported depending on the style family.
   *
   * @param elem A &lt;default-style&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
30
  private void readDefaultStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    String styleName = elem.getAttribute("family", STYLE_NAMESPACE, null);
    String family = elem.getAttribute("family", STYLE_NAMESPACE, null);
    String parentStyleName = elem.getAttribute("parent-style-name", STYLE_NAMESPACE, null);
    if (DEBUG) {
      System.out.println("ODGStylesReader <default-style family=" + styleName + " ...>...</>");
    }
    if (styleName != null) {
      Style a = styles.get(styleName);
      if (a == null) {
        a = new Style();
        a.name = styleName;
        a.family = family;
        a.parentName = parentStyleName;
        styles.put(styleName, a);
      }
      for (IXMLElement child : elem.getChildren()) {
        String ns = child.getNamespace();
        String name = child.getName();
        if (name.equals("drawing-page-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readDrawingPagePropertiesElement(child, a);
        } else if (name.equals("graphic-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readGraphicPropertiesElement(child, a);
        } else if (name.equals("paragraph-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readParagraphPropertiesElement(child, a);
        } else if (name.equals("text-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readTextPropertiesElement(child, a);
        } else {
          if (DEBUG) {
            System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child " + child);
###
2559, readStylesChildren, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 453, 478
8
/**
   * Reads the children of a styles element.
   *
   *
   * @param elem A &lt;styles&gt;, &lt;automatic-styles&gt;,
   * &lt;document-styles&gt; or a &lt;master-styles&gt; element.
   * @param styles Styles to be filled in by this method.
   */
26
  private void readStylesChildren(IXMLElement elem,
      HashMap<String, Style> styles) throws IOException {
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
      if (name.equals("default-style") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readDefaultStyleElement(child, styles);
      } else if (name.equals("layer-set") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {
        readLayerSetElement(child, styles);
      } else if (name.equals("list-style") && (ns == null || ns.equals(TEXT_NAMESPACE))) {
        readListStyleElement(child, styles);
      } else if (name.equals("marker") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {
        readMarkerElement(child, styles);
      } else if (name.equals("master-page") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readMasterPageElement(child, styles);
      } else if (name.equals("page-layout") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readPageLayoutElement(child, styles);
        //} else if (name.equals("paragraph-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        //  readParagraphPropertiesElement(child, styles);
      } else if (name.equals("style") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        readStyleElement(child, styles);
        //} else if (name.equals("text-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
        //  readTextPropertiesElement(child, styles);
      } else {
        if (DEBUG) {
          System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child: " + child);
###
2560, readAutomaticStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 493, 494
9
/**
   * Reads a &lt;automatic-styles&gt; element from the specified
   * XML element.
   * <p>
   * The automatic-styles element contains automatic styles.
   *
   *
   * @param elem A &lt;automatic-styles&gt; element.
   */
2
  private void readAutomaticStylesElement(IXMLElement elem) throws IOException {
    readStylesChildren(elem, automaticStyles);
###
2561, readDocumentStylesElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 272, 292
11
/**
   * Reads a &lt;document-styles&gt; element from the specified
   * XML element.
   * <p>
   * The document-styles element contains all named styles of
   * a document, along with the automatic styles needed for the named
   * styles.
   *
   *
   * @param elem A &lt;document-styles&gt; element.
   */
21
  private void readDocumentStylesElement(IXMLElement elem) throws IOException {
    if (DEBUG) {
      System.out.println("ODGStylesReader <" + elem.getName() + " ...>");
    }
    for (IXMLElement child : elem.getChildren()) {
      String ns = child.getNamespace();
      String name = child.getName();
      if (name.equals("styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readStylesElement(child);
      } else if (name.equals("automatic-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readAutomaticStylesElement(child);
      } else if (name.equals("master-styles") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {
        readMasterStylesElement(child);
      } else {
        if (DEBUG) {
          System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child " + child);
        }
      }
    }
    if (DEBUG) {
      System.out.println("ODGStylesReader </" + elem.getName() + ">");
###
2562, readStyleElement, ODGStylesReader, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java, 384, 425
11
/**
   * Reads a &lt;styles&gt; element from the specified
   * XML element.
   * <p>
   * The &lt;style:style&gt; element can represent paragraph, text, and
   * graphic styles.
   *
   *
   * @param elem A &lt;style&gt; element.
   * @param styles Style attributes to be filled in by this method.
   */
39
  private void readStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {
    // The style:name attribute identifies the name of the style. This attribute, combined with the
// style:family attribute, uniquely identifies a style. The <office:styles>,
// <office:automatic-styles> and <office:master-styles> elements each must not
// contain two styles with the same family and the same name.
// For automatic styles, a name is generated during document export. If the document is exported
// several times, it cannot be assumed that the same name is generated each time.
// In an XML document, the name of each style is a unique name that may be independent of the
// language selected for an office applications user interface. Usually these names are the ones used
// for the English version of the user interface.
    String styleName = elem.getAttribute("name", STYLE_NAMESPACE, null);
    String family = elem.getAttribute("family", STYLE_NAMESPACE, null);
    String parentStyleName = elem.getAttribute("parent-style-name", STYLE_NAMESPACE, null);
    if (DEBUG) {
      System.out.println("ODGStylesReader <style name=" + styleName + " ...>...</>");
    }
    if (styleName != null) {
      Style a = styles.get(styleName);
      if (a == null) {
        a = new Style();
        a.name = styleName;
        a.family = family;
        a.parentName = parentStyleName;
        styles.put(styleName, a);
      }
      for (IXMLElement child : elem.getChildren()) {
        String ns = child.getNamespace();
        String name = child.getName();
        if (name.equals("drawing-page-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readDrawingPagePropertiesElement(child, a);
        } else if (name.equals("graphic-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readGraphicPropertiesElement(child, a);
        } else if (name.equals("paragraph-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readParagraphPropertiesElement(child, a);
        } else if (name.equals("text-properties") && (ns == null || ns.equals(STYLE_NAMESPACE))) {
          readTextPropertiesElement(child, a);
        } else {
          if (DEBUG) {
            System.out.println("ODGStylesReader unsupported <" + elem.getName() + "> child " + child);
###
2565, createToolBars, PertApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplicationModel.java, 134, 160
5
/**
   * Creates toolbars for the application.
   * This class always returns an empty list. Subclasses may return other
   * values.
   */
25
  public java.util.List<JToolBar> createToolBars(Application a, View pr) {
    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.pert.Labels");
    PertView p = (PertView) pr;
    DrawingEditor editor;
    if (p == null) {
      editor = getSharedEditor();
    } else {
      editor = p.getEditor();
    }
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    JToolBar tb;
    tb = new JToolBar();
    addCreationButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.drawToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAttributesButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.attributesToolBar.title"));
    list.add(tb);
    tb = new JToolBar();
    ButtonFactory.addAlignmentButtonsTo(tb, editor);
    tb.setName(drawLabels.getString("window.alignmentToolBar.title"));
    list.add(tb);
    return list;
###
2566, Matcher, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 74, 87
8
/**
   * Creates a new instance of Matcher
   *
   * @param document The document to be examined
   * @param findString The string to be searched.
   * @param matchCase Set to true for case sensitive search.
   * @param matchType Sets the match type.
   */
14
  public Matcher(Document document, String findString, boolean matchCase, MatchType matchType) {
    this.document = document;
    this.findString = findString;
    startIndex = 0;
    
    // Convert to chars for efficiency
    if (matchCase) {
      matchLowerCase = matchUpperCase = findString.toCharArray();
    } else {
      matchUpperCase = findString.toUpperCase().toCharArray();
      matchLowerCase = findString.toLowerCase().toCharArray();
    }
    
    this.matchType = matchType;
###
2567, Matcher, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 62, 63
7
/**
   * Creates a new instance of Matcher which
   * performs a case sensitive search.
   *
   * @param document The document to be examined
   * @param findString The string to be searched.
   */
2
  public Matcher(Document document, String findString) {
    this(document, findString, true, MatchType.CONTAINS);
###
2568, findNext, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 117, 119
9
/**
   * Resets this matcher and then attempts to find the next
   * subsequence of the input sequence that matches the pattern,
   * starting at the specified index.
   *
   * @param startIndex the index from which to start the search.
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
3
  public int findNext(int startIndex) {
    this.startIndex = startIndex;
    return findNext();
###
2569, findNext, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 134, 193
13
/**
   * Attempts to find the next subsequence of the
   * input sequence that matches the pattern.
   * <p>
   * This method starts at the beginning of
   * the input sequence or, if a previous invocation
   * of the method was successful and the matcher has not
   * since been reset, at the first character not matched by
   * the previous match.
   *
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
60
  public int findNext() {
    // Don't match empty strings and don't match if we are at the end of the document.
    if (findString.length() == 0 ||
    document.getLength() - findString.length() < startIndex) {
      return -1;
    }
    
    try {
      int nextMatch = 0; // index of next matching character
      
      // Iterate through all segments of the document starting from offset
      Segment text = new Segment();
      text.setPartialReturn(true);
      int offset = startIndex;
      int nleft = document.getLength() - startIndex;
      while (nleft > 0) {
        document.getText(offset, nleft, text);
        
        // Iterate through the characters in the current segment
        char next = text.first();
        for (text.first(); next != Segment.DONE; next = text.next()) {
          
          // Check if the current character matches with the next
          // search character.
          char current = text.current();
          if (current == matchUpperCase[nextMatch] ||
          current == matchLowerCase[nextMatch]) {
            nextMatch++;
            
            // Did we match all search characters?
            if (nextMatch == matchLowerCase.length) {
              int foundIndex = text.getIndex() - text.getBeginIndex() + offset -
              matchLowerCase.length + 1;
              if (matchType == MatchType.CONTAINS) {
                return foundIndex;
                // break; <- never reached
              } else if (matchType == MatchType.STARTS_WITH) {
                if (! isWordChar(foundIndex - 1)) {
                  return foundIndex;
                }
              } else if (matchType == MatchType.FULL_WORD) {
                if (! isWordChar(foundIndex - 1) &&
                ! isWordChar(foundIndex + matchLowerCase.length)) {
                  return foundIndex;
                }
              }
              nextMatch = 0;
            }
          } else {
            nextMatch = 0;
          }
        }
        
        // Move forward to the next segment
        nleft -= text.count;
        offset += text.count;
      }
      return -1;
    } catch (BadLocationException e) {
      throw new IndexOutOfBoundsException();
###
2570, findPrevious, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 205, 207
9
/**
   * Resets this matcher and then attempts to find the previous
   * subsequence of the input sequence that matches the pattern,
   * starting at the specified index.
   *
   * @param startIndex the index from which to start the search.
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
3
  public int findPrevious(int startIndex) {
    this.startIndex = startIndex;
    return findPrevious();
###
2571, createPageable, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 125, 126
3
/**
   * Creates a Pageable object for printing this view.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(view.getDrawing());
###
2572, initActions, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 171, 173
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
2573, findPrevious, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 222, 276
13
/**
   * Attempts to find the previous subsequence of the
   * input sequence that matches the pattern.
   * <p>
   * This method starts at the beginning of
   * the input sequence or, if a previous invocation
   * of the method was successful and the matcher has not
   * since been reset, at the first character not matched by
   * the previous match.
   *
   * @return the index of the first occurrence of the search string,
   * starting at the specified offset, or -1 if no occurrence was found.
   */
55
  public int findPrevious() {
    // Don't match empty strings and don't match if we are at the beginning of the document.
    if (findString.length() == 0 ||
    startIndex < findString.length() - 1) {
      //System.out.println("too close to start");
      return -1;
    }
    
    try {
      int nextMatch = matchLowerCase.length - 1; // index of next matching character
      
      // For simplicity, we request all text of the document in a single
      // segment.
      Segment text = new Segment();
      text.setPartialReturn(false);
      document.getText(0, startIndex + 1, text);
      
      // Iterate through the characters in the current segment
      char previous = text.last();
      //System.out.println("previus isch "+previous);
      for (text.last(); previous != Segment.DONE; previous = text.previous()) {
        
        // Check if the current character matches with the next
        // search character.
        char current = text.current();
        if (current == matchUpperCase[nextMatch] ||
        current == matchLowerCase[nextMatch]) {
          nextMatch--;
          //System.out.println("matched "+nextMatch);
          // Did we match all search characters?
          if (nextMatch == -1) {
            int foundIndex = text.getIndex() - text.getBeginIndex();
            //System.out.println("found index:"+foundIndex);
            if (matchType == MatchType.CONTAINS) {
              return foundIndex;
            } else if (matchType == MatchType.STARTS_WITH) {
              if (! isWordChar(foundIndex - 1)) {
                return foundIndex;
              }
            } else if (matchType == MatchType.FULL_WORD) {
              if (! isWordChar(foundIndex - 1) &&
              ! isWordChar(foundIndex + matchLowerCase.length)) {
                return foundIndex;
              }
            }
            nextMatch = matchLowerCase.length - 1;
          }
        } else {
          nextMatch = matchLowerCase.length - 1;
        }
      }
      
      return -1;
    } catch (BadLocationException e) {
      throw new IndexOutOfBoundsException();
###
2574, clear, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 225, 242
3
/**
   * Clears the view.
   */
17
  @Override
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(newDrawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
2575, setStartIndex, Matcher, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java, 104, 105
3
/**
   * Sets the start index for the findNext(), findPrevious() methods.
   */
2
  public void setStartIndex(int newValue) {
    startIndex = newValue;
###
2576, read, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 195, 218
3
/**
   * Reads the view from the specified uri.
   */
23
  @Override
  public void read(URI f, URIChooser chooser) throws IOException {
    try {
      final Drawing drawing = createDrawing();
      InputFormat inputFormat = drawing.getInputFormats().get(0);
      inputFormat.read(new File(f), drawing, true);
      SwingUtilities.invokeAndWait(new Runnable() {
        @Override
        public void run() {
          view.getDrawing().removeUndoableEditListener(undo);
          view.setDrawing(drawing);
          view.getDrawing().addUndoableEditListener(undo);
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
###
2577, getLeftInset, NumberedParagraphView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/text/NumberedParagraphView.java, 41, 43
5
/**
   * Gets the left inset.
   *
   * @return the inset >= 0
   */
3
  protected short getLeftInset() {
    short left = super.getLeftInset();
    return (viewFactory.isLineNumbersVisible()) ? (short) (left + NUMBERS_WIDTH) : left;
###
2578, PertView, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 64, 102
3
/**
   * Creates a new view.
   */
33
  public PertView() {
    initComponents();
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    scrollPane.setLayout(new PlacardScrollPaneLayout());
    scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));
    setEditor(new DefaultDrawingEditor());
    undo = new UndoRedoManager();
    view.setDrawing(createDrawing());
    view.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(new PropertyChangeListener() {
      @Override
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
      }
    });
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    JPanel placardPanel = new JPanel(new BorderLayout());
    javax.swing.AbstractButton pButton;
    pButton = ButtonFactory.createZoomButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    placardPanel.add(pButton, BorderLayout.WEST);
    pButton = ButtonFactory.createToggleGridButton(view);
    pButton.putClientProperty("Quaqua.Button.style", "placard");
    pButton.putClientProperty("Quaqua.Component.visualMargin", new Insets(0, 0, 0, 0));
    pButton.setFont(UIManager.getFont("SmallSystemFont"));
    labels.configureToolBarButton(pButton, "view.toggleGrid.placard");
    placardPanel.add(pButton, BorderLayout.EAST);
    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);
    setGridVisible(preferences.getBoolean("view.gridVisible", false));
    setScaleFactor(preferences.getDouble("view.scaleFactor", 1d));
###
2579, write, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 185, 189
3
/**
   * Writes the view to the specified uri.
   */
5
  @Override
  public void write(URI f, URIChooser chooser) throws IOException {
    Drawing drawing = view.getDrawing();
    OutputFormat outputFormat = drawing.getOutputFormats().get(0);
    outputFormat.write(new File(f), drawing);
###
2580, initComponents, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 257, 268
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
8
  private void initComponents() {
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    setLayout(new java.awt.BorderLayout());
    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
###
2581, createDrawing, PertView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java, 108, 119
3
/**
   * Creates a new Drawing for this view.
   */
12
  protected Drawing createDrawing() {
    DefaultDrawing drawing = new DefaultDrawing();
    DOMStorableInputOutputFormat ioFormat =
        new DOMStorableInputOutputFormat(new PertFactory());
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    inputFormats.add(ioFormat);
    drawing.setInputFormats(inputFormats);
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    outputFormats.add(ioFormat);
    outputFormats.add(new ImageOutputFormat());
    drawing.setOutputFormats(outputFormats);
    return drawing;
###
2582, getScaleFactor, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 130, 131
3
/**
   * Returns the scale factor of the number formatter.
   */
2
  public double getScaleFactor() {
    return scaleFactor;
###
2583, getMinimum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 89, 90
5
/**
   * Returns the minimum permissible value.
   *
   * @return Minimum legal value that can be input
   */
2
  public Comparable getMinimum() {
    return min;
###
2584, setMinimum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 77, 81
9
/**
   * Sets the minimum permissible value. If the <code>valueClass</code> has
   * not been specified, and <code>minimum</code> is non null, the
   * <code>valueClass</code> will be set to that of the class of
   * <code>minimum</code>.
   *
   * @param minimum Minimum legal value that can be input
   * @see #setValueClass
   */
5
  public void setMinimum(Comparable minimum) {
    if (getValueClass() == null && minimum != null) {
      setValueClass(minimum.getClass());
    }
    min = minimum;
###
2585, valueToString, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 175, 215
8
/**
   * Returns a String representation of the Object <code>value</code>.
   * This invokes <code>format</code> on the current <code>Format</code>.
   *
   * @throws ParseException if there is an error in the conversion
   * @param value Value to convert
   * @return String representation of value
   */
39
  @Override
  public String valueToString(Object value) throws ParseException {
    if (value == null && allowsNullValue) {
      return "";
    }
    if (value instanceof Double) {
      double v = ((Double) value).doubleValue();
      v *= scaleFactor;
      String str = Double.toString(v);
      if (!appendsDotZero && str.endsWith(".0")) {
        str = str.substring(0, str.length() - 2);
      }
      return str;
    } else if (value instanceof Float) {
      float v = ((Float) value).floatValue();
      v = (float) (v * scaleFactor);
      String str = Float.toString(v);
      if (appendsDotZero && str.endsWith(".0")) {
        str = str.substring(0, str.length() - 2);
      }
      return str;
    } else if (value instanceof Long) {
      long v = ((Long) value).longValue();
      v = (long) (v * scaleFactor);
      return Long.toString(v);
    } else if (value instanceof Integer) {
      int v = ((Integer) value).intValue();
      v = (int) (v * scaleFactor);
      return Integer.toString(v);
    } else if (value instanceof Byte) {
      byte v = ((Byte) value).byteValue();
      v = (byte) (v * scaleFactor);
      return Byte.toString(v);
    } else if (value instanceof Short) {
      short v = ((Short) value).shortValue();
      v = (short) (v * scaleFactor);
      return Short.toString(v);
    }
    throw new ParseException("Value is of unsupported class " + value, 0);
###
2586, setMaximum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 102, 106
9
/**
   * Sets the maximum permissible value. If the <code>valueClass</code> has
   * not been specified, and <code>max</code> is non null, the
   * <code>valueClass</code> will be set to that of the class of
   * <code>max</code>.
   *
   * @param max Maximum legal value that can be input
   * @see #setValueClass
   */
5
  public void setMaximum(Comparable max) {
    if (getValueClass() == null && max != null) {
      setValueClass(max.getClass());
    }
    this.max = max;
###
2587, isValidValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 286, 312
7
/**
   * Returns true if <code>value</code> is between the min/max.
   *
   * @param wantsCCE If false, and a ClassCastException is thrown in
   *         comparing the values, the exception is consumed and
   *         false is returned.
   */
25
  @SuppressWarnings("unchecked")
  boolean isValidValue(Object value, boolean wantsCCE) {
    Comparable min = getMinimum();
    try {
      if (min != null && min.compareTo(value) > 0) {
        return false;
      }
    } catch (ClassCastException cce) {
      if (wantsCCE) {
        throw cce;
      }
      return false;
    }
    Comparable max = getMaximum();
    try {
      if (max != null && max.compareTo(value) < 0) {
        return false;
      }
    } catch (ClassCastException cce) {
      if (wantsCCE) {
        throw cce;
      }
      return false;
    }
    return true;
###
2588, getAllowsNullValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 146, 147
3
/**
   * Returns true if null values are allowed.
   */
2
  public boolean getAllowsNullValue() {
    return allowsNullValue;
###
2590, stringToValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 226, 276
8
/**
   * Returns the <code>Object</code> representation of the
   * <code>String</code> <code>text</code>.
   *
   * @param text <code>String</code> to convert
   * @return <code>Object</code> representation of text
   * @throws ParseException if there is an error in the conversion
   */
50
  @Override
  public Object stringToValue(String text) throws ParseException {
    if ((text == null || text.length() == 0) && getAllowsNullValue()) {
      return null;
    }
    Class valueClass = getValueClass();
    Object value;
    if (valueClass != null) {
      try {
        if (valueClass == Integer.class) {
          int v = Integer.parseInt(text);
          v = (int) (v / scaleFactor);
          value = new Integer(v);
        } else if (valueClass == Long.class) {
          long v = Long.parseLong(text);
          v = (long) (v / scaleFactor);
          value = new Long(v);
        } else if (valueClass == Float.class) {
          float v = Float.parseFloat(text);
          v = (float) (v / scaleFactor);
          value = new Float(v);
        } else if (valueClass == Double.class) {
          double v = Double.parseDouble(text);
          v = (double) (v / scaleFactor);
          value = new Double(v);
        } else if (valueClass == Byte.class) {
          byte v = Byte.parseByte(text);
          v = (byte) (v / scaleFactor);
          value = new Byte(v);
        } else if (valueClass == Short.class) {
          short v = Short.parseShort(text);
          v = (short) (v / scaleFactor);
          value = new Short(v);
        } else {
          throw new ParseException("Unsupported value class " + valueClass, 0);
        }
      } catch (NumberFormatException e) {
        throw new ParseException(e.getMessage(), 0);
      }
    } else {
      throw new ParseException("Unsupported value class " + valueClass, 0);
    }
    try {
      if (!isValidValue(value, true)) {
        throw new ParseException("Value not within min/max range", 0);
      }
    } catch (ClassCastException cce) {
      throw new ParseException("Class cast exception comparing values: " + cce, 0);
    }
    return value;
###
2591, JavaNumberFormatter, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 58, 65
3
/**
   * Creates a NumberFormatter with the specified Format instance.
   */
8
  public JavaNumberFormatter(double min, double max, double scaleFactor, boolean allowsNullValue, boolean appendsDotZero) {
    super();
    setMinimum(min);
    setMaximum(max);
    setScaleFactor(scaleFactor);
    setAllowsNullValue(allowsNullValue);
    setAppendsDotZero(appendsDotZero);
    setOverwriteMode(false);
###
2592, createFormatterFactory, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 320, 321
5
/**
   * Convenience method for creating a formatter factory with a
   * {@code ScalableNumberFormatter} and a Java-style DecimalFormat.
   * Doesn't allow null values and doesn't append ".0" to double and float values.
   */
2
  public static AbstractFormatterFactory createFormatterFactory(double min, double max, double scaleFactor) {
    return createFormatterFactory(min, max, scaleFactor, false, false);
###
2593, setAppendsDotZero, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 156, 157
6
/**
   * Specifies whether ".0" is appended to double and float
   * values. By default this is true.
   *
   * @param newValue
   */
2
  public void setAppendsDotZero(boolean newValue) {
    appendsDotZero = newValue;
###
2594, getMaximum, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 114, 115
5
/**
   * Returns the maximum permissible value.
   *
   * @return Maximum legal value that can be input
   */
2
  public Comparable getMaximum() {
    return max;
###
2595, JavaNumberFormatter, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 51, 52
3
/**
   * Creates a NumberFormatter with the specified Format instance.
   */
2
  public JavaNumberFormatter(double min, double max, double scaleFactor) {
    this(min, max, scaleFactor, false, true);
###
2596, setScaleFactor, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 123, 124
5
/**
   * Changes the scale factor of the number formatter.
   *
   * @param newValue
   */
2
  public void setScaleFactor(double newValue) {
    scaleFactor = newValue;
###
2597, getAppendsDotZero, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 163, 164
3
/**
   * Returns true if null values are allowed.
   */
2
  public boolean getAppendsDotZero() {
    return appendsDotZero;
###
2598, setAllowsNullValue, JavaNumberFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java, 139, 140
5
/**
   * Allows/Disallows null values.
   *
   * @param newValue
   */
2
  public void setAllowsNullValue(boolean newValue) {
    allowsNullValue = newValue;
###
2599, write, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 63, 76
5
/**
   * Write a single character.
   *
   * @exception  IOException  If an I/O error occurs
   */
14
  public void write(int c) throws IOException {
    switch (c) {
      case '\r':
        out.write(lineSeparator);
        skipLF = true;
        break;
      case '\n':
        if (!skipLF) out.write(lineSeparator);
        skipLF = false;
        break;
      default :
        out.write(c);
        skipLF = false;
        break;
###
2600, write, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 89, 113
9
/**
   * Write a portion of an array of characters.
   *
   * @param  cbuf  Buffer of characters to be written
   * @param  off   Offset from which to start reading characters
   * @param  len   Number of characters to be written
   *
   * @exception  IOException  If an I/O error occurs
   */
25
  public void write(char cbuf[], int off, int len) throws IOException {
    int end = off + len;
    for (int i=off; i < end; i++) {
      switch (cbuf[i]) {
        case '\r':
          out.write(cbuf, off, i - off);
          off = i + 1;
          out.write(lineSeparator);
          skipLF = true;
          break;
        case '\n':
          out.write(cbuf, off, i - off);
          off = i + 1;
          if (skipLF) {
            skipLF = false;
          } else {
            out.write(lineSeparator);
          }
          break;
        default :
          skipLF = false;
          break;
      }
    }
    if (off < end) out.write(cbuf, off, end - off);
###
2601, setLineSeparator, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 54, 55
3
/**
   * Sets the line separator for the println() methods.
   */
2
  public void setLineSeparator(String lineSeparator) {
    this.lineSeparator = lineSeparator;
###
2602, getLineSeparator, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 47, 48
3
/**
   * Gets the line separator of the println() methods.
   */
2
  public String getLineSeparator() {
    return lineSeparator;
###
2603, LFWriter, LFWriter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java, 39, 41
3
/**
   * Create a new line-numbering writer.
   */
3
  public LFWriter(Writer out) {
    super(out);
    lineSeparator = (String) System.getProperty("line.separator");
###
2604, createFormatterFactory, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 166, 167
5
/**
   * Convenience method for creating a formatter factory with a
   * {@code FontFormatter}.
   * Uses the RGB_INTEGER format and disallows null values.
   */
2
  public static AbstractFormatterFactory createFormatterFactory() {
    return createFormatterFactory(false);
###
2605, getAllowsUnknownFont, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 92, 93
3
/**
   * Returns true, if unknown font names are allowed.
   */
2
  public boolean getAllowsUnknownFont() {
    return allowsUnknownFont;
###
2606, clearGenericFontFamilies, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 97, 98
1
/** Clears the generic font families map. */
2
  public void clearGenericFontFamilies() {
    genericFontFamilies = null;
###
2607, getAllowsNullValue, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 77, 78
3
/**
   * Returns true, if null value is allowed.
   */
2
  public boolean getAllowsNullValue() {
    return allowsNullValue;
###
2608, putGenericFontFamily, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 102, 103
1
/** Adds a generic font family. */
2
  public void putGenericFontFamily(String familyName, Font font) {
    genericFontFamilies.put(familyName.toLowerCase(), font);
###
2609, setAllowsNullValue, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 70, 71
4
/**
   * Sets whether a null value is allowed.
   * @param newValue
   */
2
  public void setAllowsNullValue(boolean newValue) {
    allowsNullValue = newValue;
###
2610, setAllowsUnknownFont, FontFormatter, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java, 85, 86
4
/**
   * Sets whether unknown font names are allowed.
   * @param newValue
   */
2
  public void setAllowsUnknownFont(boolean newValue) {
    allowsUnknownFont = newValue;
###
2611, readSVGElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 507, 588
3
/**
   * Reads an SVG "svg" element.
   */
71
  private Figure readSVGElement(IXMLElement elem)
      throws IOException {
    // Establish a new viewport
    Viewport viewport = new Viewport();
    String widthValue = readAttribute(elem, "width", "100%");
    String heightValue = readAttribute(elem, "height", "100%");
    viewport.width = toWidth(elem, widthValue);
    viewport.height = toHeight(elem, heightValue);
    if (readAttribute(elem, "viewBox", "none").equals("none")) {
      viewport.viewBox.width = viewport.width;
      viewport.viewBox.height = viewport.height;
    } else {
      String[] viewBoxValues = toWSOrCommaSeparatedArray(readAttribute(elem, "viewBox", "none"));
      viewport.viewBox.x = toNumber(elem, viewBoxValues[0]);
      viewport.viewBox.y = toNumber(elem, viewBoxValues[1]);
      viewport.viewBox.width = toNumber(elem, viewBoxValues[2]);
      viewport.viewBox.height = toNumber(elem, viewBoxValues[3]);
      // FIXME - Calculate percentages
      if (widthValue.indexOf('%') > 0) {
        viewport.width = viewport.viewBox.width;
      }
      if (heightValue.indexOf('%') > 0) {
        viewport.height = viewport.viewBox.height;
      }
    }
    if (viewportStack.size() == 1) {
      // We always preserve the aspect ratio for to the topmost SVG element.
      // This is not compliant, but looks much better.
      viewport.isPreserveAspectRatio = true;
    } else {
      viewport.isPreserveAspectRatio = !readAttribute(elem, "preserveAspectRatio", "none").equals("none");
    }
    viewport.widthPercentFactor = viewport.viewBox.width / 100d;
    viewport.heightPercentFactor = viewport.viewBox.height / 100d;
    viewport.numberFactor = Math.min(
        viewport.width / viewport.viewBox.width,
        viewport.height / viewport.viewBox.height);
    AffineTransform viewBoxTransform = new AffineTransform();
    viewBoxTransform.translate(
        -viewport.viewBox.x * viewport.width / viewport.viewBox.width,
        -viewport.viewBox.y * viewport.height / viewport.viewBox.height);
    if (viewport.isPreserveAspectRatio) {
      double factor = Math.min(
          viewport.width / viewport.viewBox.width,
          viewport.height / viewport.viewBox.height);
      viewBoxTransform.scale(factor, factor);
    } else {
      viewBoxTransform.scale(
          viewport.width / viewport.viewBox.width,
          viewport.height / viewport.viewBox.height);
    }
    viewportStack.push(viewport);
    readViewportAttributes(elem, viewportStack.firstElement().attributes);

    // Read the figures
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
        // skip invisible elements
        if (readAttribute(child, "visibility", "visible").equals("visible") &&
            !readAttribute(child, "display", "inline").equals("none")) {
          if (childFigure != null) {
            childFigure.transform(viewBoxTransform);
            figures.add(childFigure);
          }
        }
      }
    }
    viewportStack.pop();
    return null;
###
2612, toDouble, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3215, 3220
3
/**
   * Reads a double attribute.
   */
6
  private double toDouble(IXMLElement elem, String value, double defaultValue, double min, double max) throws IOException {
    try {
      double d = Double.valueOf(value);
      return Math.max(Math.min(d, max), min);
    } catch (NumberFormatException e) {
      return defaultValue;
###
2613, readFontAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2968, 3078
3
/* Reads font attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#Font
   */
104
  private void readFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    String value;
    double doubleValue;
    // 'font-family'
    // Value:    [[ <family-name> |
    // <generic-family> ],]* [<family-name> |
    // <generic-family>] | inherit
    // Initial:    depends on user agent
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "font-family", "Dialog");
    String[] familyNames = toQuotedAndCommaSeparatedArray(value);
    Font font = null;
    // Try to find a font with exactly matching name
    for (int i = 0; i < familyNames.length; i++) {
      try {
        font = (Font) fontFormatter.stringToValue(familyNames[i]);
        break;
      } catch (ParseException e) {
      }
    }
    if (font == null) {
      // Try to create a similar font using the first name in the list
      if (familyNames.length > 0) {
        fontFormatter.setAllowsUnknownFont(true);
        try {
          font = (Font) fontFormatter.stringToValue(familyNames[0]);
        } catch (ParseException e) {
        }
        fontFormatter.setAllowsUnknownFont(false);
      }
    }
    if (font == null) {
      // Fallback to the system Dialog font
      font = new Font("Dialog", Font.PLAIN, 12);
    }
    FONT_FACE.put(a, font);
    // 'font-getChildCount'
    // Value:    <absolute-getChildCount> | <relative-getChildCount> |
    // <length> | inherit
    // Initial:    medium
    // Applies to:    text content elements
    // Inherited:    yes, the computed value is inherited
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Absolute length
    doubleValue = readInheritFontSizeAttribute(elem, "font-size", "medium");
    FONT_SIZE.put(a, doubleValue);
    // 'font-style'
    // Value:    normal | italic | oblique | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "font-style", "normal");
    FONT_ITALIC.put(a, value.equals("italic"));

    //'font-variant'
    //Value:    normal | small-caps | inherit
    //Initial:    normal
    //Applies to:    text content elements
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    no
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "font-variant", "normal");
    // if (DEBUG) System.out.println("font-variant="+value);
    // 'font-weight'
    // Value:    normal | bold | bolder | lighter | 100 | 200 | 300
    // | 400 | 500 | 600 | 700 | 800 | 900 | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     one of the legal numeric values, non-numeric
    // values shall be converted to numeric values according to the rules
    // defined below.
    value = readInheritAttribute(elem, "font-weight", "normal");
    FONT_BOLD.put(a, value.equals("bold") || value.equals("bolder") ||
        value.equals("400") || value.equals("500") || value.equals("600") ||
        value.equals("700") || value.equals("800") || value.equals("900"));
    // Note: text-decoration is an SVG 1.1 feature
    //'text-decoration'
    //Value:    none | [ underline || overline || line-through || blink ] | inherit
    //Initial:    none
    //Applies to:    text content elements
    //Inherited:    no (see prose)
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    value = readAttribute(elem, "text-decoration", "none");
    FONT_UNDERLINE.put(a, value.equals("underline"));
###
2614, readCircleElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 626, 640
3
/**
   * Reads an SVG "circle" element.
   */
13
  private Figure readCircleElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    double cx = toWidth(elem, readAttribute(elem, "cx", "0"));
    double cy = toHeight(elem, readAttribute(elem, "cy", "0"));
    double r = toWidth(elem, readAttribute(elem, "r", "0"));
    Figure figure = factory.createCircle(cx, cy, r, a);
    elementObjects.put(elem, figure);
    return figure;
###
2615, readPathElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 826, 838
3
/**
   * Reads an SVG "path" element.
   */
11
  private Figure readPathElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    BezierPath[] beziers = toPath(elem, readAttribute(elem, "d", ""));
    Figure figure = factory.createPath(beziers, a);
    elementObjects.put(elem, figure);
    return figure;
###
2616, toQuotedAndCommaSeparatedArray, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1348, 1367
4
/**
   * Returns a value as a String array.
   * The values are separated by commas with optional quotes and white space.
   */
19
  public static String[] toQuotedAndCommaSeparatedArray(String str) throws IOException {
    LinkedList<String> values = new LinkedList<String>();
    StreamTokenizer tt = new StreamTokenizer(new StringReader(str));
    tt.wordChars('a', 'z');
    tt.wordChars('A', 'Z');
    tt.wordChars(128 + 32, 255);
    tt.whitespaceChars(0, ' ');
    tt.quoteChar('"');
    tt.quoteChar('\'');
    while (tt.nextToken() != StreamTokenizer.TT_EOF) {
      switch (tt.ttype) {
        case StreamTokenizer.TT_WORD:
        case '"':
        case '\'':
          values.add(tt.sval);
          break;
      }
    }
    return values.toArray(new String[values.size()]);
###
2617, readTextFlowAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1953, 1968
3
/* Reads text flow attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#TextFlow
   */
15
  private void readTextFlowAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object value;
    //'line-increment'
    //Value:    auto | <number> | inherit
    //Initial:    auto
    //Applies to:    'textArea'
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "line-increment", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented line-increment=" + value);
###
2618, readOpacityAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1875, 1892
3
/* Reads object/group opacity as described in
   * http://www.w3.org/TR/SVGMobile12/painting.html#groupOpacity
   */
18
  private void readOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    //'opacity'
    //Value:    <opacity-value> | inherit
    //Initial:    1
    //Applies to:     'image' element
    //Inherited:    no
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    //<opacity-value>
    //The uniform opacity setting must be applied across an entire object.
    //Any values outside the range 0.0 (fully transparent) to 1.0
    //(fully opaque) shall be clamped to this range.
    //(See Clamping values which are restricted to a particular range.)
    double value = toDouble(elem, readAttribute(elem, "opacity", "1"), 1, 0, 1);
    OPACITY.put(a, value);
###
2619, toWidth, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1257, 1260
7
/**
   * Returns a value as a width.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Animation",
 --------------
4
  private double toWidth(IXMLElement elem, String str) throws IOException {
    // XXX - Compute xPercentFactor from viewport
    return toLength(elem, str,
        viewportStack.peek().widthPercentFactor);
###
2620, readUseElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1095, 1132
6
/**
   * Reads an SVG "use" element.
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#ExternalResourcesRequired",
 --------------
35
  @SuppressWarnings("unchecked")
  private Figure readUseElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    HashMap<AttributeKey, Object> a2 = new HashMap<AttributeKey, Object>();
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a2);
    readUseShapeAttributes(elem, a2);
    readFontAttributes(elem, a2);
    String href = readAttribute(elem, "xlink:href", null);
    if (href != null && href.startsWith("#")) {
      IXMLElement refElem = identifiedElements.get(href.substring(1));
      if (refElem == null) {
        if (DEBUG) {
          System.out.println("SVGInputFormat couldn't find href for <use> element:" + href);
        }
      } else {
        Object obj = readElement(refElem);
        if (obj instanceof Figure) {
          Figure figure = (Figure) ((Figure) obj).clone();
          for (Map.Entry<AttributeKey, Object> entry : a2.entrySet()) {
            figure.set(entry.getKey(), entry.getValue());
          }
          AffineTransform tx =
              (TRANSFORM.get(a) == null) ? new AffineTransform() : TRANSFORM.get(a);
          double x = toNumber(elem, readAttribute(elem, "x", "0"));
          double y = toNumber(elem, readAttribute(elem, "y", "0"));
          tx.translate(x, y);
          figure.transform(tx);
          return figure;
        }
      }
    }
    return null;
###
2621, readDefsElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 421, 426
3
/**
   * Reads an SVG "defs" element.
   */
6
  private void readDefsElement(IXMLElement elem)
      throws IOException {
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
###
2622, readTransformAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1976, 1981
3
/* Reads the transform attribute as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   */
6
  private void readTransformAttribute(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    String value;
    value = readAttribute(elem, "transform", "none");
    if (!value.equals("none")) {
      TRANSFORM.put(a, toTransform(elem, value));
###
2623, readPolylineElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 790, 802
3
/**
   * Reads an SVG "polyline" element.
   */
11
  private Figure readPolylineElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readLineAttributes(elem, a);
    Point2D.Double[] points = toPoints(elem, readAttribute(elem, "points", ""));
    Figure figure = factory.createPolyline(points, a);
    elementObjects.put(elem, figure);
    return figure;
###
2624, readViewportAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2639, 2683
2
/* Reads viewport attributes.
   */
43
  private void readViewportAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object value;
    Double doubleValue;
    // width of the viewport
    value = readAttribute(elem, "width", null);
    if (DEBUG) {
      System.out.println("SVGInputFormat READ viewport w/h factors:" + viewportStack.peek().widthPercentFactor + "," + viewportStack.peek().heightPercentFactor);
    }
    if (value != null) {
      doubleValue = toLength(elem, (String) value, viewportStack.peek().widthPercentFactor);
      VIEWPORT_WIDTH.put(a, doubleValue);
    }
    // height of the viewport
    value = readAttribute(elem, "height", null);
    if (value != null) {
      doubleValue = toLength(elem, (String) value, viewportStack.peek().heightPercentFactor);
      VIEWPORT_HEIGHT.put(a, doubleValue);
    }
    //'viewport-fill'
    //Value:   "none" | <color> | inherit
    //Initial:   none
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     "none" or specified <color> value, except inherit
    value = toPaint(elem, readInheritColorAttribute(elem, "viewport-fill", "none"));
    if (value == null || (value instanceof Color)) {
      VIEWPORT_FILL.put(a, (Color) value);
    }
    //'viewport-fill-opacity'
    //Value:  <opacity-value> | inherit
    //Initial:   1.0
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified value, except inherit
    doubleValue = toDouble(elem, readAttribute(elem, "viewport-fill-opacity", "1.0"));
    VIEWPORT_FILL_OPACITY.put(a, doubleValue);
###
2625, readTSpanElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 969, 995
3
/**
   * Reads an SVG "tspan" element.
   */
27
  private void readTSpanElement(IXMLElement elem, DefaultStyledDocument doc)
      throws IOException {
    try {
      if (elem.getContent() != null) {
        doc.insertString(doc.getLength(), toText(elem, elem.getContent()), null);
      } else {
        for (IXMLElement node : elem.getChildren()) {
          if (node instanceof IXMLElement) {
            IXMLElement child = (IXMLElement) node;
            if (node.getName() != null && node.getName().equals("tspan")) {
              readTSpanElement((IXMLElement) node, doc);
            } else {
              if (DEBUG) {
                System.out.println("SVGInputFormat unknown text node " + node.getName());
              }
            }
          } else {
            if (node.getName() == null) {
              doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);
            }
          }
        }
      }
    } catch (BadLocationException e) {
      InternalError ex = new InternalError(e.getMessage());
      ex.initCause(e);
      throw ex;
###
2626, readEllipseElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 646, 661
3
/**
   * Reads an SVG "ellipse" element.
   */
14
  private Figure readEllipseElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    double cx = toWidth(elem, readAttribute(elem, "cx", "0"));
    double cy = toHeight(elem, readAttribute(elem, "cy", "0"));
    double rx = toWidth(elem, readAttribute(elem, "rx", "0"));
    double ry = toHeight(elem, readAttribute(elem, "ry", "0"));
    Figure figure = factory.createEllipse(cx, cy, rx, ry, a);
    elementObjects.put(elem, figure);
    return figure;
###
2627, readInheritFontSizeAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1199, 1225
9
/**
   * Reads a font size attribute that is inherited.
   * As specified by
   * http://www.w3.org/TR/SVGMobile12/text.html#FontPropertiesUsedBySVG
   * http://www.w3.org/TR/2006/CR-xsl11-20060220/#font-getChildCount
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Listener",
 --------------
26
  private double readInheritFontSizeAttribute(IXMLElement elem, String attributeName, String defaultValue)
      throws IOException {
    String value = null;
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
    } else if (elem.hasAttribute(attributeName)) {
      value = elem.getAttribute(attributeName, null);
    } else if (elem.getParent() != null &&
        (elem.getParent().getNamespace() == null ||
        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
      return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      value = defaultValue;
    }
    if (value.equals("inherit")) {
      return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else if (SVG_ABSOLUTE_FONT_SIZES.containsKey(value)) {
      return SVG_ABSOLUTE_FONT_SIZES.get(value);
    } else if (SVG_RELATIVE_FONT_SIZES.containsKey(value)) {
      return SVG_RELATIVE_FONT_SIZES.get(value) * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else if (value.endsWith("%")) {
      double factor = Double.valueOf(value.substring(0, value.length() - 1));
      return factor * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      //return toScaledNumber(elem, value);
      return toNumber(elem, value);
###
2628, toPoints, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1374, 1384
4
/**
   * Returns a value as a Point2D.Double array.
   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF
   */
9
  private Point2D.Double[] toPoints(IXMLElement elem, String str) throws IOException {
    StringTokenizer tt = new StringTokenizer(str, " ,");
    Point2D.Double[] points = new Point2D.Double[tt.countTokens() / 2];
    for (int i = 0; i < points.length; i++) {
      points[i] = new Point2D.Double(
          toNumber(elem, tt.nextToken()),
          toNumber(elem, tt.nextToken()));
    }
    return points;
###
2629, SVGInputFormat, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 155, 156
1
/** Creates a new instance. */
2
  public SVGInputFormat() {
    this(new DefaultSVGFigureFactory());
###
2630, readInheritAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1138, 1158
6
/**
   * Reads an attribute that is inherited.
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Scripting",
 --------------
21
  private String readInheritAttribute(IXMLElement elem, String attributeName, String defaultValue) {
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
      if (value.equals("inherit")) {
        return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else if (elem.hasAttribute(attributeName)) {
      String value = elem.getAttribute(attributeName);
      if (value.equals("inherit")) {
        return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else if (elem.getParent() != null &&
        (elem.getParent().getNamespace() == null ||
        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
      return readInheritAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      return defaultValue;
###
2631, toPath, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1394, 1841
7
/**
   * Returns a value as a BezierPath array.
   * as specified in http://www.w3.org/TR/SVGMobile12/paths.html#PathDataBNF
   *
   * Also supports elliptical arc commands 'a' and 'A' as specified in
   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands
   */
416
  private BezierPath[] toPath(IXMLElement elem, String str) throws IOException {
    LinkedList<BezierPath> paths = new LinkedList<BezierPath>();
    BezierPath path = null;
    Point2D.Double p = new Point2D.Double();
    Point2D.Double c1 = new Point2D.Double();
    Point2D.Double c2 = new Point2D.Double();
    StreamPosTokenizer tt;
    if (toPathTokenizer == null) {
      tt = new StreamPosTokenizer(new StringReader(str));
      tt.resetSyntax();
      tt.parseNumbers();
      tt.parseExponents();
      tt.parsePlusAsNumber();
      tt.whitespaceChars(0, ' ');
      tt.whitespaceChars(',', ',');
      toPathTokenizer = tt;
    } else {
      tt = toPathTokenizer;
      tt.setReader(new StringReader(str));
    }

    char nextCommand = 'M';
    char command = 'M';
    Commands:
    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
      if (tt.ttype > 0) {
        command = (char) tt.ttype;
      } else {
        command = nextCommand;
        tt.pushBack();
      }
      BezierPath.Node node;
      switch (command) {
        case 'M':
          // absolute-moveto x y
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'M' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'm':
          // relative-moveto dx dy
          if (path != null) {
            paths.add(path);
          }
          path = new BezierPath();
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'm' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.moveTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'Z':
        case 'z':
          // close path
          p.x = path.get(0).x[0];
          p.y = path.get(0).y[0];
          // If the last point and the first point are the same, we
          // can merge them
          if (path.size() > 1) {
            BezierPath.Node first = path.get(0);
            BezierPath.Node last = path.get(path.size() - 1);
            if (first.x[0] == last.x[0] &&
                first.y[0] == last.y[0]) {
              if ((last.mask & BezierPath.C1_MASK) != 0) {
                first.mask |= BezierPath.C1_MASK;
                first.x[1] = last.x[1];
                first.y[1] = last.y[1];
              }
              path.remove(path.size() - 1);
            }
          }
          path.setClosed(true);
          break;
        case 'L':
          // absolute-lineto x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'L' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'L';
          break;
        case 'l':
          // relative-lineto dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'l' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'l';
          break;
        case 'H':
          // absolute-horizontal-lineto x
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'H' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'H';
          break;
        case 'h':
          // relative-horizontal-lineto dx
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'h' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'h';
          break;
        case 'V':
          // absolute-vertical-lineto y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'V' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'V';
          break;
        case 'v':
          // relative-vertical-lineto dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'v' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.lineTo(p.x, p.y);
          nextCommand = 'v';
          break;
        case 'C':
          // absolute-curveto x1 y1 x2 y2 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'C' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'C';
          break;
        case 'c':
          // relative-curveto dx1 dy1 dx2 dy2 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'c' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'c';
          break;
        case 'S':
          // absolute-shorthand-curveto x2 y2 x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y2 coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'S' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 'S';
          break;
        case 's':
          // relative-shorthand-curveto dx2 dy2 dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy2 coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          c2.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 's' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);
          nextCommand = 's';
          break;
        case 'Q':
          // absolute-quadto x1 y1 x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y1 coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'Q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'Q';
          break;
        case 'q':
          // relative-quadto dx1 dy1 dx dy
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.x = p.x + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy1 coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          c1.y = p.y + tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 'q' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'q';
          break;
        case 'T':
          // absolute-shorthand-quadto x y
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'T' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 'T';
          break;
        case 't':
          // relative-shorthand-quadto dx dy
          node = path.get(path.size() - 1);
          c1.x = node.x[0] * 2d - node.x[1];
          c1.y = node.y[0] * 2d - node.y[1];
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dx coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("dy coordinate missing for 't' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.quadTo(c1.x, c1.y, p.x, p.y);
          nextCommand = 's';
          break;

        case 'A': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y = tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'A';
          break;
        }
        case 'a': {
          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("rx coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          // If rX or rY have negative signs, these are dropped;
          // the absolute value is used instead.
          double rx = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("ry coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double ry = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x-axis-rotation missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          double xAxisRotation = tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("large-arc-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean largeArcFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("sweep-flag missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          boolean sweepFlag = tt.nval != 0;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("x coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.x += tt.nval;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("y coordinate missing for 'A' at position " + tt.getStartPosition() + " in " + str);
          }
          p.y += tt.nval;
          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);
          nextCommand = 'a';
          break;
        }
        default:
          if (DEBUG) {
            System.out.println("SVGInputFormat.toPath aborting after illegal path command: " + command + " found in path " + str);
          }
          break Commands;
        //throw new IOException("Illegal command: "+command);
      }
    }
    if (path != null) {
      paths.add(path);
    }
    return paths.toArray(new BezierPath[paths.size()]);
###
2632, readAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1233, 1249
6
/**
   * Reads an attribute that is not inherited, unless its value is "inherit".
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#TimedAnimation",
 --------------
17
  private String readAttribute(IXMLElement elem, String attributeName, String defaultValue) {
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
      if (value.equals("inherit")) {
        return readAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else if (elem.hasAttribute(attributeName)) {
      String value = elem.getAttribute(attributeName, null);
      if (value.equals("inherit")) {
        return readAttribute(elem.getParent(), attributeName, defaultValue);
      } else {
        return value;
      }
    } else {
      return defaultValue;
###
2633, readAElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 464, 501
3
/**
   * Reads an SVG "a" element.
   */
35
  private Figure readAElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    CompositeFigure g = factory.createG(a);
    String href = readAttribute(elem, "xlink:href", null);
    if (href == null) {
      href = readAttribute(elem, "href", null);
    }
    String target = readAttribute(elem, "target", null);
    if (DEBUG) {
      System.out.println("SVGInputFormat.readAElement href=" + href);
    }
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
        // skip invisible elements
        if (readAttribute(child, "visibility", "visible").equals("visible") &&
            !readAttribute(child, "display", "inline").equals("none")) {
          if (childFigure != null) {
            g.basicAdd(childFigure);
          }
        }
        if (childFigure != null) {
          childFigure.set(LINK, href);
          childFigure.set(LINK_TARGET, target);
        } else {
          if (DEBUG) {
            System.out.println("SVGInputFormat <a> has no child figure");
          }
        }
      }
    }
    return (g.getChildCount() == 1) ? g.getChild(0) : g;
###
2634, toNumber, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1277, 1278
4
/**
   * Returns a value as a number.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeNumber
   */
2
  private double toNumber(IXMLElement elem, String str) throws IOException {
    return toLength(elem, str, viewportStack.peek().numberFactor);
###
2635, readTextAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1898, 1946
3
/* Reads text attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#Text
   */
46
  private void readTextAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    Object value;
    //'text-anchor'
    //Value:    start | middle | end | inherit
    //Initial:    start
    //Applies to:    'text' IXMLElement
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "text-anchor", "start");
    if (SVG_TEXT_ANCHORS.get(value) != null) {
      TEXT_ANCHOR.put(a, SVG_TEXT_ANCHORS.get(value));
    }
    //'display-align'
    //Value:    auto | before | center | after | inherit
    //Initial:    auto
    //Applies to:    'textArea'
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "display-align", "auto");
    // XXX - Implement me properly
    if (!value.equals("auto")) {
      if (value.equals("center")) {
        TEXT_ANCHOR.put(a, TextAnchor.MIDDLE);
      } else if (value.equals("before")) {
        TEXT_ANCHOR.put(a, TextAnchor.END);
      }
    }
    //text-align
    //Value:   start | end | center | inherit
    //Initial:   start
    //Applies to:   textArea elements
    //Inherited:   yes
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    value = readInheritAttribute(elem, "text-align", "start");
    // XXX - Implement me properly
    if (!value.equals("start")) {
      TEXT_ALIGN.put(a, SVG_TEXT_ALIGNS.get(value));
###
2636, toText, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3233, 3238
5
/**
   * Reads a text attribute.
   * This method takes the "xml:space" attribute into account.
   * http://www.w3.org/TR/SVGMobile12/text.html#WhiteSpace
   */
6
  private String toText(IXMLElement elem, String value) throws IOException {
    String space = readInheritAttribute(elem, "xml:space", "default");
    if (space.equals("default")) {
      return value.trim().replaceAll("\\s++", " ");
    } else /*if (space.equals("preserve"))*/ {
      return value;
###
2637, readUseShapeAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2224, 2433
2
/* Reads shape attributes for the SVG "use" element.
   */
198
  private void readUseShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object objectValue;
    String value;
    double doubleValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // value = readInheritAttribute(elem, "color", "black");
    // if (DEBUG) System.out.println("color="+value);
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // value = readInheritAttribute(elem, "color-rendering", "auto");
    // if (DEBUG) System.out.println("color-rendering="+value);
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    objectValue = readInheritColorAttribute(elem, "fill", null);
    if (objectValue != null) {
      objectValue = toPaint(elem, (String) objectValue);
      if (objectValue instanceof Color) {
        FILL_COLOR.put(a, (Color) objectValue);
      } else if (objectValue instanceof Gradient) {
        FILL_GRADIENT.put(a, (Gradient) objectValue);
      } else if (objectValue == null) {
        FILL_COLOR.put(a, null);
      } else {
        FILL_COLOR.put(a, null);
        if (DEBUG) {
          System.out.println("SVGInputFormat not implemented  fill=" + objectValue);
        }
      }
    }
    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "fill-opacity", null);
    if (objectValue != null) {
      FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    }
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "fill-rule", null);
    if (value != null) {
      WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
    }
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "stroke", null));
    if (objectValue != null) {
      if (objectValue instanceof Color) {
        STROKE_COLOR.put(a, (Color) objectValue);
      } else if (objectValue instanceof Gradient) {
        STROKE_GRADIENT.put(a, (Gradient) objectValue);
      }
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-dasharray", null);
    if (value != null && !value.equals("none")) {
      String[] values = toCommaSeparatedArray(value);
      double[] dashes = new double[values.length];
      for (int i = 0; i < values.length; i++) {
        dashes[i] = toNumber(elem, values[i]);
      }
      STROKE_DASHES.put(a, dashes);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-dashoffset", null);
    if (objectValue != null) {
      doubleValue = toNumber(elem, (String) objectValue);
      STROKE_DASH_PHASE.put(a, doubleValue);
      IS_STROKE_DASH_FACTOR.put(a, false);
    }
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linecap", null);
    if (value != null) {
      STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));
    }
    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linejoin", null);
    if (value != null) {
      STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
    }
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-miterlimit", null);
    if (objectValue != null) {
      doubleValue = toDouble(elem, (String) objectValue, 4d, 1d, Double.MAX_VALUE);
      STROKE_MITER_LIMIT.put(a, doubleValue);
      IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
    }
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-opacity", null);
    if (objectValue != null) {
      STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    }
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-width", null);
    if (objectValue != null) {
      doubleValue = toNumber(elem, (String) objectValue);
      STROKE_WIDTH.put(a, doubleValue);
###
2638, toHeight, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1267, 1270
7
/**
   * Returns a value as a height.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Audio",
 --------------
4
  private double toHeight(IXMLElement elem, String str) throws IOException {
    // XXX - Compute yPercentFactor from viewport
    return toLength(elem, str,
        viewportStack.peek().heightPercentFactor);
###
2639, flattenStyles, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 295, 324
11
/**
   * Flattens all CSS styles.
   * Styles defined in a "style" attribute and in CSS rules are converted
   * into attributes with the same name.
   */
 --------------
/**
     * Factor for number values in the user coordinate system.
     * This is the smaller value of width / viewBox.width and height / viewBox.height.
     */
 --------------
26
  private void flattenStyles(IXMLElement elem)
      throws IOException {
    if (elem.getName() != null && elem.getName().equals("style") &&
        readAttribute(elem, "type", "").equals("text/css") &&
        elem.getContent() != null) {
      CSSParser cssParser = new CSSParser();
      cssParser.parse(elem.getContent(), styleManager);
    } else {
      if (elem.getNamespace() == null ||
          elem.getNamespace().equals(SVG_NAMESPACE)) {
        String style = readAttribute(elem, "style", null);
        if (style != null) {
          for (String styleProperty : style.split(";")) {
            String[] stylePropertyElements = styleProperty.split(":");
            if (stylePropertyElements.length == 2 &&
                !elem.hasAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE)) {
              //if (DEBUG) System.out.println("flatten:"+Arrays.toString(stylePropertyElements));
              elem.setAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE, stylePropertyElements[1].trim());
            }
          }
        }
        styleManager.applyStylesTo(elem);
        for (IXMLElement node : elem.getChildren()) {
          if (node instanceof IXMLElement) {
            IXMLElement child = (IXMLElement) node;
            flattenStyles(child);
###
2640, toTransform, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3246, 3358
4
/* Converts an SVG transform attribute value into an AffineTransform
   * as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   */
104
  public static AffineTransform toTransform(IXMLElement elem, String str) throws IOException {
    AffineTransform t = new AffineTransform();
    if (str != null && !str.equals("none")) {
      StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));
      tt.resetSyntax();
      tt.wordChars('a', 'z');
      tt.wordChars('A', 'Z');
      tt.wordChars(128 + 32, 255);
      tt.whitespaceChars(0, ' ');
      tt.whitespaceChars(',', ',');
      tt.parseNumbers();
      tt.parseExponents();
      while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {
        if (tt.ttype != StreamPosTokenizer.TT_WORD) {
          throw new IOException("Illegal transform " + str);
        }
        String type = tt.sval;
        if (tt.nextToken() != '(') {
          throw new IOException("'(' not found in transform " + str);
        }
        if (type.equals("matrix")) {
          double[] m = new double[6];
          for (int i = 0; i < 6; i++) {
            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
              throw new IOException("Matrix value " + i + " not found in transform " + str + " token:" + tt.ttype + " " + tt.sval);
            }
            m[i] = tt.nval;
          }
          t.concatenate(new AffineTransform(m));
        } else if (type.equals("translate")) {
          double tx, ty;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-translation value not found in transform " + str);
          }
          tx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            ty = tt.nval;
          } else {
            tt.pushBack();
            ty = 0;
          }
          t.translate(tx, ty);
        } else if (type.equals("scale")) {
          double sx, sy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("X-scale value not found in transform " + str);
          }
          sx = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            sy = tt.nval;
          } else {
            tt.pushBack();
            sy = sx;
          }
          t.scale(sx, sy);
        } else if (type.equals("rotate")) {
          double angle, cx, cy;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Angle value not found in transform " + str);
          }
          angle = tt.nval;
          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {
            cx = tt.nval;
            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
              throw new IOException("Y-center value not found in transform " + str);
            }
            cy = tt.nval;
          } else {
            tt.pushBack();
            cx = cy = 0;
          }
          t.rotate(angle * Math.PI / 180d, cx, cy);

        } else if (type.equals("skewX")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.concatenate(new AffineTransform(
              1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));
        } else if (type.equals("skewY")) {
          double angle;
          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {
            throw new IOException("Skew angle not found in transform " + str);
          }
          angle = tt.nval;
          t.concatenate(new AffineTransform(
              1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));
        } else if (type.equals("ref")) {
          System.err.println("SVGInputFormat warning: ignored ref(...) transform attribute in element " + elem);
          while (tt.nextToken() != ')' && tt.ttype != StreamPosTokenizer.TT_EOF) {
            // ignore tokens between brackets
          }
          tt.pushBack();
        } else {
          throw new IOException("Unknown transform " + type + " in " + str + " in element " + elem);
        }
        if (tt.nextToken() != ')') {
          throw new IOException("')' not found in transform " + str);
        }
      }
    }
    return t;
###
2641, identifyElements, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1863, 1868
4
/**
   * Puts all elments with an "id" or an "xml:id" attribute into the
   * hashtable {@code identifiedElements}.
   */
5
  private void identifyElements(IXMLElement elem) {
    identifiedElements.put(elem.getAttribute("id"), elem);
    identifiedElements.put(elem.getAttribute("xml:id"), elem);
    for (IXMLElement child : elem.getChildren()) {
      identifyElements(child);
###
2642, toCommaSeparatedArray, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1326, 1327
4
/**
   * Returns a value as a String array.
   * The values are separated by commas with optional white space.
   */
2
  public static String[] toCommaSeparatedArray(String str) throws IOException {
    return str.split("\\s*,\\s*");
###
2643, read, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 176, 277
14
/**
   * This is the main reading method.
   *
   * @param in The input stream.
   * @param drawing The drawing to which this method adds figures.
   * @param replace Whether attributes on the drawing object
   * should by changed by this method. Set this to false, when reading individual
   * images from the clipboard.
   */
 --------------
/**
     * Factor for percent values relative to Viewport height.
     */
 --------------
92
  public void read(InputStream in, Drawing drawing, boolean replace) throws IOException {
    long start = System.currentTimeMillis();
    this.figures = new LinkedList<Figure>();
    IXMLParser parser;
    try {
      parser = XMLParserFactory.createDefaultXMLParser();
    } catch (Exception ex) {
      InternalError e = new InternalError("Unable to instantiate NanoXML Parser");
      e.initCause(ex);
      throw e;
    }
    System.out.println("SVGInputFormat parser created " + (System.currentTimeMillis() - start));
    IXMLReader reader = new StdXMLReader(in);
    parser.setReader(reader);
    System.out.println("SVGInputFormat reader created " + (System.currentTimeMillis() - start));
    try {
      document = (IXMLElement) parser.parse();
    } catch (XMLException ex) {
      IOException e = new IOException(ex.getMessage());
      e.initCause(ex);
      throw e;
    }
    System.out.println("SVGInputFormat document created " + (System.currentTimeMillis() - start));
    // Search for the first 'svg' element in the XML document
    // in preorder sequence
    IXMLElement svg = document;
    Stack<Iterator<IXMLElement>> stack = new Stack<Iterator<IXMLElement>>();
    LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();
    ll.add(document);
    stack.push(ll.iterator());
    while (!stack.empty() && stack.peek().hasNext()) {
      Iterator<IXMLElement> iter = stack.peek();
      IXMLElement node = iter.next();
      Iterator<IXMLElement> children = (node.getChildren() == null) ? null : node.getChildren().iterator();
      if (!iter.hasNext()) {
        stack.pop();
      }
      if (children != null && children.hasNext()) {
        stack.push(children);
      }
      if (node.getName() != null &&
          node.getName().equals("svg") &&
          (node.getNamespace() == null ||
          node.getNamespace().equals(SVG_NAMESPACE))) {
        svg = node;
        break;
      }
    }

    if (svg.getName() == null ||
        !svg.getName().equals("svg") ||
        (svg.getNamespace() != null &&
        !svg.getNamespace().equals(SVG_NAMESPACE))) {
      throw new IOException("'svg' element expected: " + svg.getName());
    }
    //long end1 = System.currentTimeMillis();
    // Flatten CSS Styles
    initStorageContext(document);
    flattenStyles(svg);
    //long end2 = System.currentTimeMillis();
    readElement(svg);
    long end = System.currentTimeMillis();
    if (DEBUG) {
      System.out.println("SVGInputFormat elapsed:" + (end - start));
    }
    /*if (DEBUG) System.out.println("SVGInputFormat read:"+(end1-start));
    if (DEBUG) System.out.println("SVGInputFormat flatten:"+(end2-end1));
    if (DEBUG) System.out.println("SVGInputFormat build:"+(end-end2));
     */
    if (replace) {
      drawing.removeAllChildren();
    }
    drawing.addAll(figures);

    if (replace) {
      Viewport viewport = viewportStack.firstElement();
      drawing.set(VIEWPORT_FILL, VIEWPORT_FILL.get(viewport.attributes));
      drawing.set(VIEWPORT_FILL_OPACITY, VIEWPORT_FILL_OPACITY.get(viewport.attributes));
      drawing.set(VIEWPORT_HEIGHT, VIEWPORT_HEIGHT.get(viewport.attributes));
      drawing.set(VIEWPORT_WIDTH, VIEWPORT_WIDTH.get(viewport.attributes));
    }
    // Get rid of all objects we don't need anymore to help garbage collector.
    document.dispose();
    identifiedElements.clear();
    elementObjects.clear();
    viewportStack.clear();
    styleManager.clear();
    document = null;
    identifiedElements = null;
    elementObjects = null;
    viewportStack = null;
    styleManager = null;
###
2644, readInheritColorAttribute, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1167, 1190
8
/**
   * Reads a color attribute that is inherited.
   * This is similar to {@code readInheritAttribute}, but takes care of the
   * "currentColor" magic attribute value.
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#Handler",
 --------------
24
  private String readInheritColorAttribute(IXMLElement elem, String attributeName, String defaultValue) {
    String value = null;
    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {
      value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);
      if (value.equals("inherit")) {
        return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
      }
    } else if (elem.hasAttribute(attributeName)) {
      value = elem.getAttribute(attributeName);
      if (value.equals("inherit")) {
        return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
      }
    } else if (elem.getParent() != null &&
        (elem.getParent().getNamespace() == null ||
        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {
      value = readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);
    } else {
      value = defaultValue;
    }
    if (value != null && value.toLowerCase().equals("currentcolor") && !attributeName.equals("color")) {
      // Lets do some magic stuff for "currentColor" attribute value
      value = readInheritColorAttribute(elem, "color", "defaultValue");
    }
    return value;
###
2645, readPolygonElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 808, 820
3
/**
   * Reads an SVG "polygon" element.
   */
11
  private Figure readPolygonElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    Point2D.Double[] points = toPoints(elem, readAttribute(elem, "points", ""));
    Figure figure = factory.createPolygon(points, a);
    elementObjects.put(elem, figure);
    return figure;
###
2646, readRectElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 594, 620
3
/**
   * Reads an SVG "rect" element.
   */
24
  private Figure readRectElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    double x = toNumber(elem, readAttribute(elem, "x", "0"));
    double y = toNumber(elem, readAttribute(elem, "y", "0"));
    double w = toWidth(elem, readAttribute(elem, "width", "0"));
    double h = toHeight(elem, readAttribute(elem, "height", "0"));
    String rxValue = readAttribute(elem, "rx", "none");
    String ryValue = readAttribute(elem, "ry", "none");
    if (rxValue.equals("none")) {
      rxValue = ryValue;
    }
    if (ryValue.equals("none")) {
      ryValue = rxValue;
    }
    double rx = toNumber(elem, rxValue.equals("none") ? "0" : rxValue);
    double ry = toNumber(elem, ryValue.equals("none") ? "0" : ryValue);
    Figure figure = factory.createRect(x, y, w, h, rx, ry, a);
    elementObjects.put(elem, figure);
    return figure;
###
2647, toColor, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3151, 3201
4
/**
   * Reads a color style attribute. This can be a Color or null.
   * FIXME - Doesn't support url(...) colors yet.
   */
50
  private Color toColor(IXMLElement elem, String value) throws IOException {
    String str = value;
    if (str == null) {
      return null;
    }
    str = str.trim().toLowerCase();
    if (str.equals("currentcolor")) {
      String currentColor = readInheritAttribute(elem, "color", "black");
      if (currentColor == null || currentColor.trim().toLowerCase().equals("currentColor")) {
        return null;
      } else {
        return toColor(elem, currentColor);
      }
    } else if (SVG_COLORS.containsKey(str)) {
      return SVG_COLORS.get(str);
    } else if (str.startsWith("#") && str.length() == 7) {
      return new Color(Integer.decode(str));
    } else if (str.startsWith("#") && str.length() == 4) {
      // Three digits hex value
      int th = Integer.decode(str);
      return new Color(
          (th & 0xf) | ((th & 0xf) << 4) |
          ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |
          ((th & 0xf00) << 8) | ((th & 0xf00) << 12));
    } else if (str.startsWith("rgb")) {
      try {
        StringTokenizer tt = new StringTokenizer(str, "() ,");
        tt.nextToken();
        String r = tt.nextToken();
        String g = tt.nextToken();
        String b = tt.nextToken();
        Color c = new Color(
            r.endsWith("%") ? (int) (Integer.decode(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),
            g.endsWith("%") ? (int) (Integer.decode(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),
            b.endsWith("%") ? (int) (Integer.decode(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));
        return c;
      } catch (Exception e) {
        if (DEBUG) {
          System.out.println("SVGInputFormat.toColor illegal RGB value " + str);
        }
        return null;
      }
    } else if (str.startsWith("url")) {
      // FIXME - Implement me
      if (DEBUG) {
        System.out.println("SVGInputFormat.toColor not implemented for " + str);
      }
      return null;
    } else {
      return null;
###
2648, readSolidColorElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1987, 2017
2
/* Reads solid color attributes.
   */
28
  private void readSolidColorElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    // 'solid-color'
    //Value:   currentColor | <color> | inherit
    //Initial:   black
    //Applies to:   'solidColor' elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified <color> value, except inherit
    Color color = toColor(elem, readAttribute(elem, "solid-color", "black"));
    //'solid-opacity'
    //Value:  <opacity-value> | inherit
    //Initial:   1
    //Applies to:   'solidColor' elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified value, except inherit
    double opacity = toDouble(elem, readAttribute(elem, "solid-opacity", "1"), 1, 0, 1);
    if (opacity != 1) {
      color = new Color(((int) (255 * opacity) << 24) | (0xffffff & color.getRGB()), true);
    }
    elementObjects.put(elem, color);
###
2649, readGElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 434, 458
3
/**
   * Reads an SVG "g" element.
   */
24
  private Figure readGElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readOpacityAttribute(elem, a);
    CompositeFigure g = factory.createG(a);
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        Figure childFigure = readElement(child);
        // skip invisible elements
        if (readAttribute(child, "visibility", "visible").equals("visible") &&
            !readAttribute(child, "display", "inline").equals("none")) {
          if (childFigure != null) {
            g.basicAdd(childFigure);
          }
        }
      }
    }
    readTransformAttribute(elem, a);
    if (TRANSFORM.get(a) != null) {
      g.transform(TRANSFORM.get(a));
    }
    return g;
###
2650, readShapeAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2024, 2219
2
/** Reads shape attributes.
   */
183
  private void readShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object objectValue;
    String value;
    double doubleValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // value = readInheritAttribute(elem, "color", "black");
    // if (DEBUG) System.out.println("color="+value);
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // value = readInheritAttribute(elem, "color-rendering", "auto");
    // if (DEBUG) System.out.println("color-rendering="+value);
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "fill", "black"));
    if (objectValue instanceof Color) {
      FILL_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      FILL_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      FILL_COLOR.put(a, null);
    } else {
      FILL_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  fill=" + objectValue);
      }
    }
    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "fill-opacity", "1");
    FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "fill-rule", "nonzero");
    WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "stroke", "none"));
    if (objectValue instanceof Color) {
      STROKE_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      STROKE_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      STROKE_COLOR.put(a, null);
    } else {
      STROKE_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  stroke=" + objectValue);
      }
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-dasharray", "none");
    if (!value.equals("none")) {
      String[] values = toWSOrCommaSeparatedArray(value);
      double[] dashes = new double[values.length];
      for (int i = 0; i < values.length; i++) {
        dashes[i] = toNumber(elem, values[i]);
      }
      STROKE_DASHES.put(a, dashes);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-dashoffset", "0"));
    STROKE_DASH_PHASE.put(a, doubleValue);
    IS_STROKE_DASH_FACTOR.put(a, false);
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linecap", "butt");
    STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));

    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linejoin", "miter");
    STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toDouble(elem, readInheritAttribute(elem, "stroke-miterlimit", "4"), 4d, 1d, Double.MAX_VALUE);
    STROKE_MITER_LIMIT.put(a, doubleValue);
    IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-opacity", "1");
    STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-width", "1"));
    STROKE_WIDTH.put(a, doubleValue);
###
2651, toLength, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1285, 1319
4
/**
   * Returns a value as a length.
   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength
   */
33
  private double toLength(IXMLElement elem, String str, double percentFactor) throws IOException {
    double scaleFactor = 1d;
    if (str == null || str.length() == 0 || str.equals("none")) {
      return 0d;
    }
    if (str.endsWith("%")) {
      str = str.substring(0, str.length() - 1);
      scaleFactor = percentFactor;
    } else if (str.endsWith("px")) {
      str = str.substring(0, str.length() - 2);
    } else if (str.endsWith("pt")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 1.25;
    } else if (str.endsWith("pc")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 15;
    } else if (str.endsWith("mm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 3.543307;
    } else if (str.endsWith("cm")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 35.43307;
    } else if (str.endsWith("in")) {
      str = str.substring(0, str.length() - 2);
      scaleFactor = 90;
    } else if (str.endsWith("em")) {
      str = str.substring(0, str.length() - 2);
      // XXX - This doesn't work
      scaleFactor = toLength(elem, readAttribute(elem, "font-size", "0"), percentFactor);
    } else {
      scaleFactor = 1d;
    }
    return Double.parseDouble(str) * scaleFactor;
###
2652, toWSOrCommaSeparatedArray, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1335, 1340
5
/**
   * Returns a value as a String array.
   * The values are separated by whitespace or by commas with optional white
   * space.
   */
6
  public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {
    String[] result = str.split("(\\s*,\\s*|\\s+)");
    if (result.length == 1 && result[0].equals("")) {
      return new String[0];
    } else {
      return result;
###
2653, readLineAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2439, 2634
2
/** Reads line and polyline attributes.
   */
183
  private void readLineAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)
      throws IOException {
    Object objectValue;
    String value;
    double doubleValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // value = readInheritAttribute(elem, "color", "black");
    // if (DEBUG) System.out.println("color="+value);
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // value = readInheritAttribute(elem, "color-rendering", "auto");
    // if (DEBUG) System.out.println("color-rendering="+value);
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "fill", "none"));
    if (objectValue instanceof Color) {
      FILL_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      FILL_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      FILL_COLOR.put(a, null);
    } else {
      FILL_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  fill=" + objectValue);
      }
    }
    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "fill-opacity", "1");
    FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "fill-rule", "nonzero");
    WINDING_RULE.put(a, SVG_FILL_RULES.get(value));
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    objectValue = toPaint(elem, readInheritColorAttribute(elem, "stroke", "black"));
    if (objectValue instanceof Color) {
      STROKE_COLOR.put(a, (Color) objectValue);
    } else if (objectValue instanceof Gradient) {
      STROKE_GRADIENT.putClone(a, (Gradient) objectValue);
    } else if (objectValue == null) {
      STROKE_COLOR.put(a, null);
    } else {
      STROKE_COLOR.put(a, null);
      if (DEBUG) {
        System.out.println("SVGInputFormat not implemented  stroke=" + objectValue);
      }
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-dasharray", "none");
    if (!value.equals("none")) {
      String[] values = toWSOrCommaSeparatedArray(value);
      double[] dashes = new double[values.length];
      for (int i = 0; i < values.length; i++) {
        dashes[i] = toNumber(elem, values[i]);
      }
      STROKE_DASHES.put(a, dashes);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-dashoffset", "0"));
    STROKE_DASH_PHASE.put(a, doubleValue);
    IS_STROKE_DASH_FACTOR.put(a, false);
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linecap", "butt");
    STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));

    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "stroke-linejoin", "miter");
    STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toDouble(elem, readInheritAttribute(elem, "stroke-miterlimit", "4"), 4d, 1d, Double.MAX_VALUE);
    STROKE_MITER_LIMIT.put(a, doubleValue);
    IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    objectValue = readInheritAttribute(elem, "stroke-opacity", "1");
    STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    doubleValue = toNumber(elem, readInheritAttribute(elem, "stroke-width", "1"));
    STROKE_WIDTH.put(a, doubleValue);
###
2654, readLinearGradientElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2805, 2883
3
/**
   * Reads an SVG "linearGradient" element.
   */
71
  private void readLinearGradientElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    double x1 = toLength(elem, readAttribute(elem, "x1", "0"), 0.01);
    double y1 = toLength(elem, readAttribute(elem, "y1", "0"), 0.01);
    double x2 = toLength(elem, readAttribute(elem, "x2", "1"), 0.01);
    double y2 = toLength(elem, readAttribute(elem, "y2", "0"), 0.01);
    boolean isRelativeToFigureBounds = readAttribute(elem, "gradientUnits", "objectBoundingBox").equals("objectBoundingBox");
    ArrayList<IXMLElement> stops = elem.getChildrenNamed("stop", SVG_NAMESPACE);
    if (stops.size() == 0) {
      stops = elem.getChildrenNamed("stop");
    }
    if (stops.size() == 0) {
      // FIXME - Implement xlink support throughouth SVGInputFormat
      String xlink = readAttribute(elem, "xlink:href", "");
      if (xlink.startsWith("#") &&
          identifiedElements.get(xlink.substring(1)) != null) {
        stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop", SVG_NAMESPACE);
        if (stops.size() == 0) {
          stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop");
        }
      }
    }
    if (stops.size() == 0) {
      if (DEBUG) {
        System.out.println("SVGInpuFormat: Warning no stops in linearGradient " + elem);
      }
    }
    double[] stopOffsets = new double[stops.size()];
    Color[] stopColors = new Color[stops.size()];
    double[] stopOpacities = new double[stops.size()];
    for (int i = 0; i < stops.size(); i++) {
      IXMLElement stopElem = stops.get(i);
      String offsetStr = readAttribute(stopElem, "offset", "0");
      if (offsetStr.endsWith("%")) {
        stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;
      } else {
        stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);
      }
      // 'stop-color'
      // Value:    currentColor | <color> | inherit
      // Initial:    black
      // Applies to:     'stop' elements
      // Inherited:    no
      // Percentages:    N/A
      // Media:    visual
      // Animatable:    yes
      // Computed value:     Specified <color> value, except i
      stopColors[i] = toColor(stopElem, readAttribute(stopElem, "stop-color", "black"));
      if (stopColors[i] == null) {
        stopColors[i] = new Color(0x0, true);
        //throw new IOException("stop color missing in "+stopElem);
      }
      //'stop-opacity'
      //Value:    <opacity-value> | inherit
      //Initial:    1
      //Applies to:     'stop' elements
      //Inherited:    no
      //Percentages:    N/A
      //Media:    visual
      //Animatable:    yes
      //Computed value:     Specified value, except inherit
      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, "stop-opacity", "1"), 1, 0, 1);
    }
    AffineTransform tx = toTransform(elem, readAttribute(elem, "gradientTransform", "none"));
    Gradient gradient = factory.createLinearGradient(
        x1, y1, x2, y2,
        stopOffsets, stopColors, stopOpacities,
        isRelativeToFigureBounds, tx);
    elementObjects.put(elem, gradient);
###
2655, toDouble, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3208, 3209
3
/**
   * Reads a double attribute.
   */
2
  private double toDouble(IXMLElement elem, String value) throws IOException {
    return toDouble(elem, value, 0, Double.MIN_VALUE, Double.MAX_VALUE);
###
2656, readElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 336, 415
5
/**
   * Reads an SVG element of any kind.
   * @return Returns the Figure, if the SVG element represents a Figure.
   * Returns null in all other cases.
   */
79
  private Figure readElement(IXMLElement elem)
      throws IOException {
    if (DEBUG) {
      System.out.println("SVGInputFormat.readElement " + elem.getName() + " line:" + elem.getLineNr());
    }
    Figure f = null;
    if (elem.getNamespace() == null ||
        elem.getNamespace().equals(SVG_NAMESPACE)) {
      String name = elem.getName();
      if (name == null) {
        if (DEBUG) {
          System.err.println("SVGInputFormat warning: skipping nameless element at line " + elem.getLineNr());
        }
      } else if (name.equals("a")) {
        f = readAElement(elem);
      } else if (name.equals("circle")) {
        f = readCircleElement(elem);
      } else if (name.equals("defs")) {
        readDefsElement(elem);
        f = null;
      } else if (name.equals("ellipse")) {
        f = readEllipseElement(elem);
      } else if (name.equals("g")) {
        f = readGElement(elem);
      } else if (name.equals("image")) {
        f = readImageElement(elem);
      } else if (name.equals("line")) {
        f = readLineElement(elem);
      } else if (name.equals("linearGradient")) {
        readLinearGradientElement(elem);
        f = null;
      } else if (name.equals("path")) {
        f = readPathElement(elem);
      } else if (name.equals("polygon")) {
        f = readPolygonElement(elem);
      } else if (name.equals("polyline")) {
        f = readPolylineElement(elem);
      } else if (name.equals("radialGradient")) {
        readRadialGradientElement(elem);
        f = null;
      } else if (name.equals("rect")) {
        f = readRectElement(elem);
      } else if (name.equals("solidColor")) {
        readSolidColorElement(elem);
        f = null;
      } else if (name.equals("svg")) {
        f = readSVGElement(elem);
        //f = readGElement(elem);
      } else if (name.equals("switch")) {
        f = readSwitchElement(elem);
      } else if (name.equals("text")) {
        f = readTextElement(elem);
      } else if (name.equals("textArea")) {
        f = readTextAreaElement(elem);
      } else if (name.equals("title")) {
        //FIXME - Implement reading of title element
        //f = readTitleElement(elem);
      } else if (name.equals("use")) {
        f = readUseElement(elem);
      } else if (name.equals("style")) {
        // Nothing to do, style elements have been already
        // processed in method flattenStyles
      } else {
        if (DEBUG) {
          System.out.println("SVGInputFormat not implemented for <" + name + ">");
        }
      }
    }
    if (f instanceof SVGFigure) {
      if (((SVGFigure) f).isEmpty()) {
        // if (DEBUG) System.out.println("Empty figure "+f);
        return null;
      }
    } else if (f != null) {
      if (DEBUG) {
        System.out.println("SVGInputFormat warning: not an SVGFigure " + f);
      }
    }
    return f;
###
2657, toPaint, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 3085, 3143
4
/**
   * Reads a paint style attribute. This can be a Color or a Gradient or null.
   * XXX - Doesn't support url(...) colors yet.
   */
57
  private Object toPaint(IXMLElement elem, String value) throws IOException {
    String str = value;
    if (str == null) {
      return null;
    }
    str = str.trim().toLowerCase();
    if (str.equals("none")) {
      return null;
    } else if (str.equals("currentcolor")) {
      String currentColor = readInheritAttribute(elem, "color", "black");
      if (currentColor == null || currentColor.trim().toLowerCase().equals("currentColor")) {
        return null;
      } else {
        return toPaint(elem, currentColor);
      }
    } else if (SVG_COLORS.containsKey(str)) {
      return SVG_COLORS.get(str);
    } else if (str.startsWith("#") && str.length() == 7) {
      return new Color(Integer.decode(str));
    } else if (str.startsWith("#") && str.length() == 4) {
      // Three digits hex value
      int th = Integer.decode(str);
      return new Color(
          (th & 0xf) | ((th & 0xf) << 4) |
          ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |
          ((th & 0xf00) << 8) | ((th & 0xf00) << 12));
    } else if (str.startsWith("rgb")) {
      try {
        StringTokenizer tt = new StringTokenizer(str, "() ,");
        tt.nextToken();
        String r = tt.nextToken();
        String g = tt.nextToken();
        String b = tt.nextToken();
        Color c = new Color(
            r.endsWith("%") ? (int) (Double.parseDouble(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),
            g.endsWith("%") ? (int) (Double.parseDouble(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),
            b.endsWith("%") ? (int) (Double.parseDouble(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));
        return c;
      } catch (Exception e) {
        /*if (DEBUG)*/ System.out.println("SVGInputFormat.toPaint illegal RGB value " + str);
        e.printStackTrace();
        return null;
      }
    } else if (str.startsWith("url(")) {
      String href = value.substring(4, value.length() - 1);
      if (identifiedElements.containsKey(href.substring(1)) &&
          elementObjects.containsKey(identifiedElements.get(href.substring(1)))) {
        Object obj = elementObjects.get(identifiedElements.get(href.substring(1)));
        return obj;
      }
      // XXX - Implement me
      if (DEBUG) {
        System.out.println("SVGInputFormat.toPaint not implemented for " + href);
      }
      return null;
    } else {
      return null;
###
2658, readLineElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 757, 784
3
/**
   * Reads an SVG "line" element.
   */
25
  private Figure readLineElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readLineAttributes(elem, a);
    // Because 'line' elements are single lines and thus are geometrically
    // one-dimensional, they have no interior; thus, 'line' elements are
    // never filled (see the 'fill' property).
    if (FILL_COLOR.get(a) != null && STROKE_COLOR.get(a) == null) {
      STROKE_COLOR.put(a, FILL_COLOR.get(a));
    }
    if (FILL_GRADIENT.get(a) != null && STROKE_GRADIENT.get(a) == null) {
      STROKE_GRADIENT.put(a, FILL_GRADIENT.get(a));
    }
    FILL_COLOR.put(a, null);
    FILL_GRADIENT.put(a, null);
    double x1 = toNumber(elem, readAttribute(elem, "x1", "0"));
    double y1 = toNumber(elem, readAttribute(elem, "y1", "0"));
    double x2 = toNumber(elem, readAttribute(elem, "x2", "0"));
    double y2 = toNumber(elem, readAttribute(elem, "y2", "0"));
    Figure figure = factory.createLine(x1, y1, x2, y2, a);
    elementObjects.put(elem, figure);
    return figure;
###
2659, readTextElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 844, 912
3
/**
   * Reads an SVG "text" element.
   */
64
  private Figure readTextElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    readFontAttributes(elem, a);
    readTextAttributes(elem, a);
    String[] xStr = toCommaSeparatedArray(readAttribute(elem, "x", "0"));
    String[] yStr = toCommaSeparatedArray(readAttribute(elem, "y", "0"));
    Point2D.Double[] coordinates = new Point2D.Double[Math.max(xStr.length, yStr.length)];
    double lastX = 0;
    double lastY = 0;
    for (int i = 0; i < coordinates.length; i++) {
      if (xStr.length > i) {
        try {
          lastX = toNumber(elem, xStr[i]);
        } catch (NumberFormatException ex) {
        }
      }
      if (yStr.length > i) {
        try {
          lastY = toNumber(elem, yStr[i]);
        } catch (NumberFormatException ex) {
        }
      }
      coordinates[i] = new Point2D.Double(lastX, lastY);
    }

    String[] rotateStr = toCommaSeparatedArray(readAttribute(elem, "rotate", ""));
    double[] rotate = new double[rotateStr.length];
    for (int i = 0; i < rotateStr.length; i++) {
      try {
        rotate[i] = toDouble(elem, rotateStr[i]);
      } catch (NumberFormatException ex) {
        rotate[i] = 0;
      }
    }
    DefaultStyledDocument doc = new DefaultStyledDocument();
    try {
      if (elem.getContent() != null) {
        doc.insertString(0, toText(elem, elem.getContent()), null);
      } else {
        for (IXMLElement node : elem.getChildren()) {
          if (node.getName() == null) {
            doc.insertString(0, toText(elem, node.getContent()), null);
          } else if (node.getName().equals("tspan")) {
            readTSpanElement((IXMLElement) node, doc);
          } else {
            if (DEBUG) {
              System.out.println("SVGInputFormat unsupported text node <" + node.getName() + ">");
            }
          }
        }
      }
    } catch (BadLocationException e) {
      InternalError ex = new InternalError(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
    Figure figure = factory.createText(coordinates, rotate, doc, a);
    elementObjects.put(elem, figure);
    return figure;
###
2660, readGraphicsAttributes, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2689, 2798
3
/* Reads graphics attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#GraphicsAttribute
   */
104
  private void readGraphicsAttributes(IXMLElement elem, Figure f)
      throws IOException {
    Object value;
    // 'display'
    // Value:     inline | block | list-item |
    // run-in | compact | marker |
    // table | inline-table | table-row-group | table-header-group |
    // table-footer-group | table-row | table-column-group | table-column |
    // table-cell | table-caption | none | inherit
    // Initial:     inline
    // Applies to:     'svg' , 'g' , 'switch' , 'a' , 'foreignObject' ,
    // graphics elements (including the text content block elements) and text
    // sub-elements (for example, 'tspan' and 'a' )
    // Inherited:     no
    // Percentages:     N/A
    // Media:     all
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    value = readAttribute(elem, "display", "inline");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented display=" + value);
    }

    //'image-rendering'
    //Value:     auto | optimizeSpeed | optimizeQuality | inherit
    //Initial:     auto
    //Applies to:     images
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "image-rendering", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented image-rendering=" + value);
    }
    //'pointer-events'
    //Value:    boundingBox | visiblePainted | visibleFill | visibleStroke | visible |
    //painted | fill | stroke | all | none | inherit
    //Initial:    visiblePainted
    //Applies to:    graphics elements
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:    Specified value, except inherit
    value = readInheritAttribute(elem, "pointer-events", "visiblePainted");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented pointer-events=" + value);
    }
    // 'shape-rendering'
    //Value:     auto | optimizeSpeed | crispEdges |
    //geometricPrecision | inherit
    //Initial:     auto
    //Applies to:     shapes
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "shape-rendering", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented shape-rendering=" + value);
    }
    //'text-rendering'
    //Value:     auto | optimizeSpeed | optimizeLegibility |
    //geometricPrecision | inherit
    //Initial:     auto
    //Applies to:    text content block elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "text-rendering", "auto");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented text-rendering=" + value);
    }
    //'vector-effect'
    //Value:     non-scaling-stroke | none | inherit
    //Initial:     none
    //Applies to:     graphics elements
    //Inherited:     no
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readAttribute(elem, "vector-effect", "none");
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented vector-effect=" + value);
    }
    //'visibility'
    //Value:     visible | hidden | collapse | inherit
    //Initial:     visible
    //Applies to:     graphics elements (including the text content block
    // elements) and text sub-elements (for example, 'tspan' and 'a' )
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    value = readInheritAttribute(elem, "visibility", null);
    if (DEBUG) {
      System.out.println("SVGInputFormat not implemented visibility=" + value);
###
2661, readRadialGradientElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 2889, 2962
3
/**
   * Reads an SVG "radialGradient" element.
   */
69
  private void readRadialGradientElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    double cx = toLength(elem, readAttribute(elem, "cx", "0.5"), 0.01);
    double cy = toLength(elem, readAttribute(elem, "cy", "0.5"), 0.01);
    double fx = toLength(elem, readAttribute(elem, "fx", readAttribute(elem, "cx", "0.5")), 0.01);
    double fy = toLength(elem, readAttribute(elem, "fy", readAttribute(elem, "cy", "0.5")), 0.01);
    double r = toLength(elem, readAttribute(elem, "r", "0.5"), 0.01);
    boolean isRelativeToFigureBounds =
        readAttribute(elem, "gradientUnits", "objectBoundingBox").equals("objectBoundingBox");
    ArrayList<IXMLElement> stops = elem.getChildrenNamed("stop", SVG_NAMESPACE);
    if (stops.size() == 0) {
      stops = elem.getChildrenNamed("stop");
    }
    if (stops.size() == 0) {
      // FIXME - Implement xlink support throughout SVGInputFormat
      String xlink = readAttribute(elem, "xlink:href", "");
      if (xlink.startsWith("#") &&
          identifiedElements.get(xlink.substring(1)) != null) {
        stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop", SVG_NAMESPACE);
        if (stops.size() == 0) {
          stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed("stop");
        }
      }
    }
    double[] stopOffsets = new double[stops.size()];
    Color[] stopColors = new Color[stops.size()];
    double[] stopOpacities = new double[stops.size()];
    for (int i = 0; i < stops.size(); i++) {
      IXMLElement stopElem = stops.get(i);
      String offsetStr = readAttribute(stopElem, "offset", "0");
      if (offsetStr.endsWith("%")) {
        stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;
      } else {
        stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);
      }
      // 'stop-color'
      // Value:    currentColor | <color> | inherit
      // Initial:    black
      // Applies to:     'stop' elements
      // Inherited:    no
      // Percentages:    N/A
      // Media:    visual
      // Animatable:    yes
      // Computed value:     Specified <color> value, except i
      stopColors[i] = toColor(stopElem, readAttribute(stopElem, "stop-color", "black"));
      if (stopColors[i] == null) {
        stopColors[i] = new Color(0x0, true);
        //throw new IOException("stop color missing in "+stopElem);
      }
      //'stop-opacity'
      //Value:    <opacity-value> | inherit
      //Initial:    1
      //Applies to:     'stop' elements
      //Inherited:    no
      //Percentages:    N/A
      //Media:    visual
      //Animatable:    yes
      //Computed value:     Specified value, except inherit
      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, "stop-opacity", "1"), 1, 0, 1);
    }
    AffineTransform tx = toTransform(elem, readAttribute(elem, "gradientTransform", "none"));
    Gradient gradient = factory.createRadialGradient(
        cx, cy, fx, fy, r,
        stopOffsets, stopColors, stopOpacities,
        isRelativeToFigureBounds,
        tx);
    elementObjects.put(elem, gradient);
###
2662, readTextAreaElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 918, 963
3
/**
   * Reads an SVG "textArea" element.
   */
42
  private Figure readTextAreaElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    readShapeAttributes(elem, a);
    readFontAttributes(elem, a);
    readTextAttributes(elem, a);
    readTextFlowAttributes(elem, a);
    double x = toNumber(elem, readAttribute(elem, "x", "0"));
    double y = toNumber(elem, readAttribute(elem, "y", "0"));
// XXX - Handle "auto" width and height
    double w = toWidth(elem, readAttribute(elem, "width", "0"));
    double h = toHeight(elem, readAttribute(elem, "height", "0"));
    DefaultStyledDocument doc = new DefaultStyledDocument();
    try {
      if (elem.getContent() != null) {
        doc.insertString(0, toText(elem, elem.getContent()), null);
      } else {
        for (IXMLElement node : elem.getChildren()) {
          if (node.getName() == null) {
            doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);
          } else if (node.getName().equals("tbreak")) {
            doc.insertString(doc.getLength(), "\n", null);
          } else if (node.getName().equals("tspan")) {
            readTSpanElement((IXMLElement) node, doc);
          } else {
            if (DEBUG) {
              System.out.println("SVGInputFormat unknown  text node " + node.getName());
            }
          }
        }
      }
    } catch (BadLocationException e) {
      InternalError ex = new InternalError(e.getMessage());
      ex.initCause(e);
      throw ex;
    }
    Figure figure = factory.createTextArea(x, y, w, h, doc, a);
    elementObjects.put(elem, figure);
    return figure;
###
2663, readSwitchElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 1041, 1089
7
/**
   * Evaluates an SVG "switch" element.
   *
   */
 --------------
//"http://www.w3.org/Graphics/SVG/feature/1.2/#XlinkAttribute",
 --------------
46
  private Figure readSwitchElement(IXMLElement elem)
      throws IOException {
    for (IXMLElement node : elem.getChildren()) {
      if (node instanceof IXMLElement) {
        IXMLElement child = (IXMLElement) node;
        String[] requiredFeatures = toWSOrCommaSeparatedArray(readAttribute(child, "requiredFeatures", ""));
        String[] requiredExtensions = toWSOrCommaSeparatedArray(readAttribute(child, "requiredExtensions", ""));
        String[] systemLanguage = toWSOrCommaSeparatedArray(readAttribute(child, "systemLanguage", ""));
        String[] requiredFormats = toWSOrCommaSeparatedArray(readAttribute(child, "requiredFormats", ""));
        String[] requiredFonts = toWSOrCommaSeparatedArray(readAttribute(child, "requiredFonts", ""));
        boolean isMatch;
        isMatch = supportedFeatures.containsAll(Arrays.asList(requiredFeatures)) &&
            requiredExtensions.length == 0 &&
            requiredFormats.length == 0 &&
            requiredFonts.length == 0;
        if (isMatch && systemLanguage.length > 0) {
          isMatch = false;
          Locale locale = LocaleUtil.getDefault();
          for (String lng : systemLanguage) {
            int p = lng.indexOf('-');
            if (p == -1) {
              if (locale.getLanguage().equals(lng)) {
                isMatch = true;
                break;
              }
            } else {
              if (locale.getLanguage().equals(lng.substring(0, p)) &&
                  locale.getCountry().toLowerCase().equals(lng.substring(p + 1))) {
                isMatch = true;
                break;
              }
            }
          }
        }
        if (isMatch) {
          Figure figure = readElement(child);
          if (readAttribute(child, "visibility", "visible").equals("visible") &&
              !readAttribute(child, "display", "inline").equals("none")) {
            return figure;
          } else {
            return null;
          }
        }
      }
    }
    return null;
###
2664, readImageElement, SVGInputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java, 667, 751
3
/**
   * Reads an SVG "image" element.
   */
80
  private Figure readImageElement(IXMLElement elem)
      throws IOException {
    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();
    readCoreAttributes(elem, a);
    readTransformAttribute(elem, a);
    readOpacityAttribute(elem, a);
    double x = toNumber(elem, readAttribute(elem, "x", "0"));
    double y = toNumber(elem, readAttribute(elem, "y", "0"));
    double w = toWidth(elem, readAttribute(elem, "width", "0"));
    double h = toHeight(elem, readAttribute(elem, "height", "0"));
    String href = readAttribute(elem, "xlink:href", null);
    if (href == null) {
      href = readAttribute(elem, "href", null);
    }
    byte[] imageData = null;
    if (href != null) {
      if (href.startsWith("data:")) {
        int semicolonPos = href.indexOf(';');
        if (semicolonPos != -1) {
          if (href.indexOf(";base64,") == semicolonPos) {
            imageData = Base64.decode(href.substring(semicolonPos + 8));
          } else {
            throw new IOException("Unsupported encoding in data href in image element:" + href);
          }
        } else {
          throw new IOException("Unsupported data href in image element:" + href);
        }
      } else {
        URL imageUrl = new URL(url, href);
        // Check whether the imageURL is an SVG image.
        // Load it as a group.
        if (imageUrl.getFile().endsWith("svg")) {
          SVGInputFormat svgImage = new SVGInputFormat(factory);
          Drawing svgDrawing = new DefaultDrawing();
          svgImage.read(imageUrl, svgDrawing, true);
          CompositeFigure svgImageGroup = factory.createG(a);
          for (Figure f : svgDrawing.getChildren()) {
            svgImageGroup.add(f);
          }
          svgImageGroup.setBounds(new Point2D.Double(x, y), new Point2D.Double(x + w, y + h));
          return svgImageGroup;
        }
        // Read the image data from the URL into a byte array
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        byte[] buf = new byte[512];
        int len = 0;
        try {
          InputStream in = imageUrl.openStream();
          try {
            while ((len = in.read(buf)) > 0) {
              bout.write(buf, 0, len);
            }
            imageData = bout.toByteArray();
          } finally {
            in.close();
          }
        } catch (FileNotFoundException e) {
          // Use empty image
        }
      }
    }
    // Create a buffered image from the image data
    BufferedImage bufferedImage = null;
    if (imageData != null) {
      try {
        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));
      } catch (IIOException e) {
        System.err.println("SVGInputFormat warning: skipped unsupported image format.");
        e.printStackTrace();
      }
    }
    // Delete the image data in case of failure
    if (bufferedImage == null) {
      imageData = null;
      //if (DEBUG) System.out.println("FAILED:"+imageUrl);
    }
    // Create a figure from the image data and the buffered image.
    Figure figure = factory.createImage(x, y, w, h, imageData, bufferedImage, a);
    elementObjects.put(elem, figure);
    return figure;
###
2666, write, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1311, 1338
3
/**
   * All other write methods delegate their work to here.
   */
22
  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {
    document = new XMLElement("svg", SVG_NAMESPACE);
    document.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
    document.setAttribute("version", "1.2");
    document.setAttribute("baseProfile", "tiny");
    writeViewportAttributes(document, drawing.getAttributes());
    initStorageContext(document);
    defs = new XMLElement("defs");
    document.addChild(defs);
    for (Figure f : figures) {
      writeElement(document, f);
    }
    // Write XML prolog
    PrintWriter writer = new PrintWriter(
        new OutputStreamWriter(out, "UTF-8"));
    writer.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    // Write XML content
    XMLWriter xmlWriter = new XMLWriter(writer);
    xmlWriter.write(document, isPrettyPrint);
    // Flush writer
    writer.flush();
    document.dispose();
###
2667, toNumber, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1169, 1174
3
/**
   * Returns a double array as a number attribute value.
   */
6
  public static String toNumber(double number) {
    String str = (isFloatPrecision) ? Float.toString((float) number) : Double.toString(number);
    if (str.endsWith(".0")) {
      str = str.substring(0, str.length() - 2);
    }
    return str;
###
2668, writeTransformAttribute, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 846, 850
4
/* Writes the transform attribute as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   *
   */
5
  protected void writeTransformAttribute(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    AffineTransform t = TRANSFORM.get(a);
    if (t != null) {
      writeAttribute(elem, "transform", toTransform(t), "none");
###
2669, writeFontAttributes, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 857, 934
3
/* Writes font attributes as listed in
   * http://www.w3.org/TR/SVGMobile12/feature.html#Font
   */
72
  private void writeFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    String value;
    double doubleValue;
    // 'font-family'
    // Value:    [[ <family-name> |
    // <generic-family> ],]* [<family-name> |
    // <generic-family>] | inherit
    // Initial:    depends on user agent
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    writeAttribute(elem, "font-family", FONT_FACE.get(a).getFontName(), "Dialog");
    // 'font-getChildCount'
    // Value:    <absolute-getChildCount> | <relative-getChildCount> |
    // <length> | inherit
    // Initial:    medium
    // Applies to:    text content elements
    // Inherited:    yes, the computed value is inherited
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Absolute length
    writeAttribute(elem, "font-size", FONT_SIZE.get(a), 0d);
    // 'font-style'
    // Value:    normal | italic | oblique | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     Specified value, except inherit
    writeAttribute(elem, "font-style", (FONT_ITALIC.get(a)) ? "italic" : "normal", "normal");

    //'font-variant'
    //Value:    normal | small-caps | inherit
    //Initial:    normal
    //Applies to:    text content elements
    //Inherited:    yes
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    no
    //Computed value:     Specified value, except inherit
    // XXX - Implement me
    writeAttribute(elem, "font-variant", "normal", "normal");
    // 'font-weight'
    // Value:    normal | bold | bolder | lighter | 100 | 200 | 300
    // | 400 | 500 | 600 | 700 | 800 | 900 | inherit
    // Initial:    normal
    // Applies to:    text content elements
    // Inherited:    yes
    // Percentages:    N/A
    // Media:    visual
    // Animatable:    yes
    // Computed value:     one of the legal numeric values, non-numeric
    // values shall be converted to numeric values according to the rules
    // defined below.
    writeAttribute(elem, "font-weight", (FONT_BOLD.get(a)) ? "bold" : "normal", "normal");
    // Note: text-decoration is an SVG 1.1 feature
    //'text-decoration'
    //Value:    none | [ underline || overline || line-through || blink ] | inherit
    //Initial:    none
    //Applies to:    text content elements
    //Inherited:    no (see prose)
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    writeAttribute(elem, "text-decoration", (FONT_UNDERLINE.get(a)) ? "underline" : "none", "none");
###
2671, writeOpacityAttribute, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 823, 839
2
/* Writes the opacity attribute.
   */
17
  protected void writeOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> m)
      throws IOException {
    //'opacity'
    //Value:    <opacity-value> | inherit
    //Initial:    1
    //Applies to:     'image' element
    //Inherited:    no
    //Percentages:    N/A
    //Media:    visual
    //Animatable:    yes
    //Computed value:     Specified value, except inherit
    //<opacity-value>
    //The uniform opacity setting must be applied across an entire object.
    //Any values outside the range 0.0 (fully transparent) to 1.0
    //(fully opaque) shall be clamped to this range.
    //(See Clamping values which are restricted to a particular range.)
    writeAttribute(elem, "opacity", OPACITY.get(m), 1d);
###
2672, writeShapeAttributes, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 581, 818
2
/* Writes shape attributes.
   */
225
  protected void writeShapeAttributes(IXMLElement elem, Map<AttributeKey, Object> m)
      throws IOException {
    Color color;
    String value;
    int intValue;
    //'color'
    // Value:    <color> | inherit
    // Initial:     depends on user agent
    // Applies to:    None. Indirectly affects other properties via currentColor
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified <color> value, except inherit
    //
    // Nothing to do: Attribute 'color' is not needed.
    //'color-rendering'
    // Value:     auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:     auto
    // Applies to:     container elements , graphics elements and 'animateColor'
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    //
    // Nothing to do: Attribute 'color-rendering' is not needed.
    // 'fill'
    // Value:    <paint> | inherit (See Specifying paint)
    // Initial:     black
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     "none", system paint, specified <color> value or absolute IRI
    Gradient gradient = FILL_GRADIENT.get(m);
    if (gradient != null) {
      String id;
      if (gradientToIDMap.containsKey(gradient)) {
        id = gradientToIDMap.get(gradient);
      } else {
        IXMLElement gradientElem;
        if (gradient instanceof LinearGradient) {
          LinearGradient lg = (LinearGradient) gradient;
          gradientElem = createLinearGradient(document,
              lg.getX1(), lg.getY1(),
              lg.getX2(), lg.getY2(),
              lg.getStopOffsets(),
              lg.getStopColors(),
              lg.getStopOpacities(),
              lg.isRelativeToFigureBounds(),
              lg.getTransform());
        } else /*if (gradient instanceof RadialGradient)*/ {
          RadialGradient rg = (RadialGradient) gradient;
          gradientElem = createRadialGradient(document,
              rg.getCX(), rg.getCY(),
              rg.getFX(), rg.getFY(),
              rg.getR(),
              rg.getStopOffsets(),
              rg.getStopColors(),
              rg.getStopOpacities(),
              rg.isRelativeToFigureBounds(),
              rg.getTransform());
        }
        id = getId(gradientElem);
        gradientElem.setAttribute("id", "xml", id);
        defs.addChild(gradientElem);
        gradientToIDMap.put(gradient, id);
      }
      writeAttribute(elem, "fill", "url(#" + id + ")", "#000");
    } else {
      writeAttribute(elem, "fill", toColor(FILL_COLOR.get(m)), "#000");
    }

    //'fill-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "fill-opacity", FILL_OPACITY.get(m), 1d);
    // 'fill-rule'
    // Value:   nonzero | evenodd | inherit
    // Initial:    nonzero
    // Applies to:     shapes and text content elements
    // Inherited:     yes
    // Percentages:     N/A
    // Media:     visual
    // Animatable:     yes
    // Computed value:     Specified value, except inherit
    if (WINDING_RULE.get(m) != WindingRule.NON_ZERO) {
      writeAttribute(elem, "fill-rule", "evenodd", "nonzero");
    }
    //'stroke'
    //Value:    <paint> | inherit (See Specifying paint)
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     "none", system paint, specified <color> value
    // or absolute IRI
    gradient = STROKE_GRADIENT.get(m);
    if (gradient != null) {
      String id;
      if (gradientToIDMap.containsKey(gradient)) {
        id = gradientToIDMap.get(gradient);
      } else {
        IXMLElement gradientElem;
        if (gradient instanceof LinearGradient) {
          LinearGradient lg = (LinearGradient) gradient;
          gradientElem = createLinearGradient(document,
              lg.getX1(), lg.getY1(),
              lg.getX2(), lg.getY2(),
              lg.getStopOffsets(),
              lg.getStopColors(),
              lg.getStopOpacities(),
              lg.isRelativeToFigureBounds(),
              lg.getTransform());
        } else /*if (gradient instanceof RadialGradient)*/ {
          RadialGradient rg = (RadialGradient) gradient;
          gradientElem = createRadialGradient(document,
              rg.getCX(), rg.getCY(),
              rg.getFX(), rg.getFY(),
              rg.getR(),
              rg.getStopOffsets(),
              rg.getStopColors(),
              rg.getStopOpacities(),
              rg.isRelativeToFigureBounds(),
              rg.getTransform());
        }
        id = getId(gradientElem);
        gradientElem.setAttribute("id", "xml", id);
        defs.addChild(gradientElem);
        gradientToIDMap.put(gradient, id);
      }
      writeAttribute(elem, "stroke", "url(#" + id + ")", "none");
    } else {
      writeAttribute(elem, "stroke", toColor(STROKE_COLOR.get(m)), "none");
    }
    //'stroke-dasharray'
    //Value:     none | <dasharray> | inherit
    //Initial:     none
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes (non-additive)
    //Computed value:     Specified value, except inherit
    double[] dashes = STROKE_DASHES.get(m);
    if (dashes != null) {
      StringBuilder buf = new StringBuilder();
      for (int i = 0; i < dashes.length; i++) {
        if (i != 0) {
          buf.append(',');
        }
        buf.append(toNumber(dashes[i]));
      }
      writeAttribute(elem, "stroke-dasharray", buf.toString(), null);
    }
    //'stroke-dashoffset'
    //Value:    <length> | inherit
    //Initial:     0
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-dashoffset", STROKE_DASH_PHASE.get(m), 0d);
    //'stroke-linecap'
    //Value:     butt | round | square | inherit
    //Initial:     butt
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-linecap", strokeLinecapMap.get(STROKE_CAP.get(m)), "butt");
    //'stroke-linejoin'
    //Value:     miter | round | bevel | inherit
    //Initial:     miter
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-linejoin", strokeLinejoinMap.get(STROKE_JOIN.get(m)), "miter");
    //'stroke-miterlimit'
    //Value:     <miterlimit> | inherit
    //Initial:     4
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-miterlimit", STROKE_MITER_LIMIT.get(m), 4d);
    //'stroke-opacity'
    //Value:     <opacity-value> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-opacity", STROKE_OPACITY.get(m), 1d);
    //'stroke-width'
    //Value:    <length> | inherit
    //Initial:     1
    //Applies to:     shapes and text content elements
    //Inherited:     yes
    //Percentages:     N/A
    //Media:     visual
    //Animatable:     yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "stroke-width", STROKE_WIDTH.get(m), 1d);
###
2673, writeViewportAttributes, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 939, 970
2
/* Writes viewport attributes.
   */
30
  private void writeViewportAttributes(IXMLElement elem, Map<AttributeKey, Object> a)
      throws IOException {
    Object value;
    Double doubleValue;
    if (VIEWPORT_WIDTH.get(a) != null && VIEWPORT_HEIGHT.get(a) != null) {
      // width of the viewport
      writeAttribute(elem, "width", toNumber(VIEWPORT_WIDTH.get(a)), null);
      // height of the viewport
      writeAttribute(elem, "height", toNumber(VIEWPORT_HEIGHT.get(a)), null);
    }
    //'viewport-fill'
    //Value:   "none" | <color> | inherit
    //Initial:   none
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     "none" or specified <color> value, except inherit
    writeAttribute(elem, "viewport-fill", toColor(VIEWPORT_FILL.get(a)), "none");
    //'viewport-fill-opacity'
    //Value:  <opacity-value> | inherit
    //Initial:   1.0
    //Applies to:  viewport-creating elements
    //Inherited:   no
    //Percentages:   N/A
    //Media:   visual
    //Animatable:   yes
    //Computed value:     Specified value, except inherit
    writeAttribute(elem, "viewport-fill-opacity", VIEWPORT_FILL_OPACITY.get(a), 1.0);
###
2674, toTransform, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1197, 1270
3
/* Converts an AffineTransform into an SVG transform attribute value as specified in
   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute
   */
73
  public static String toTransform(AffineTransform t) throws IOException {
    StringBuilder buf = new StringBuilder();
    switch (t.getType()) {
      case AffineTransform.TYPE_IDENTITY:
        buf.append("none");
        break;
      case AffineTransform.TYPE_TRANSLATION:
        // translate(<tx> [<ty>]), specifies a translation by tx and ty.
        // If <ty> is not provided, it is assumed to be zero.
        buf.append("translate(");
        buf.append(toNumber(t.getTranslateX()));
        if (t.getTranslateY() != 0d) {
          buf.append(' ');
          buf.append(toNumber(t.getTranslateY()));
        }
        buf.append(')');
        break;
      /*
      case AffineTransform.TYPE_GENERAL_ROTATION :
      case AffineTransform.TYPE_QUADRANT_ROTATION :
      case AffineTransform.TYPE_MASK_ROTATION :
      // rotate(<rotate-angle> [<cx> <cy>]), specifies a rotation by
      // <rotate-angle> degrees about a given point.
      // If optional parameters <cx> and <cy> are not supplied, the
      // rotate is about the origin of the current user coordinate
      // system. The operation corresponds to the matrix
      // [cos(a) sin(a) -sin(a) cos(a) 0 0].
      // If optional parameters <cx> and <cy> are supplied, the rotate
      // is about the point (<cx>, <cy>). The operation represents the
      // equivalent of the following specification:
      // translate(<cx>, <cy>) rotate(<rotate-angle>)
      // translate(-<cx>, -<cy>).
      buf.append("rotate(");
      buf.append(toNumber(t.getScaleX()));
      buf.append(')');
      break;*/
      case AffineTransform.TYPE_UNIFORM_SCALE:
        // scale(<sx> [<sy>]), specifies a scale operation by sx
        // and sy. If <sy> is not provided, it is assumed to be equal
        // to <sx>.
        buf.append("scale(");
        buf.append(toNumber(t.getScaleX()));
        buf.append(')');
        break;
      case AffineTransform.TYPE_GENERAL_SCALE:
      case AffineTransform.TYPE_MASK_SCALE:
        // scale(<sx> [<sy>]), specifies a scale operation by sx
        // and sy. If <sy> is not provided, it is assumed to be equal
        // to <sx>.
        buf.append("scale(");
        buf.append(toNumber(t.getScaleX()));
        buf.append(' ');
        buf.append(toNumber(t.getScaleY()));
        buf.append(')');
        break;
      default:
        // matrix(<a> <b> <c> <d> <e> <f>), specifies a transformation
        // in the form of a transformation matrix of six values.
        // matrix(a,b,c,d,e,f) is equivalent to applying the
        // transformation matrix [a b c d e f].
        buf.append("matrix(");
        double[] matrix = new double[6];
        t.getMatrix(matrix);
        for (int i = 0; i < matrix.length; i++) {
          if (i != 0) {
            buf.append(' ');
          }
          buf.append(toNumber(matrix[i]));
        }
        buf.append(')');
        break;
    }
    return buf.toString();
###
2675, toPath, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 997, 1163
3
/** Returns a value as a SVG Path attribute.
   * as specified in http://www.w3.org/TR/SVGMobile12/paths.html#PathDataBNF
   */
162
  public static String toPath(BezierPath[] paths) {
    StringBuilder buf = new StringBuilder();
    for (int j = 0; j < paths.length; j++) {
      BezierPath path = paths[j];
      if (path.size() == 0) {
        // nothing to do
      } else if (path.size() == 1) {
        BezierPath.Node current = path.get(0);
        buf.append("M ");
        buf.append(toNumber(current.x[0]));
        buf.append(' ');
        buf.append(toNumber(current.y[0]));
        //buf.append(" L ");
        buf.append(toNumber(current.x[0]));
        buf.append(' ');
        buf.append(toNumber(current.y[0] + 1));
      } else {
        BezierPath.Node previous;
        BezierPath.Node current;
        previous = current = path.get(0);
        buf.append("M ");
        buf.append(toNumber(current.x[0]));
        buf.append(' ');
        buf.append(toNumber(current.y[0]));
        char nextCommand = 'L';
        for (int i = 1, n = path.size(); i < n; i++) {
          previous = current;
          current = path.get(i);
          if ((previous.mask & BezierPath.C2_MASK) == 0) {
            if ((current.mask & BezierPath.C1_MASK) == 0) {
              if (nextCommand != 'L') {
                buf.append(" L ");
                nextCommand = 'L';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            } else {
              if (nextCommand != 'Q') {
                buf.append(" Q ");
                nextCommand = 'Q';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(current.x[1]));
              buf.append(' ');
              buf.append(toNumber(current.y[1]));
              buf.append(' ');
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            }
          } else {
            if ((current.mask & BezierPath.C1_MASK) == 0) {
              if (nextCommand != 'Q') {
                buf.append(" Q ");
                nextCommand = 'Q';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(previous.x[2]));
              buf.append(' ');
              buf.append(toNumber(previous.y[2]));
              buf.append(' ');
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            } else {
              if (nextCommand != 'C') {
                buf.append(" C ");
                nextCommand = 'C';
              } else {
                buf.append(' ');
              }
              buf.append(toNumber(previous.x[2]));
              buf.append(' ');
              buf.append(toNumber(previous.y[2]));
              buf.append(' ');
              buf.append(toNumber(current.x[1]));
              buf.append(' ');
              buf.append(toNumber(current.y[1]));
              buf.append(' ');
              buf.append(toNumber(current.x[0]));
              buf.append(' ');
              buf.append(toNumber(current.y[0]));
            }
          }
        }
        if (path.isClosed()) {
          if (path.size() > 1) {
            previous = path.get(path.size() - 1);
            current = path.get(0);
            if ((previous.mask & BezierPath.C2_MASK) == 0) {
              if ((current.mask & BezierPath.C1_MASK) == 0) {
                if (nextCommand != 'L') {
                  buf.append(" L ");
                  nextCommand = 'L';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              } else {
                if (nextCommand != 'Q') {
                  buf.append(" Q ");
                  nextCommand = 'Q';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(current.x[1]));
                buf.append(' ');
                buf.append(toNumber(current.y[1]));
                buf.append(' ');
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              }
            } else {
              if ((current.mask & BezierPath.C1_MASK) == 0) {
                if (nextCommand != 'Q') {
                  buf.append(" Q ");
                  nextCommand = 'Q';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(previous.x[2]));
                buf.append(' ');
                buf.append(toNumber(previous.y[2]));
                buf.append(' ');
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              } else {
                if (nextCommand != 'C') {
                  buf.append(" C ");
                  nextCommand = 'C';
                } else {
                  buf.append(' ');
                }
                buf.append(toNumber(previous.x[2]));
                buf.append(' ');
                buf.append(toNumber(previous.y[2]));
                buf.append(' ');
                buf.append(toNumber(current.x[1]));
                buf.append(' ');
                buf.append(toNumber(current.y[1]));
                buf.append(' ');
                buf.append(toNumber(current.x[0]));
                buf.append(' ');
                buf.append(toNumber(current.y[0]));
              }
            }
          }
          buf.append(" Z");
          nextCommand = '\0';
        }
      }
    }
    return buf.toString();
###
2676, toPoints, SVGOutputFormat, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java, 1181, 1191
4
/**
   * Returns a Point2D.Double array as a Points attribute value.
   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF
   */
11
  public static String toPoints(Point2D.Double[] points) throws IOException {
    StringBuilder buf = new StringBuilder();
    for (int i = 0; i < points.length; i++) {
      if (i != 0) {
        buf.append(", ");
      }
      buf.append(toNumber(points[i].x));
      buf.append(',');
      buf.append(toNumber(points[i].y));
    }
    return buf.toString();
###
2677, ViewToolBar, ViewToolBar, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBar.java, 45, 48
1
/** Creates new instance. */
4
  public ViewToolBar() {
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    setName(labels.getString(getID() + ".toolbar"));
    setDisclosureStateCount(3);
###
2678, getTransferData, XMLTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java, 57, 61
11
/**
   * Returns an object which represents the data to be transferred.  The class
   * of the object returned is defined by the representation class of the flavor.
   *
   * @param flavor the requested flavor for the data
   * @see DataFlavor#getRepresentationClass
   * @exception IOException        if the data is no longer available
   *       in the requested flavor.
   * @exception UnsupportedFlavorException if the requested data flavor is
   *       not supported.
   */
5
  public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {
    if (this.flavor.equals(flavor)) {
      return new ByteArrayInputStream(data);
    } else {
      throw new UnsupportedFlavorException(flavor);
###
2679, getTransferDataFlavors, XMLTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java, 71, 72
6
/**
   * Returns an array of DataFlavor objects indicating the flavors the data
   * can be provided in.  The array should be ordered according to preference
   * for providing the data (from most richly descriptive to least descriptive).
   * @return an array of data flavors in which this data can be transferred
   */
2
  public DataFlavor[] getTransferDataFlavors() {
    return new DataFlavor[] {flavor};
###
2680, XMLTransferable, XMLTransferable, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java, 31, 33
1
/** Creates new XMLTransferable */
3
  public XMLTransferable(byte[] data, String mimeType, String humanPresentableName) {
    this.data = data;
    this.flavor = new DataFlavor(mimeType, humanPresentableName);
###
2683, PathTool, PathTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/PathTool.java, 47, 48
1
/** Creates a new instance. */
2
  public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {
    this(pathPrototype, bezierPrototype, null);
###
2684, createDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 268, 277
3
/**
   * Creates the drawing.
   */
10
  protected Drawing createDrawing() {
    DefaultDrawing drawing = new DefaultDrawing();
    drawing.addInputFormat(new SVGZInputFormat());
    drawing.addInputFormat(new ImageInputFormat(new SVGImageFigure()));
    drawing.addOutputFormat(new SVGOutputFormat());
    drawing.addOutputFormat(new SVGZOutputFormat());
    drawing.addOutputFormat(new ImageOutputFormat());
    drawing.addOutputFormat(new ImageOutputFormat("JPG", "Joint Photographics Experts Group (JPEG)", "jpg", BufferedImage.TYPE_INT_RGB));
    drawing.addOutputFormat(new ImageOutputFormat("BMP", "Windows Bitmap (BMP)", "bmp", BufferedImage.TYPE_BYTE_INDEXED));
    return drawing;
###
2685, init, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 104, 206
7
/**
   * Displays a progress indicator and then invokes <code>loadDrawing</code>
   * on a worker thread. Displays the drawing panel when done successfully.
   * Displays an error message when done unsuccessfully.
   *
   * @see #loadDrawing
   */
92
  @Override
  public final void init() {
    // set the language of the applet
    if (getParameter("Locale") != null) {
      Locale.setDefault(new Locale(getParameter("Locale")));
    }

    final ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    // Set look and feel
    // -----------------
    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Throwable e) {
      // Do nothing.
      // If we can't set the desired look and feel, UIManager does
      // automaticaly the right thing for us.
    }
    // Set our own popup factory, because the one that comes with Mac OS X
    // creates translucent popups which is not useful for color selection
    // using pop menus.
    try {
      PopupFactory.setSharedInstance(new PopupFactory());
    } catch (Throwable e) {
      // If we can't set the popup factory, we have to use what is there.
    }
    // Display a progress indicator while we are loading the drawing
    // ----------------------------------------------------------
    Container c = getContentPane();
    final ProgressIndicator progress = new ProgressIndicator(
        getName(), labels.getString("progressInitializing"));
    c.add(progress);
    progress.revalidate();
    // Load the drawing using a worker thread
    // --------------------------------------
    new Worker() {
      protected Object construct() throws Exception {
        Thread t = new Thread() {
          @Override
          public void run() {
            drawingComponent = createDrawingComponent();
          }
        };
        t.start();
        progress.setNote(labels.getString("progressLoading"));
        Object drawing = loadDrawing(progress);
        progress.setNote(labels.getString("progressOpeningEditor"));
        progress.setIndeterminate(true);
        t.join();
        return drawing;
      }
      protected void done(Object result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        c.add(drawingComponent.getComponent());
        initComponents();
        if (result != null) {
          if (result instanceof Drawing) {
            setDrawing((Drawing) result);
          } else if (result instanceof Throwable) {
            setDrawing(createDrawing());
            getDrawing().add(new SVGTextFigure(result.toString()));
            ((Throwable) result).printStackTrace();
          }
        }
        drawingComponent.revalidate();
      }
      protected void failed(Throwable result) {
        Container c = getContentPane();
        c.setLayout(new BorderLayout());
        c.removeAll();
        Throwable error = (Throwable) result;
        error.printStackTrace();
        String message = (error.getMessage() == null) ? error.toString() : error.getMessage();
        MessagePanel mp = new MessagePanel(
            UIManager.getIcon("OptionPane.errorIcon"),
            labels.getFormatted("messageLoadFailed", htmlencode(getParameter("DrawingURL")), htmlencode(message)));
        c.add(mp);
        mp.addActionListener(new ActionListener() {
          public void actionPerformed(ActionEvent evt) {
            if (evt.getActionCommand().equals("close")) {
              close();
            }
          }
        });
        mp.revalidate();
      }
      protected void finished() {
        long end = System.currentTimeMillis();
        System.out.println("AbstractDrawingApplet startup latency:" + (end - start));
      }
    }.start();
###
2686, getParameter, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 75, 80
4
/**
   * Same as <code>Applet.getParameter()</code> but doesn't throw a
   * NullPointerException when used without an Applet context.
   */
6
  @Override
  public String getParameter(String name) {
    try {
      return super.getParameter(name);
    } catch (NullPointerException e) {
      return null;
###
2687, htmlencode, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 402, 432
5
/**
   * Escapes all '<', '>' and '&' characters in a string.
   * @param str A String.
   * @return HTMlEncoded String.
   */
24
  private static String htmlencode(String str) {
    if (str == null) {
      return "";
    } else {
      StringBuilder buf = new StringBuilder();
      for (char ch : str.toCharArray()) {
        switch (ch) {
          case '<':
            buf.append("&lt;");
            break;
          case '>':
            buf.append("&gt;");
            break;
          case '&':
            buf.append("&amp;");
            break;
          default:
            buf.append(ch);
            break;
        }


      }
      return buf.toString();
###
2688, setDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 212, 213
3
/**
   * Sets the drawing on the drawing panel.
   */
2
  private void setDrawing(Drawing d) {
    drawingComponent.setDrawing(d);
###
2689, getParameter, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 88, 93
4
/**
   * Same as <code>Applet.getParameter()</code> but doesn't throw a
   * NullPointerException when used without an Applet context.
   */
6
  public String getParameter(String name, String defaultValue) {
    try {
      String value = super.getParameter(name);
      return (value == null) ? defaultValue : value;
    } catch (NullPointerException e) {
      return defaultValue;
###
2690, getDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 219, 220
3
/**
   * Gets the drawing from the drawing panel.
   */
2
  private Drawing getDrawing() {
    return drawingComponent.getDrawing();
###
2691, getAppletInfo, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 253, 259
3
/**
   * Returns information about the applet.
   */
7
  @Override
  public String getAppletInfo() {
    return getName() +
        "\nVersion " + getVersion() +
        "\n\nCopyright 1996-2010 (c) by the original authors of JHotDraw and all its contributors" +
        "\nThis software is licensed under LGPL or" +
        "\nCreative Commons 2.5 BY";
###
2692, loadDrawing, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 310, 370
8
/**
   * Loads the drawing.
   * By convention this method is invoked on a worker thread.
   *
   * @param progress A ProgressIndicator to inform the user about the progress
   * of the operation.
   * @return The Drawing that was loaded.
   */
58
  protected Drawing loadDrawing(ProgressIndicator progress) throws IOException {
    Drawing drawing = createDrawing();
    if (getParameter("datafile") != null) {
      ByteArrayOutputStream buf = new ByteArrayOutputStream();
      URL url = new URL(getDocumentBase(), getParameter("datafile"));
      URLConnection uc = url.openConnection();
      // Disable caching. This ensures that we always request the
      // newest version of the drawing from the server.
      // (Note: The server still needs to set the proper HTTP caching
      // properties to prevent proxies from caching the drawing).
      if (uc instanceof HttpURLConnection) {
        ((HttpURLConnection) uc).setUseCaches(false);
      }
      // Read the data into a buffer
      int contentLength = uc.getContentLength();
      InputStream in = uc.getInputStream();
      try {
        if (contentLength != -1) {
          in = new BoundedRangeInputStream(in);
          ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);
          progress.setProgressModel((BoundedRangeModel) in);
          progress.setIndeterminate(false);
        }
        BufferedInputStream bin = new BufferedInputStream(in);
        bin.mark(512);
        // Read the data using all supported input formats
        // until we succeed
        final ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
        IOException formatException = null;
        for (InputFormat format : drawing.getInputFormats()) {
          try {
            bin.reset();
          } catch (IOException e) {
            uc = url.openConnection();
            in = uc.getInputStream();
            in = new BoundedRangeInputStream(in);
            ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);
            progress.setProgressModel((BoundedRangeModel) in);
            bin = new BufferedInputStream(in);
            bin.mark(512);
          }
          try {
            bin.reset();
            format.read(bin, drawing, true);
            formatException = null;
            break;
          } catch (IOException e) {
            formatException = e;
          }
        }
        if (formatException != null) {
          throw formatException;
        }
      } finally {
        in.close();
      }
    }
    return drawing;
###
2693, createDrawingComponent, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 283, 288
3
/**
   * Creates the drawing component.
   */
5
  protected SVGDrawingPanel createDrawingComponent() {
    SVGDrawingPanel p = new SVGDrawingPanel();
    DefaultDrawingEditor editor = new DefaultDrawingEditor();
    p.setEditor(new DefaultDrawingEditor());
    return p;
###
2694, getVersion, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 226, 247
3
/**
   * Gets the version of the applet.
   */
22
  public String getVersion() {
    if (version == null) {
      BufferedReader r = null;
      try {
        InputStream resource = SVGApplet.class.getResourceAsStream("version.txt");
        r = new BufferedReader(new InputStreamReader(resource, "UTF-8"));
        version = r.readLine();
      } catch (IOException e) {
        version = "unknown";
      } catch (NullPointerException e) {
        version = "unknown";
      } finally {
        if (r != null) {
          try {
            r.close();
          } catch (IOException e) {
            // suppress
          }
        }
      }
    }
    return version;
###
2695, close, SVGApplet, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java, 377, 391
4
/**
   * Closes the applet. This method can be implemented by invoking
   * <code>getAppletContext().showDocument(...)</code>.
   */
14
  protected void close() {
    AppletContext appletContext;
    try {
      appletContext = getAppletContext();
    } catch (Throwable e) {
      appletContext = null;
    }
    if (appletContext == null) {
      System.exit(0);
    } else {
      try {
        appletContext.showDocument(new URL(getDocumentBase(), getParameter("PageURL")));
      } catch (MalformedURLException ex) {
        ex.printStackTrace();
###
2697, SVGCreateFromFileTool, SVGCreateFromFileTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGCreateFromFileTool.java, 62, 65
1
/** Creates a new instance. */
4
  public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype, Map<AttributeKey, Object> attributes) {
    super(imagePrototype, attributes);
    this.groupPrototype = groupPrototype;
    this.imagePrototype = imagePrototype;
###
2698, SVGCreateFromFileTool, SVGCreateFromFileTool, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGCreateFromFileTool.java, 55, 58
1
/** Creates a new instance. */
4
  public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype) {
    super(imagePrototype);
    this.groupPrototype = groupPrototype;
    this.imagePrototype = imagePrototype;
###
2699, SVGApplicationModel, SVGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplicationModel.java, 56, 57
1
/** Creates a new instance. */
2
  public SVGApplicationModel() {
    gridConstrainer = new GridConstrainer(12, 12);
###
2700, createToolBars, SVGApplicationModel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplicationModel.java, 175, 178
7
/**
   * Overriden to create no toolbars.
   * 
   * @param app
   * @param p
   * @return An empty list.
   */
4
  @Override
  public List<JToolBar> createToolBars(Application app, View p) {
    LinkedList<JToolBar> list = new LinkedList<JToolBar>();
    return list;
###
2702, main, Main, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/Main.java, 28, 49
1
/** Creates a new instance. */
21
  public static void main(String[] args) {
    // Debug resource bundle
    ResourceBundleUtil.setVerbose(true);
    Application app;
    String os = System.getProperty("os.name").toLowerCase();
    if (os.startsWith("mac")) {
      app = new OSXApplication();
    } else if (os.startsWith("win")) {
      //  app = new DefaultMDIApplication();
      app = new SDIApplication();
    } else {
      app = new SDIApplication();
    }
    SVGApplicationModel model = new SVGApplicationModel();
    model.setName("JHotDraw SVG");
    model.setVersion(Main.class.getPackage().getImplementationVersion());
    model.setCopyright("Copyright 2006-2010 (c) by the authors of JHotDraw.\n" +
        "This software is licensed under LGPL and Creative Commons 3.0 Attribution.");
    model.setViewClassName("org.jhotdraw.samples.svg.SVGView");
    app.setModel(model);
    app.launch(args);
###
2703, ConvexHullOutlineHandle, ConvexHullOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java, 55, 88
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   * 
   * @param owner
   */
34
  public ConvexHullOutlineHandle(SVGPathFigure owner, boolean isTransformHandle, boolean isHoverHandle) {
    super(owner);
    if (isTransformHandle) {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;
    } else {
      if (isHoverHandle) {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;
      } else {
        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;
        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;
        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;
        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;
      }
      stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;
      strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;
      stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;
      strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;
###
2704, ConvexHullOutlineHandle, ConvexHullOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java, 46, 47
5
/**
   * Creates a bounds outline handle for resizing a component.
   * 
   * @param owner
   */
2
  public ConvexHullOutlineHandle(SVGPathFigure owner) {
    this(owner, false, false);
###
2705, ConvexHullOutlineHandle, ConvexHullOutlineHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java, 97, 111
5
/**
   * Creates a bounds outline handle for resizing or transforming a component.
   *
   * @param owner
   */
15
  public ConvexHullOutlineHandle(SVGPathFigure owner, //
      AttributeKey<Stroke> stroke1Enabled, AttributeKey<Color> strokeColor1Enabled,//
      AttributeKey<Stroke> stroke2Enabled, AttributeKey<Color> strokeColor2Enabled,//
      AttributeKey<Stroke> stroke1Disabled, AttributeKey<Color> strokeColor1Disabled,//
      AttributeKey<Stroke> stroke2Disabled, AttributeKey<Color> strokeColor2Disabled
      ) {
    super(owner);
    this.stroke1Enabled = stroke1Enabled;
    this.strokeColor1Enabled = strokeColor1Enabled;
    this.stroke2Enabled = stroke2Enabled;
    this.strokeColor2Enabled = strokeColor2Enabled;
    this.stroke1Disabled = stroke1Disabled;
    this.strokeColor1Disabled = strokeColor1Disabled;
    this.stroke2Disabled = stroke2Disabled;
    this.strokeColor2Disabled = strokeColor2Disabled;
###
2706, LinkHandle, LinkHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/LinkHandle.java, 34, 35
1
/** Creates a new instance. */
2
  public LinkHandle(Figure owner) {
    super(owner);
###
2707, draw, LinkHandle, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/LinkHandle.java, 46, 56
3
/**
   * Draws this handle.
   */
11
  @Override public void draw(Graphics2D g) {
    Figure o = getOwner();
    if (o.get(LINK)!=null&&o.get(LINK).trim().length()>0) {
      g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));
      Rectangle r = basicGetBounds();
      g.drawLine(r.x+(r.width/2)-1, r.y, r.x, r.y);
      g.drawLine(r.x, r.y, r.x, r.y+r.height-1);
      g.drawLine(r.x, r.y+r.height-1, r.x+(r.width/2)-1, r.y+r.height-1);
      g.drawLine(r.x+(r.width/3), r.y+r.height/2, r.x+r.width-1, r.y+r.height/2);
      g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.25));
      g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.75));
###
2709, getDefaultEventIndex, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 150, 151
7
/**
   * A bean may have a "default" event that is the event that will
   * mostly commonly be used by human's when using the bean.
   * @return Index of default event in the EventSetDescriptor array
   *    returned by getEventSetDescriptors.
   * <P>  Returns -1 if there is no default event.
   */
2
  public int getDefaultEventIndex() {
    return defaultEventIndex;
###
2712, getDefaultPropertyIndex, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 139, 140
8
/**
   * A bean may have a "default" property that is the property that will
   * mostly commonly be initially chosen for update by human's who are
   * customizing the bean.
   * @return  Index of default property in the PropertyDescriptor array
   *     returned by getPropertyDescriptors.
   * <P>  Returns -1 if there is no default property.
   */
2
  public int getDefaultPropertyIndex() {
    return defaultPropertyIndex;
###
2713, getEventSetDescriptors, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 116, 117
7
/**
   * Gets the bean's <code>EventSetDescriptor</code>s.
   *
   * @return  An array of EventSetDescriptors describing the kinds of
   * events fired by this bean.  May return null if the information
   * should be obtained by automatic analysis.
   */
2
  public EventSetDescriptor[] getEventSetDescriptors() {
    return getEdescriptor();
###
2714, getPropertyDescriptors, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 105, 106
12
/**
   * Gets the bean's <code>PropertyDescriptor</code>s.
   *
   * @return An array of PropertyDescriptors describing the editable
   * properties supported by this bean.  May return null if the
   * information should be obtained by automatic analysis.
   * <p>
   * If a property is indexed, then its entry in the result array will
   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.
   * A client of getPropertyDescriptors can use "instanceof" to check
   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.
   */
2
  public PropertyDescriptor[] getPropertyDescriptors() {
    return getPdescriptor();
###
2715, getBeanDescriptor, SVGDrawingPanelBeanInfo, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java, 89, 90
7
/**
   * Gets the bean's <code>BeanDescriptor</code>s.
   *
   * @return BeanDescriptor describing the editable
   * properties of this bean.  May return null if the
   * information should be obtained by automatic analysis.
   */
2
  public BeanDescriptor getBeanDescriptor() {
    return getBdescriptor();
###
2717, ViewSourceAction, ViewSourceAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/action/ViewSourceAction.java, 49, 52
1
/** Creates a new instance. */
4
  public ViewSourceAction(Application app, View view) {
    super(app, view);
    ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    labels.configureAction(this, ID);
###
2718, read, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 329, 360
8
/**
   * Reads a drawing from the specified file into the SVGDrawingPanel using
   * the specified input format.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is read.
   */
29
  public void read(File f, InputFormat format) throws IOException {
    if (format == null) {
      read(f);
      return;
    }
    // Create a new drawing object
    Drawing newDrawing = createDrawing();
    if (newDrawing.getInputFormats().size() == 0) {
      throw new InternalError("Drawing object has no input formats.");
    }
    format.read(f, newDrawing);
    final Drawing loadedDrawing = newDrawing;
    Runnable r = new Runnable() {
      public void run() {
        // Set the drawing on the Event Dispatcher Thread
        setDrawing(loadedDrawing);
      }
    };
    if (SwingUtilities.isEventDispatchThread()) {
      r.run();
    } else {
      try {
        SwingUtilities.invokeAndWait(r);
      } catch (InterruptedException ex) {
        // suppress silently
      } catch (InvocationTargetException ex) {
        InternalError ie = new InternalError("Error setting drawing.");
        ie.initCause(ex);
        throw ie;
###
2719, write, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 372, 415
7
/**
   * Writes the drawing from the SVGDrawingPanel into a file.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is written.
   */
38
  public void write(File f) throws IOException {
    // Defensively clone the drawing object, so that we are not
    // affected by changes of the drawing while we write it into the file.
    final Drawing[] helper = new Drawing[1];
    Runnable r = new Runnable() {
      public void run() {
        helper[0] = (Drawing) getDrawing().clone();
      }
    };
    if (SwingUtilities.isEventDispatchThread()) {
      r.run();
    } else {
      try {
        SwingUtilities.invokeAndWait(r);
      } catch (InterruptedException ex) {
        // suppress silently
      } catch (InvocationTargetException ex) {
        InternalError ie = new InternalError("Error getting drawing.");
        ie.initCause(ex);
        throw ie;
      }
    }
    Drawing saveDrawing = helper[0];
    if (saveDrawing.getOutputFormats().size() == 0) {
      throw new InternalError("Drawing object has no output formats.");
    }
    // Try out all output formats until we find one which accepts the
    // filename entered by the user.
    for (OutputFormat format : saveDrawing.getOutputFormats()) {
      if (format.getFileFilter().accept(f)) {
        format.write(f, saveDrawing);
        // We get here if writing was successful.
        // We can return since we are done.
        return;
      }

    }
    throw new IOException("No output format for " + f.getName());
###
2720, read, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 272, 318
7
/**
   * Reads a drawing from the specified file into the SVGDrawingPanel.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is read.
   */
45
  public void read(File f) throws IOException {
    // Create a new drawing object
    Drawing newDrawing = createDrawing();
    if (newDrawing.getInputFormats().size() == 0) {
      throw new InternalError("Drawing object has no input formats.");
    }
    // Try out all input formats until we succeed
    IOException firstIOException = null;
    for (InputFormat format : newDrawing.getInputFormats()) {
      try {
        format.read(f, newDrawing);
        final Drawing loadedDrawing = newDrawing;
        Runnable r = new Runnable() {
          public void run() {
            // Set the drawing on the Event Dispatcher Thread
            setDrawing(loadedDrawing);
          }
        };
        if (SwingUtilities.isEventDispatchThread()) {
          r.run();
        } else {
          try {
            SwingUtilities.invokeAndWait(r);
          } catch (InterruptedException ex) {
            // suppress silently
          } catch (InvocationTargetException ex) {
            InternalError ie = new InternalError("Error setting drawing.");
            ie.initCause(ex);
            throw ie;
          }
        }
        // We get here if reading was successful.
        // We can return since we are done.
        return;
        //
      } catch (IOException e) {
        // We get here if reading failed.
        // We only preserve the exception of the first input format,
        // because that's the one which is best suited for this drawing.
        if (firstIOException == null) {
          firstIOException = e;
        }
      }
    }
    throw firstIOException;
###
2721, write, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 426, 458
8
/**
   * Writes the drawing from the SVGDrawingPanel into a file using the
   * specified output format.
   * <p>
   * This method should be called from a worker thread.
   * Calling it from the Event Dispatcher Thread will block the user
   * interface, until the drawing is written.
   */
29
  public void write(File f, OutputFormat format) throws IOException {
    if (format == null) {
      write(f);
      return;
    }
    // Defensively clone the drawing object, so that we are not
    // affected by changes of the drawing while we write it into the file.
    final Drawing[] helper = new Drawing[1];
    Runnable r = new Runnable() {
      public void run() {
        helper[0] = (Drawing) getDrawing().clone();
      }
    };
    if (SwingUtilities.isEventDispatchThread()) {
      r.run();
    } else {
      try {
        SwingUtilities.invokeAndWait(r);
      } catch (InterruptedException ex) {
        // suppress silently
      } catch (InvocationTargetException ex) {
        InternalError ie = new InternalError("Error getting drawing.");
        ie.initCause(ex);
        throw ie;
      }
    }
    // Write drawing to file
    Drawing saveDrawing = helper[0];
    format.write(f, saveDrawing);
###
2723, createDrawing, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 193, 211
4
/**
   * Creates a new Drawing object which can be used with this
   * {@code SVGDrawingPanel}.
   */
18
  public Drawing createDrawing() {
    Drawing drawing = new QuadTreeDrawing();
    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();
    inputFormats.add(new SVGZInputFormat());
    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), "PNG", "Portable Network Graphics (PNG)", "png", "image/png"));
    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), "JPG", "Joint Photographics Experts Group (JPEG)", "jpg","image/jpg"));
    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), "GIF", "Graphics Interchange Format (GIF)", "gif", "image/gif"));
    inputFormats.add(new TextInputFormat(new SVGTextFigure()));
    drawing.setInputFormats(inputFormats);
    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();
    outputFormats.add(new SVGOutputFormat());
    outputFormats.add(new SVGZOutputFormat());
    outputFormats.add(new ImageOutputFormat());
    outputFormats.add(new ImageOutputFormat("JPG", "Joint Photographics Experts Group (JPEG)", "jpg", BufferedImage.TYPE_INT_RGB));
    outputFormats.add(new ImageOutputFormat("BMP", "Windows Bitmap (BMP)", "bmp", BufferedImage.TYPE_BYTE_INDEXED));
    outputFormats.add(new ImageMapOutputFormat());
    drawing.setOutputFormats(outputFormats);
    return drawing;
###
2724, initComponents, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 467, 529
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
52
  private void initComponents() {
    java.awt.GridBagConstraints gridBagConstraints;
    toolButtonGroup = new javax.swing.ButtonGroup();
    scrollPane = new javax.swing.JScrollPane();
    view = new org.jhotdraw.draw.DefaultDrawingView();
    toolsPanel = new javax.swing.JPanel();
    toolsScrollPane = new javax.swing.JScrollPane();
    toolsPane = new javax.swing.JPanel();
    creationToolBar = new org.jhotdraw.samples.svg.gui.ToolsToolBar();
    actionToolBar = new org.jhotdraw.samples.svg.gui.ActionsToolBar();
    fillToolBar = new org.jhotdraw.samples.svg.gui.FillToolBar();
    strokeToolBar = new org.jhotdraw.samples.svg.gui.StrokeToolBar();
    fontToolBar = new org.jhotdraw.samples.svg.gui.FontToolBar();
    arrangeToolBar = new org.jhotdraw.samples.svg.gui.ArrangeToolBar();
    alignToolBar = new org.jhotdraw.samples.svg.gui.AlignToolBar();
    figureToolBar = new org.jhotdraw.samples.svg.gui.FigureToolBar();
    linkToolBar = new org.jhotdraw.samples.svg.gui.LinkToolBar();
    canvasToolBar = new org.jhotdraw.samples.svg.gui.CanvasToolBar();
    viewToolBar = new org.jhotdraw.samples.svg.gui.ViewToolBar();
    setBackground(new java.awt.Color(255, 255, 255));
    setLayout(new java.awt.BorderLayout());
    scrollPane.setBorder(null);
    scrollPane.setViewportView(view);
    add(scrollPane, java.awt.BorderLayout.CENTER);
    toolsPanel.setBackground(new java.awt.Color(255, 255, 255));
    toolsPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
    toolsPanel.setOpaque(true);
    toolsPanel.setLayout(new java.awt.GridBagLayout());
    toolsScrollPane.setBorder(PaletteLookAndFeel.getInstance().getBorder("Ribbon.border"));
    toolsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
    toolsScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
    toolsScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));
    toolsPane.setForeground(new java.awt.Color(153, 153, 153));
    toolsPane.add(creationToolBar);
    toolsPane.add(actionToolBar);
    toolsPane.add(fillToolBar);
    strokeToolBar.setMargin(new java.awt.Insets(0, 10, 0, 0));
    toolsPane.add(strokeToolBar);
    toolsPane.add(fontToolBar);
    toolsPane.add(arrangeToolBar);
    toolsPane.add(alignToolBar);
    toolsPane.add(figureToolBar);
    toolsPane.add(linkToolBar);
    toolsPane.add(canvasToolBar);
    toolsPane.add(viewToolBar);
    toolsScrollPane.setViewportView(toolsPane);
    gridBagConstraints = new java.awt.GridBagConstraints();
    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
    gridBagConstraints.weightx = 1.0;
    gridBagConstraints.weighty = 1.0;
    toolsPanel.add(toolsScrollPane, gridBagConstraints);
    add(toolsPanel, java.awt.BorderLayout.SOUTH);
###
2725, SVGDrawingPanel, SVGDrawingPanel, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java, 94, 164
1
/** Creates new instance. */
59
  public SVGDrawingPanel() {
    labels = ResourceBundleUtil.getBundle("org.jhotdraw.samples.svg.Labels");
    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle("org.jhotdraw.draw.Labels");
    try {
      prefs = PreferencesUtil.userNodeForPackage(getClass());
    } catch (SecurityException e) {
      // prefs is null, because we are not permitted to read preferences
    }
    
    initComponents();
    toolsPane.setLayout(new ToolBarLayout());
    toolsPane.setBackground(new Color(0xf0f0f0));
    toolsPane.setOpaque(true);
    viewToolBar.setView(view);
    undoManager = new UndoRedoManager();
    Drawing drawing = createDrawing();
    view.setDrawing(drawing);
    drawing.addUndoableEditListener(undoManager);
    // Try to install the DnDDrawingViewTransferHandler
    // Since this class only works on J2SE 6, we have to use reflection.
    try {
      view.setTransferHandler((TransferHandler) Class.forName("org.jhotdraw.draw.DnDDrawingViewTransferHandler").newInstance());
    } catch (Exception e) {
      // bail silently
    }
    // Sort the toolbars according to the user preferences
    ArrayList<JToolBar> sortme = new ArrayList<JToolBar>();
    for (Component c : toolsPane.getComponents()) {
      if (c instanceof JToolBar) {
        sortme.add((JToolBar) c);
      }
    }
    Collections.sort(sortme, new Comparator<JToolBar>() {
      public int compare(JToolBar tb1, JToolBar tb2) {
        int i1 = prefs.getInt("toolBarIndex." + tb1.getName(), 0);
        int i2 = prefs.getInt("toolBarIndex." + tb2.getName(), 0);
        return i1 - i2;
      }
    });
    toolsPane.removeAll();
    for (JToolBar tb : sortme) {
      toolsPane.add(tb);
    }
    toolsPane.addContainerListener(containerHandler = new ContainerListener() {
      public void componentAdded(ContainerEvent e) {
        int i = 0;
        for (Component c : toolsPane.getComponents()) {
          if (c instanceof JToolBar) {
            JToolBar tb = (JToolBar) c;
            prefs.putInt("toolBarIndex." + tb.getName(), i);
            i++;
          }
        }
      }
      public void componentRemoved(ContainerEvent e) {
      }
    });

    setEditor(new DefaultDrawingEditor());
###
2726, CombineAction, CombineAction, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/action/CombineAction.java, 45, 46
1
/** Creates a new instance. */
2
  public CombineAction(DrawingEditor editor) {
    this(editor, new SVGPathFigure(true), true);
###
2727, SVGBezierFigure, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 42, 43
1
/** Creates a new instance. */
2
  public SVGBezierFigure() {
    this(false);
###
2728, findSegment, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 157, 168
5
/**
   * Gets the segment of the polyline that is hit by
   * the given Point2D.Double.
   * @return the index of the segment or -1 if no segment was hit.
   */
11
  @Override
  public int findSegment(Point2D.Double find, double tolerance) {
    // Apply inverse of transform to point
    if (get(TRANSFORM) != null) {
      try {
        find = (Point2D.Double) get(TRANSFORM).inverseTransform(find, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        System.err.println("Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.");
      }
    }
    return getBezierPath().findSegment(find, tolerance);
###
2729, joinSegments, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 180, 197
9
/**
   * Joins two segments into one if the given Point2D.Double hits a node
   * of the polyline.
   * @return true if the two segments were joined.
   *
   * @param join a Point at a node on the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
16
  @Override
  public boolean joinSegments(Point2D.Double join, double tolerance) {
    // Apply inverse of transform to point
    if (get(TRANSFORM) != null) {
      try {
        join = (Point2D.Double) get(TRANSFORM).inverseTransform(join, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        System.err.println("Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.");
      }
    }
    int i = getBezierPath().findSegment(join, tolerance);
    if (i != -1 && i > 1) {
      removeNode(i);
      return true;
    }
    return false;
###
2730, splitSegment, SVGBezierFigure, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java, 208, 224
8
/**
   * Splits the segment at the given Point2D.Double if a segment was hit.
   * @return the index of the segment or -1 if no segment was hit.
   *
   * @param split a Point on (or near) a segment of the bezier path
   * @param tolerance a tolerance, tolerance should take into account
   * the line width, plus 2 divided by the zoom factor. 
   */
15
  @Override
  public int splitSegment(Point2D.Double split, double tolerance) {
    // Apply inverse of transform to point
    if (get(TRANSFORM) != null) {
      try {
        split = (Point2D.Double) get(TRANSFORM).inverseTransform(split, new Point2D.Double());
      } catch (NoninvertibleTransformException ex) {
        System.err.println("Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform.");
      }
    }
    int i = getBezierPath().findSegment(split, tolerance);
    if (i != -1) {
      addNode(i + 1, new BezierPath.Node(split));
    }
    return i + 1;
###
2731, createDrawing, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 106, 107
3
/**
   * Creates a new Drawing for this View.
   */
2
  protected Drawing createDrawing() {
    return svgPanel.createDrawing();
###
2733, createPageable, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 113, 114
3
/**
   * Creates a Pageable object for printing the View.
   */
2
  public Pageable createPageable() {
    return new DrawingPageable(svgPanel.getDrawing());
###
2734, read, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 150, 204
3
/**
   * Reads the view from the specified uri.
   */
52
  public void read(final URI uri, URIChooser chooser) throws IOException {
    try {
      JFileURIChooser fc = (JFileURIChooser) chooser;
      final Drawing drawing = createDrawing();
      // We start with the selected uri format in the uri chooser,
      // and then try out all formats we can import.
      // We need to try out all formats, because the user may have
      // chosen to load a uri without having used the uri chooser.
      InputFormat selectedFormat = fileFilterInputFormatMap.get(fc.getFileFilter());
      boolean success = false;
      if (selectedFormat != null) {
        try {
          selectedFormat.read(new File(uri), drawing, true);
          success = true;
        } catch (Exception e) {
          e.printStackTrace();
          // try with the next input format
        }
      }
      if (!success) {
        for (InputFormat sfi : drawing.getInputFormats()) {
          if (sfi != selectedFormat) {
            try {
              sfi.read(new File(uri), drawing, true);
              success = true;
              break;
            } catch (Exception e) {
              // try with the next input format
            }
          }
        }
      }
      if (!success) {
        ResourceBundleUtil labels = ResourceBundleUtil.getBundle("org.jhotdraw.app.Labels");
        throw new IOException(labels.getFormatted("file.open.unsupportedFileFormat.message", URIUtil.getName(uri)));
      }
      SwingUtilities.invokeAndWait(new Runnable() {
        public void run() {
          Drawing oldDrawing = svgPanel.getDrawing();
          svgPanel.setDrawing(drawing);
          firePropertyChange(DRAWING_PROPERTY, oldDrawing, svgPanel.getDrawing());
          undo.discardAllEdits();
        }
      });
    } catch (InterruptedException e) {
      InternalError error = new InternalError();
      e.initCause(e);
      throw error;
    } catch (InvocationTargetException e) {
      InternalError error = new InternalError();
      error.initCause(e);
      throw error;
###
2735, init, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 70, 87
3
/**
   * Initializes the View.
   */
14
  @Override
  public void init() {
    super.init();
    initComponents();
    JPanel zoomButtonPanel = new JPanel(new BorderLayout());
    undo = svgPanel.getUndoRedoManager();
    Drawing oldDrawing = svgPanel.getDrawing();
    svgPanel.setDrawing(createDrawing());
    firePropertyChange(DRAWING_PROPERTY, oldDrawing, svgPanel.getDrawing());
    svgPanel.getDrawing().addUndoableEditListener(undo);
    initActions();
    undo.addPropertyChangeListener(propertyHandler = new PropertyChangeListener() {
      public void propertyChange(PropertyChangeEvent evt) {
        setHasUnsavedChanges(undo.hasSignificantEdits());
###
2736, initComponents, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 260, 265
5
/** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
4
  private void initComponents() {
    svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();
    setLayout(new java.awt.BorderLayout());
    add(svgPanel, java.awt.BorderLayout.CENTER);
###
2737, initActions, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 129, 131
3
/**
   * Initializes view specific actions.
   */
3
  private void initActions() {
    getActionMap().put(UndoAction.ID, undo.getUndoAction());
    getActionMap().put(RedoAction.ID, undo.getRedoAction());
###
2738, clear, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 220, 243
3
/**
   * Clears the view.
   */
23
  public void clear() {
    final Drawing newDrawing = createDrawing();
    try {
      Runnable r = new Runnable() {
        public void run() {
          Drawing oldDrawing = svgPanel.getDrawing();
          svgPanel.setDrawing(newDrawing);
          firePropertyChange(DRAWING_PROPERTY, oldDrawing, newDrawing);
          if (oldDrawing != null) {
            oldDrawing.removeAllChildren();
          }
          undo.discardAllEdits();
        }
      };
      if (SwingUtilities.isEventDispatchThread()) {
        r.run();
      } else {
        SwingUtilities.invokeAndWait(r);
      }
    } catch (InvocationTargetException ex) {
      ex.printStackTrace();
    } catch (InterruptedException ex) {
      ex.printStackTrace();
###
2739, write, SVGView, JHotDraw741
jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java, 143, 144
3
/**
   * Writes the view to the specified uri.
   */
2
  public void write(URI uri, URIChooser chooser) throws IOException {
    new SVGOutputFormat().write(new File(uri), svgPanel.getDrawing());
###
