method_id,method_name,class_name,software_system,filepath,start_line,end_line,Length_of_Head_Comment,Head_Comment,Length_of_the_Implementation,Method_Implementation
58,close,ContentReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java,177,208,6,/**\n  * Skips remaining data and closes the stream.\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,28,"   public void close()\n    throws IOException\n   {\n    try {\n     int bufferLength = this.buffer.length();\n     for (;;) {\n      String str = """";\n      char ch;\n      if (this.bufferIndex >= bufferLength) {\n         str = XMLUtil.read(this.reader, \'&\');\n         ch = str.charAt(0);\n      } else {\n         ch = this.buffer.charAt(this.bufferIndex);\n         this.bufferIndex++;\n         continue; // don\'t interprete chars in the buffer\n      }\n      if (ch == \'<\') {\n         this.reader.unread(ch);\n         break;\n      }\n      if ((ch == \'&\') && (str.length() > 1)) {\n         if (str.charAt(1) != \'#\') {\n          XMLUtil.processEntity(str, this.reader, this.resolver);\n         }\n      }\n     }\n    } catch (XMLParseException e) {\n     throw new IOException(e.getMessage());\n"
59,ContentReader,ContentReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java,78,85,7,/**\n  * Creates the reader.\n  *\n  * @param reader the encapsulated reader\n  * @param resolver the entity resolver\n  * @param buffer data that has already been read from <code>reader</code>\n  */,8,"   ContentReader(IXMLReader     reader,\n         IXMLEntityResolver resolver,\n         String       buffer)\n   {\n    this.reader = reader;\n    this.resolver = resolver;\n    this.buffer = buffer;\n    this.bufferIndex = 0;\n"
60,read,ContentReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java,114,166,12,"/**\n  * Reads a block of data.\n  *\n  * @param outputBuffer where to put the read data\n  * @param offset first position in buffer to put the data\n  * @param size maximum number of chars to read\n  *\n  * @return the number of chars read, or -1 if at EOF\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */",45,"   public int read(char[] outputBuffer,\n           int  offset,\n           int  size)\n    throws IOException\n   {\n    try {\n     int charsRead = 0;\n     int bufferLength = this.buffer.length();\n     if ((offset + size) > outputBuffer.length) {\n      size = outputBuffer.length - offset;\n     }\n     while (charsRead < size) {\n      String str = """";\n      char ch;\n      if (this.bufferIndex >= bufferLength) {\n         str = XMLUtil.read(this.reader, \'&\');\n         ch = str.charAt(0);\n      } else {\n         ch = this.buffer.charAt(this.bufferIndex);\n         this.bufferIndex++;\n         outputBuffer[charsRead] = ch;\n         charsRead++;\n         continue; // don\'t interprete chars in the buffer\n      }\n      if (ch == \'<\') {\n         this.reader.unread(ch);\n         break;\n      }\n      if ((ch == \'&\') && (str.length() > 1)) {\n         if (str.charAt(1) == \'#\') {\n          ch = XMLUtil.processCharLiteral(str);\n         } else {\n          XMLUtil.processEntity(str, this.reader, this.resolver);\n          continue;\n         }\n      }\n      outputBuffer[charsRead] = ch;\n      charsRead++;\n     }\n     if (charsRead == 0) {\n      charsRead = -1;\n     }\n     return charsRead;\n    } catch (XMLParseException e) {\n     throw new IOException(e.getMessage());\n"
61,finalize,ContentReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ContentReader.java,92,98,3,/**\n  * Cleans up the object when it's destroyed.\n  */,7,   protected void finalize()\n    throws Throwable\n   {\n    this.reader = null;\n    this.resolver = null;\n    this.buffer = null;\n    super.finalize();\n
62,finalize,PIReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java,74,78,3,/**\n  * Cleans up the object when it's destroyed.\n  */,5,   protected void finalize()\n    throws Throwable\n   {\n    this.reader = null;\n    super.finalize();\n
63,read,PIReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java,94,131,12,"/**\n  * Reads a block of data.\n  *\n  * @param buffer where to put the read data\n  * @param offset first position in buffer to put the data\n  * @param size maximum number of chars to read\n  *\n  * @return the number of chars read, or -1 if at EOF\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */",29,"   public int read(char[] buffer,\n           int  offset,\n           int  size)\n    throws IOException\n   {\n    if (this.atEndOfData) {\n     return -1;\n    }\n    int charsRead = 0;\n    if ((offset + size) > buffer.length) {\n     size = buffer.length - offset;\n    }\n    while (charsRead < size) {\n     char ch = this.reader.read();\n     if (ch == '?') {\n      char ch2 = this.reader.read();\n      if (ch2 == '>') {\n         this.atEndOfData = true;\n         break;\n      }\n      this.reader.unread(ch2);\n     }\n     buffer[charsRead] = ch;\n     charsRead++;\n    }\n    if (charsRead == 0) {\n     charsRead = -1;\n    }\n    return charsRead;\n"
64,PIReader,PIReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/PIReader.java,64,67,5,/**\n  * Creates the reader.\n  *\n  * @param reader the encapsulated reader\n  */,4,   PIReader(IXMLReader reader)\n   {\n    this.reader = reader;\n    this.atEndOfData = false;\n
77,getParameterEntityResolver,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,115,117,5,/**\n  * Returns the parameter entity resolver.\n  *\n  * @return the entity resolver.\n  */,3,   public IXMLEntityResolver getParameterEntityResolver()\n   {\n    return this.parameterEntityResolver;\n
78,attributeAdded,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,608,616,8,/**\n  * Indicates that an attribute has been added to the current element.\n  *\n  * @param key    the name of the attribute.\n  * @param value    the value of the attribute.\n  * @param systemId   the system ID of the XML data of the element.\n  * @param lineNr   the line number in the XML data of the element.\n  */,8,"   public void attributeAdded(String key,\n                String value,\n                String systemId,\n                int  lineNr)\n   {\n    Properties props = (Properties) this.currentElements.peek();\n    if (props.containsKey(key)) {\n     props.remove(key);\n"
79,processElement,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,184,217,9,/**\n  * Processes an element in the DTD.\n  *\n  * @param reader     the reader to read data from.\n  * @param entityResolver the entity resolver.\n  *\n  * @throws java.lang.Exception\n  *   If something went wrong.\n  */,27,"   protected void processElement(IXMLReader     reader,\n                 IXMLEntityResolver entityResolver)\n    throws Exception\n   {\n    String str = XMLUtil.read(reader, '%');\n    char ch = str.charAt(0);\n    if (ch != '!') {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    str = XMLUtil.read(reader, '%');\n    ch = str.charAt(0);\n    switch (ch) {\n     case '-':\n      XMLUtil.skipComment(reader);\n      break;\n     case '[':\n      this.processConditionalSection(reader, entityResolver);\n      break;\n     case 'E':\n      this.processEntity(reader, entityResolver);\n      break;\n     case 'A':\n      this.processAttList(reader, entityResolver);\n      break;\n     default:\n      XMLUtil.skipTag(reader);\n"
80,NonValidator,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,76,80,3,/**\n  * Creates the &quot;validator&quot;.\n  */,5,   public NonValidator()\n   {\n    this.attributeDefaultValues = new Hashtable();\n    this.currentElements = new Stack();\n    this.parameterEntityResolver = new XMLEntityResolver();\n
81,processEntity,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,460,530,9,/**\n  * Processes an ENTITY element.\n  *\n  * @param reader     the reader to read data from.\n  * @param entityResolver the entity resolver.\n  *\n  * @throws java.lang.Exception\n  *   If something went wrong.\n  */,61,"   protected void processEntity(IXMLReader     reader,\n                IXMLEntityResolver entityResolver)\n    throws Exception\n   {\n    if (! XMLUtil.checkLiteral(reader, ""NTITY"")) {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    XMLUtil.skipWhitespace(reader, null);\n    char ch = XMLUtil.readChar(reader, \'\\0\');\n    if (ch == \'%\') {\n     XMLUtil.skipWhitespace(reader, null);\n     entityResolver = this.parameterEntityResolver;\n    } else {\n     reader.unread(ch);\n    }\n    String key = XMLUtil.scanIdentifier(reader);\n    XMLUtil.skipWhitespace(reader, null);\n    ch = XMLUtil.readChar(reader, \'%\');\n    String systemID = null;\n    String publicID = null;\n    switch (ch) {\n     case \'P\':\n      if (! XMLUtil.checkLiteral(reader, ""UBLIC"")) {\n         XMLUtil.skipTag(reader);\n         return;\n      }\n      XMLUtil.skipWhitespace(reader, null);\n      publicID = XMLUtil.scanString(reader, \'%\',\n                      this.parameterEntityResolver);\n      XMLUtil.skipWhitespace(reader, null);\n      systemID = XMLUtil.scanString(reader, \'%\',\n                      this.parameterEntityResolver);\n      XMLUtil.skipWhitespace(reader, null);\n      XMLUtil.readChar(reader, \'%\');\n      break;\n     case \'S\':\n      if (! XMLUtil.checkLiteral(reader, ""YSTEM"")) {\n         XMLUtil.skipTag(reader);\n         return;\n      }\n      XMLUtil.skipWhitespace(reader, null);\n      systemID = XMLUtil.scanString(reader, \'%\',\n                      this.parameterEntityResolver);\n      XMLUtil.skipWhitespace(reader, null);\n      XMLUtil.readChar(reader, \'%\');\n      break;\n     case \'""\':\n     case \'\\\'\':\n      reader.unread(ch);\n      String value = XMLUtil.scanString(reader, \'%\',\n                        this.parameterEntityResolver);\n      entityResolver.addInternalEntity(key, value);\n      XMLUtil.skipWhitespace(reader, null);\n      XMLUtil.readChar(reader, \'%\');\n      break;\n     default:\n      XMLUtil.skipTag(reader);\n    }\n    if (systemID != null) {\n     entityResolver.addExternalEntity(key, publicID, systemID);\n"
83,parseDTD,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,133,170,12,"/**\n  * Parses the DTD. The validator object is responsible for reading the\n  * full DTD.\n  *\n  * @param publicID     the public ID, which may be null.\n  * @param reader     the reader to read the DTD from.\n  * @param entityResolver the entity resolver.\n  * @param external     true if the DTD is external.\n  *\n  * @throws java.lang.Exception\n  *   If something went wrong.\n  */",33,"   public void parseDTD(String       publicID,\n            IXMLReader     reader,\n            IXMLEntityResolver entityResolver,\n            boolean      external)\n    throws Exception\n   {\n    XMLUtil.skipWhitespace(reader, null);\n    int origLevel = reader.getStreamLevel();\n    for (;;) {\n     String str = XMLUtil.read(reader, '%');\n     char ch = str.charAt(0);\n     if (ch == '%') {\n      XMLUtil.processEntity(str, reader,\n                  this.parameterEntityResolver);\n      continue;\n     } else if (ch == '<') {\n      this.processElement(reader, entityResolver);\n     } else if (ch == ']') {\n      return; // end internal DTD\n     } else {\n      XMLUtil.errorInvalidInput(reader.getSystemID(),\n                    reader.getLineNr(),\n                    str);\n     }\n     do {\n      ch = reader.read();\n      if (external && (reader.getStreamLevel() < origLevel)) {\n         reader.unread(ch);\n         return; // end external DTD\n      }\n     } while ((ch == ' ') || (ch == '\\t') || (ch == '\\n')\n          || (ch == '\\r'));\n     reader.unread(ch);\n"
84,elementStarted,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,542,555,7,/**\n  * Indicates that an element has been started.\n  *\n  * @param name     the name of the element.\n  * @param systemId   the system ID of the XML data of the element.\n  * @param lineNr   the line number in the XML data of the element.\n  */,12,"   public void elementStarted(String name,\n                String systemId,\n                int  lineNr)\n   {\n    Properties attribs\n     = (Properties) this.attributeDefaultValues.get(name);\n    if (attribs == null) {\n     attribs = new Properties();\n    } else {\n     attribs = (Properties) attribs.clone();\n    }\n    this.currentElements.push(attribs);\n"
85,elementAttributesProcessed,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,585,595,14,"/**\n  * This method is called when the attributes of an XML element have been\n  * processed.\n  * If there are attributes with a default value which have not been\n  * specified yet, they have to be put into <I>extraAttributes</I>.\n  *\n  * @param name      the name of the element.\n  * @param extraAttributes where to put extra attributes.\n  * @param systemId    the system ID of the XML data of the element.\n  * @param lineNr      the line number in the XML data of the element.\n  */\n --------------\n// nothing to do\n --------------",10,"   public void elementAttributesProcessed(String   name,\n                      Properties extraAttributes,\n                      String   systemId,\n                      int    lineNr)\n   {\n    Properties props = (Properties) this.currentElements.pop();\n    Enumeration enm = props.keys();\n    while (enm.hasMoreElements()) {\n     String key = (String) enm.nextElement();\n     extraAttributes.put(key, props.get(key));\n"
86,processIgnoreSection,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,303,323,9,/**\n  * Processes an ignore section.\n  *\n  * @param reader     the reader to read data from.\n  * @param entityResolver the entity resolver.\n  *\n  * @throws java.lang.Exception\n  *   If something went wrong.\n  */,17,"   protected void processIgnoreSection(IXMLReader     reader,\n                     IXMLEntityResolver entityResolver)\n    throws Exception\n   {\n    if (! XMLUtil.checkLiteral(reader, ""NORE"")) {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    XMLUtil.skipWhitespace(reader, null);\n    String str = XMLUtil.read(reader, \'%\');\n    char ch = str.charAt(0);\n    if (ch != \'[\') {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    Reader subreader = new CDATAReader(reader);\n    subreader.close();\n"
87,processConditionalSection,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,231,290,9,/**\n  * Processes a conditional section.\n  *\n  * @param reader     the reader to read data from.\n  * @param entityResolver the entity resolver.\n  *\n  * @throws java.lang.Exception\n  *   If something went wrong.\n  */,45,"   protected void processConditionalSection(IXMLReader     reader,\n                      IXMLEntityResolver entityResolver)\n    throws Exception\n   {\n    XMLUtil.skipWhitespace(reader, null);\n    String str = XMLUtil.read(reader, \'%\');\n    char ch = str.charAt(0);\n    if (ch != \'I\') {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    str = XMLUtil.read(reader, \'%\');\n    ch = str.charAt(0);\n    switch (ch) {\n     case \'G\':\n      this.processIgnoreSection(reader, entityResolver);\n      return;\n     case \'N\':\n      break;\n     default:\n      XMLUtil.skipTag(reader);\n      return;\n    }\n    if (! XMLUtil.checkLiteral(reader, ""CLUDE"")) {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    XMLUtil.skipWhitespace(reader, null);\n    str = XMLUtil.read(reader, \'%\');\n    ch = str.charAt(0);\n    if (ch != \'[\') {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    Reader subreader = new CDATAReader(reader);\n    StringBuffer buf = new StringBuffer(1024);\n    for (;;) {\n     int ch2 = subreader.read();\n     if (ch2 < 0) {\n      break;\n     }\n     buf.append((char) ch2);\n    }\n    subreader.close();\n    reader.startNewStream(new StringReader(buf.toString()));\n"
88,setParameterEntityResolver,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,104,106,5,/**\n  * Sets the parameter entity resolver.\n  *\n  * @param resolver the entity resolver.\n  */,3,   public void setParameterEntityResolver(IXMLEntityResolver resolver)\n   {\n    this.parameterEntityResolver = resolver;\n
89,processAttList,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,336,446,9,/**\n  * Processes an ATTLIST element.\n  *\n  * @param reader     the reader to read data from.\n  * @param entityResolver the entity resolver.\n  *\n  * @throws java.lang.Exception\n  *   If something went wrong.\n  */,100,"   protected void processAttList(IXMLReader     reader,\n                 IXMLEntityResolver entityResolver)\n    throws Exception\n   {\n    if (! XMLUtil.checkLiteral(reader,  ""TTLIST"")) {\n     XMLUtil.skipTag(reader);\n     return;\n    }\n    XMLUtil.skipWhitespace(reader, null);\n    String str = XMLUtil.read(reader, \'%\');\n    char ch = str.charAt(0);\n    while (ch == \'%\') {\n     XMLUtil.processEntity(str, reader,\n                 this.parameterEntityResolver);\n     str = XMLUtil.read(reader, \'%\');\n     ch = str.charAt(0);\n    }\n    reader.unread(ch);\n    String elementName = XMLUtil.scanIdentifier(reader);\n    XMLUtil.skipWhitespace(reader, null);\n    \n    str = XMLUtil.read(reader, \'%\');\n    ch = str.charAt(0);\n    while (ch == \'%\') {\n     XMLUtil.processEntity(str, reader,\n                 this.parameterEntityResolver);\n     str = XMLUtil.read(reader, \'%\');\n     ch = str.charAt(0);\n    }\n    Properties props = new Properties();\n    while (ch != \'>\') {\n     reader.unread(ch);\n     String attName = XMLUtil.scanIdentifier(reader);\n     XMLUtil.skipWhitespace(reader, null);\n     str = XMLUtil.read(reader, \'%\');\n     ch = str.charAt(0);\n     while (ch == \'%\') {\n       XMLUtil.processEntity(str, reader,\n                   this.parameterEntityResolver);\n       str = XMLUtil.read(reader, \'%\');\n       ch = str.charAt(0);\n     }\n     if (ch == \'(\') {\n       while (ch != \')\') {\n         str = XMLUtil.read(reader, \'%\');\n         ch = str.charAt(0);\n         while (ch == \'%\') {\n           XMLUtil.processEntity(str, reader,\n                       this.parameterEntityResolver);\n           str = XMLUtil.read(reader, \'%\');\n           ch = str.charAt(0);\n         }\n       }\n     } else {\n      reader.unread(ch);\n      XMLUtil.scanIdentifier(reader);\n     }\n     XMLUtil.skipWhitespace(reader, null);\n     str = XMLUtil.read(reader, \'%\');\n     ch = str.charAt(0);\n     while (ch == \'%\') {\n       XMLUtil.processEntity(str, reader,\n                   this.parameterEntityResolver);\n       str = XMLUtil.read(reader, \'%\');\n       ch = str.charAt(0);\n     }\n     \n     if (ch == \'#\') {\n      str = XMLUtil.scanIdentifier(reader);\n      XMLUtil.skipWhitespace(reader, null);\n      if (! str.equals(""FIXED"")) {\n         XMLUtil.skipWhitespace(reader, null);\n         str = XMLUtil.read(reader, \'%\');\n         ch = str.charAt(0);\n         while (ch == \'%\') {\n          XMLUtil.processEntity(str, reader,\n                    this.parameterEntityResolver);\n          str = XMLUtil.read(reader, \'%\');\n          ch = str.charAt(0);\n         }\n         continue;\n      }\n     } else {\n      reader.unread(ch);\n     }\n     String value = XMLUtil.scanString(reader, \'%\',\n                       this.parameterEntityResolver);\n     props.put(attName, value);\n     XMLUtil.skipWhitespace(reader, null);\n     str = XMLUtil.read(reader, \'%\');\n     ch = str.charAt(0);\n     while (ch == \'%\') {\n      XMLUtil.processEntity(str, reader,\n                  this.parameterEntityResolver);\n      str = XMLUtil.read(reader, \'%\');\n      ch = str.charAt(0);\n     }\n    }\n    if (! props.isEmpty()) {\n     this.attributeDefaultValues.put(elementName, props);\n"
90,finalize,NonValidator,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/NonValidator.java,87,95,3,/**\n  * Cleans up the object when it's destroyed.\n  */,9,   protected void finalize()\n    throws Throwable\n   {\n    this.parameterEntityResolver = null;\n    this.attributeDefaultValues.clear();\n    this.attributeDefaultValues = null;\n    this.currentElements.clear();\n    this.currentElements = null;\n    super.finalize();\n
149,CDATAReader,CDATAReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java,70,74,5,/**\n  * Creates the reader.\n  *\n  * @param reader the encapsulated reader\n  */,5,   CDATAReader(IXMLReader reader)\n   {\n    this.reader = reader;\n    this.savedChar = 0;\n    this.atEndOfData = false;\n
150,finalize,CDATAReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java,81,85,3,/**\n  * Cleans up the object when it's destroyed.\n  */,5,   protected void finalize()\n    throws Throwable\n   {\n    this.reader = null;\n    super.finalize();\n
151,read,CDATAReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/CDATAReader.java,101,150,12,"/**\n  * Reads a block of data.\n  *\n  * @param buffer where to put the read data\n  * @param offset first position in buffer to put the data\n  * @param size maximum number of chars to read\n  *\n  * @return the number of chars read, or -1 if at EOF\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */",41,"   public int read(char[] buffer,\n           int  offset,\n           int  size)\n    throws IOException\n   {\n    int charsRead = 0;\n    if (this.atEndOfData) {\n     return -1;\n    }\n    if ((offset + size) > buffer.length) {\n     size = buffer.length - offset;\n    }\n    while (charsRead < size) {\n     char ch = this.savedChar;\n     if (ch == 0) {\n      ch = this.reader.read();\n     } else {\n      this.savedChar = 0;\n     }\n     if (ch == ']') {\n      char ch2 = this.reader.read();\n      \n      if (ch2 == ']') {\n         char ch3 = this.reader.read();\n         if (ch3 == '>') {\n          this.atEndOfData = true;\n          break;\n         }\n         this.savedChar = ch2;\n         this.reader.unread(ch3);\n      } else {\n         this.reader.unread(ch2);\n      }\n     }\n     buffer[charsRead] = ch;\n     charsRead++;\n    }\n    if (charsRead == 0) {\n     charsRead = -1;\n    }\n    return charsRead;\n"
215,getElementName,XMLValidationException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java,165,167,4,"/**\n  * Returns the name of the element in which the validation is violated.\n  * If there is no current element, null is returned.\n  */",3,   public String getElementName()\n   {\n    return this.elementName;\n
216,getAttributeName,XMLValidationException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java,175,177,4,"/**\n  * Returns the name of the attribute in which the validation is violated.\n  * If there is no current attribute, null is returned.\n  */",3,   public String getAttributeName()\n   {\n    return this.attributeName;\n
217,XMLValidationException,XMLValidationException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java,127,144,12,/**\n  * Creates a new exception.\n  *\n  * @param errorType    the type of validity error\n  * @param systemID     the system ID from where the data came\n  * @param lineNr     the line number in the XML data where the\n  *             exception occurred.\n  * @param elementName  the name of the offending element\n  * @param attributeName  the name of the offending attribute\n  * @param attributeValue the value of the offending attribute\n  * @param msg      the message of the exception.\n  */,18,"   public XMLValidationException(int  errorType,\n                 String systemID,\n                 int  lineNr,\n                 String elementName,\n                 String attributeName,\n                 String attributeValue,\n                 String msg)\n   {\n    super(systemID, lineNr, null,\n      msg + ((elementName == null) ? """" : ("", element="" + elementName))\n      + ((attributeName == null) ? """"\n                     : ("", attribute="" + attributeName))\n      + ((attributeValue == null) ? """"\n                     : ("", value=\'"" + attributeValue + ""\'"")),\n      false);\n    this.elementName = elementName;\n    this.attributeName = attributeName;\n    this.attributeValue = attributeValue;\n"
218,finalize,XMLValidationException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLValidationException.java,151,157,3,/**\n  * Cleans up the object when it's destroyed.\n  */,7,   protected void finalize()\n    throws Throwable\n   {\n    this.elementName = null;\n    this.attributeName = null;\n    this.attributeValue = null;\n    super.finalize();\n
219,errorClosingTagNotEmpty,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,552,557,7,/**\n  * Throws an XMLParseException to indicate that extra data is encountered\n  * in a closing tag.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  */,6,"   static void errorClosingTagNotEmpty(String systemID,\n                     int  lineNr)\n    throws XMLParseException\n   {\n    throw new XMLParseException(systemID, lineNr,\n                  ""Closing tag must be empty"");\n"
221,errorUnexpectedPCData,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,722,733,8,/**\n  * Throws an XMLValidationException to indicate that a #PCDATA element was\n  * unexpected.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param parentElementName the name of the parent element\n  */,12,"   static void errorUnexpectedPCData(String systemID,\n                   int  lineNr,\n                   String parentElementName)\n    throws XMLValidationException\n   {\n    throw new XMLValidationException(\n            XMLValidationException.UNEXPECTED_PCDATA,\n            systemID, lineNr,\n            /*elementName*/ null,\n            /*attributeName*/ null,\n            /*attributeValue*/ null,\n            ""Unexpected #PCDATA in element "" + parentElementName);\n"
223,errorUnexpectedCDATA,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,496,501,7,/**\n  * Throws an XMLParseException to indicate that a CDATA section is\n  * unexpected at this point.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  */,6,"   static void errorUnexpectedCDATA(String systemID,\n                  int  lineNr)\n    throws XMLParseException\n   {\n    throw new XMLParseException(systemID, lineNr,\n                  ""No CDATA section is expected here"");\n"
225,errorInvalidAttributeValue,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,674,687,10,/**\n  * Throws an XMLValidationException to indicate that an attribute has an\n  * invalid value.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param elementName  the name of the element\n  * @param attributeName  the name of the attribute\n  * @param attributeValue the value of that attribute\n  */,14,"   static void errorInvalidAttributeValue(String systemID,\n                      int  lineNr,\n                      String elementName,\n                      String attributeName,\n                      String attributeValue)\n    throws XMLValidationException\n   {\n    throw new XMLValidationException(\n               XMLValidationException.ATTRIBUTE_WITH_INVALID_VALUE,\n               systemID, lineNr,\n               elementName,\n               attributeName,\n               attributeValue,\n               ""Invalid value for attribute "" + attributeName);\n"
227,errorUnexpectedAttribute,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,647,660,9,/**\n  * Throws an XMLValidationException to indicate that an attribute is\n  * unexpected.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param elementName  the name of the element\n  * @param attributeName  the name of the unexpected attribute\n  */,14,"   static void errorUnexpectedAttribute(String systemID,\n                    int  lineNr,\n                    String elementName,\n                    String attributeName)\n    throws XMLValidationException\n   {\n    throw new XMLValidationException(\n           XMLValidationException.UNEXPECTED_ATTRIBUTE,\n           systemID, lineNr,\n           elementName,\n           attributeName,\n           /*attributeValue*/ null,\n           ""Element "" + elementName + "" did not expect an attribute ""\n           + ""named "" + attributeName);\n"
230,scanPublicID,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,128,140,11,/**\n  * Scans a public ID.\n  *\n  * @param publicID     will contain the public ID\n  * @param reader     the reader\n  *\n  * @return the system ID\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,12,"   static String scanPublicID(StringBuffer publicID,\n                IXMLReader   reader)\n    throws IOException,\n       XMLParseException\n   {\n    if (! XMLUtil.checkLiteral(reader, ""UBLIC"")) {\n     return null;\n    }\n    XMLUtil.skipWhitespace(reader, null);\n    publicID.append(XMLUtil.scanString(reader, \'\\0\', null));\n    XMLUtil.skipWhitespace(reader, null);\n    return XMLUtil.scanString(reader, \'\\0\', null);\n"
231,errorWrongClosingTag,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,532,541,9,/**\n  * Throws an XMLParseException to indicate that the closing tag of an\n  * element does not match the opening tag.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param expectedName the name of the opening tag\n  * @param wrongName  the name of the closing tag\n  */,10,"   static void errorWrongClosingTag(String systemID,\n                  int  lineNr,\n                  String   expectedName,\n                  String   wrongName)\n    throws XMLParseException\n   {\n    throw new XMLParseException(systemID, lineNr,\n                  ""Closing tag does not match opening tag: `""\n                  + wrongName + ""\' != `"" + expectedName\n                  + ""\'"");\n"
232,readChar,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,391,405,7,/**\n  * Reads a character from the reader disallowing entities.\n  *\n  * @param reader     the reader\n  * @param entityChar   the escape character (&amp; or %) used to indicate\n  *             an entity\n  */,13,"   static char readChar(IXMLReader reader,\n            char     entityChar)\n    throws IOException,\n       XMLParseException\n   {\n    String str = XMLUtil.read(reader, entityChar);\n    char ch = str.charAt(0);\n    if (ch == entityChar) {\n     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),\n                     reader.getLineNr(),\n                     str);\n    }\n    return ch;\n"
233,updateApplicationEnabled,AbstractApplicationAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java,91,94,4,/**\n   * Updates the enabled state of this action depending on the new enabled\n   * state of the application.\n   */,4,"  protected void updateApplicationEnabled() {\n    firePropertyChange(""enabled"",\n        Boolean.valueOf(!isEnabled()),\n        Boolean.valueOf(isEnabled()));\n"
234,checkLiteral,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,419,430,10,/**\n  * Returns true if the data starts with <I>literal</I>.\n  * Enough chars are read to determine this result.\n  *\n  * @param reader     the reader\n  * @param literal    the literal to check\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,11,"   static boolean checkLiteral(IXMLReader     reader,\n                 String       literal)\n    throws IOException,\n       XMLParseException\n   {\n    for (int i = 0; i < literal.length(); i++) {\n     if (reader.read() != literal.charAt(i)) {\n      return false;\n     }\n    }\n    return true;\n"
235,isEnabled,AbstractApplicationAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java,105,107,8,"/**\n   * Returns true if the action is enabled.\n   * The enabled state of the action depends on the state that has been set\n   * using setEnabled() and on the enabled state of the application.\n   *\n   * @return true if the action is enabled, false otherwise\n   * @see Action#isEnabled\n   */",3,  @Override\n  public boolean isEnabled() {\n    return app != null && app.isEnabled() && enabled;\n
236,installApplicationListeners,AbstractApplicationAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java,58,62,3,/*\n   * Installs listeners on the application object.\n   */,5,  protected void installApplicationListeners(Application app) {\n    if (applicationListener == null) {\n      applicationListener = createApplicationListener();\n    }\n    app.addPropertyChangeListener(new WeakPropertyChangeListener(applicationListener));\n
237,scanString,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,209,256,10,/**\n  * Retrieves a delimited string from the data.\n  *\n  * @param reader        the reader\n  * @param entityChar      the escape character (&amp; or %)\n  * @param entityResolver    the entity resolver\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,44,"   static String scanString(IXMLReader     reader,\n              char         entityChar,\n              IXMLEntityResolver entityResolver)\n    throws IOException,\n       XMLParseException\n   {\n    StringBuffer result = new StringBuffer();\n    int startingLevel = reader.getStreamLevel();\n    char delim = reader.read();\n    if ((delim != \'\\\'\') && (delim != \'""\')) {\n     XMLUtil.errorExpectedInput(reader.getSystemID(),\n                  reader.getLineNr(),\n                  ""delimited string"");\n    }\n    for (;;) {\n     String str = XMLUtil.read(reader, entityChar);\n     char ch = str.charAt(0);\n     if (ch == entityChar) {\n      if (str.charAt(1) == \'#\') {\n         result.append(XMLUtil.processCharLiteral(str));\n      } else {\n         XMLUtil.processEntity(str, reader, entityResolver);\n      }\n     } else if (ch == \'&\') {\n      reader.unread(ch);\n      str = XMLUtil.read(reader, \'&\');\n      if (str.charAt(1) == \'#\') {\n         result.append(XMLUtil.processCharLiteral(str));\n      } else {\n         result.append(str);\n      }\n     } else if (reader.getStreamLevel() == startingLevel) {\n      if (ch == delim) {\n         break;\n      } else if ((ch == 9) || (ch == 10) || (ch == 13)) {\n         result.append(\' \');\n      } else {\n         result.append(ch);\n      }\n     } else {\n      result.append(ch);\n     }\n    }\n    return result.toString();\n"
238,uninstallApplicationListeners,AbstractApplicationAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java,68,69,3,/**\n   * Installs listeners on the application object.\n   */,2,  protected void uninstallApplicationListeners(Application app) {\n    app.removePropertyChangeListener(applicationListener);\n
239,AbstractApplicationAction,AbstractApplicationAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractApplicationAction.java,49,52,1,/** Creates a new instance. */,4,  public AbstractApplicationAction(Application app) {\n    this.app = app;\n    installApplicationListeners(app);\n    updateApplicationEnabled();\n
240,errorMissingAttribute,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,621,634,9,/**\n  * Throws an XMLValidationException to indicate that an attribute is\n  * missing.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param elementName  the name of the element\n  * @param attributeName  the name of the missing attribute\n  */,14,"   static void errorMissingAttribute(String systemID,\n                   int  lineNr,\n                   String elementName,\n                   String attributeName)\n    throws XMLValidationException\n   {\n    throw new XMLValidationException(\n           XMLValidationException.MISSING_ATTRIBUTE,\n           systemID, lineNr,\n           elementName,\n           attributeName,\n           /*attributeValue*/ null,\n           ""Element "" + elementName + "" expects an attribute named ""\n           + attributeName);\n"
241,scanSystemID,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,154,163,10,/**\n  * Scans a system ID.\n  *\n  * @param reader     the reader\n  *\n  * @return the system ID\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,9,"   static String scanSystemID(IXMLReader reader)\n    throws IOException,\n      XMLParseException\n   {\n    if (! XMLUtil.checkLiteral(reader, ""YSTEM"")) {\n     return null;\n    }\n    XMLUtil.skipWhitespace(reader, null);\n    return XMLUtil.scanString(reader, \'\\0\', null);\n"
242,skipComment,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,55,81,9,/**\n  * Skips the remainder of a comment.\n  * It is assumed that &lt;!- is already read.\n  *\n  * @param reader the reader\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,23,"   static void skipComment(IXMLReader reader)\n    throws IOException,\n       XMLParseException\n   {\n    if (reader.read() != \'-\') {\n     XMLUtil.errorExpectedInput(reader.getSystemID(),\n                  reader.getLineNr(),\n                  ""<!--"");\n    }\n    \n    int dashesRead = 0;\n    for (;;) {\n     char ch = reader.read();\n     switch (ch) {\n      case \'-\':\n         dashesRead++;\n         break;\n      case \'>\':\n         if (dashesRead == 2) {\n          return;\n         }\n      default:\n         dashesRead = 0;\n"
243,read,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,364,380,12,"/**\n  * Reads a character from the reader.\n  *\n  * @param reader     the reader\n  * @param entityChar   the escape character (&amp; or %) used to indicate\n  *             an entity\n  *\n  * @return the character, or an entity expression (like e.g. &amp;lt;)\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */",15,"   static String read(IXMLReader     reader,\n            char         entityChar)\n    throws IOException,\n       XMLParseException\n   {\n    char ch = reader.read();\n    StringBuffer buf = new StringBuffer();\n    buf.append(ch);\n    if (ch == entityChar) {\n     while (ch != ';') {\n      ch = reader.read();\n      buf.append(ch);\n     }\n    }\n    return buf.toString();\n"
244,errorInvalidEntity,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,460,466,8,/**\n  * Throws an XMLParseException to indicate that an entity could not be\n  * resolved.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param entity  the name of the entity\n  */,7,"   static void errorInvalidEntity(String systemID,\n                  int  lineNr,\n                  String   entity)\n    throws XMLParseException\n   {\n    throw new XMLParseException(systemID, lineNr,\n                  ""Invalid entity: `&"" + entity + "";\'"");\n"
245,errorUnexpectedElement,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,595,608,9,/**\n  * Throws an XMLValidationException to indicate that an element is\n  * unexpected.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param parentElementName the name of the parent element\n  * @param unexpectedElementName the name of the unexpected element\n  */,14,"   static void errorUnexpectedElement(String systemID,\n                    int  lineNr,\n                    String parentElementName,\n                    String unexpectedElementName)\n    throws XMLValidationException\n   {\n    throw new XMLValidationException(\n                XMLValidationException.UNEXPECTED_ELEMENT,\n                systemID, lineNr,\n                unexpectedElementName,\n                /*attributeName*/ null,\n                /*attributeValue*/ null,\n                ""Unexpected "" + unexpectedElementName + "" in a ""\n                + parentElementName);\n"
246,errorInvalidInput,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,513,519,8,/**\n  * Throws an XMLParseException to indicate that a string is not expected\n  * at this point.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param unexpectedString the string that is unexpected\n  */,7,"   static void errorInvalidInput(String systemID,\n                 int  lineNr,\n                 String   unexpectedString)\n    throws XMLParseException\n   {\n    throw new XMLParseException(systemID, lineNr,\n                  ""Invalid input: "" + unexpectedString);\n"
247,errorMissingPCData,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,699,710,8,/**\n  * Throws an XMLValidationException to indicate that a #PCDATA element was\n  * missing.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param parentElementName the name of the parent element\n  */,12,"   static void errorMissingPCData(String systemID,\n                  int  lineNr,\n                  String parentElementName)\n    throws XMLValidationException\n   {\n    throw new XMLValidationException(\n               XMLValidationException.MISSING_PCDATA,\n               systemID, lineNr,\n               /*elementName*/ null,\n               /*attributeName*/ null,\n               /*attributeValue*/ null,\n               ""Missing #PCDATA in element "" + parentElementName);\n"
248,errorExpectedInput,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,442,448,8,/**\n  * Throws an XMLParseException to indicate that an expected string is not\n  * encountered.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param expectedString the string that is expected\n  */,7,"   static void errorExpectedInput(String systemID,\n                  int  lineNr,\n                  String expectedString)\n    throws XMLParseException\n   {\n    throw new XMLParseException(systemID, lineNr,\n                  ""Expected: "" + expectedString);\n"
249,errorMissingElement,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,569,582,8,/**\n  * Throws an XMLValidationException to indicate that an element is missing.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param parentElementName the name of the parent element\n  * @param missingElementName the name of the missing element\n  */,14,"   static void errorMissingElement(String systemID,\n                   int  lineNr,\n                   String parentElementName,\n                   String missingElementName)\n    throws XMLValidationException\n   {\n    throw new XMLValidationException(\n                XMLValidationException.MISSING_ELEMENT,\n                systemID, lineNr,\n                missingElementName,\n                /*attributeName*/ null,\n                /*attributeValue*/ null,\n                ""Element "" + parentElementName\n                + "" expects to have a "" + missingElementName);\n"
250,errorUnexpectedEntity,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,478,485,8,/**\n  * Throws an XMLParseException to indicate that an entity reference is\n  * unexpected at this point.\n  *\n  * @param systemID     the system ID of the data source\n  * @param lineNr     the line number in the data source\n  * @param entity  the name of the entity\n  */,8,"   static void errorUnexpectedEntity(String systemID,\n                   int  lineNr,\n                   String entity)\n    throws XMLParseException\n   {\n    throw new XMLParseException(systemID, lineNr,\n                  ""No entity reference is expected here (""\n                  + entity + "")"");\n"
251,AbstractSaveUnsavedChangesAction,AbstractSaveUnsavedChangesAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractSaveUnsavedChangesAction.java,52,53,1,/** Creates a new instance. */,2,"  public AbstractSaveUnsavedChangesAction(Application app, View view) {\n    super(app, view);\n"
252,processEntity,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,270,286,10,/**\n  * Processes an entity.\n  *\n  * @param entity     the entity\n  * @param reader     the reader\n  * @param entityResolver the entity resolver\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,15,"   static void processEntity(String       entity,\n               IXMLReader     reader,\n               IXMLEntityResolver entityResolver)\n    throws IOException,\n       XMLParseException\n   {\n    entity = entity.substring(1, entity.length() - 1);\n    Reader entityReader = entityResolver.getEntity(reader, entity);\n    if (entityReader == null) {\n     XMLUtil.errorInvalidEntity(reader.getSystemID(),\n                  reader.getLineNr(),\n                  entity);\n    }\n    boolean externalEntity = entityResolver.isExternalEntity(entity);\n    reader.startNewStream(entityReader, !externalEntity);\n"
253,scanIdentifier,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,175,195,8,/**\n  * Retrieves an identifier from the data.\n  *\n  * @param reader     the reader\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,18,"   static String scanIdentifier(IXMLReader reader)\n    throws IOException,\n       XMLParseException\n   {\n    StringBuffer result = new StringBuffer();\n    for (;;) {\n     char ch = reader.read();\n     if ((ch == '_') || (ch == ':') || (ch == '-') || (ch == '.')\n       || ((ch >= 'a') && (ch <= 'z'))\n       || ((ch >= 'A') && (ch <= 'Z'))\n       || ((ch >= '0') && (ch <= '9')) || (ch > '\\u007E')) {\n      result.append(ch);\n     } else {\n      reader.unread(ch);\n      break;\n     }\n    }\n    return result.toString();\n"
254,skipWhitespace,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,322,348,10,/**\n  * Skips whitespace from the reader.\n  *\n  * @param reader     the reader\n  * @param buffer     where to put the whitespace; null if the\n  *             whitespace does not have to be stored.\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,23,"   static void skipWhitespace(IXMLReader   reader,\n                StringBuffer buffer)\n    throws IOException\n   {\n    char ch;\n    if (buffer == null) {\n     do {\n      ch = reader.read();\n     } while ((ch == ' ') || (ch == '\\t') || (ch == '\\n'));\n    } else {\n     for (;;) {\n      ch = reader.read();\n      if ((ch != ' ') && (ch != '\\t') && (ch != '\\n')) {\n         break;\n      }\n      if (ch == '\\n') {\n         buffer.append('\\n');\n      } else {\n         buffer.append(' ');\n      }\n     }\n    }\n    reader.unread(ch);\n"
255,skipTag,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,95,111,8,/**\n  * Skips the remainder of the current XML tag.\n  *\n  * @param reader     the reader\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,14,"   static void skipTag(IXMLReader reader)\n    throws IOException,\n       XMLParseException\n   {\n    int level = 1;\n    while (level > 0) {\n     char ch = reader.read();\n     switch (ch) {\n      case '<':\n         ++level;\n         break;\n      case '>':\n         --level;\n         break;\n"
256,processCharLiteral,XMLUtil,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLUtil.java,298,307,8,/**\n  * Processes a character literal.\n  *\n  * @param entity     the entity\n  *\n  * @throws java.io.IOException\n  *    if an error occurred reading the data\n  */,10,"   static char processCharLiteral(String entity)\n    throws IOException,\n       XMLParseException\n   {\n    if (entity.charAt(2) == 'x') {\n     entity = entity.substring(3, entity.length() - 1);\n     return (char) Integer.parseInt(entity, 16);\n    } else {\n     entity = entity.substring(2, entity.length() - 1);\n     return (char) Integer.parseInt(entity, 10);\n"
260,setViewClassName,AbstractApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java,79,82,3,/**\n   * Use this method for best application startup performance.\n   */,4,"  public void setViewClassName(String newValue) {\n    String oldValue = viewClassName;\n    viewClassName = newValue;\n    firePropertyChange(VIEW_CLASS_NAME_PROPERTY, oldValue, newValue);\n"
263,createImportChooser,AbstractApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java,166,168,1,/** Returns createOpenChooser. */,3,"  @Override\n  public URIChooser createImportChooser(Application a, View v) {\n    return createOpenChooser(a,v);\n"
264,setViewClass,AbstractApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplicationModel.java,88,91,3,"/**\n   * Use this method only, if setViewClassName() does not suit you.\n   */",4,"  public void setViewClass(Class newValue) {\n    Class oldValue = viewClass;\n    viewClass = newValue;\n    firePropertyChange(VIEW_CLASS_PROPERTY, oldValue, newValue);\n"
266,XMLParseException,XMLParseException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLParseException.java,48,50,5,/**\n  * Creates a new exception.\n  *\n  * @param msg the message of the exception.\n  */,3,   public XMLParseException(String msg)\n   {\n    super(msg);\n
268,createMenuBar,OSXApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java,300,371,3,/**\n   * Creates a menu bar.\n   */,68,"  protected JMenuBar createMenuBar(View v) {\n    JMenuBar mb = new JMenuBar();\n    // Get menus from application model\n    JMenu fileMenu = null;\n    JMenu editMenu = null;\n    JMenu helpMenu = null;\n    JMenu viewMenu = null;\n    JMenu windowMenu = null;\n    String fileMenuText = labels.getString(""file.text"");\n    String editMenuText = labels.getString(""edit.text"");\n    String viewMenuText = labels.getString(""view.text"");\n    String windowMenuText = labels.getString(""window.text"");\n    String helpMenuText = labels.getString(""help.text"");\n    for (JMenu mm : getModel().createMenus(this, v)) {\n      String text = mm.getText();\n      if (text == null) {\n        mm.setText(""-null-"");\n      } else if (text.equals(fileMenuText)) {\n        fileMenu = mm;\n        continue;\n      } else if (text.equals(editMenuText)) {\n        editMenu = mm;\n        continue;\n      } else if (text.equals(viewMenuText)) {\n        viewMenu = mm;\n        continue;\n      } else if (text.equals(windowMenuText)) {\n        windowMenu = mm;\n        continue;\n      } else if (text.equals(helpMenuText)) {\n        helpMenu = mm;\n        continue;\n      }\n      mb.add(mm);\n    }\n    // Create missing standard menus\n    if (fileMenu == null) {\n      fileMenu = createFileMenu(v);\n    }\n    if (editMenu == null) {\n      editMenu = createEditMenu(v);\n    }\n    if (viewMenu == null) {\n      viewMenu = createViewMenu(v);\n    }\n    if (windowMenu == null) {\n      windowMenu = createWindowMenu(v);\n    }\n    if (helpMenu == null) {\n      helpMenu = createHelpMenu(v);\n    }\n    // Insert standard menus into menu bar\n    if (fileMenu != null) {\n      mb.add(fileMenu, 0);\n    }\n    if (editMenu != null) {\n      mb.add(editMenu, Math.min(1, mb.getComponentCount()));\n    }\n    if (viewMenu != null) {\n      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));\n    }\n    if (windowMenu != null) {\n      mb.add(windowMenu);\n    }\n    if (helpMenu != null) {\n      mb.add(helpMenu);\n    }\n    return mb;\n"
270,addDisposable,AbstractView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java,238,242,6,"/**\n   * Adds a disposable object, which will be disposed when the specified view\n   * is disposed.\n   *\n   * @param disposable\n   */",5,  public void addDisposable(Disposable disposable) {\n    if (disposables == null) {\n      disposables = new LinkedList<Disposable>();\n    }\n    disposables.add(disposable);\n
271,initComponents,AbstractView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java,152,154,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,2,  private void initComponents() {\n    setLayout(new java.awt.BorderLayout());\n
272,updateViewTitle,OSXApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java,267,283,6,/**\n   * Updates the title of a view and displays it in the given frame.\n   * \n   * @param v The view.\n   * @param f The frame.\n   */,16,"  protected void updateViewTitle(View v, JFrame f) {\n    String title;\n    URI uri = v.getURI();\n    if (uri == null) {\n      title = labels.getString(""unnamedFile"");\n    } else {\n      title = URIUtil.getName(uri);\n    }\n    v.setTitle(labels.getFormatted(""frame.title"", title, getName(), v.getMultipleOpenId()));\n    f.setTitle(v.getTitle());\n    // Adds a proxy icon for the file to the title bar\n    // See http://developer.apple.com/technotes/tn2007/tn2196.html#WINDOW_DOCUMENTFILE\n    if (uri != null && uri.getScheme() != null && uri.getScheme().equals(""file"")) {\n      f.getRootPane().putClientProperty(""Window.documentFile"", new File(uri));\n    } else {\n      f.getRootPane().putClientProperty(""Window.documentFile"", null);\n"
273,hasUnsavedChanges,AbstractView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java,176,177,4,"/**\n   * Returns true, if the view has unsaved changes.\n   * This is a bound property.\n   */",2,  public boolean hasUnsavedChanges() {\n    return hasUnsavedChanges;\n
277,getComponent,OSXApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/OSXApplication.java,557,571,2,/** Returns the Frame which holds the frameless JMenuBar.\n   */,15,"  public Component getComponent() {\n    if (invisibleFrame == null) {\n      invisibleFrame = new JFrame();\n      invisibleFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);\n      invisibleFrame.setUndecorated(true);\n      // Move it way off screen\n      invisibleFrame.setLocation(10000, 10000);\n      // make the frame transparent and shadowless\n      // see https://developer.apple.com/mac/library/technotes/tn2007/tn2196.html\n      invisibleFrame.getRootPane().putClientProperty(""Window.alpha"", 0f);\n      invisibleFrame.getRootPane().putClientProperty(""Window.shadow"", false);\n      // make it visible, so the menu bar will show\n      invisibleFrame.setVisible(true);\n    }\n    return invisibleFrame;\n"
278,addExternalEntity,XMLEntityResolver,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java,102,107,7,"/**\n  * Adds an external entity.\n  *\n  * @param name the name of the entity.\n  * @param publicID the public ID of the entity, which may be null.\n  * @param systemID the system ID of the entity.\n  */",6,"   public void addExternalEntity(String name,\n                 String publicID,\n                 String systemID)\n   {\n    if (! this.entities.containsKey(name)) {\n     this.entities.put(name, new String[] { publicID, systemID } );\n"
279,execute,AbstractView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java,191,195,5,/**\n   * Executes the specified runnable on the worker thread of the view.\n   * Execution is perfomred sequentially in the same sequence as the\n   * runnables have been passed to this method.\n   */,5,  public void execute(Runnable worker) {\n    if (executor == null) {\n      executor = Executors.newSingleThreadExecutor();\n    }\n    executor.execute(worker);\n
280,isExternalEntity,XMLEntityResolver,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java,142,145,5,/**\n  * Returns true if an entity is external.\n  *\n  * @param name the name of the entity.\n  */,4,   public boolean isExternalEntity(String name)\n   {\n    Object obj = this.entities.get(name);\n    return ! (obj instanceof java.lang.String);\n
281,dispose,AbstractView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java,111,125,4,/**\n   * Gets rid of all the resources of the view.\n   * No other methods should be invoked on the view afterwards.\n   */,13,"      @SuppressWarnings(""unchecked"")\n  public void dispose() {\n    if (executor != null) {\n      executor.shutdown();\n      executor = null;\n    }\n    if (disposables != null) {\n      for (Disposable d : (LinkedList<Disposable>)disposables.clone()) {\n        d.dispose();\n      }\n      disposables = null;\n    }\n    removeAll();\n"
283,addInternalEntity,XMLEntityResolver,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java,86,90,6,/**\n  * Adds an internal entity.\n  *\n  * @param name the name of the entity.\n  * @param value the value of the entity.\n  */,5,"   public void addInternalEntity(String name,\n                 String value)\n   {\n    if (! this.entities.containsKey(name)) {\n     this.entities.put(name, value);\n"
284,AbstractView,AbstractView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractView.java,78,79,3,/**\n   * Creates a new instance.\n   */,2,  public AbstractView() {\n    preferences = PreferencesUtil.userNodeForPackage(getClass());\n
286,XMLEntityResolver,XMLEntityResolver,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java,57,64,3,/**\n  * Initializes the resolver.\n  */,8,"   public XMLEntityResolver()\n   {\n    this.entities = new Hashtable();\n    this.entities.put(""amp"", ""&#38;"");\n    this.entities.put(""quot"", ""&#34;"");\n    this.entities.put(""apos"", ""&#39;"");\n    this.entities.put(""lt"", ""&#60;"");\n    this.entities.put(""gt"", ""&#62;"");\n"
287,getEntity,XMLEntityResolver,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java,120,132,8,"/**\n  * Returns a Java reader containing the value of an entity.\n  *\n  * @param xmlReader the current XML reader\n  * @param name the name of the entity.\n  *\n  * @return the reader, or null if the entity could not be resolved.\n  */",12,"   public Reader getEntity(IXMLReader xmlReader,\n               String   name)\n    throws XMLParseException\n   {\n    Object obj = this.entities.get(name);\n    if (obj == null) {\n     return null;\n    } else if (obj instanceof java.lang.String) {\n     return new StringReader((String)obj);\n    } else {\n     String[] id = (String[]) obj;\n     return this.openExternalEntity(xmlReader, id[0], id[1]);\n"
288,finalize,XMLEntityResolver,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLEntityResolver.java,71,76,3,/**\n  * Cleans up the object when it's destroyed.\n  */,6,   protected void finalize()\n    throws Throwable\n   {\n    this.entities.clear();\n    this.entities = null;\n    super.finalize();\n
289,XMLWriter,XMLWriter,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java,79,81,5,/**\n  * Creates a new XML writer.\n  *\n  * @param stream where to write the output to.\n  */,3,   public XMLWriter(OutputStream stream)\n   {\n    this.writer = new PrintWriter(stream);\n
291,write,XMLWriter,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java,148,261,8,/**\n  * Writes an XML element.\n  *\n  * @param xml the non-null XML element to write.\n  * @param prettyPrint if spaces need to be inserted to make the output more\n  *          readable\n  * @param indent how many spaces to indent the element.\n  */,95,"   public void write(IXMLElement xml,\n           boolean   prettyPrint,\n           int     indent,\n           boolean   collapseEmptyElements)\n    throws IOException\n   {\n    if (prettyPrint) {\n     for (int i = 0; i < indent; i++) {\n      this.writer.print(\' \');\n     }\n    }\n    if (xml.getName() == null) {\n     if (xml.getContent() != null) {\n      if (prettyPrint) {\n         this.writeEncoded(xml.getContent().trim());\n         writer.println();\n      } else {\n         this.writeEncoded(xml.getContent());\n      }\n     }\n    } else {\n     this.writer.print(\'<\');\n     this.writer.print(xml.getFullName());\n     Vector nsprefixes = new Vector();\n     if (xml.getNamespace() != null) {\n      if (xml.getName().equals(xml.getFullName())) {\n         this.writer.print("" xmlns=\\"""" + xml.getNamespace() + \'""\');\n      } else {\n         String prefix = xml.getFullName();\n         prefix = prefix.substring(0, prefix.indexOf(\':\'));\n         nsprefixes.addElement(prefix);\n         this.writer.print("" xmlns:"" + prefix);\n         this.writer.print(""=\\"""" + xml.getNamespace() + ""\\"""");\n      }\n     }\n     Iterator enm = xml.iterateAttributeNames();\n     while (enm.hasNext()) {\n      String key = (String) enm.next();\n      int index = key.indexOf(\':\');\n      if (index >= 0) {\n         String namespace = xml.getAttributeNamespace(key);\n         if (namespace != null) {\n          String prefix = key.substring(0, index);\n          if (! nsprefixes.contains(prefix)) {\n           this.writer.print("" xmlns:"" + prefix);\n           this.writer.print(""=\\"""" + namespace + \'""\');\n           nsprefixes.addElement(prefix);\n          }\n         }\n      }\n     }\n     enm = xml.iterateAttributeNames();\n     while (enm.hasNext()) {\n      String key = (String) enm.next();\n      String value = xml.getAttribute(key, null);\n      this.writer.print("" "" + key + ""=\\"""");\n      this.writeEncoded(value);\n      this.writer.print(\'""\');\n     }\n     if ((xml.getContent() != null)\n       && (xml.getContent().length() > 0)) {\n      writer.print(\'>\');\n      this.writeEncoded(xml.getContent());\n      writer.print(""</"" + xml.getFullName() + \'>\');\n      if (prettyPrint) {\n         writer.println();\n      }\n     } else if (xml.hasChildren() || (! collapseEmptyElements)) {\n      writer.print(\'>\');\n      if (prettyPrint) {\n         writer.println();\n      }\n      enm = xml.iterateChildren();\n      while (enm.hasNext()) {\n         IXMLElement child = (IXMLElement) enm.next();\n         this.write(child, prettyPrint, indent + 4,\n              collapseEmptyElements);\n      }\n      if (prettyPrint) {\n         for (int i = 0; i < indent; i++) {\n          this.writer.print(\' \');\n         }\n      }\n      this.writer.print(""</"" + xml.getFullName() + "">"");\n      if (prettyPrint) {\n         writer.println();\n      }\n     } else {\n      this.writer.print(""/>"");\n      if (prettyPrint) {\n         writer.println();\n      }\n     }\n    }\n    this.writer.flush();\n"
292,write,XMLWriter,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java,101,104,5,/**\n  * Writes an XML element.\n  *\n  * @param xml the non-null XML element to write.\n  */,4,"   public void write(IXMLElement xml)\n    throws IOException\n   {\n    this.write(xml, false, 0, true);\n"
295,XMLWriter,XMLWriter,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLWriter.java,64,69,5,/**\n  * Creates a new XML writer.\n  *\n  * @param writer where to write the output to.\n  */,6,   public XMLWriter(Writer writer)\n   {\n    if (writer instanceof PrintWriter) {\n     this.writer = (PrintWriter) writer;\n    } else {\n     this.writer = new PrintWriter(writer);\n
297,createMenuBar,MDIApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/MDIApplication.java,384,455,3,/**\n   * Creates a menu bar.\n   */,68,"  protected JMenuBar createMenuBar(View v) {\n    JMenuBar mb = new JMenuBar();\n    // Get menus from application model\n    JMenu fileMenu = null;\n    JMenu editMenu = null;\n    JMenu helpMenu = null;\n    JMenu viewMenu = null;\n    JMenu windowMenu = null;\n    String fileMenuText = labels.getString(""file.text"");\n    String editMenuText = labels.getString(""edit.text"");\n    String viewMenuText = labels.getString(""view.text"");\n    String windowMenuText = labels.getString(""window.text"");\n    String helpMenuText = labels.getString(""help.text"");\n    for (JMenu mm : getModel().createMenus(this, v)) {\n      String text = mm.getText();\n      if (text == null) {\n        mm.setText(""-null-"");\n      } else if (text.equals(fileMenuText)) {\n        fileMenu = mm;\n        continue;\n      } else if (text.equals(editMenuText)) {\n        editMenu = mm;\n        continue;\n      } else if (text.equals(viewMenuText)) {\n        viewMenu = mm;\n        continue;\n      } else if (text.equals(windowMenuText)) {\n        windowMenu = mm;\n        continue;\n      } else if (text.equals(helpMenuText)) {\n        helpMenu = mm;\n        continue;\n      }\n      mb.add(mm);\n    }\n    // Create missing standard menus\n    if (fileMenu == null) {\n      fileMenu = createFileMenu(v);\n    }\n    if (editMenu == null) {\n      editMenu = createEditMenu(v);\n    }\n    if (viewMenu == null) {\n      viewMenu = createViewMenu(v);\n    }\n    if (windowMenu == null) {\n      windowMenu = createWindowMenu(v);\n    }\n    if (helpMenu == null) {\n      helpMenu = createHelpMenu(v);\n    }\n    // Insert standard menus into menu bar\n    if (fileMenu != null) {\n      mb.add(fileMenu, 0);\n    }\n    if (editMenu != null) {\n      mb.add(editMenu, Math.min(1, mb.getComponentCount()));\n    }\n    if (viewMenu != null) {\n      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));\n    }\n    if (windowMenu != null) {\n      mb.add(windowMenu);\n    }\n    if (helpMenu != null) {\n      mb.add(helpMenu);\n    }\n    return mb;\n"
298,wrapDesktopPane,MDIApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/MDIApplication.java,365,378,3,/**\n   * Returns the wrapped desktop pane.\n   */,14,"  protected Component wrapDesktopPane(Component c, LinkedList<Action> toolBarActions) {\n    if (getModel() != null) {\n      int id = 0;\n      for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, null))) {\n        id++;\n        JPanel panel = new JPanel(new BorderLayout());\n        panel.add(tb, BorderLayout.NORTH);\n        panel.add(c, BorderLayout.CENTER);\n        c = panel;\n        PreferencesUtil.installToolBarPrefsHandler(prefs, ""toolbar."" + id, tb);\n        toolBarActions.addFirst(new ToggleToolBarAction(tb, tb.getName()));\n      }\n    }\n    return c;\n"
299,getNamespace,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,312,313,6,"/**\n   * Returns the namespace of the element.\n   *\n   * @return the namespace, or null if no namespace is associated with the\n   *     element.\n   */",2,  public String getNamespace() {\n    return this.namespace;\n
300,getChildren,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,464,465,5,/**\n   * Returns a vector containing all the child iterator.\n   *\n   * @return the vector.\n   */,2,  public ArrayList getChildren() {\n    return this.children;\n
301,maybeAddSeparator,AbstractApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,306,307,2,"/** Adds a separator to the supplied menu. The separator will only\n  be added, if additional items are added using addAction. */",2,"  protected void maybeAddSeparator(JMenu m) {\n    m.putClientProperty(""needsSeparator"", Boolean.TRUE);\n"
302,addAction,AbstractApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,275,276,1,/** Adds the specified action as a menu item to the supplied menu. */,2,"  protected void addAction(JMenu m, View view, String actionID) {\n    addAction(m, getAction(view, actionID));\n"
304,setActiveView,AbstractApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,138,147,6,"/**\n   * Sets the active view. Calls deactivate on the previously\n   * active view, and then calls activate on the given view.\n   * \n   * @param newValue Active view, can be null.\n   */",10,"  public void setActiveView(View newValue) {\n    View oldValue = activeView;\n    if (activeView != null) {\n      activeView.deactivate();\n    }\n    activeView = newValue;\n    if (activeView != null) {\n      activeView.activate();\n    }\n    firePropertyChange(ACTIVE_VIEW_PROPERTY, oldValue, newValue);\n"
305,hasChildren,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,444,445,5,/**\n   * Returns whether the element has children.\n   *\n   * @return true if the element has children.\n   */,2,  public boolean hasChildren() {\n    return (! this.children.isEmpty());\n
306,getAttributeType,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,828,834,8,"/**\n   * Returns the type of an attribute.\n   *\n   * @param name the non-null name of the attribute.\n   * @param namespace the namespace URI, which may be null.\n   *\n   * @return the type, or null if the attribute does not exist.\n   */",7,"  public String getAttributeType(String name,\n      String namespace) {\n    XMLAttribute attr = this.findAttribute(name, namespace);\n    if (attr == null) {\n      return null;\n    } else {\n      return attr.getType();\n"
307,AbstractSelectionAction,AbstractSelectionAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractSelectionAction.java,49,66,5,/** Creates a new instance which acts on the specified component.\n   *\n   * @param target The target of the action. Specify null for the currently\n   * focused component.\n   */,16,"  public AbstractSelectionAction(JComponent target) {\n    this.target = target;\n    if (target != null) {\n      // Register with a weak reference on the JComponent.\n      propertyHandler = new PropertyChangeListener() {\n        @Override\n        public void propertyChange(PropertyChangeEvent evt) {\n          String n = evt.getPropertyName();\n          if (n.equals(""enabled"")) {\n            updateEnabled();\n          } else if (n.equals(EditableComponent.SELECTION_EMPTY_PROPERTY)) {\n            updateEnabled();\n          }\n        }\n      };\n      target.addPropertyChangeListener(new WeakPropertyChangeListener(propertyHandler));\n"
308,addChild,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,354,368,5,/**\n   * Adds a child element.\n   *\n   * @param child the non-null child to add.\n   */,15,"  public void addChild(IXMLElement child) {\n    if (child == null) {\n      throw new IllegalArgumentException(""child must not be null"");\n    }\n    if ((child.getName() == null) && (! this.children.isEmpty())) {\n      IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);\n      \n      if (lastChild.getName() == null) {\n        lastChild.setContent(lastChild.getContent()\n        + child.getContent());\n        return;\n      }\n    }\n    ((XMLElement)child).parent = this;\n    this.children.add(child);\n"
310,getFirstChildNamed,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,513,530,8,"/**\n   * Searches a child element.\n   *\n   * @param name    the name of the child to search for.\n   * @param namespace the namespace, which may be null.\n   *\n   * @return the child element, or null if no such child was found.\n   */",18,"  public IXMLElement getFirstChildNamed(String name,\n      String namespace) {\n    Iterator enm = this.children.iterator();\n    while (enm.hasNext()) {\n      IXMLElement child = (IXMLElement) enm.next();\n      String str = child.getName();\n      boolean found = (str != null) && (str.equals(name));\n      str = child.getNamespace();\n      if (str == null) {\n        found &= (name == null);\n      } else {\n        found &= str.equals(namespace);\n      }\n      if (found) {\n        return child;\n      }\n    }\n    return null;\n"
311,addAction,AbstractApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,280,289,1,/** Adds the specified action as a menu item to the supplied menu. */,10,"  protected void addAction(JMenu m, Action a) {\n    if (a != null) {\n      if (m.getClientProperty(""needsSeparator"") == Boolean.TRUE) {\n        m.addSeparator();\n        m.putClientProperty(""needsSeparator"", null);\n      }\n      JMenuItem mi;\n      mi = m.add(a);\n      mi.setIcon(null);\n      mi.setToolTipText(null);\n"
312,getActiveView,AbstractApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,155,156,5,/**\n   * Gets the active view.\n   * \n   * @return The active view can be null.\n   */,2,  public View getActiveView() {\n    return activeView;\n
313,removeChildAtIndex,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,414,415,5,"/**\n   * Removes the child located at a certain index.\n   *\n   * @param index the index of the child, where the first child has index 0.\n   */",2,  public void removeChildAtIndex(int index) {\n    this.children.remove(index);\n
314,setActionMap,AbstractApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,536,537,3,/**\n   * Sets the application-wide action map.\n   */,2,  public void setActionMap(ActionMap m) {\n    actionMap = m;\n
315,getFullName,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,291,292,6,"/**\n   * Returns the full name (i.e. the name including an eventual namespace\n   * prefix) of the element.\n   *\n   * @return the name, or null if the element only contains #PCDATA.\n   */",2,  public String getFullName() {\n    return this.fullName;\n
316,getParent,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,280,281,4,/**\n   * Returns the parent element. This method returns null for the root\n   * element.\n   */,2,  public IXMLElement getParent() {\n    return this.parent;\n
319,setAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,845,852,6,/**\n   * Sets an attribute.\n   *\n   * @param name the non-null full name of the attribute.\n   * @param value the non-null value of the attribute.\n   */,8,"  public void setAttribute(String name,\n      String value) {\n    XMLAttribute attr = this.findAttribute(name);\n    if (attr == null) {\n      attr = new XMLAttribute(name, name, null, value, ""CDATA"");\n      this.attributes.add(attr);\n    } else {\n      attr.setValue(value);\n"
320,addMenuItem,AbstractApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,294,300,1,/** Adds the specified action as a menu item to the supplied menu. */,7,"  protected void addMenuItem(JMenu m, JMenuItem mi) {\n    if (mi != null) {\n      if (m.getClientProperty(""needsSeparator"") == Boolean.TRUE) {\n        m.addSeparator();\n        m.putClientProperty(""needsSeparator"", null);\n      }\n      m.add(mi);\n"
321,equals,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,1053,1057,5,/**\n   * Returns true if the element equals another element.\n   *\n   * @param rawElement the element to compare to\n   */,5,  public boolean equals(Object rawElement) {\n    try {\n      return this.equalsXMLElement((IXMLElement) rawElement);\n    } catch (ClassCastException e) {\n      return false;\n
322,getName,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,301,302,5,"/**\n   * Returns the name of the element.\n   *\n   * @return the name, or null if the element only contains #PCDATA.\n   */",2,  public String getName() {\n    return this.name;\n
324,getAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,725,728,8,"/**\n   * Returns the value of an attribute.\n   *\n   * @param name the non-null full name of the attribute.\n   * @param defaultValue the default value of the attribute.\n   *\n   * @return the value, or defaultValue if the attribute does not exist.\n   */",4,"  public int getAttribute(String name,\n      int  defaultValue) {\n    String value = this.getAttribute(name, Integer.toString(defaultValue));\n    return Integer.parseInt(value);\n"
326,XMLElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,135,136,5,/**\n   * Creates an empty element.\n   *\n   * @param fullName the name of the element.\n   */,2,"  public XMLElement(String fullName) {\n    this(fullName, null, null, NO_LINE);\n"
329,XMLElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,125,126,3,/**\n   * Creates an empty element to be used for #PCDATA content.\n   */,2,"  public XMLElement() {\n    this(null, null, null, NO_LINE);\n"
331,getContent,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,1032,1033,8,"/**\n   * Return the #PCDATA content of the element. If the element has a\n   * combination of #PCDATA content and child iterator, the #PCDATA\n   * sections can be retrieved as unnamed child objects. In this case,\n   * this method returns null.\n   *\n   * @return the content.\n   */",2,  public String getContent() {\n    return this.content;\n
333,createElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,224,227,7,/**\n   * Creates an empty element.\n   *\n   * @param fullName the name of the element.\n   * @param systemID the system ID of the XML data where the element starts.\n   * @param lineNr   the line in the XML data where the element starts.\n   */,4,"  public IXMLElement createElement(String fullName,\n      String systemID,\n      int  lineNr) {\n    return new XMLElement(fullName, systemID, lineNr);\n"
337,updateOpenRecentMenu,OpenRecentMenuHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/AbstractApplication.java,393,428,3,"/**\n     * Updates the ""File &gt; Open Recent"" menu.\n     */",33,"    protected void updateOpenRecentMenu() {\n      if (openRecentMenu.getItemCount() > 0) {\n        JMenuItem clearRecentFilesItem = (JMenuItem) openRecentMenu.getItem(\n            openRecentMenu.getItemCount() - 1);\n        openRecentMenu.remove(openRecentMenu.getItemCount() - 1);\n        // Dispose the actions and the menu items that are currently in the menu\n        for (Action action : openRecentActions) {\n          if (action instanceof Disposable) {\n            ((Disposable) action).dispose();\n          }\n        }\n        openRecentActions.clear();\n        openRecentMenu.removeAll();\n        // Create new actions and add them to the menu\n        if (getAction(view, LoadFileAction.ID) != null || //\n            getAction(view, LoadDirectoryAction.ID) != null) {\n          for (URI f : getRecentURIs()) {\n            LoadRecentFileAction action = new LoadRecentFileAction(AbstractApplication.this, view, f);\n            openRecentMenu.add(action);\n            openRecentActions.add(action);\n          }\n        } else {\n          for (URI f : getRecentURIs()) {\n            OpenRecentFileAction action = new OpenRecentFileAction(AbstractApplication.this, f);\n            openRecentMenu.add(action);\n            openRecentActions.add(action);\n          }\n        }\n        if (getRecentURIs().size() > 0) {\n          openRecentMenu.addSeparator();\n        }\n        // Add a separator and the clear recent files item.\n        openRecentMenu.add(clearRecentFilesItem);\n"
338,getAttributesInNamespace,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,980,995,7,"/**\n   * Returns all attributes in a specific namespace as a Properties object.\n   *\n   * @param namespace the namespace URI of the attributes, which may be null.\n   *\n   * @return the non-null set.\n   */",16,"  public Properties getAttributesInNamespace(String namespace) {\n    Properties result = new Properties();\n    Iterator enm = this.attributes.iterator();\n    while (enm.hasNext()) {\n      XMLAttribute attr = (XMLAttribute) enm.next();\n      if (namespace == null) {\n        if (attr.getNamespace() == null) {\n          result.put(attr.getName(), attr.getValue());\n        }\n      } else {\n        if (namespace.equals(attr.getNamespace())) {\n          result.put(attr.getName(), attr.getValue());\n        }\n      }\n    }\n    return result;\n"
343,equalsXMLElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,1067,1103,5,/**\n   * Returns true if the element equals another element.\n   *\n   * @param elt the element to compare to\n   */,37,"  public boolean equalsXMLElement(IXMLElement elt) {\n    if (! this.name.equals(elt.getName())) {\n      return false;\n    }\n    if (this.attributes.size() != elt.getAttributeCount()) {\n      return false;\n    }\n    Iterator enm = this.attributes.iterator();\n    while (enm.hasNext()) {\n      XMLAttribute attr = (XMLAttribute) enm.next();\n      if (! elt.hasAttribute(attr.getName(), attr.getNamespace())) {\n        return false;\n      }\n      String value = elt.getAttribute(attr.getName(),\n          attr.getNamespace(),\n          null);\n      if (! attr.getValue().equals(value)) {\n        return false;\n      }\n      String type = elt.getAttributeType(attr.getName(),\n          attr.getNamespace());\n      if (! attr.getType().equals(type)) {\n        return false;\n      }\n    }\n    if (this.children.size() != elt.getChildrenCount()) {\n      return false;\n    }\n    for (int i = 0; i < this.children.size(); i++) {\n      IXMLElement child1 = this.getChildAtIndex(i);\n      IXMLElement child2 = elt.getChildAtIndex(i);\n      \n      if (! child1.equalsXMLElement(child2)) {\n        return false;\n      }\n    }\n    return true;\n"
346,getLineNr,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,1019,1020,8,"/**\n   * Returns the line number in the data where the element started.\n   *\n   * @return the line number, or NO_LINE if unknown.\n   *\n   * @see #NO_LINE\n   * @see #getSystemID\n   */",2,  public int getLineNr() {\n    return this.lineNr;\n
348,removeChild,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,401,405,5,/**\n   * Removes a child element.\n   *\n   * @param child the non-null child to remove.\n   */,5,"  public void removeChild(IXMLElement child) {\n    if (child == null) {\n      throw new IllegalArgumentException(""child must not be null"");\n    }\n    this.children.remove(child);\n"
350,createPCDataElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,202,203,3,/**\n   * Creates an element to be used for #PCDATA content.\n   */,2,  public IXMLElement createPCDataElement() {\n    return new XMLElement();\n
353,XMLElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,160,162,6,/**\n   * Creates an empty element.\n   *\n   * @param fullName  the full name of the element\n   * @param namespace the namespace URI.\n   */,3,"  public XMLElement(String fullName,\n      String namespace) {\n    this(fullName, namespace, null, NO_LINE);\n"
355,getAttributeNamespace,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,810,815,7,"/**\n   * Returns the namespace of an attribute.\n   *\n   * @param name the non-null full name of the attribute.\n   *\n   * @return the namespace, or null if there is none associated.\n   */",6,  public String getAttributeNamespace(String name) {\n    XMLAttribute attr = this.findAttribute(name);\n    if (attr == null) {\n      return null;\n    } else {\n      return attr.getNamespace();\n
358,getChildrenNamed,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,541,551,7,/**\n   * Returns a vector of all child iterator named <I>name</I>.\n   *\n   * @param name the full name of the children to search for.\n   *\n   * @return the non-null vector of child iterator.\n   */,11,  public ArrayList getChildrenNamed(String name) {\n    ArrayList result = new ArrayList(this.children.size());\n    Iterator enm = this.children.iterator();\n    while (enm.hasNext()) {\n      IXMLElement child = (IXMLElement) enm.next();\n      String childName = child.getFullName();\n      if ((childName != null) && childName.equals(name)) {\n        result.add(child);\n      }\n    }\n    return result;\n
361,createElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,251,255,8,/**\n   * Creates an empty element.\n   *\n   * @param fullName  the full name of the element\n   * @param namespace the namespace URI.\n   * @param systemID  the system ID of the XML data where the element starts.\n   * @param lineNr  the line in the XML data where the element starts.\n   */,5,"  public IXMLElement createElement(String fullName,\n      String namespace,\n      String systemID,\n      int  lineNr) {\n    return new XMLElement(fullName, namespace, systemID, lineNr);\n"
363,getAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,683,690,9,"/**\n   * Returns the value of an attribute.\n   *\n   * @param name the non-null name of the attribute.\n   * @param namespace the namespace URI, which may be null.\n   * @param defaultValue the default value of the attribute.\n   *\n   * @return the value, or defaultValue if the attribute does not exist.\n   */",8,"  public String getAttribute(String name,\n      String namespace,\n      String defaultValue) {\n    XMLAttribute attr = this.findAttribute(name, namespace);\n    if (attr == null) {\n      return defaultValue;\n    } else {\n      return attr.getValue();\n"
365,getAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,741,746,9,"/**\n   * Returns the value of an attribute.\n   *\n   * @param name the non-null name of the attribute.\n   * @param namespace the namespace URI, which may be null.\n   * @param defaultValue the default value of the attribute.\n   *\n   * @return the value, or defaultValue if the attribute does not exist.\n   */",6,"  public int getAttribute(String name,\n      String namespace,\n      int  defaultValue) {\n    String value = this.getAttribute(name, namespace,\n        Integer.toString(defaultValue));\n    return Integer.parseInt(value);\n"
368,getFirstChildNamed,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,492,501,7,"/**\n   * Searches a child element.\n   *\n   * @param name the full name of the child to search for.\n   *\n   * @return the child element, or null if no such child was found.\n   */",10,  public IXMLElement getFirstChildNamed(String name) {\n    Iterator enm = this.children.iterator();\n    while (enm.hasNext()) {\n      IXMLElement child = (IXMLElement) enm.next();\n      String childName = child.getFullName();\n      if ((childName != null) && childName.equals(name)) {\n        return child;\n      }\n    }\n    return null;\n
370,getAttributeCount,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,636,637,3,/**\n   * Returns the number of attributes.\n   */,2,  public int getAttributeCount() {\n    return this.attributes.size();\n
372,XMLElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,147,150,7,/**\n   * Creates an empty element.\n   *\n   * @param fullName the name of the element.\n   * @param systemID the system ID of the XML data where the element starts.\n   * @param lineNr   the line in the XML data where the element starts.\n   */,4,"  public XMLElement(String fullName,\n      String systemID,\n      int  lineNr) {\n    this(fullName, null, systemID, lineNr);\n"
374,XMLElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,174,195,8,/**\n   * Creates an empty element.\n   *\n   * @param fullName  the full name of the element\n   * @param namespace the namespace URI.\n   * @param systemID  the system ID of the XML data where the element starts.\n   * @param lineNr  the line in the XML data where the element starts.\n   */,22,"  public XMLElement(String fullName,\n      String namespace,\n      String systemID,\n      int  lineNr) {\n    this.attributes = new ArrayList();\n    this.children = new ArrayList(8);\n    this.fullName = fullName;\n    if (namespace == null) {\n      this.name = fullName;\n    } else {\n      int index = fullName.indexOf(':');\n      if (index >= 0) {\n        this.name = fullName.substring(index + 1);\n      } else {\n        this.name = fullName;\n      }\n    }\n    this.namespace = namespace;\n    this.content = null;\n    this.lineNr = lineNr;\n    this.systemID = systemID;\n    this.parent = null;\n"
375,createElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,212,213,5,/**\n   * Creates an empty element.\n   *\n   * @param fullName the name of the element.\n   */,2,  public IXMLElement createElement(String fullName) {\n    return new XMLElement(fullName);\n
376,setName,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,336,345,6,"/**\n   * Sets the name.\n   *\n   * @param fullName  the non-null full name.\n   * @param namespace the namespace URI, which may be null.\n   */",10,"  public void setName(String fullName,\n      String namespace) {\n    int index = fullName.indexOf(':');\n    if ((namespace == null) || (index < 0)) {\n      this.name = fullName;\n    } else {\n      this.name = fullName.substring(index + 1);\n    }\n    this.fullName = fullName;\n    this.namespace = namespace;\n"
377,hasAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,941,942,5,/**\n   * Returns whether an attribute exists.\n   *\n   * @return true if the attribute exists.\n   */,2,  public boolean hasAttribute(String name) {\n    return this.findAttribute(name) != null;\n
378,removeAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,884,889,5,/**\n   * Removes an attribute.\n   *\n   * @param name the non-null name of the attribute.\n   */,6,  public void removeAttribute(String name) {\n    for (int i = 0; i < this.attributes.size(); i++) {\n      XMLAttribute attr = (XMLAttribute) this.attributes.get(i);\n      if (attr.getFullName().equals(name)) {\n        this.attributes.remove(i);\n        return;\n
379,createElement,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,237,239,6,/**\n   * Creates an empty element.\n   *\n   * @param fullName  the full name of the element\n   * @param namespace the namespace URI.\n   */,3,"  public IXMLElement createElement(String fullName,\n      String namespace) {\n    return new XMLElement(fullName, namespace);\n"
381,getAttributes,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,962,969,5,/**\n   * Returns all attributes as a Properties object.\n   *\n   * @return the non-null set.\n   */,8,"  public Properties getAttributes() {\n    Properties result = new Properties();\n    Iterator enm = this.attributes.iterator();\n    while (enm.hasNext()) {\n      XMLAttribute attr = (XMLAttribute) enm.next();\n      result.put(attr.getFullName(), attr.getValue());\n    }\n    return result;\n"
382,isLeaf,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,434,435,5,/**\n   * Returns whether the element is a leaf element.\n   *\n   * @return true if the element has no children.\n   */,2,  public boolean isLeaf() {\n    return this.children.isEmpty();\n
383,findAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,593,601,7,"/**\n   * Searches an attribute.\n   *\n   * @param fullName the non-null full name of the attribute.\n   *\n   * @return the attribute, or null if the attribute does not exist.\n   */",9,  private XMLAttribute findAttribute(String fullName) {\n    Iterator enm = this.attributes.iterator();\n    while (enm.hasNext()) {\n      XMLAttribute attr = (XMLAttribute) enm.next();\n      if (attr.getFullName().equals(fullName)) {\n        return attr;\n      }\n    }\n    return null;\n
384,findAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,613,629,8,"/**\n   * Searches an attribute.\n   *\n   * @param name the non-null short name of the attribute.\n   * @param namespace the name space, which may be null.\n   *\n   * @return the attribute, or null if the attribute does not exist.\n   */",17,"  private XMLAttribute findAttribute(String name,\n      String namespace) {\n    Iterator enm = this.attributes.iterator();\n    while (enm.hasNext()) {\n      XMLAttribute attr = (XMLAttribute) enm.next();\n      boolean found = attr.getName().equals(name);\n      if (namespace == null) {\n        found &= (attr.getNamespace() == null);\n      } else {\n        found &= namespace.equals(attr.getNamespace());\n      }\n      \n      if (found) {\n        return attr;\n      }\n    }\n    return null;\n"
385,getChildrenCount,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,454,455,5,/**\n   * Returns the number of children.\n   *\n   * @return the count.\n   */,2,  public int getChildrenCount() {\n    return this.children.size();\n
386,getDoubleAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,702,712,9,"/**\n   * Returns an attribute of the element.\n   * If the attribute doesn't exist, <code>defaultValue</code> is returned.\n   *\n   * @param name     The name of the attribute.\n   * @param namespace the namespace URI, which may be null.\n   * @param defaultValue Key to use if the attribute is missing.\n   *\n   */",11,"  public double getDoubleAttribute(String name,\n      String namespace,\n      double defaultValue) {\n    XMLAttribute attr = this.findAttribute(name, namespace);\n    if (attr == null) {\n      return defaultValue;\n    } else {\n      try {\n        return Double.parseDouble(attr.getValue());\n      } catch (NumberFormatException e) {\n        return defaultValue;\n"
387,getChildrenNamed,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,563,582,8,"/**\n   * Returns a vector of all child iterator named <I>name</I>.\n   *\n   * @param name    the name of the children to search for.\n   * @param namespace the namespace, which may be null.\n   *\n   * @return the non-null vector of child iterator.\n   */",20,"  public ArrayList getChildrenNamed(String name,\n      String namespace) {\n    ArrayList result = new ArrayList(this.children.size());\n    Iterator enm = this.children.iterator();\n    while (enm.hasNext()) {\n      IXMLElement child = (IXMLElement) enm.next();\n      String str = child.getName();\n      boolean found = (str != null) && (str.equals(name));\n      str = child.getNamespace();\n      if (str == null) {\n        found &= (name == null);\n      } else {\n        found &= str.equals(namespace);\n      }\n      \n      if (found) {\n        result.add(child);\n      }\n    }\n    return result;\n"
388,getAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,775,782,27,"/**\n   * Returns an attribute by looking up a key in a hashtable.\n   * If the attribute doesn\'t exist, the value corresponding to defaultKey\n   * is returned.\n   * <P>\n   * As an example, if valueSet contains the mapping <code>""one"" =&gt;\n   * ""1""</code>\n   * and the element contains the attribute <code>attr=""one""</code>, then\n   * <code>getAttribute(""attr"", mapping, defaultKey, false)</code> returns\n   * <code>""1""</code>.\n   *\n   * @param name\n   *   The name of the attribute.\n   * @param namespace the namespace URI, which may be null.\n   * @param valueSet\n   *   HashMap mapping keySet().iterator to values.\n   * @param defaultKey\n   *   Key to use if the attribute is missing.\n   *\n   * </dl><dl><dt><b>Preconditions:</b></dt><dd>\n   * <ul><li><code>name != null</code>\n   *   <li><code>name</code> is a valid XML identifier\n   *   <li><code>valueSet</code> != null\n   *   <li>the keySet().iterator of <code>valueSet</code> are strings\n   * </ul></dd></dl><dl>\n   *\n   */",8,"  public Object getAttribute(String name, String namespace,\n      Map valueSet,\n      String  defaultKey) {\n    String key = this.getAttribute(name, namespace, null);\n    if (key == null || ! valueSet.containsKey(key)) {\n      return valueSet.get(defaultKey);\n    }\n    return valueSet.get(key);\n"
389,getAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,650,651,9,"/**\n   * @deprecated As of NanoXML/Java 2.1, replaced by\n   *       {@link #getAttribute(java.lang.String,java.lang.String)}\n   * Returns the value of an attribute.\n   *\n   * @param name the non-null name of the attribute.\n   *\n   * @return the value, or null if the attribute does not exist.\n   */",2,"  public String getAttribute(String name) {\n    return this.getAttribute(name, null);\n"
390,removeAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,901,914,6,"/**\n   * Removes an attribute.\n   *\n   * @param name the non-null name of the attribute.\n   * @param namespace the namespace URI of the attribute, which may be null.\n   */",14,"  public void removeAttribute(String name,\n      String namespace) {\n    for (int i = 0; i < this.attributes.size(); i++) {\n      XMLAttribute attr = (XMLAttribute) this.attributes.get(i);\n      boolean found = attr.getName().equals(name);\n      if (namespace == null) {\n        found &= (attr.getNamespace() == null);\n      } else {\n        found &= attr.getNamespace().equals(namespace);\n      }\n      \n      if (found) {\n        this.attributes.remove(i);\n        return;\n"
391,setContent,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,1043,1044,6,/**\n   * Sets the #PCDATA content. It is an error to call this method with a\n   * non-null value if there are child objects.\n   *\n   * @param content the (possibly null) content.\n   */,2,  public void setContent(String content) {\n    this.content = content;\n
392,getSystemID,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,1006,1007,7,"/**\n   * Returns the system ID of the data where the element started.\n   *\n   * @return the system ID, or null if unknown.\n   *\n   * @see #getLineNr\n   */",2,  public String getSystemID() {\n    return this.systemID;\n
393,getAttributeType,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,793,798,7,"/**\n   * Returns the type of an attribute.\n   *\n   * @param name the non-null full name of the attribute.\n   *\n   * @return the type, or null if the attribute does not exist.\n   */",6,  public String getAttributeType(String name) {\n    XMLAttribute attr = this.findAttribute(name);\n    if (attr == null) {\n      return null;\n    } else {\n      return attr.getType();\n
395,getChildAtIndex,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,479,481,10,/**\n   * Returns the child at a specific index.\n   *\n   * @param index the index of the child\n   *\n   * @return the non-null child\n   *\n   * @throws java.lang.ArrayIndexOutOfBoundsException\n   *    if the index is out of bounds.\n   */,3,  public IXMLElement getChildAtIndex(int index)\n  throws ArrayIndexOutOfBoundsException {\n    return (IXMLElement) this.children.get(index);\n
396,iterateChildren,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,424,425,5,/**\n   * Returns an enumeration of all child iterator.\n   *\n   * @return the non-null enumeration\n   */,2,  public Iterator iterateChildren() {\n    return this.children.iterator();\n
397,setName,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,323,326,6,/**\n   * Sets the full name. This method also sets the short name and clears the\n   * namespace URI.\n   *\n   * @param name the non-null name.\n   */,4,  public void setName(String name) {\n    this.name = name;\n    this.fullName = name;\n    this.namespace = null;\n
398,insertChild,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,378,392,6,/**\n   * Inserts a child element.\n   *\n   * @param child the non-null child to add.\n   * @param index where to put the child.\n   */,15,"  public void insertChild(IXMLElement child,\n      int     index) {\n    if (child == null) {\n      throw new IllegalArgumentException(""child must not be null"");\n    }\n    if ((child.getName() == null) && (! this.children.isEmpty())) {\n      IXMLElement lastChild = (IXMLElement) this.children.get(this.children.size() - 1);\n      if (lastChild.getName() == null) {\n        lastChild.setContent(lastChild.getContent()\n        + child.getContent());\n        return;\n      }\n    }\n    ((XMLElement) child).parent = this;\n    this.children.add(index, child);\n"
399,getAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,663,669,8,"/**\n   * Returns the value of an attribute.\n   *\n   * @param name the non-null full name of the attribute.\n   * @param defaultValue the default value of the attribute.\n   *\n   * @return the value, or defaultValue if the attribute does not exist.\n   */",7,"  public String getAttribute(String name,\n      String defaultValue) {\n    XMLAttribute attr = this.findAttribute(name);\n    if (attr == null) {\n      return defaultValue;\n    } else {\n      return attr.getValue();\n"
400,createMenuBar,SDIApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java,249,319,3,/**\n   * Creates a menu bar.\n   */,67,"  protected JMenuBar createMenuBar(View v) {\n    JMenuBar mb = new JMenuBar();\n    // Get menus from application model\n    JMenu fileMenu = null;\n    JMenu editMenu = null;\n    JMenu helpMenu = null;\n    JMenu viewMenu = null;\n    JMenu windowMenu = null;\n    String fileMenuText = labels.getString(""file.text"");\n    String editMenuText = labels.getString(""edit.text"");\n    String viewMenuText = labels.getString(""view.text"");\n    String windowMenuText = labels.getString(""window.text"");\n    String helpMenuText = labels.getString(""help.text"");\n    for (JMenu mm : getModel().createMenus(this, v)) {\n      String text = mm.getText();\n      if (text == null) {\n      } else if (text.equals(fileMenuText)) {\n        fileMenu = mm;\n        continue;\n      } else if (text.equals(editMenuText)) {\n        editMenu = mm;\n        continue;\n      } else if (text.equals(viewMenuText)) {\n        viewMenu = mm;\n        continue;\n      } else if (text.equals(windowMenuText)) {\n        windowMenu = mm;\n        continue;\n      } else if (text.equals(helpMenuText)) {\n        helpMenu = mm;\n        continue;\n      }\n      mb.add(mm);\n    }\n    // Create missing standard menus\n    if (fileMenu == null) {\n      fileMenu = createFileMenu(v);\n    }\n    if (editMenu == null) {\n      editMenu = createEditMenu(v);\n    }\n    if (viewMenu == null) {\n      viewMenu = createViewMenu(v);\n    }\n    if (windowMenu == null) {\n      windowMenu = createWindowMenu(v);\n    }\n    if (helpMenu == null) {\n      helpMenu = createHelpMenu(v);\n    }\n    // Insert standard menus into menu bar\n    if (fileMenu != null) {\n      mb.add(fileMenu, 0);\n    }\n    if (editMenu != null) {\n      mb.add(editMenu, Math.min(1, mb.getComponentCount()));\n    }\n    if (viewMenu != null) {\n      mb.add(viewMenu, Math.min(2, mb.getComponentCount()));\n    }\n    if (windowMenu != null) {\n      mb.add(windowMenu);\n    }\n    if (helpMenu != null) {\n      mb.add(helpMenu);\n    }\n    return mb;\n"
401,iterateAttributeNames,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,925,932,5,/**\n   * Returns an enumeration of all attribute names.\n   *\n   * @return the non-null enumeration.\n   */,8,  public Iterator iterateAttributeNames() {\n    ArrayList result = new ArrayList();\n    Iterator enm = this.attributes.iterator();\n    while (enm.hasNext()) {\n      XMLAttribute attr = (XMLAttribute) enm.next();\n      result.add(attr.getFullName());\n    }\n    return result.iterator();\n
402,updateViewTitle,SDIApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java,390,402,6,/**\n   * Updates the title of a view and displays it in the given frame.\n   * \n   * @param view The view.\n   * @param f The frame.\n   */,13,"  protected void updateViewTitle(View view, JFrame f) {\n    URI uri = view.getURI();\n    String title;\n    if (uri == null) {\n      title = labels.getString(""unnamedFile"");\n    } else {\n      title = URIUtil.getName(uri);\n    }\n    if (view.hasUnsavedChanges()) {\n      title += ""*"";\n    }\n    view.setTitle(labels.getFormatted(""frame.title"", title, getName(), view.getMultipleOpenId()));\n    f.setTitle(view.getTitle());\n"
403,setAttribute,XMLElement,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLElement.java,864,874,7,"/**\n   * Sets an attribute.\n   *\n   * @param fullName the non-null full name of the attribute.\n   * @param namespace the namespace URI of the attribute, which may be null.\n   * @param value the non-null value of the attribute.\n   */",11,"  public void setAttribute(String fullName,\n      String namespace,\n      String value) {\n    int index = fullName.indexOf(\':\');\n    String name = fullName.substring(index + 1);\n    XMLAttribute attr = this.findAttribute(name, namespace);\n    if (attr == null) {\n      attr = new XMLAttribute(fullName, name, namespace, value, ""CDATA"");\n      this.attributes.add(attr);\n    } else {\n      attr.setValue(value);\n"
404,wrapViewComponent,SDIApplication,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/SDIApplication.java,209,226,4,/**\n   * Returns the view component. Eventually wraps it into\n   * another component in order to provide additional functionality.\n   */,17,"  protected Component wrapViewComponent(View p) {\n    JComponent c = p.getComponent();\n    if (getModel() != null) {\n      LinkedList<Action> toolBarActions = new LinkedList<Action>();\n      int id = 0;\n      for (JToolBar tb : new ReversedList<JToolBar>(getModel().createToolBars(this, p))) {\n        id++;\n        JPanel panel = new JPanel(new BorderLayout());\n        panel.add(tb, BorderLayout.NORTH);\n        panel.add(c, BorderLayout.CENTER);\n        c = panel;\n        PreferencesUtil.installToolBarPrefsHandler(prefs, ""toolbar."" + id, tb);\n        toolBarActions.addFirst(new ToggleVisibleAction(tb, tb.getName()));\n      }\n      p.getComponent().putClientProperty(""toolBarActions"", toolBarActions);\n    }\n    return c;\n"
405,stringReader,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,97,99,5,/**\n  * Creates a new reader using a string as input.\n  *\n  * @param str the string containing the XML data\n  */,3,   public static IXMLReader stringReader(String str)\n   {\n    return new StdXMLReader(new StringReader(str));\n
406,fileReader,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,113,125,10,/**\n  * Creates a new reader using a file as input.\n  *\n  * @param filename the name of the file containing the XML data\n  *\n  * @throws java.io.FileNotFoundException\n  *   if the file could not be found\n  * @throws java.io.IOException\n  *   if an I/O error occurred\n  */,11,"   public static IXMLReader fileReader(String filename)\n    throws FileNotFoundException,\n       IOException\n   {\n    StdXMLReader r = new StdXMLReader(new FileInputStream(filename));\n    r.setSystemID(filename);\n    for (int i = 0; i < r.readers.size(); i++) {\n     StackedReader sr = (StackedReader) r.readers.elementAt(i);\n     sr.systemId = r.currentReader.systemId;\n    }\n    return r;\n"
407,getSystemID,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,613,615,3,/**\n  * Returns the current system ID.\n  */,3,   public String getSystemID()\n   {\n    return this.currentReader.systemId.toString();\n
408,getLineNr,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,567,579,3,/**\n  * Returns the line number of the data in the current stream.\n  */,11,   public int getLineNr()\n   {\n    if (this.currentReader.lineReader == null) {\n     StackedReader sr = (StackedReader) this.readers.peek();\n     if (sr.lineReader == null) {\n      return 0;\n     } else {\n      return sr.lineReader.getLineNumber() + 1;\n     }\n    }\n    return this.currentReader.lineReader.getLineNumber() + 1;\n
409,StdXMLReader,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,346,365,8,/**\n  * Initializes the XML reader.\n  *\n  * @param stream the input for the XML data.\n  *\n  * @throws java.io.IOException\n  *    if an I/O error occurred\n  */,18,"   public StdXMLReader(InputStream stream)\n    throws IOException\n   {\n    PushbackInputStream pbstream = new PushbackInputStream(stream);\n    StringBuffer charsRead = new StringBuffer();\n    Reader reader = this.stream2reader(stream, charsRead);\n    this.currentReader = new StackedReader();\n    this.readers = new Stack();\n    this.currentReader.lineReader = new LineNumberReader(reader);\n    this.currentReader.pbReader\n     = new PushbackReader(this.currentReader.lineReader, 2);\n    this.currentReader.publicId = """";\n    try {\n     this.currentReader.systemId = new URL(""file:."");\n    } catch (MalformedURLException e) {\n     // never happens\n    }\n    this.startNewStream(new StringReader(charsRead.toString()));\n"
410,getEncoding,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,216,270,7,"/**\n  * Scans the encoding from an &lt;?xml...?&gt; tag.\n  *\n  * @param str the first tag in the XML data.\n  *\n  * @return the encoding, or null if no encoding has been specified.\n  */",42,"   protected String getEncoding(String str)\n   {\n    if (! str.startsWith(""<?xml"")) {\n     return null;\n    }\n    int index = 5;\n    while (index < str.length()) {\n     StringBuffer key = new StringBuffer();\n     while ((index < str.length()) && (str.charAt(index) <= \' \')) {\n      index++;\n     }\n     while ((index < str.length())\n        && (str.charAt(index) >= \'a\')\n        && (str.charAt(index) <= \'z\')) {\n      key.append(str.charAt(index));\n      index++;\n     }\n     while ((index < str.length()) && (str.charAt(index) <= \' \')) {\n      index++;\n     }\n     if ((index >= str.length()) || (str.charAt(index) != \'=\')) {\n      break;\n     }\n     while ((index < str.length()) && (str.charAt(index) != \'\\\'\')\n        && (str.charAt(index) != \'""\')) {\n      index++;\n     }\n     if (index >= str.length()) {\n      break;\n     }\n     char delimiter = str.charAt(index);\n     index++;\n     int index2 = str.indexOf(delimiter, index);\n     if (index2 < 0) {\n      break;\n     }\n     if (key.toString().equals(""encoding"")) {\n      return str.substring(index, index2);\n     }\n     index = index2 + 1;\n    }\n    return null;\n"
411,startNewStream,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,519,521,7,"/**\n  * Starts a new stream from a Java reader. The new stream is used\n  * temporary to read data from. If that stream is exhausted, control\n  * returns to the parent stream.\n  *\n  * @param reader the non-null reader to read the new data from\n  */",3,"   public void startNewStream(Reader reader)\n   {\n    this.startNewStream(reader, false);\n"
412,unread,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,451,454,8,/**\n  * Pushes the last character read back to the stream.\n  *\n  * @param ch the character to push back.\n  *\n  * @throws java.io.IOException\n  *   if an I/O error occurred\n  */,4,   public void unread(char ch)\n    throws IOException\n   {\n    this.currentReader.pbReader.unread(ch);\n
413,setPublicID,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,604,606,5,/**\n  * Sets the public ID of the current stream.\n  *\n  * @param publicID the public ID\n  */,3,   public void setPublicID(String publicID)\n   {\n    this.currentReader.publicId = publicID;\n
414,stream2reader,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,283,333,9,/**\n  * Converts a stream to a reader while detecting the encoding.\n  *\n  * @param stream  the input for the XML data.\n  * @param charsRead buffer where to put characters that have been read\n  *\n  * @throws java.io.IOException\n  *   if an I/O error occurred\n  */,40,"   protected Reader stream2reader(InputStream  stream,\n                  StringBuffer charsRead)\n    throws IOException\n   {\n    PushbackInputStream pbstream = new PushbackInputStream(stream);\n    int b = pbstream.read();\n    switch (b) {\n     case 0x00:\n     case 0xFE:\n     case 0xFF:\n      pbstream.unread(b);\n      return new InputStreamReader(pbstream, ""UTF-16"");\n     case 0xEF:\n      for (int i = 0; i < 2; i++) {\n         pbstream.read();\n      }\n      return new InputStreamReader(pbstream, ""UTF-8"");\n     case 0x3C:\n      b = pbstream.read();\n      charsRead.append(\'<\');\n      while ((b > 0) && (b != 0x3E)) {\n         charsRead.append((char) b);\n         b = pbstream.read();\n      }\n      if (b > 0) {\n         charsRead.append((char) b);\n      }\n      String encoding = this.getEncoding(charsRead.toString());\n      if (encoding == null) {\n         return new InputStreamReader(pbstream, ""UTF-8"");\n      }\n      charsRead.setLength(0);\n      try {\n         return new InputStreamReader(pbstream, encoding);\n      } catch (UnsupportedEncodingException e) {\n         return new InputStreamReader(pbstream, ""UTF-8"");\n      }\n      default:\n         charsRead.append((char) b);\n         return new InputStreamReader(pbstream, ""UTF-8"");\n"
415,openStream,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,471,508,13,"/**\n  * Opens a stream from a public and system ID.\n  *\n  * @param publicID the public ID, which may be null\n  * @param systemID the system ID, which is never null\n  *\n  * @throws java.net.MalformedURLException\n  *   if the system ID does not contain a valid URL\n  * @throws java.io.FileNotFoundException\n  *   if the system ID refers to a local file which does not exist\n  * @throws java.io.IOException\n  *   if an error occurred opening the stream\n  */",31,"   public Reader openStream(String publicID,\n              String systemID)\n    throws MalformedURLException,\n       FileNotFoundException,\n       IOException\n   {\n    URL url = new URL(this.currentReader.systemId, systemID);\n    if (url.getRef() != null) {\n     String ref = url.getRef();\n     if (url.getFile().length() > 0) {\n      url = new URL(url.getProtocol(), url.getHost(), url.getPort(),\n              url.getFile());\n      url = new URL(""jar:"" + url + \'!\' + ref);\n     } else {\n      url = StdXMLReader.class.getResource(ref);\n     }\n    }\n    this.currentReader.publicId = publicID;\n    this.currentReader.systemId = url;\n    StringBuffer charsRead = new StringBuffer();\n    Reader reader = this.stream2reader(url.openStream(), charsRead);\n    if (charsRead.length() == 0) {\n     return reader;\n    }\n    String charsReadStr = charsRead.toString();\n    PushbackReader pbreader = new PushbackReader(reader,\n                           charsReadStr.length());\n    for (int i = charsReadStr.length() - 1; i >= 0; i--) {\n     pbreader.unread(charsReadStr.charAt(i));\n    }\n    return pbreader;\n"
416,read,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,377,392,8,/**\n  * Reads a character.\n  *\n  * @return the character\n  *\n  * @throws java.io.IOException\n  *    if no character could be read\n  */,13,"   public char read()\n    throws IOException\n   {\n    int ch = this.currentReader.pbReader.read();\n    while (ch < 0) {\n     if (this.readers.empty()) {\n      throw new IOException(""Unexpected EOF"");\n     }\n     this.currentReader.pbReader.close();\n     this.currentReader = (StackedReader) this.readers.pop();\n     ch = this.currentReader.pbReader.read();\n    }\n    return (char) ch;\n"
417,StdXMLReader,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,176,187,5,/**\n  * Initializes the XML reader.\n  *\n  * @param reader the input for the XML data.\n  */,11,"   public StdXMLReader(Reader reader)\n   {\n    this.currentReader = new StackedReader();\n    this.readers = new Stack();\n    this.currentReader.lineReader = new LineNumberReader(reader);\n    this.currentReader.pbReader\n     = new PushbackReader(this.currentReader.lineReader, 2);\n    this.currentReader.publicId = """";\n    try {\n     this.currentReader.systemId = new URL(""file:."");\n    } catch (MalformedURLException e) {\n"
418,atEOF,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,423,439,6,/**\n  * Returns true if there are no more characters left to be read.\n  *\n  * @throws java.io.IOException\n  *    if an I/O error occurred\n  */,14,   public boolean atEOF()\n    throws IOException\n   {\n    int ch = this.currentReader.pbReader.read();\n    while (ch < 0) {\n     if (this.readers.empty()) {\n      return true;\n     }\n     this.currentReader.pbReader.close();\n     this.currentReader = (StackedReader) this.readers.pop();\n     ch = this.currentReader.pbReader.read();\n    }\n    this.currentReader.pbReader.unread(ch);\n    return false;\n
419,atEOFOfCurrentStream,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,403,412,7,/**\n  * Returns true if the current stream has no more characters left to be\n  * read.\n  *\n  * @throws java.io.IOException\n  *    if an I/O error occurred\n  */,9,   public boolean atEOFOfCurrentStream()\n    throws IOException\n   {\n    int ch = this.currentReader.pbReader.read();\n    if (ch < 0) {\n     return true;\n    } else {\n     this.currentReader.pbReader.unread(ch);\n     return false;\n
420,StdXMLReader,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,142,167,13,/**\n  * Initializes the reader from a system and public ID.\n  *\n  * @param publicID the public ID which may be null.\n  * @param systemID the non-null system ID.\n  *\n  * @throws MalformedURLException\n  *   if the system ID does not contain a valid URL\n  * @throws FileNotFoundException\n  *   if the system ID refers to a local file which does not exist\n  * @throws IOException\n  *   if an error occurred opening the stream\n  */,23,"   public StdXMLReader(String publicID,\n             String systemID)\n    throws MalformedURLException,\n       FileNotFoundException,\n       IOException\n   {\n    URL systemIDasURL = null;\n    try {\n     systemIDasURL = new URL(systemID);\n    } catch (MalformedURLException e) {\n     systemID = ""file:"" + systemID;\n     try {\n      systemIDasURL = new URL(systemID);\n     } catch (MalformedURLException e2) {\n      throw e;\n     }\n    }\n    this.currentReader = new StackedReader();\n    this.readers = new Stack();\n    Reader reader = this.openStream(publicID, systemIDasURL.toString());\n    this.currentReader.lineReader = new LineNumberReader(reader);\n    this.currentReader.pbReader\n     = new PushbackReader(this.currentReader.lineReader, 2);\n"
421,setSystemID,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,591,595,8,/**\n  * Sets the system ID of the current stream.\n  *\n  * @param systemID the system ID\n  *\n  * @throws java.net.MalformedURLException\n  *   if the system ID does not contain a valid URL\n  */,5,"   public void setSystemID(String systemID)\n    throws MalformedURLException\n   {\n    this.currentReader.systemId = new URL(this.currentReader.systemId,\n                      systemID);\n"
422,finalize,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,196,205,3,/**\n  * Cleans up the object when it's destroyed.\n  */,10,   protected void finalize()\n    throws Throwable\n   {\n    this.currentReader.lineReader = null;\n    this.currentReader.pbReader = null;\n    this.currentReader.systemId = null;\n    this.currentReader.publicId = null;\n    this.currentReader = null;\n    this.readers.clear();\n    super.finalize();\n
423,getStreamLevel,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,558,560,3,"/**\n  * Returns the current ""level"" of the stream on the stack of streams.\n  */",3,   public int getStreamLevel()\n   {\n    return this.readers.size();\n
424,startNewStream,StdXMLReader,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLReader.java,534,551,9,"/**\n  * Starts a new stream from a Java reader. The new stream is used\n  * temporary to read data from. If that stream is exhausted, control\n  * returns to the parent stream.\n  *\n  * @param reader the non-null reader to read the new data from\n  * @param isInternalEntity true if the reader is produced by resolving\n  *             an internal entity\n  */",16,"   public void startNewStream(Reader  reader,\n                boolean isInternalEntity)\n   {\n    StackedReader oldReader = this.currentReader;\n    this.readers.push(this.currentReader);\n    this.currentReader = new StackedReader();\n    if (isInternalEntity) {\n     this.currentReader.lineReader = null;\n     this.currentReader.pbReader = new PushbackReader(reader, 2);\n    } else {\n     this.currentReader.lineReader = new LineNumberReader(reader);\n     this.currentReader.pbReader\n      = new PushbackReader(this.currentReader.lineReader, 2);\n    }\n    this.currentReader.systemId = oldReader.systemId;\n    this.currentReader.publicId = oldReader.publicId;\n"
426,invalidAttributeValue,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,345,353,13,/**\n  * Throws an XMLValidationException to indicate that an attribute has an\n  * invalid value.\n  *\n  * @param systemID     the system ID of the XML data of the element\n  * @param lineNr     the line number in the XML data of the element\n  * @param elementName  the name of the element\n  * @param attributeName  the name of the attribute\n  * @param attributeValue the value of the attribute\n  *\n  * @throws net.n3.nanoxml.XMLValidationException\n  *    of course :-)\n  */,9,"   public void invalidAttributeValue(String systemID,\n                   int  lineNr,\n                   String elementName,\n                   String attributeName,\n                   String attributeValue)\n    throws XMLValidationException\n   {\n    XMLUtil.errorInvalidAttributeValue(systemID, lineNr, elementName,\n                     attributeName, attributeValue);\n"
430,getDelegate,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,77,79,3,/**\n  * Returns the delegate.\n  */,3,   public IXMLValidator getDelegate()\n   {\n    return this.delegate;\n
432,setParameterEntityResolver,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,99,101,5,/**\n  * Sets the parameter entity resolver.\n  *\n  * @param resolver the entity resolver.\n  */,3,   public void setParameterEntityResolver(IXMLEntityResolver resolver)\n   {\n    this.delegate.setParameterEntityResolver(resolver);\n
433,getParameterEntityResolver,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,110,112,5,/**\n  * Returns the parameter entity resolver.\n  *\n  * @return the entity resolver.\n  */,3,   public IXMLEntityResolver getParameterEntityResolver()\n   {\n    return this.delegate.getParameterEntityResolver();\n
434,ValidatorPlugin,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,57,59,3,/**\n  * Initializes the plugin.\n  */,3,   public ValidatorPlugin()\n   {\n    this.delegate = null;\n
438,finalize,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,66,70,3,/**\n  * Cleans up the object when it's destroyed.\n  */,5,   protected void finalize()\n    throws Throwable\n   {\n    this.delegate = null;\n    super.finalize();\n
439,setDelegate,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,88,90,5,/**\n  * Sets the delegate.\n  *\n  * @param delegate the delegate\n  */,3,   public void setDelegate(IXMLValidator delegate)\n   {\n    this.delegate = delegate;\n
440,unexpectedAttribute,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,321,328,12,/**\n  * Throws an XMLValidationException to indicate that an attribute is\n  * unexpected.\n  *\n  * @param systemID    the system ID of the XML data of the element\n  * @param lineNr    the line number in the XML data of the element\n  * @param elementName   the name of the element\n  * @param attributeName the name of the unexpected attribute\n  *\n  * @throws net.n3.nanoxml.XMLValidationException\n  *    of course :-)\n  */,8,"   public void unexpectedAttribute(String systemID,\n                   int  lineNr,\n                   String elementName,\n                   String attributeName)\n    throws XMLValidationException\n   {\n    XMLUtil.errorUnexpectedAttribute(systemID, lineNr, elementName,\n                     attributeName);\n"
441,parseDTD,ValidatorPlugin,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/ValidatorPlugin.java,128,134,12,"/**\n  * Parses the DTD. The validator object is responsible for reading the\n  * full DTD.\n  *\n  * @param publicID     the public ID, which may be null.\n  * @param reader     the reader to read the DTD from.\n  * @param entityResolver the entity resolver.\n  * @param external     true if the DTD is external.\n  *\n  * @throws java.lang.Exception\n  *   if something went wrong.\n  */",7,"   public void parseDTD(String       publicID,\n            IXMLReader     reader,\n            IXMLEntityResolver entityResolver,\n            boolean      external)\n    throws Exception\n   {\n    this.delegate.parseDTD(publicID, reader, entityResolver, external);\n"
444,StdXMLBuilder,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,72,74,3,/**\n  * Creates the builder.\n  */,3,   public StdXMLBuilder()\n   {\n    this(new XMLElement());\n
445,StdXMLBuilder,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,83,87,5,/**\n  * Creates the builder.\n  *\n  * @param prototype the prototype to use when building the tree.\n  */,5,   public StdXMLBuilder(IXMLElement prototype)\n   {\n    this.stack = null;\n    this.root = null;\n    this.prototype = prototype;\n
447,addPCData,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,282,318,12,"/**\n  * This method is called when a PCDATA element is encountered. A Java\n  * reader is supplied from which you can read the data. The reader will\n  * only read the data of the element. You don't need to check for\n  * boundaries. If you don't read the full element, the rest of the data\n  * is skipped. You also don't have to care about entities; they are\n  * resolved by the parser.\n  *\n  * @param reader   the Java reader from which you can retrieve the data.\n  * @param systemID the system ID of the XML data source.\n  * @param lineNr   the line in the source where the element starts.\n  */",30,"   public void addPCData(Reader reader,\n             String systemID,\n             int  lineNr)\n   {\n    int bufSize = 2048;\n    int sizeRead = 0;\n    StringBuffer str = new StringBuffer(bufSize);\n    char[] buf = new char[bufSize];\n    for (;;) {\n     if (sizeRead >= bufSize) {\n      bufSize *= 2;\n      str.ensureCapacity(bufSize);\n     }\n     int size;\n     try {\n      size = reader.read(buf);\n     } catch (IOException e) {\n      break;\n     }\n     if (size < 0) {\n      break;\n     }\n     str.append(buf, 0, size);\n     sizeRead += size;\n    }\n    IXMLElement elt = this.prototype.createElement(null, systemID, lineNr);\n    elt.setContent(str.toString());\n    if (! this.stack.empty()) {\n     IXMLElement top = (IXMLElement) this.stack.peek();\n     top.addChild(elt);\n"
448,finalize,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,94,101,3,/**\n  * Cleans up the object when it's destroyed.\n  */,8,   protected void finalize()\n    throws Throwable\n   {\n    this.prototype = null;\n    this.root = null;\n    this.stack.clear();\n    this.stack = null;\n    super.finalize();\n
449,addAttribute,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,241,265,17,"/**\n  * This method is called when a new attribute of an XML element is\n  * encountered.\n  *\n  * @param key    the key (name) of the attribute.\n  * @param nsPrefix   the prefix used to identify the namespace. If no\n  *           namespace has been specified, this parameter is null.\n  * @param nsURI    the URI associated with the namespace. If no\n  *           namespace has been specified, or no URI is\n  *           associated with nsPrefix, this parameter is null.\n  * @param value    the value of the attribute.\n  * @param type     the type of the attribute. If no type is known,\n  *           ""CDATA"" is returned.\n  *\n  * @throws java.lang.Exception\n  *   If an exception occurred while processing the event.\n  */",21,"   public void addAttribute(String key,\n              String nsPrefix,\n              String nsURI,\n              String value,\n              String type)\n    throws Exception\n   {\n    String fullName = key;\n    if (nsPrefix != null) {\n     fullName = nsPrefix + \':\' + key;\n    }\n    IXMLElement top = (IXMLElement) this.stack.peek();\n    if (top.hasAttribute(fullName)) {\n     throw new XMLParseException(top.getSystemID(),\n                   top.getLineNr(),\n                   ""Duplicate attribute: "" + key);\n    }\n    if (nsPrefix != null) {\n     top.setAttribute(fullName, nsURI, value);\n    } else {\n     top.setAttribute(fullName, value);\n"
450,endElement,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,207,218,15,"/**\n  * This method is called when the end of an XML elemnt is encountered.\n  *\n  * @see #startElement\n  *\n  * @param name     the name of the element.\n  * @param nsPrefix   the prefix used to identify the namespace. If no\n  *           namespace has been specified, this parameter is null.\n  * @param nsURI    the URI associated with the namespace. If no\n  *           namespace has been specified, or no URI is\n  *           associated with nsPrefix, this parameter is null.\n  */\n --------------\n// nothing to do\n --------------",10,"   public void endElement(String name,\n              String nsPrefix,\n              String nsURI)\n   {\n    IXMLElement elt = (IXMLElement) this.stack.pop();\n    if (elt.getChildrenCount() == 1) {\n     IXMLElement child = elt.getChildAtIndex(0);\n     if (child.getName() == null) {\n      elt.setContent(child.getContent());\n      elt.removeChildAtIndex(0);\n"
451,startBuilding,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,111,115,6,/**\n  * This method is called before the parser starts processing its input.\n  *\n  * @param systemID the system ID of the XML data source.\n  * @param lineNr   the line on which the parsing starts.\n  */,5,"   public void startBuilding(String systemID,\n               int  lineNr)\n   {\n    this.stack = new Stack();\n    this.root = null;\n"
452,startElement,StdXMLBuilder,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLBuilder.java,147,169,14,"/**\n  * This method is called when a new XML element is encountered.\n  *\n  * @see #endElement\n  *\n  * @param name   the name of the element.\n  * @param nsPrefix   the prefix used to identify the namespace. If no\n  *       namespace has been specified, this parameter is null.\n  * @param nsURI  the URI associated with the namespace. If no\n  *       namespace has been specified, or no URI is\n  *       associated with nsPrefix, this parameter is null.\n  * @param systemID   the system ID of the XML data source.\n  * @param lineNr   the line in the source where the element starts.\n  */",19,"   public void startElement(String name,\n              String nsPrefix,\n              String nsURI,\n              String systemID,\n              int  lineNr)\n   {\n    String fullName = name;\n    if (nsPrefix != null) {\n     fullName = nsPrefix + ':' + name;\n    }\n    IXMLElement elt = this.prototype.createElement(fullName, nsURI,\n                           systemID, lineNr);\n    if (this.stack.empty()) {\n     this.root = elt;\n    } else {\n     IXMLElement top = (IXMLElement) this.stack.peek();\n     top.addChild(elt);\n    }\n    this.stack.push(elt);\n"
454,setReader,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,173,175,5,/**\n  * Sets the reader from which the parser retrieves its data.\n  *\n  * @param reader the reader\n  */,3,   public void setReader(IXMLReader reader)\n   {\n    this.reader = reader;\n
455,setValidator,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,129,131,5,/**\n  * Sets the validator that validates the XML data.\n  *\n  * @param validator the non-null validator\n  */,3,   public void setValidator(IXMLValidator validator)\n   {\n    this.validator = validator;\n
456,setResolver,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,151,153,5,/**\n  * Sets the entity resolver.\n  *\n  * @param resolver the non-null resolver\n  */,3,   public void setResolver(IXMLEntityResolver resolver)\n   {\n    this.entityResolver = resolver;\n
457,scanSomeTag,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,269,294,10,/**\n  * Scans an XML tag.\n  *\n  * @param allowCDATA true if CDATA sections are allowed at this point\n  * @param defaultNamespace the default namespace URI (or null)\n  * @param namespaces list of defined namespaces\n  *\n  * @throws java.lang.Exception\n  *   if something went wrong\n  */,22,"   protected void scanSomeTag(boolean  allowCDATA,\n                String   defaultNamespace,\n                Properties namespaces)\n    throws Exception\n   {\n    String str = XMLUtil.read(this.reader, '&');\n    char ch = str.charAt(0);\n    if (ch == '&') {\n     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),\n                     reader.getLineNr(),\n                     str);\n    }\n    switch (ch) {\n     case '?':\n      this.processPI();\n      break;\n     case '!':\n      this.processSpecialTag(allowCDATA);\n      break;\n     default:\n      this.reader.unread(ch);\n      this.processElement(defaultNamespace, namespaces);\n"
458,processElement,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,461,655,12,/**\n  * Processes a regular element.\n  *\n  * @param defaultNamespace the default namespace URI (or null)\n  * @param namespaces list of defined namespaces\n  *\n  * @throws java.lang.Exception\n  *   if something went wrong\n  */\n --------------\n// END PATCH W. Randelshofer Don\'t read DTD\n --------------,165,"   protected void processElement(String   defaultNamespace,\n                 Properties namespaces)\n    throws Exception\n   {\n    String fullName = XMLUtil.scanIdentifier(this.reader);\n    String name = fullName;\n    XMLUtil.skipWhitespace(this.reader, null);\n    String prefix = null;\n    int colonIndex = name.indexOf(\':\');\n    if (colonIndex > 0) {\n     prefix = name.substring(0, colonIndex);\n     name = name.substring(colonIndex + 1);\n    }\n    Vector attrNames = new Vector();\n    Vector attrValues = new Vector();\n    Vector attrTypes = new Vector();\n    this.validator.elementStarted(fullName,\n                  this.reader.getSystemID(),\n                  this.reader.getLineNr());\n    char ch;\n    for (;;) {\n     ch = this.reader.read();\n     if ((ch == \'/\') || (ch == \'>\')) {\n      break;\n     }\n     this.reader.unread(ch);\n     this.processAttribute(attrNames, attrValues, attrTypes);\n     XMLUtil.skipWhitespace(this.reader, null);\n    }\n    Properties extraAttributes = new Properties();\n    this.validator.elementAttributesProcessed(fullName,\n                        extraAttributes,\n                        this.reader.getSystemID(),\n                        this.reader.getLineNr());\n    Enumeration enm = extraAttributes.keys();\n    while (enm.hasMoreElements()) {\n     String key = (String) enm.nextElement();\n     String value = extraAttributes.getProperty(key);\n     attrNames.addElement(key);\n     attrValues.addElement(value);\n     attrTypes.addElement(""CDATA"");\n    }\n    for (int i = 0; i < attrNames.size(); i++) {\n     String key = (String) attrNames.elementAt(i);\n     String value = (String) attrValues.elementAt(i);\n     String type = (String) attrTypes.elementAt(i);\n     if (key.equals(""xmlns"")) {\n      defaultNamespace = value;\n     } else if (key.startsWith(""xmlns:"")) {\n      namespaces.put(key.substring(6), value);\n     }\n    }\n    if (prefix == null) {\n     this.builder.startElement(name, prefix, defaultNamespace,\n                   this.reader.getSystemID(),\n                   this.reader.getLineNr());\n    } else {\n     this.builder.startElement(name, prefix,\n                   namespaces.getProperty(prefix),\n                   this.reader.getSystemID(),\n                   this.reader.getLineNr());\n    }\n    for (int i = 0; i < attrNames.size(); i++) {\n     String key = (String) attrNames.elementAt(i);\n     if (key.startsWith(""xmlns"")) {\n      continue;\n     }\n     String value = (String) attrValues.elementAt(i);\n     String type = (String) attrTypes.elementAt(i);\n     colonIndex = key.indexOf(\':\');\n     if (colonIndex > 0) {\n      String attPrefix = key.substring(0, colonIndex);\n      key = key.substring(colonIndex + 1);\n      this.builder.addAttribute(key, attPrefix,\n                    namespaces.getProperty(attPrefix),\n                    value, type);\n     } else {\n      this.builder.addAttribute(key, null, null, value, type);\n     }\n    }\n    if (prefix == null) {\n     this.builder.elementAttributesProcessed(name, prefix,\n                         defaultNamespace);\n    } else {\n     this.builder.elementAttributesProcessed(name, prefix,\n                         namespaces\n                           .getProperty(prefix));\n    }\n    if (ch == \'/\') {\n     if (this.reader.read() != \'>\') {\n      XMLUtil.errorExpectedInput(reader.getSystemID(),\n                     reader.getLineNr(),\n                     ""`>\'"");\n     }\n     this.validator.elementEnded(name,\n                   this.reader.getSystemID(),\n                   this.reader.getLineNr());\n     if (prefix == null) {\n      this.builder.endElement(name, prefix, defaultNamespace);\n     } else {\n      this.builder.endElement(name, prefix,\n                  namespaces.getProperty(prefix));\n     }\n     return;\n    }\n    StringBuffer buffer = new StringBuffer(16);\n    for (;;) {\n     buffer.setLength(0);\n     String str;\n     for (;;) {\n      XMLUtil.skipWhitespace(this.reader, buffer);\n      str = XMLUtil.read(this.reader, \'&\');\n      if ((str.charAt(0) == \'&\') && (str.charAt(1) != \'#\')) {\n         XMLUtil.processEntity(str, this.reader,\n                   this.entityResolver);\n      } else {\n         break;\n      }\n     }\n     if (str.charAt(0) == \'<\') {\n      str = XMLUtil.read(this.reader, \'\\0\');\n      if (str.charAt(0) == \'/\') {\n         XMLUtil.skipWhitespace(this.reader, null);\n         str = XMLUtil.scanIdentifier(this.reader);\n         if (! str.equals(fullName)) {\n          XMLUtil.errorWrongClosingTag(reader.getSystemID(),\n                         reader.getLineNr(),\n                         name, str);\n         }\n         XMLUtil.skipWhitespace(this.reader, null);\n         if (this.reader.read() != \'>\') {\n          XMLUtil.errorClosingTagNotEmpty(reader.getSystemID(),\n                          reader.getLineNr());\n         }\n         this.validator.elementEnded(fullName,\n                       this.reader.getSystemID(),\n                       this.reader.getLineNr());\n         if (prefix == null) {\n           this.builder.endElement(name, prefix, defaultNamespace);\n         } else {\n           this.builder.endElement(name, prefix,\n                       namespaces.getProperty(prefix));\n         }\n         break;\n      } else { // <[^/]\n         this.reader.unread(str.charAt(0));\n         this.scanSomeTag(true, //CDATA allowed\n                defaultNamespace,\n                (Properties) namespaces.clone());\n      }\n     } else { // [^<]\n      if (str.charAt(0) == \'&\') {\n         ch = XMLUtil.processCharLiteral(str);\n         buffer.append(ch);\n      } else {\n         reader.unread(str.charAt(0));\n      }\n      this.validator.PCDataAdded(this.reader.getSystemID(),\n                     this.reader.getLineNr());\n      Reader r = new ContentReader(this.reader,\n                     this.entityResolver,\n                     buffer.toString());\n      this.builder.addPCData(r, this.reader.getSystemID(),\n                   this.reader.getLineNr());\n      r.close();\n"
459,getResolver,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,162,164,5,/**\n  * Returns the entity resolver.\n  *\n  * @return the non-null resolver\n  */,3,   public IXMLEntityResolver getResolver()\n   {\n    return this.entityResolver;\n
460,finalize,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,91,98,3,/**\n  * Cleans up the object when it's destroyed.\n  */,8,   protected void finalize()\n    throws Throwable\n   {\n    this.builder = null;\n    this.reader = null;\n    this.entityResolver = null;\n    this.validator = null;\n    super.finalize();\n
461,processDocType,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,393,445,6,/**\n  * Processes a document type declaration.\n  *\n  * @throws java.lang.Exception\n  *    if an error occurred reading or parsing the data\n  */,49,"   protected void processDocType()\n    throws Exception\n   {\n    if (! XMLUtil.checkLiteral(this.reader, ""OCTYPE"")) {\n     XMLUtil.errorExpectedInput(reader.getSystemID(),\n                  reader.getLineNr(),\n                  ""<!DOCTYPE"");\n     return;\n    }\n    XMLUtil.skipWhitespace(this.reader, null);\n    String systemID = null;\n    StringBuffer publicID = new StringBuffer();\n    String rootElement = XMLUtil.scanIdentifier(this.reader);\n    XMLUtil.skipWhitespace(this.reader, null);\n    char ch = this.reader.read();\n    if (ch == \'P\') {\n     systemID = XMLUtil.scanPublicID(publicID, reader);\n     XMLUtil.skipWhitespace(this.reader, null);\n     ch = this.reader.read();\n    } else if (ch == \'S\') {\n     systemID = XMLUtil.scanSystemID(reader);\n     XMLUtil.skipWhitespace(this.reader, null);\n     ch = this.reader.read();\n    }\n    if (ch == \'[\') {\n     this.validator.parseDTD(publicID.toString(),\n                 this.reader,\n                 this.entityResolver,\n                 false);\n     XMLUtil.skipWhitespace(this.reader, null);\n     ch = this.reader.read();\n    }\n    if (ch != \'>\') {\n     XMLUtil.errorExpectedInput(reader.getSystemID(),\n                  reader.getLineNr(),\n                  ""`>\'"");\n    }\n// BEGIN PATCH W. Randelshofer Don\'t read DTD\n  if (false) {\n    if (systemID != null) {\n     Reader reader = this.reader.openStream(publicID.toString(),\n                        systemID);\n     this.reader.startNewStream(reader);\n     this.reader.setSystemID(systemID);\n     this.reader.setPublicID(publicID.toString());\n     this.validator.parseDTD(publicID.toString(),\n                 this.reader,\n                 this.entityResolver,\n                 true);\n"
462,StdXMLParser,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,79,84,3,/**\n  * Creates a new parser.\n  */,6,   public StdXMLParser()\n   {\n    this.builder = null;\n    this.validator = null;\n    this.reader = null;\n    this.entityResolver = new XMLEntityResolver();\n
463,scanData,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,223,253,9,/**\n  * Scans the XML data for elements.\n  *\n  * @throws java.lang.Exception\n  *   if something went wrong\n  */\n --------------\n// throw new XMLException(e);\n --------------,28,"   protected void scanData()\n    throws Exception\n   {\n    while ((! this.reader.atEOF()) && (this.builder.getResult() == null)) {\n     String str = XMLUtil.read(this.reader, \'&\');\n     char ch = str.charAt(0);\n     if (ch == \'&\') {\n      XMLUtil.processEntity(str, this.reader, this.entityResolver);\n      continue;\n     }\n     switch (ch) {\n      case \'<\':\n         this.scanSomeTag(false, // don\'t allow CDATA\n                null,  // no default namespace\n                new Properties());\n         break;\n      case \' \':\n      case \'\\t\':\n      case \'\\r\':\n      case \'\\n\':\n         // skip whitespace\n         break;\n      default:\n         XMLUtil.errorInvalidInput(reader.getSystemID(),\n                     reader.getLineNr(),\n                     ""`"" + ch + ""\' (0x""\n                     + Integer.toHexString((int) ch)\n                     + \')\');\n"
464,getValidator,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,140,142,5,/**\n  * Returns the validator that validates the XML data.\n  *\n  * @return the validator\n  */,3,   public IXMLValidator getValidator()\n   {\n    return this.validator;\n
465,PasteAction,PasteAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/PasteAction.java,46,47,1,/** Creates a new instance which acts on the currently focused component. */,2,  public PasteAction() {\n    this(null);\n
466,processCDATA,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,369,383,6,/**\n  * Processes a CDATA section.\n  *\n  * @throws java.lang.Exception\n  *   if something went wrong\n  */,14,"   protected void processCDATA()\n    throws Exception\n   {\n    if (! XMLUtil.checkLiteral(this.reader, ""CDATA["")) {\n     XMLUtil.errorExpectedInput(reader.getSystemID(),\n                  reader.getLineNr(),\n                  ""<![[CDATA["");\n    }\n    this.validator.PCDataAdded(this.reader.getSystemID(),\n                 this.reader.getLineNr());\n    Reader reader = new CDATAReader(this.reader);\n    this.builder.addPCData(reader, this.reader.getSystemID(),\n               this.reader.getLineNr());\n    reader.close();\n"
467,processPI,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,305,317,6,"/**\n  * Processes a ""processing instruction"".\n  *\n  * @throws java.lang.Exception\n  *   if something went wrong\n  */",11,"   protected void processPI()\n    throws Exception\n   {\n    XMLUtil.skipWhitespace(this.reader, null);\n    String target = XMLUtil.scanIdentifier(this.reader);\n    XMLUtil.skipWhitespace(this.reader, null);\n    Reader reader = new PIReader(this.reader);\n    if (! target.equalsIgnoreCase(""xml"")) {\n     this.builder.newProcessingInstruction(target, reader);\n    }\n    reader.close();\n"
468,parse,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,198,211,8,/**\n  * Parses the data and lets the builder create the logical data structure.\n  *\n  * @return the logical structure built by the builder\n  *\n  * @throws net.n3.nanoxml.XMLException\n  *    if an error occurred reading or parsing the data\n  */,14,"   public Object parse()\n    throws XMLException\n   {\n    try {\n     this.builder.startBuilding(this.reader.getSystemID(),\n                  this.reader.getLineNr());\n     this.scanData();\n     return this.builder.getResult();\n    } catch (XMLException e) {\n     throw e;\n    } catch (Exception e) {\n      XMLException error = new XMLException(e);\n      error.initCause(e);\n      throw error;\n"
469,getReader,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,184,186,5,/**\n  * Returns the reader from which the parser retrieves its data.\n  *\n  * @return the reader\n  */,3,   public IXMLReader getReader()\n   {\n    return this.reader;\n
470,getBuilder,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,118,120,5,/**\n  * Returns the builder which creates the logical structure of the XML data.\n  *\n  * @return the builder\n  */,3,   public IXMLBuilder getBuilder()\n   {\n    return this.builder;\n
471,setBuilder,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,107,109,5,/**\n  * Sets the builder which creates the logical structure of the XML data.\n  *\n  * @param builder the non-null builder\n  */,3,   public void setBuilder(IXMLBuilder builder)\n   {\n    this.builder = builder;\n
472,processSpecialTag,StdXMLParser,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/StdXMLParser.java,329,358,8,/**\n  * Processes a tag that starts with a bang (&lt;!...&gt;).\n  *\n  * @param allowCDATA true if CDATA sections are allowed at this point\n  *\n  * @throws java.lang.Exception\n  *   if something went wrong\n  */,25,"   protected void processSpecialTag(boolean allowCDATA)\n    throws Exception\n   {\n    String str = XMLUtil.read(this.reader, '&');\n    char ch = str.charAt(0);\n    if (ch == '&') {\n     XMLUtil.errorUnexpectedEntity(reader.getSystemID(),\n                     reader.getLineNr(),\n                     str);\n    }\n    switch (ch) {\n     case '[':\n      if (allowCDATA) {\n         this.processCDATA();\n      } else {\n         XMLUtil.errorUnexpectedCDATA(reader.getSystemID(),\n                      reader.getLineNr());\n      }\n      return;\n     case 'D':\n      this.processDocType();\n      return;\n     case '-':\n      XMLUtil.skipComment(this.reader);\n      return;\n"
473,installViewListeners,RedoAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/RedoAction.java,87,92,3,/**\n   * Installs listeners on the view object.\n   */,6,  @Override\n  protected void installViewListeners(View p) {\n    super.installViewListeners(p);\n    Action redoActionInView = p.getActionMap().get(ID);\n    if (redoActionInView != null && redoActionInView != this) {\n      redoActionInView.addPropertyChangeListener(redoActionPropertyListener);\n
474,RedoAction,RedoAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/RedoAction.java,58,60,1,/** Creates a new instance. */,3,"  public RedoAction(Application app, View view) {\n    super(app, view);\n    labels.configureAction(this, ID);\n"
475,createDefaultXMLParser,XMLParserFactory,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLParserFactory.java,71,85,15,/**\n   * Creates a default parser.\n   *\n   * @see #DEFAULT_CLASS\n   * @see #CLASS_KEY\n   *\n   * @return the non-null parser.\n   *\n   * @throws java.lang.ClassNotFoundException\n   *    if the class of the parser or validator could not be found.\n   * @throws java.lang.InstantiationException\n   *    if the parser could not be created\n   * @throws java.lang.IllegalAccessException\n   *    if the parser could not be created\n   */,15,"  public static IXMLParser createDefaultXMLParser()\n  throws ClassNotFoundException,\n      InstantiationException,\n      IllegalAccessException {\n    // BEGIN PATCH W. Randelshofer catch AccessControlException\n    String className = XMLParserFactory.DEFAULT_CLASS;\n    try {\n      className = System.getProperty(XMLParserFactory.CLASS_KEY,\n          XMLParserFactory.DEFAULT_CLASS);\n    } catch (AccessControlException e) {\n      // do nothing\n    }\n    // END PATCH W. Randelshofer catch AccessControlException\n    return XMLParserFactory.createXMLParser(className,\n        new StdXMLBuilder());\n"
476,createDefaultXMLParser,XMLParserFactory,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLParserFactory.java,106,119,17,/**\n   * Creates a default parser.\n   *\n   * @see #DEFAULT_CLASS\n   * @see #CLASS_KEY\n   *\n   * @param builder the XML builder.\n   *\n   * @return the non-null parser.\n   *\n   * @throws java.lang.ClassNotFoundException\n   *    if the class of the parser could not be found.\n   * @throws java.lang.InstantiationException\n   *    if the parser could not be created\n   * @throws java.lang.IllegalAccessException\n   *    if the parser could not be created\n   */,14,"  public static IXMLParser createDefaultXMLParser(IXMLBuilder builder)\n  throws ClassNotFoundException,\n      InstantiationException,\n      IllegalAccessException {\n    // BEGIN PATCH W. Randelshofer catch AccessControlException\n    String className = XMLParserFactory.DEFAULT_CLASS;\n    try {\n     className = System.getProperty(XMLParserFactory.CLASS_KEY,\n        XMLParserFactory.DEFAULT_CLASS);\n     } catch (AccessControlException e) {\n       // do nothing\n     }\n    // END PATCH W. Randelshofer catch AccessControlException\n    return XMLParserFactory.createXMLParser(className, builder);\n"
477,installViewListeners,UndoAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/UndoAction.java,83,87,3,/**\n   * Installs listeners on the view object.\n   */,5,  @Override protected void installViewListeners(View p) {\n    super.installViewListeners(p);\n    Action undoActionInView = p.getActionMap().get(ID);\n    if (undoActionInView != null && undoActionInView != this) {\n    undoActionInView.addPropertyChangeListener(redoActionPropertyListener);\n
478,XMLAttribute,XMLAttribute,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java,82,92,9,"/**\n  * Creates a new attribute.\n  *\n  * @param fullName  the non-null full name\n  * @param name    the non-null short name\n  * @param namespace the namespace URI, which may be null\n  * @param value   the value of the attribute\n  * @param type    the type of the attribute\n  */",11,"   XMLAttribute(String fullName,\n        String name,\n        String namespace,\n        String value,\n        String type)\n   {\n    this.fullName = fullName;\n    this.name = name;\n    this.namespace = namespace;\n    this.value = value;\n    this.type = type;\n"
480,UndoAction,UndoAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/UndoAction.java,56,58,1,/** Creates a new instance. */,3,"  public UndoAction(Application app, View view) {\n    super(app, view);\n    labels.configureAction(this, ID);\n"
481,setValue,XMLAttribute,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java,137,139,5,/**\n  * Sets the value of the attribute.\n  *\n  * @param value the new value.\n  */,3,   void setValue(String value)\n   {\n    this.value = value;\n
483,getValue,XMLAttribute,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java,126,128,3,/**\n  * Returns the value of the attribute.\n  */,3,   String getValue()\n   {\n    return this.value;\n
485,getName,XMLAttribute,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java,108,110,3,/**\n  * Returns the short name of the attribute.\n  */,3,   String getName()\n   {\n    return this.name;\n
487,getNamespace,XMLAttribute,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java,117,119,3,/**\n  * Returns the namespace of the attribute.\n  */,3,   String getNamespace()\n   {\n    return this.namespace;\n
489,getFullName,XMLAttribute,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLAttribute.java,99,101,3,/**\n  * Returns the full name of the attribute.\n  */,3,   String getFullName()\n   {\n    return this.fullName;\n
490,ClearSelectionAction,ClearSelectionAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/ClearSelectionAction.java,46,47,1,/** Creates a new instance which acts on the currently focused component. */,2,  public ClearSelectionAction() {\n    this(null);\n
493,DuplicateAction,DuplicateAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DuplicateAction.java,45,46,1,/** Creates a new instance which acts on the currently focused component. */,2,  public DuplicateAction() {\n    this(null);\n
496,CopyAction,CopyAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CopyAction.java,54,57,5,/** Creates a new instance which acts on the specified component.\n   *\n   * @param target The target of the action. Specify null for the currently\n   * focused component.\n   */,4,"  public CopyAction(JComponent target) {\n    super(target);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
497,buildMessage,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,164,186,11,"/**\n  * Builds the exception message\n  *\n  * @param systemID   the system ID from where the data came\n  * @param lineNr     the line number in the XML data where the exception\n  *           occurred.\n  * @param e      the encapsulated exception.\n  * @param msg      the message of the exception.\n  * @param reportParams true if the systemID, lineNr and e params need to be\n  *           appended to the message\n  */",19,"   private static String buildMessage(String  systemID,\n                    int     lineNr,\n                    Exception e,\n                    String  msg,\n                    boolean   reportParams)\n   {\n    String str = msg;\n    if (reportParams) {\n     if (systemID != null) {\n      str += "", SystemID=\'"" + systemID + ""\'"";\n     }\n     if (lineNr >= 0) {\n      str += "", Line="" + lineNr;\n     }\n     if (e != null) {\n      str += "", Exception: "" + e;\n     }\n    }\n    return str;\n"
498,CopyAction,CopyAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CopyAction.java,45,46,1,/** Creates a new instance which acts on the currently focused component. */,2,  public CopyAction() {\n    this(null);\n
499,XMLException,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,118,122,9,/**\n  * Creates a new exception.\n  *\n  * @param systemID the system ID of the XML data where the exception\n  *         occurred\n  * @param lineNr   the line number in the XML data where the exception\n  *         occurred.\n  * @param msg    the message of the exception.\n  */,5,"   public XMLException(String systemID,\n             int  lineNr,\n             String msg)\n   {\n    this(systemID, lineNr, null, msg, true);\n"
500,XMLException,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,101,105,9,/**\n  * Creates a new exception.\n  *\n  * @param systemID the system ID of the XML data where the exception\n  *         occurred\n  * @param lineNr   the line number in the XML data where the exception\n  *         occurred.\n  * @param e    the encapsulated exception.\n  */,5,"   public XMLException(String systemID,\n             int  lineNr,\n             Exception e)\n   {\n    this(systemID, lineNr, e, ""Nested Exception"", true);\n"
501,printStackTrace,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,253,259,5,/**\n  * Dumps the exception stack to an output stream.\n  *\n  * @param stream the output stream\n  */,6,"   public void printStackTrace(PrintStream stream)\n   {\n    super.printStackTrace(stream);\n    if (this.encapsulatedException != null) {\n     stream.println(""*** Nested Exception:"");\n     this.encapsulatedException.printStackTrace(stream);\n"
502,getSystemID,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,206,208,4,"/**\n  * Returns the system ID of the XML data where the exception occurred.\n  * If there is no system ID known, null is returned.\n  */",3,   public String getSystemID()\n   {\n    return this.systemID;\n
503,XMLException,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,75,77,5,/**\n  * Creates a new exception.\n  *\n  * @param msg the message of the exception.\n  */,3,"   public XMLException(String msg)\n   {\n    this(null, -1, null, msg, false);\n"
504,XMLException,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,137,149,11,"/**\n  * Creates a new exception.\n  *\n  * @param systemID   the system ID from where the data came\n  * @param lineNr     the line number in the XML data where the exception\n  *           occurred.\n  * @param e      the encapsulated exception.\n  * @param msg      the message of the exception.\n  * @param reportParams true if the systemID, lineNr and e params need to be\n  *           appended to the message\n  */",13,"   public XMLException(String  systemID,\n             int     lineNr,\n             Exception e,\n             String  msg,\n             boolean   reportParams)\n   {\n    super(XMLException.buildMessage(systemID, lineNr, e, msg,\n                    reportParams));\n    this.systemID = systemID;\n    this.lineNr = lineNr;\n    this.encapsulatedException = e;\n    this.msg = XMLException.buildMessage(systemID, lineNr, e, msg,\n                       reportParams);\n"
506,DeleteAction,DeleteAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DeleteAction.java,54,55,1,/** Creates a new instance which acts on the currently focused component. */,2,  public DeleteAction() {\n    this(null);\n
507,contains,AbstractConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java,80,81,3,/**\n   * Tests if a point is contained in the connector.\n   */,2,  public boolean contains(Point2D.Double p) {\n    return getOwner().contains(p);\n
508,getException,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,226,228,4,"/**\n  * Returns the encapsulated exception, or null if no exception is\n  * encapsulated.\n  */",3,   public Exception getException()\n   {\n    return this.encapsulatedException;\n
509,DeleteAction,DeleteAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/DeleteAction.java,63,80,5,/** Creates a new instance which acts on the specified component.\n   *\n   * @param target The target of the action. Specify null for the currently\n   * focused component.\n   */,17,"  public DeleteAction(JComponent target) {\n    super(ID);\n    this.target = target;\n    if (target != null) {\n      // Register with a weak reference on the JComponent.\n      propertyHandler = new PropertyChangeListener() {\n        @Override\n        public void propertyChange(PropertyChangeEvent evt) {\n          if (evt.getPropertyName().equals(""enabled"")) {\n            setEnabled((Boolean) evt.getNewValue());\n          }\n        }\n      };\n      target.addPropertyChangeListener(new WeakPropertyChangeListener(propertyHandler));\n    }\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
510,AbstractConnector,AbstractConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java,63,64,3,/**\n   * Constructs a connector with the given owner figure.\n   */,2,  public AbstractConnector(Figure owner) {\n    this.owner = owner;\n
511,printStackTrace,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,237,243,5,/**\n  * Dumps the exception stack to a print writer.\n  *\n  * @param writer the print writer\n  */,6,"   public void printStackTrace(PrintWriter writer)\n   {\n    super.printStackTrace(writer);\n    if (this.encapsulatedException != null) {\n     writer.println(""*** Nested Exception:"");\n     this.encapsulatedException.printStackTrace(writer);\n"
512,findPoint,AbstractConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java,97,98,5,/**\n   * Gets the connection point. Override when the connector\n   * does not need to distinguish between the start and end\n   * point of a connection.\n   */,2,  protected Point2D.Double findPoint(ConnectionFigure connection) {\n    return Geom.center(getBounds());\n
513,finalize,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,193,198,3,/**\n  * Cleans up the object when it's destroyed.\n  */,6,   protected void finalize()\n    throws Throwable\n   {\n    this.systemID = null;\n    this.encapsulatedException = null;\n    super.finalize();\n
514,getOwner,AbstractConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java,104,105,3,/**\n   * Gets the connector's owner.\n   */,2,  public Figure getOwner() {\n    return owner;\n
515,XMLException,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,86,88,5,/**\n  * Creates a new exception.\n  *\n  * @param e the encapsulated exception.\n  */,3,"   public XMLException(Exception e)\n   {\n    this(null, -1, e, ""Nested Exception"", false);\n"
516,setOwner,AbstractConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java,110,111,3,/**\n   * Sets the connector's owner.\n   */,2,  protected void setOwner(Figure newValue) {\n    owner = newValue;\n
517,printStackTrace,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,267,273,3,/**\n  * Dumps the exception stack to System.err.\n  */,6,"   public void printStackTrace()\n   {\n    super.printStackTrace();\n    if (this.encapsulatedException != null) {\n     System.err.println(""*** Nested Exception:"");\n     this.encapsulatedException.printStackTrace();\n"
518,AbstractConnector,AbstractConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/AbstractConnector.java,57,58,5,/**\n   * Constructs a connector that has no owner. It is only\n   * used internally to resurrect a connectors from a\n   * StorableOutput. It should never be called directly.\n   */,2,  public AbstractConnector() {\n    owner = null;\n
519,getLineNr,XMLException,JHotDraw741,jhotdraw7/src/main/java/net/n3/nanoxml/XMLException.java,216,218,4,"/**\n  * Returns the line number in the XML data where the exception occurred.\n  * If there is no line number known, -1 is returned.\n  */",3,   public int getLineNr()\n   {\n    return this.lineNr;\n
521,CutAction,CutAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/edit/CutAction.java,45,46,1,/** Creates a new instance which acts on the currently focused component. */,2,  public CutAction() {\n    this(null);\n
522,contains,LocatorConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/LocatorConnector.java,69,70,3,/**\n   * Tests if a point is contained in the connector.\n   */,2,  @Override public boolean contains(Point2D.Double p) {\n    return getBounds().contains(p);\n
525,ZoomEditorAction,ZoomEditorAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ZoomEditorAction.java,37,38,3,/**\n   * Creates a new instance.\n   */,2,"  public ZoomEditorAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {\n    this(editor, scaleFactor, button, true);\n"
527,chop,ChopDiamondConnector,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/connector/ChopDiamondConnector.java,44,119,3,/**\n   * Return an appropriate connection point on the edge of a diamond figure\n   */,76,"  protected Point2D.Double chop(Figure target, Point2D.Double from) {\n    target = getConnectorTarget(target);\n    Rectangle2D.Double r = target.getBounds();\n    \n    if (target.get(DiamondFigure.IS_QUADRATIC)) {\n      double side = Math.max(r.width, r.height);\n      r.x -= (side - r.width) / 2;\n      r.y -= (side - r.height) / 2;\n      r.width = r.height = side;\n    }\n    double growx;\n    double growy;\n    // FIXME - This code is wrong. Copy correct code from DiamondFigure.\n    switch (target.get(STROKE_PLACEMENT)) {\n      case INSIDE : {\n        growx = growy = 0f;\n        break;\n      }\n      case OUTSIDE : {\n        double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);\n        double scale = getStrokeTotalWidth(target) * 2d / lineLength;\n        growx = scale * r.height;\n        growy = scale * r.width;\n        //growy = getStrokeTotalWidth() * SQRT2;\n        break;\n      }\n      case CENTER :\n      default :\n        double lineLength = Math.sqrt(r.width * r.width + r.height * r.height);\n        double scale = getStrokeTotalWidth(target) / lineLength;\n        growx = scale * r.height;\n        growy = scale * r.width;\n        //growx = growy = getStrokeTotalWidth() / 2d * SQRT2;\n        break;\n    }\n    Geom.grow(r, growx, growy);\n    \n    // Center point\n    Point2D.Double c1 = new Point2D.Double(r.x + r.width/2, r.y + (r.height/2));\n    Point2D.Double p2 = new Point2D.Double(r.x + r.width/2, r.y + r.height);\n    Point2D.Double p4 = new Point2D.Double(r.x + r.width/2, r.y);\n    \n    // If overlapping, just return the opposite corners\n    if (r.contains(from)) {\n      if (from.y > r.y && from.y < (r.y +r.height/2)) {\n        return p2;\n      } else {\n        return p4;\n      }\n    }\n    \n    // Calculate angle to determine quadrant\n    double ang = Geom.pointToAngle(r, from);\n    \n    // Dermine line points\n    Point2D.Double p1 = new Point2D.Double(r.x + r.width  , r.y + (r.height/2));\n    Point2D.Double p3 = new Point2D.Double(r.x      , r.y + (r.height/2));\n    Point2D.Double rp = null; // This will be returned\n    \n    // Get the intersection with edges\n    if (ang > 0 && ang < 1.57) {\n      rp = Geom.intersect(p1.x, p1.y, p2.x, p2.y, c1.x, c1.y, from.x, from.y);\n    } else if (ang > 1.575 && ang < 3.14) {\n      rp = Geom.intersect(p2.x, p2.y, p3.x, p3.y, c1.x, c1.y, from.x, from.y);\n    } else if (ang > -3.14 && ang < -1.575) {\n      rp = Geom.intersect(p3.x, p3.y, p4.x, p4.y, c1.x, c1.y, from.x, from.y);\n    } else if (ang > -1.57 && ang < 0) {\n      rp = Geom.intersect(p4.x, p4.y, p1.x, p1.y, c1.x, c1.y, from.x, from.y);\n    }\n    \n    // No proper edge found, we should send one of four corners\n    if (rp == null) {\n      rp = Geom.angleToPoint(r, ang);\n    }\n    \n    return rp;\n"
529,configureJCheckBoxMenuItem,ActionUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/ActionUtil.java,59,69,3,/**\n   * Configures a JCheckBoxMenuItem for an Action.\n   */,11,"  public static void configureJCheckBoxMenuItem(final JCheckBoxMenuItem mi, final Action a) {\n    mi.setSelected((Boolean) a.getValue(ActionUtil.SELECTED_KEY));\n    PropertyChangeListener propertyHandler = new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (evt.getPropertyName().equals(ActionUtil.SELECTED_KEY)) {\n          mi.setSelected((Boolean) a.getValue(ActionUtil.SELECTED_KEY));\n        }\n      }\n    };\n    a.addPropertyChangeListener(propertyHandler);\n    mi.putClientProperty(""actionPropertyHandler"", propertyHandler);\n"
530,PrintApplicationFileAction,PrintApplicationFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/app/PrintApplicationFileAction.java,52,54,1,/** Creates a new instance. */,3,"  public PrintApplicationFileAction(Application app) {\n    super(app, null);\n    putValue(Action.NAME, ""OSX Print File"");\n"
531,ExitAction,ExitAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/app/ExitAction.java,52,55,1,/** Creates a new instance. */,4,"  public ExitAction(Application app) {\n    super(app);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
532,actionPerformed,OpenApplicationFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/app/OpenApplicationFileAction.java,65,88,6,/**\n   * Opens a new view.\n   * <p>\n   * The file name is passed in the action command of the action event.\n   *\n   */,22,"  @Override\n  public void actionPerformed(ActionEvent evt) {\n    final Application app = getApplication();\n    final String filename = evt.getActionCommand();\n    if (app.isEnabled()) {\n      app.setEnabled(false);\n      // Search for an empty view\n      View emptyView = app.getActiveView();\n      if (emptyView == null\n          || emptyView.getURI() != null\n          || emptyView.hasUnsavedChanges()) {\n        emptyView = null;\n      }\n      final View p;\n      if (emptyView == null) {\n        p = app.createView();\n        app.add(p);\n        app.show(p);\n      } else {\n        p = emptyView;\n      }\n      openView(p, new File(filename).toURI());\n"
533,OpenApplicationFileAction,OpenApplicationFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/app/OpenApplicationFileAction.java,54,56,1,/** Creates a new instance. */,3,"  public OpenApplicationFileAction(Application app) {\n    super(app);\n    putValue(Action.NAME, ""OSX Open File"");\n"
534,installViewListeners,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,122,123,3,/**\n   * Installs listeners on the view object.\n   */,2,  protected void installViewListeners(View p) {\n    p.addPropertyChangeListener(viewListener);\n
535,isEnabled,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,157,161,8,"/**\n   * Returns true if the action is enabled.\n   * The enabled state of the action depends on the state that has been set\n   * using setEnabled() and on the enabled state of the application.\n   *\n   * @return true if the action is enabled, false otherwise\n   * @see Action#isEnabled\n   */",5,  @Override\n  public boolean isEnabled() {\n    return getActiveView() != null\n        && getActiveView().isEnabled()\n        && this.enabled;\n
536,updateView,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,79,91,4,/**\n   * Updates the listeners of this action depending on the current view\n   * of the application.\n   */,13,"  protected void updateView(View oldValue, View newValue) {\n    // We only need to do this, if the view has not been explicitly set\n    if (view == null) {\n      if (oldValue != null) {\n        uninstallViewListeners(oldValue);\n      }\n      if (newValue != null) {\n        installViewListeners(newValue);\n      }\n      firePropertyChange(VIEW_PROPERTY, oldValue, newValue);\n      updateEnabled(oldValue != null && oldValue.isEnabled(),\n          newValue != null && newValue.isEnabled());\n      updateView();\n"
537,setPropertyName,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,98,101,3,/**\n   * Sets the property name.\n   */,4,  protected void setPropertyName(String name) {\n    this.propertyName = name;\n    if (name != null) {\n      updateView();\n
538,getPropertyName,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,108,109,3,/**\n   * Gets the property name.\n   */,2,  protected String getPropertyName() {\n    return propertyName;\n
539,uninstallViewListeners,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,129,130,3,/**\n   * Uninstalls listeners on the view object.\n   */,2,  protected void uninstallViewListeners(View p) {\n    p.removePropertyChangeListener(viewListener);\n
540,AbstractViewAction,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,63,72,1,/** Creates a new instance which acts on the specified view of the application. */,10,"  public AbstractViewAction(Application app, View view) {\n    this.app = app;\n    this.view = view;\n    this.enabled = true;\n    if (view == null) {\n      app.addPropertyChangeListener(applicationListener);\n    } else {\n      view.addPropertyChangeListener(viewListener);\n    }\n    updateView(null, getActiveView());\n"
541,updateEnabled,AbstractViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/AbstractViewAction.java,137,138,4,/**\n   * Updates the enabled state of this action depending on the new enabled\n   * state of the view.\n   */,2,"  protected void updateEnabled(boolean oldValue, boolean newValue) {\n    firePropertyChange(""enabled"", oldValue, newValue && isEnabled());\n"
543,AboutAction,AboutAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/app/AboutAction.java,43,46,1,/** Creates a new instance. */,4,"  public AboutAction(Application app) {\n    super(app);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
544,AttributeChangeEdit,AttributeChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/AttributeChangeEdit.java,34,38,1,/** Creates a new instance. */,5,"  public AttributeChangeEdit(Figure owner, AttributeKey<T> name, T oldValue, T newValue) {\n    this.owner = owner;\n    this.name = name;\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n"
545,CompositeFigureEdit,CompositeFigureEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java,57,59,5,/**\n   * Creates new CompositeFigureEdit which uses the specified presentation name.\n   *\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */,3,"  public CompositeFigureEdit(Figure figure, String presentationName) {\n    super(presentationName);\n    this.figure = figure;\n"
546,CompositeFigureEdit,CompositeFigureEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java,47,49,5,/**\n   * Creates new CompositeFigureEdit which uses the specified significance.\n   *\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */,3,"  public CompositeFigureEdit(Figure figure, boolean isSignificant) {\n    super(isSignificant);\n    this.figure = figure;\n"
547,CompositeFigureEdit,CompositeFigureEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEdit.java,38,39,6,/**\n   * Creates a new {@code CompositeFigureEdit} which uses\n   * CompoundEdit.getPresentatioName and is significant.\n   *\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */,2,  public CompositeFigureEdit(Figure figure) {\n    this.figure = figure;\n
548,ArrowTip,ArrowTip,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/ArrowTip.java,47,48,4,/**\n   * Constructs an arrow tip with the specified angle and outer and inner \n   * radius.\n   */,2,"  public ArrowTip(double angle, double outerRadius, double innerRadius) {\n    this(angle, outerRadius, innerRadius, true, false, true);\n"
549,ArrowTip,ArrowTip,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/ArrowTip.java,54,58,3,/**\n   * Constructs an arrow tip with the specified parameters.\n   */,5,"  public ArrowTip(double angle, double outerRadius, double innerRadius, boolean isFilled, boolean isStroked, boolean isSolid) {\n    super(isFilled, isStroked, isSolid);\n    this.angle = angle;\n    this.outerRadius = outerRadius;\n    this.innerRadius = innerRadius;\n"
550,AbstractLineDecoration,AbstractLineDecoration,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java,46,49,3,/**\n   * Constructs an arrow tip with the given angle and radius.\n   */,4,"  public AbstractLineDecoration(boolean isFilled, boolean isStroked, boolean isSolid) {\n    this.isFilled = isFilled;\n    this.isStroked = isStroked;\n    this.isSolid = isSolid;\n"
551,draw,AbstractLineDecoration,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java,66,85,4,/**\n   * Draws the arrow tip in the direction specified by the given two\n   * Points. (template method)\n   */,20,"  public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {\n    Path2D.Double path = getTransformedDecoratorPath(f, p1, p2);\n    Color color;\n    if (isFilled) {\n      if (isSolid) {\n        color = f.get(STROKE_COLOR);\n      } else {\n        color = f.get(FILL_COLOR);\n      }\n      if (color != null) {\n        g.setColor(color);\n        g.fill(path);\n      }\n    }\n    if (isStroked) {\n      color = f.get(STROKE_COLOR);\n      if (color != null) {\n        g.setColor(color);\n        g.setStroke(AttributeKeys.getStroke(f));\n        g.draw(path);\n"
552,getDrawingArea,AbstractLineDecoration,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/AbstractLineDecoration.java,93,114,3,/**\n   * Returns the drawing area of the decorator.\n   */,22,"  public Rectangle2D.Double getDrawingArea(Figure f, Point2D.Double p1, Point2D.Double p2) {\n    Path2D.Double path = getTransformedDecoratorPath(f, p1, p2);\n    Rectangle2D b = path.getBounds2D();\n    Rectangle2D.Double area = new Rectangle2D.Double(b.getX(), b.getY(), b.getWidth(), b.getHeight());\n    \n    if (isStroked) {\n      double strokeWidth = f.get(STROKE_WIDTH);\n      int strokeJoin = f.get(STROKE_JOIN);\n      double miterLimit = (f.get(STROKE_MITER_LIMIT) * strokeWidth);\n      \n      double grow;\n      if (strokeJoin == BasicStroke.JOIN_MITER) {\n        grow  = (int) (1 + strokeWidth / 2 * miterLimit);\n      } else {\n        grow  = (int) (1 + strokeWidth / 2);\n      }\n      Geom.grow(area, grow, grow);\n    } else {\n      Geom.grow(area, 1, 1); // grow due to antialiasing\n    }\n    \n    return area;\n"
554,PerpendicularBar,PerpendicularBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java,36,37,3,/**\n   * Constructs a perpendicular line with a height of 10.\n   */,2,  public PerpendicularBar() {\n    this(10);\n
555,PerpendicularBar,PerpendicularBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java,43,46,3,/**\n   * Constructs a perpendicular line with the given height.\n   */,3,"  public PerpendicularBar(double height) {\n    super(false, true, false);\n    this.height = height;\n"
556,getDecoratorPath,PerpendicularBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/PerpendicularBar.java,53,60,4,/**\n   * Calculates the path of the decorator...a simple line\n   * perpendicular to the figure.\n   */,6,"  protected Path2D.Double getDecoratorPath(Figure f) {\n    Path2D.Double path = new Path2D.Double();\n    double halfHeight = height / 2;\n    path.moveTo(+halfHeight, 0);\n    path.lineTo(-halfHeight, 0);\n    return path;\n"
560,CompositeLineDecoration,CompositeLineDecoration,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java,51,53,3,/**\n   * Constructs a composite line decoration with the two supplied decorations.\n   */,3,"  public CompositeLineDecoration(LineDecoration decoration1, LineDecoration decoration2) {\n    addDecoration(decoration1);\n    addDecoration(decoration2);\n"
561,addDecoration,CompositeLineDecoration,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java,61,63,5,/**\n   * Add another line decoration into the composite line decoration.\n   * The new decoration will be appended to the existing decorations\n   * and is also the last drawn.\n   */,3,  public void addDecoration(LineDecoration decoration) {\n    if (decoration != null) {\n      decorations.add(decoration);\n
562,draw,CompositeLineDecoration,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java,71,73,4,/**\n   * Draws the arrow tip in the direction specified by the given two\n   * Points.. (template method)\n   */,3,"  public void draw(Graphics2D g, Figure f, Point2D.Double p1, Point2D.Double p2) {\n    for (LineDecoration decoration : decorations) {\n      decoration.draw(g, f, p1, p2);\n"
563,getDrawingArea,CompositeLineDecoration,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/decoration/CompositeLineDecoration.java,80,91,3,/**\n   * Returns the drawing area of the decorator.\n   */,12,"  public Rectangle2D.Double getDrawingArea(Figure f, Point2D.Double p1, Point2D.Double p2) {\n    Rectangle2D.Double r = null;\n    \n    for (LineDecoration decoration : decorations) {\n      Rectangle2D.Double aR = decoration.getDrawingArea(f, p1, p2);\n      if (r == null)\n        r = aR;\n      else\n        r.add(aR);\n    }\n    \n    return r;\n"
564,HandleMulticaster,HandleMulticaster,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/HandleMulticaster.java,35,37,1,/** Creates a new instance. */,3,  public HandleMulticaster(Handle handle) {\n    this.handles = new LinkedList<Handle>();\n    this.handles.add(handle);\n
571,getFigure,FigureEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java,67,68,3,/**\n   *  Gets the changed figure\n   */,2,  public Figure getFigure() {\n    return (Figure) getSource();\n
572,FigureEvent,FigureEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java,57,61,3,/**\n   * Constructs an event for the given source Figure.\n   */,5,"  public FigureEvent(Figure source, AttributeKey attribute, Object oldValue, Object newValue) {\n    super(source);\n    this.attribute = attribute;\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n"
573,FigureEvent,FigureEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/FigureEvent.java,49,51,4,/**\n   * Constructs an event for the given source Figure.\n   * @param invalidatedArea The bounds of the invalidated area on the drawing.\n   */,3,"  public FigureEvent(Figure source, Rectangle2D.Double invalidatedArea) {\n    super(source);\n    this.invalidatedArea = invalidatedArea;\n"
574,HandleEvent,HandleEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/HandleEvent.java,42,44,1,/** Creates a new instance. */,3,"  public HandleEvent(Handle src, Rectangle invalidatedArea) {\n    super(src);\n    this.invalidatedArea = invalidatedArea;\n"
575,CompositeFigureEvent,CompositeFigureEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java,47,51,6,/**\n   * Constructs an event for the provided CompositeFigure.\n   * @param source The composite figure.\n   * @param child The changed figure.\n   * @param invalidatedArea The bounds of the invalidated area on the drawing.\n   */,5,"  public CompositeFigureEvent(CompositeFigure source, Figure child, Rectangle2D.Double invalidatedArea, int zIndex) {\n    super(source);\n    this.child = child;\n    this.invalidatedArea = invalidatedArea;\n    this.index = 0;\n"
576,getInvalidatedArea,CompositeFigureEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java,71,72,3,/**\n   *  Gets the bounds of the invalidated area on the drawing.\n   */,2,  public Rectangle2D.Double getInvalidatedArea() {\n    return invalidatedArea;\n
577,getChildFigure,CompositeFigureEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java,64,65,3,/**\n   *  Gets the changed child figure.\n   */,2,  public Figure getChildFigure() {\n    return child;\n
578,getCompositeFigure,CompositeFigureEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/CompositeFigureEvent.java,58,59,3,/**\n   *  Gets the changed drawing.\n   */,2,  public CompositeFigure getCompositeFigure() {\n    return (CompositeFigure) getSource();\n
582,OpenFileAction,OpenFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java,56,59,1,/** Creates a new instance. */,4,"  public OpenFileAction(Application app) {\n    super(app);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
583,createDialog,OpenFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java,222,261,3,"/** We implement JFileChooser.showDialog by ourselves, so that we can center\n   * dialogs properly on screen on Mac OS X.\n   */",35,"  protected JDialog createDialog(URIChooser chooser, Component parent) throws HeadlessException {\n    String title = chooser.getDialogTitle();\n    if (chooser instanceof JFileChooser) {\n      ((JFileChooser) chooser).getAccessibleContext().setAccessibleDescription(title);\n    }\n    JDialog dialog;\n    Window window = (parent instanceof Window) ? (Window) parent : SwingUtilities.getWindowAncestor(parent);\n    if (window instanceof Frame) {\n      dialog = new JDialog((Frame) window, title, true);\n    } else {\n      dialog = new JDialog((Dialog) window, title, true);\n    }\n    dialog.setComponentOrientation(chooser.getComponent().getComponentOrientation());\n    Container contentPane = dialog.getContentPane();\n    contentPane.setLayout(new BorderLayout());\n    contentPane.add(chooser.getComponent(), BorderLayout.CENTER);\n    if (JDialog.isDefaultLookAndFeelDecorated()) {\n      boolean supportsWindowDecorations =\n          UIManager.getLookAndFeel().getSupportsWindowDecorations();\n      if (supportsWindowDecorations) {\n        dialog.getRootPane().setWindowDecorationStyle(JRootPane.FILE_CHOOSER_DIALOG);\n      }\n    }\n    //dialog.pack();\n    Preferences prefs = PreferencesUtil.userNodeForPackage(getApplication().getModel().getClass());\n    PreferencesUtil.installFramePrefsHandler(prefs, ""openChooser"", dialog);\n    /*\n    if (window.getBounds().isEmpty()) {\n    Rectangle screenBounds = window.getGraphicsConfiguration().getBounds();\n    dialog.setLocation(screenBounds.x + (screenBounds.width - dialog.getWidth()) / 2, //\n    screenBounds.y + (screenBounds.height - dialog.getHeight()) / 3);\n    } else {\n    dialog.setLocationRelativeTo(parent);\n    }*/\n    return dialog;\n"
584,showDialog,OpenFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenFileAction.java,185,216,3,"/** We implement JFileChooser.showDialog by ourselves, so that we can center\n   * dialogs properly on screen on Mac OS X.\n   */",29,"  public int showDialog(URIChooser chooser, Component parent) {\n    final Component finalParent = parent;\n    final int[] returnValue = new int[1];\n    final JDialog dialog = createDialog(chooser, finalParent);\n    dialog.addWindowListener(new WindowAdapter() {\n      @Override\n      public void windowClosing(WindowEvent e) {\n        returnValue[0] = JFileChooser.CANCEL_OPTION;\n      }\n    });\n    chooser.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        if (e.getActionCommand().equals(""CancelSelection"")) {\n          returnValue[0] = JFileChooser.CANCEL_OPTION;\n          dialog.setVisible(false);\n        } else if (e.getActionCommand().equals(""ApproveSelection"")) {\n          returnValue[0] = JFileChooser.APPROVE_OPTION;\n          dialog.setVisible(false);\n        }\n      }\n    });\n    returnValue[0] = JFileChooser.ERROR_OPTION;\n    chooser.rescanCurrentDirectory();\n    dialog.setVisible(true);\n    //chooser.firePropertyChange(""JFileChooserDialogIsClosingProperty"", dialog, null);\n    dialog.removeAll();\n    dialog.dispose();\n    return returnValue[0];\n"
585,LoadFileAction,LoadFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/LoadFileAction.java,57,60,1,/** Creates a new instance. */,4,"  public LoadFileAction(Application app, View view) {\n    super(app, view);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
586,ExportFileAction,ExportFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ExportFileAction.java,53,56,1,/** Creates a new instance. */,4,"  public ExportFileAction(Application app, View view) {\n    super(app, view);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
587,ClearRecentFilesMenuAction,ClearRecentFilesMenuAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ClearRecentFilesMenuAction.java,42,46,1,/** Creates a new instance. */,5,"  public ClearRecentFilesMenuAction(Application app) {\n    super(app);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n    updateEnabled();\n"
588,installApplicationListeners,ClearRecentFilesMenuAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/ClearRecentFilesMenuAction.java,52,57,3,/**\n   * Installs listeners on the application object.\n   */,6,  @Override protected void installApplicationListeners(Application app) {\n    super.installApplicationListeners(app);\n    if (applicationListener == null) {\n      applicationListener = createApplicationListener();\n    }\n    app.addPropertyChangeListener(applicationListener);\n
589,fireHandleRequestRemove,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,124,137,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireHandleRequestRemove(Rectangle invalidatedArea) {\n    HandleEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == HandleListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new HandleEvent(this, invalidatedArea);\n        }\n        ((HandleListener) listeners[i + 1]).handleRequestRemove(event);\n"
591,areaInvalidated,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,275,276,7,/**\n   * Sent when a region used by the figure needs to be repainted.\n   * The implementation of this method assumes that the handle\n   * is located on the bounds of the figure or inside the figure.\n   * If the handle is located elsewhere this method must be reimpleted\n   * by the subclass.\n   */,2,  public void areaInvalidated(FigureEvent evt) {\n    updateBounds();\n
593,addHandleListener,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,63,64,3,/**\n   * Adds a listener for this handle.\n   */,2,"  public void addHandleListener(HandleListener l) {\n    listenerList.add(HandleListener.class, l);\n"
594,removeHandleListener,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,70,71,3,/**\n   * Removes a listener for this handle.\n   */,2,"  public void removeHandleListener(HandleListener l) {\n    listenerList.remove(HandleListener.class, l);\n"
595,AbstractHandle,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,48,53,1,/** Creates a new instance. */,6,"  public AbstractHandle(Figure owner) {\n    if (owner == null) {\n      throw new IllegalArgumentException(""owner must not be null"");\n    }\n    this.owner = owner;\n    owner.addFigureListener(this);\n"
596,getCursor,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,310,311,3,/**\n   * Returns a cursor for the handle.\n   */,2,  public Cursor getCursor() {\n    return Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR);\n
597,LoadRecentFileAction,LoadRecentFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/LoadRecentFileAction.java,47,50,1,/** Creates a new instance. */,4,"  public LoadRecentFileAction(Application app, View view, URI uri) {\n    super(app, view);\n    this.uri = uri;\n    putValue(Action.NAME, URIUtil.getName(uri));\n"
598,fireHandleRequestSecondaryHandles,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,146,159,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireHandleRequestSecondaryHandles() {\n    HandleEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == HandleListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new HandleEvent(this, null);\n        }\n        ((HandleListener) listeners[i + 1]).handleRequestSecondaryHandles(event);\n"
599,getToolTipText,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,379,380,4,"/**\n   * Returns a tooltip for the specified location.\n   * By default, AbstractHandle returns null.\n   */",2,  public String getToolTipText(Point p) {\n    return toolTipText;\n
600,draw,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,167,170,3,/**\n   * Draws this handle.\n   */,4,"  public void draw(Graphics2D g) {\n    drawCircle(g,\n        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_FILL_COLOR),\n        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.HANDLE_STROKE_COLOR));\n"
601,fireUndoableEditHappened,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,116,117,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,2,  protected void fireUndoableEditHappened(UndoableEdit edit) {\n    view.getDrawing().fireUndoableEditHappened(edit);\n
602,figureChanged,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,303,304,3,/**\n   * Sent when the bounds or shape of a figure has changed.\n   */,2,  public void figureChanged(FigureEvent evt) {\n    updateBounds();\n
605,fireAreaInvalidated,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,94,107,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireAreaInvalidated(Rectangle invalidatedArea) {\n    HandleEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == HandleListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new HandleEvent(this, invalidatedArea);\n        }\n        ((HandleListener) listeners[i + 1]).areaInvalidated(event);\n"
606,isCombinableWith,AbstractHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractHandle.java,318,319,4,"/**\n   * Returns true, if the given handle is an instance of the same\n   * class or of a subclass of this handle,.\n   */",2,  public boolean isCombinableWith(Handle handle) {\n    return getClass().isAssignableFrom(handle.getClass());\n
607,trackStart,AbstractConnectionHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java,113,119,3,/**\n   * Disconnects the connection.\n   */,7,"  public void trackStart(Point anchor, int modifiersEx) {\n    savedTarget = getTarget();\n    start = anchor;\n    savedLiner = getOwner().getLiner();\n    getOwner().setLiner(null);\n    //disconnect();\n    fireHandleRequestSecondaryHandles();\n"
608,getSource,AbstractConnectionHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java,103,107,4,/**\n   * Gets the side of the connection that is unaffected by\n   * the change.\n   */,5,  protected Connector getSource() {\n    if (getTarget() == getOwner().getStartConnector()) {\n      return getOwner().getEndConnector();\n    }\n    return getOwner().getStartConnector();\n
609,trackStep,AbstractConnectionHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java,125,138,3,/**\n   * Finds a new connectableConnector of the connection.\n   */,14,"  public void trackStep(Point anchor, Point lead, int modifiersEx) {\n    Point2D.Double p = view.viewToDrawing(lead);\n    view.getConstrainer().constrainPoint(p);\n    connectableFigure = findConnectableFigure(p, view.getDrawing());\n    if (connectableFigure != null) {\n      Connector aTarget = findConnectionTarget(p, view.getDrawing());\n      if (aTarget != null) {\n        p = aTarget.getAnchor();\n      }\n    }\n    getOwner().willChange();\n    setLocation(p);\n    getOwner().changed();\n    repaintConnectors();\n"
614,draw,AbstractConnectionHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java,209,226,3,/**\n   * Draws this handle.\n   */,16,"  @Override\n  public void draw(Graphics2D g) {\n    Graphics2D gg = (Graphics2D) g.create();\n    gg.transform(view.getDrawingToViewTransform());\n    for (Connector c : connectors) {\n      c.draw(gg);\n    }\n    gg.dispose();\n    if (getTarget() == null) {\n      drawCircle(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_FILL_COLOR),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.DISCONNECTED_CONNECTION_HANDLE_STROKE_COLOR));\n    } else {\n      drawCircle(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_FILL_COLOR),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.CONNECTED_CONNECTION_HANDLE_STROKE_COLOR));\n"
615,trackEnd,AbstractConnectionHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractConnectionHandle.java,145,180,4,/**\n   * Connects the figure to the new connectableConnector. If there is no\n   * new connectableConnector the connection reverts to its original one.\n   */,34,"  public void trackEnd(Point anchor, Point lead, int modifiersEx) {\n    ConnectionFigure f = getOwner();\n    // Change node type\n    if ((modifiersEx & (InputEvent.META_DOWN_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.ALT_DOWN_MASK | InputEvent.SHIFT_DOWN_MASK)) != 0 &&\n        (modifiersEx & InputEvent.BUTTON2_DOWN_MASK) == 0) {\n      f.willChange();\n      int index = getBezierNodeIndex();\n      BezierPath.Node v = f.getNode(index);\n      if (index > 0 && index < f.getNodeCount()) {\n        v.mask = (v.mask + 3) % 4;\n      } else if (index == 0) {\n        v.mask = ((v.mask & BezierPath.C2_MASK) == 0) ? BezierPath.C2_MASK : 0;\n      } else {\n        v.mask = ((v.mask & BezierPath.C1_MASK) == 0) ? BezierPath.C1_MASK : 0;\n      }\n      f.setNode(index, v);\n      f.changed();\n      fireHandleRequestSecondaryHandles();\n    }\n    Point2D.Double p = view.viewToDrawing(lead);\n    view.getConstrainer().constrainPoint(p);\n    Connector target = findConnectionTarget(p, view.getDrawing());\n    if (target == null) {\n      target = savedTarget;\n    }\n    setLocation(p);\n    if (target != savedTarget) {\n      disconnect();\n      connect(target);\n    }\n    getOwner().setLiner(savedLiner);\n    getOwner().updateConnection();\n    connectableConnector = null;\n    connectors = Collections.emptyList();\n"
618,getTool,ToolEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java,52,53,3,/**\n   * Gets the tool which is the source of the event.\n   */,2,  public Tool getTool() {\n    return (Tool) getSource();\n
619,getView,ToolEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java,58,59,3,/**\n   * Gets the drawing view of the tool.\n   */,2,  public DrawingView getView() {\n    return view;\n
620,ToolEvent,ToolEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/event/ToolEvent.java,43,46,1,/** Creates a new instance. */,4,"  public ToolEvent(Tool src, DrawingView view, Rectangle invalidatedArea) {\n    super(src);\n    this.view = view;\n    this.invalidatedArea = invalidatedArea;\n"
621,draw,BezierControlPointHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierControlPointHandle.java,88,139,3,/**\n   * Draws this handle.\n   */,51,"  public void draw(Graphics2D g) {\n    BezierFigure f = getBezierFigure();\n    if (f.getNodeCount() > index) {\n      BezierPath.Node v = f.getNode(index);\n      Point2D.Double p0 = new Point2D.Double(v.x[0], v.y[0]);\n      Point2D.Double pc = new Point2D.Double(v.x[controlPointIndex], v.y[controlPointIndex]);\n      Figure tOwner = getTransformOwner();\n      if (tOwner.get(TRANSFORM) != null) {\n        tOwner.get(TRANSFORM).transform(p0, p0);\n        tOwner.get(TRANSFORM).transform(pc, pc);\n      }\n      Color handleFillColor;\n      Color handleStrokeColor;\n      Stroke stroke1;\n      Color strokeColor1;\n      Stroke stroke2;\n      Color strokeColor2;\n      if (getEditor().getTool().supportsHandleInteraction()) {\n        handleFillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_FILL_COLOR);\n        handleStrokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_STROKE_COLOR);\n        stroke1 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_1);\n        strokeColor1 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_1);\n        stroke2 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_2);\n        strokeColor2 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_2);\n      } else {\n        handleFillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_FILL_COLOR_DISABLED);\n        handleStrokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_CONTROL_POINT_HANDLE_STROKE_COLOR_DISABLED);\n        stroke1 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_1_DISABLED);\n        strokeColor1 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_1_DISABLED);\n        stroke2 = (Stroke) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_STROKE_2_DISABLED);\n        strokeColor2 = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_TANGENT_COLOR_2_DISABLED);\n      }\n      if (stroke1 != null && strokeColor1 != null) {\n        g.setStroke(stroke1);\n        g.setColor(strokeColor1);\n        g.draw(new Line2D.Double(\n            view.drawingToView(p0),\n            view.drawingToView(pc)));\n      }\n      if (stroke2 != null && strokeColor2 != null) {\n        g.setStroke(stroke2);\n        g.setColor(strokeColor2);\n        g.draw(new Line2D.Double(\n            view.drawingToView(p0),\n            view.drawingToView(pc)));\n      }\n      if (v.keepColinear && v.mask == BezierPath.C1C2_MASK &&\n          (index > 0 && index < f.getNodeCount() - 1 || f.isClosed())) {\n        drawCircle(g, handleStrokeColor, handleFillColor);\n      } else {\n        drawCircle(g, handleFillColor, handleStrokeColor);\n"
622,BezierControlPointHandle,BezierControlPointHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierControlPointHandle.java,43,44,1,/** Creates a new instance. */,2,"  public BezierControlPointHandle(BezierFigure owner, int index, int coord) {\n    this(owner, index, coord, owner);\n"
626,AbstractRotateHandle,AbstractRotateHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/AbstractRotateHandle.java,45,46,1,/** Creates a new instance. */,2,  public AbstractRotateHandle(Figure owner) {\n    super(owner);\n
628,ColorWheelImageProducer,ColorWheelImageProducer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelImageProducer.java,49,57,1,/** Creates a new instance. */,9,"  public ColorWheelImageProducer(ColorSystem sys, int w, int h) {\n    super(w, h, null, 0, w);\n    pixels = new int[w * h];\n    this.w = w;\n    this.h = h;\n    this.colorSystem = sys;\n    setAnimated(true);\n    \n    newPixels(pixels, ColorModel.getRGBdefault(), 0, w);\n"
630,getBoundedRangeModel,DefaultColorSliderModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java,101,102,3,/**\n   * Returns the bounded range model of the specified color componentIndex.\n   */,2,  public DefaultBoundedRangeModel getBoundedRangeModel(int componentIndex) {\n    return componentModels[componentIndex];\n
631,unconfigureSlider,DefaultColorSliderModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java,87,94,3,/**\n   * Unconfigures a JSlider from this AbstractColorSystem.\n   */,8,"  public void unconfigureSlider(JSlider slider) {\n    if (slider.getClientProperty(""colorSliderModel"") == this) {\n      // XXX - This creates a NullPointerException ??\n      //slider.setUI((SliderUI) UIManager.getUI(slider));\n      slider.setModel(new DefaultBoundedRangeModel());\n      slider.putClientProperty(""colorSliderModel"", null);\n      slider.putClientProperty(""colorComponentIndex"", null);\n      removeColorSlider(slider);\n"
632,getSliderValue,DefaultColorSliderModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java,108,109,3,/**\n   * Returns the value of the specified color componentIndex.\n   */,2,  public int getSliderValue(int componentIndex) {\n    return componentModels[componentIndex].getValue();\n
633,configureSlider,DefaultColorSliderModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/DefaultColorSliderModel.java,71,81,5,"/**\n   * Configures a JSlider for this AbstractColorSystem.\n   * If the JSlider is already configured for another AbstractColorSystem,\n   * it is unconfigured first.\n   */",11,"  public void configureSlider(int componentIndex, JSlider slider) {\n    if (slider.getClientProperty(""colorSliderModel"") != null) {\n      ((DefaultColorSliderModel) slider.getClientProperty(""colorSliderModel"")).unconfigureSlider(slider);\n    }\n    if (!(slider.getUI() instanceof ColorSliderUI)) {\n      slider.setUI((ColorSliderUI) ColorSliderUI.createUI(slider));\n    }\n    slider.setModel(getBoundedRangeModel(componentIndex));\n    slider.putClientProperty(""colorSliderModel"", this);\n    slider.putClientProperty(""colorComponentIndex"", new Integer(componentIndex));\n    addColorSlider(slider);\n"
634,SaveFileAction,SaveFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/SaveFileAction.java,52,53,1,/** Creates a new instance. */,2,"  public SaveFileAction(Application app, View view) {\n    this(app, view, false);\n"
635,printQuartz,PrintFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java,147,218,4,"/**\n   * On Mac OS X with the Quartz rendering engine, the following code achieves\n   * the best results.\n   */",66,"  public void printQuartz(PrintableView v) {\n    Frame frame = (Frame) SwingUtilities.getWindowAncestor(v.getComponent());\n    final Pageable pageable = v.createPageable();\n    final double resolution = 300d;\n    JobAttributes jobAttr = new JobAttributes();\n    // FIXME - PageAttributes should be retrieved from View\n    PageAttributes pageAttr = new PageAttributes();\n    pageAttr.setMedia(PageAttributes.MediaType.A4);\n    pageAttr.setPrinterResolution((int) resolution);\n    final PrintJob pj = frame.getToolkit().getPrintJob(\n        frame,\n        ""Job Title"",\n        jobAttr,\n        pageAttr);\n    getActiveView().setEnabled(false);\n    new Worker() {\n      protected Object construct() throws PrinterException {\n        // Compute page format from settings of the print job\n        Paper paper = new Paper();\n        paper.setSize(\n            pj.getPageDimension().width / resolution * 72d,\n            pj.getPageDimension().height / resolution * 72d);\n        paper.setImageableArea(64d, 32d, paper.getWidth() - 96d, paper.getHeight() - 64);\n        PageFormat pageFormat = new PageFormat();\n        pageFormat.setPaper(paper);\n        // Print the job\n        try {\n          for (int i = 0,  n = pageable.getNumberOfPages(); i < n; i++) {\n            PageFormat pf = pageable.getPageFormat(i);\n            pf = pageFormat;\n            Graphics g = pj.getGraphics();\n            if (g instanceof Graphics2D) {\n              pageable.getPrintable(i).print(g, pf, i);\n            } else {\n              BufferedImage buf = new BufferedImage(\n                  (int) (pf.getImageableWidth() * resolution / 72d),\n                  (int) (pf.getImageableHeight() * resolution / 72d),\n                  BufferedImage.TYPE_INT_RGB);\n              Graphics2D bufG = buf.createGraphics();\n\n              bufG.setBackground(Color.WHITE);\n              bufG.fillRect(0, 0, buf.getWidth(), buf.getHeight());\n              bufG.scale(resolution / 72d, resolution / 72d);\n              bufG.translate(-pf.getImageableX(), -pf.getImageableY());\n              pageable.getPrintable(i).print(bufG, pf, i);\n              bufG.dispose();\n              g.drawImage(buf,\n                  (int) (pf.getImageableX() * resolution / 72d),\n                  (int) (pf.getImageableY() * resolution / 72d),\n                  null);\n              buf.flush();\n            }\n            g.dispose();\n          }\n        } finally {\n          pj.end();\n        }\n        return null;\n      }\n      protected void failed(Throwable error) {\n         error.printStackTrace();\n      }\n      protected void finished() {\n        getActiveView().setEnabled(true);\n      }\n    }.start();\n"
636,printJava2D,PrintFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java,81,109,3,/*\n   * This prints at 72 DPI only. We might need this for some JVM versions on\n   * Mac OS X.*/,28,"  public void printJava2D(PrintableView v) {\n    Pageable pageable = v.createPageable();\n    if (pageable == null) {\n      throw new InternalError(""View does not have a method named java.awt.Pageable createPageable()"");\n    }\n    try {\n      PrinterJob job = PrinterJob.getPrinterJob();\n      // FIXME - PrintRequestAttributeSet should be retrieved from View\n      PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();\n      attr.add(new PrinterResolution(300, 300, PrinterResolution.DPI));\n      job.setPageable(pageable);\n      if (job.printDialog()) {\n        try {\n          job.print();\n        } catch (PrinterException e) {\n          String message = (e.getMessage() == null) ? e.toString() : e.getMessage();\n          View view = getActiveView();\n          ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n          JSheet.showMessageSheet(view.getComponent(),\n              ""<html>"" + UIManager.getString(""OptionPane.css"") +\n              ""<b>"" + labels.getString(""couldntPrint"") + ""</b><br>"" +\n              ((message == null) ? """" : message));\n        }\n      } else {\n        System.out.println(""JOB ABORTED!"");\n      }\n    } catch (Throwable t) {\n      t.printStackTrace();\n"
637,printJava2DAlternative,PrintFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java,116,139,3,/*\n   * This prints at 72 DPI only. We might need this for some JVM versions on\n   * Mac OS X.*/,23,"  public void printJava2DAlternative(PrintableView v) {\n    Pageable pageable = v.createPageable();\n    if (pageable == null) {\n      throw new InternalError(""View does not have a method named java.awt.Pageable createPageable()"");\n    }\n    try {\n      final PrinterJob job = PrinterJob.getPrinterJob();\n      PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();\n      attr.add(new PrinterResolution(300, 300, PrinterResolution.DPI));\n      job.setPageable(pageable);\n      if (job.printDialog(attr)) {\n        try {\n          job.print();\n        } catch (PrinterException e) {\n          ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n          JSheet.showMessageSheet(getActiveView().getComponent(),\n              labels.getFormatted(""couldntPrint"", e));\n        }\n      } else {\n        System.out.println(""JOB ABORTED!"");\n      }\n    } catch (Throwable t) {\n      t.printStackTrace();\n"
638,PrintFileAction,PrintFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/PrintFileAction.java,61,64,1,/** Creates a new instance. */,4,"  public PrintFileAction(Application app, View view) {\n    super(app, view);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n"
639,ViewPropertyAction,ViewPropertyAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/view/ViewPropertyAction.java,46,47,1,/** Creates a new instance. */,2,"  public ViewPropertyAction(Application app, View view, String propertyName, Object propertyValue) {\n    this(app, view, propertyName, propertyValue.getClass(), propertyValue);\n"
640,FocusWindowAction,FocusWindowAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/window/FocusWindowAction.java,40,53,1,/** Creates a new instance. */,14,"  public FocusWindowAction(View view) {\n    this.view = view;\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n    labels.configureAction(this, ID);\n    //setEnabled(false);\n    setEnabled(view != null);\n    \n    view.addPropertyChangeListener(ppc = new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n        String name = evt.getPropertyName();\n        if (name.equals(View.TITLE_PROPERTY)) {\n          putValue(Action.NAME,\n              evt.getNewValue()\n"
641,OpenRecentFileAction,OpenRecentFileAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/file/OpenRecentFileAction.java,49,52,1,/** Creates a new instance. */,4,"  public OpenRecentFileAction(Application app, URI uri) {\n    super(app);\n    this.uri = uri;\n    putValue(Action.NAME, URIUtil.getName(uri));\n"
642,ToggleViewPropertyAction,ToggleViewPropertyAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/action/view/ToggleViewPropertyAction.java,47,48,1,/** Creates a new instance. */,2,"  public ToggleViewPropertyAction(Application app, View view, String propertyName) {\n    this(app, view, propertyName, Boolean.TYPE, true, false);\n"
645,get,AbstractAttributedFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedFigure.java,95,96,3,/**\n   * Gets an attribute from the figure.\n   */,2,  public <T> T get(AttributeKey<T> key) {\n    return key.get(attributes);\n
647,set,AbstractAttributedFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedFigure.java,85,89,5,/**\n   * Sets an attribute of the figure.\n   * AttributeKey name and semantics are defined by the class implementing\n   * the figure interface.\n   */,5,"  public <T> void set(AttributeKey<T> key, T newValue) {\n    if (forbiddenAttributes == null\n        || ! forbiddenAttributes.contains(key)) {\n      T oldValue = (T) key.put(attributes, newValue);\n      fireAttributeChanged(key, oldValue, newValue);\n"
649,get,AbstractAttributedCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedCompositeFigure.java,96,98,3,/**\n   * Gets an attribute from the figure.\n   */,3,  @Override\n  public <T> T get(AttributeKey<T> key) {\n    return key.get(attributes);\n
652,set,AbstractAttributedCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractAttributedCompositeFigure.java,78,83,5,/**\n   * Sets an attribute of the figure.\n   * AttributeKey name and semantics are defined by the class implementing\n   * the figure interface.\n   */,6,"  @Override\n  public <T> void set(AttributeKey<T> key, T newValue) {\n    if (forbiddenAttributes == null || !forbiddenAttributes.contains(key)) {\n      Object oldValue = attributes.put(key, newValue);\n      setAttributeOnChildren(key, newValue);\n      fireAttributeChanged(key, oldValue, newValue);\n"
655,transform,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,290,294,3,/**\n   * Transforms the figure.\n   */,5,  public void transform(AffineTransform tx) {\n    for (Figure f : getChildren()) {\n      f.transform(tx);\n    }\n    invalidate();\n
656,getLayouter,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,431,432,9,"/**\n   * Get a Layouter object which encapsulated a layout\n   * algorithm for this figure. Typically, a Layouter\n   * accesses the child components of this figure and arranges\n   * their graphical presentation.\n   *\n   *\n   * @return layout strategy used by this figure\n   */",2,  public Layouter getLayouter() {\n    return layouter;\n
657,fireFigureRemoved,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,673,686,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireFigureRemoved(Figure f, int zIndex) {\n    CompositeFigureEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == CompositeFigureListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);\n        }\n        ((CompositeFigureListener) listeners[i + 1]).figureRemoved(event);\n"
658,bringToFront,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,280,283,5,/**\n   * Brings a figure to the front of the drawing.\n   *\n   * @param figure that is part of the drawing\n   */,4,  public synchronized void bringToFront(Figure figure) {\n    if (basicRemove(figure) != -1) {\n      basicAdd(figure);\n      fireAreaInvalidated(figure.getDrawingArea());\n
659,fireFigureAdded,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,651,664,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireFigureAdded(Figure f, int zIndex) {\n    CompositeFigureEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == CompositeFigureListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);\n        }\n        ((CompositeFigureListener) listeners[i + 1]).figureAdded(event);\n"
660,setLayouter,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,464,465,12,"/**\n   * Set a Layouter object which encapsulated a layout\n   * algorithm for this figure. Typically, a Layouter\n   * accesses the child components of this figure and arranges\n   * their graphical presentation. It is a good idea to set\n   * the Layouter in the protected initialize() method\n   * so it can be recreated if a GraphicalCompositeFigure is\n   * read and restored from a StorableInput stream.\n   *\n   *\n   * @param newLayouter  encapsulation of a layout algorithm.\n   */",2,  public void setLayouter(Layouter newLayouter) {\n    this.layouter = newLayouter;\n
661,removeAll,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,219,221,5,/**\n   * Removes all specified children.\n   *\n   * @see #add\n   */,3,  public void removeAll(Collection<? extends Figure> figures) {\n    for (Figure f : figures) {\n      remove(f);\n
662,sendToBack,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,268,271,5,/**\n   * Sends a figure to the back of the composite figure.\n   *\n   * @param figure that is part of this composite figure\n   */,4,"  public synchronized void sendToBack(Figure figure) {\n    if (basicRemove(figure) != -1) {\n      basicAdd(0, figure);\n      fireAreaInvalidated(figure.getDrawingArea());\n"
664,basicRemoveAllChildren,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,246,248,5,/**\n   * Removes all children.\n   *\n   * @see #add\n   */,3,  public void basicRemoveAllChildren() {\n    for (Figure f : new LinkedList<Figure>(getChildren())) {\n      basicRemove(f);\n
665,layout,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,441,448,6,/**\n   * A layout algorithm is used to define how the child components\n   * should be laid out in relation to each other. The task for\n   * layouting the child components for presentation is delegated\n   * to a Layouter which can be plugged in at runtime.\n   */,8,"  public void layout() {\n    if (getLayouter() != null) {\n      Rectangle2D.Double bounds = getBounds();\n      Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);\n      Rectangle2D.Double r = getLayouter().layout(\n          this, p, p);\n      setBounds(new Point2D.Double(r.x, r.y), new Point2D.Double(r.x + r.width, r.y + r.height));\n      invalidate();\n"
666,removeAllChildren,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,230,238,5,/**\n   * Removes all children.\n   *\n   * @see #add\n   */,9,  public void removeAllChildren() {\n    willChange();\n    for (Figure f : new LinkedList<Figure>(getChildren())) {\n      if (getDrawing() != null) {\n        f.removeNotify(getDrawing());\n      }\n      int index = basicRemove(f);\n    }\n    changed();\n
667,getChildrenFrontToBack,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,330,331,4,/**\n   * Returns an iterator to iterate in\n   * Z-order front to back over the children.\n   */,2,  public java.util.List<Figure> getChildrenFrontToBack() {\n    return children.size() == 0 ? new LinkedList<Figure>() : new ReversedList<Figure>(getChildren());\n
668,basicRemoveAll,AbstractCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractCompositeFigure.java,257,259,5,/**\n   * Removes all children.\n   *\n   * @see #add\n   */,3,  public void basicRemoveAll(Collection<? extends Figure> figures) {\n    for (Figure f : figures) {\n      basicRemove(f);\n
670,JColorWheel,JColorWheel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/JColorWheel.java,84,85,3,/**\n   * Creates a new instance.\n   */,2,  public JColorWheel() {\n    this(new HSVRGBColorSystem());\n
671,JHarmonicColorWheel,JHarmonicColorWheel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/JHarmonicColorWheel.java,128,141,1,/** Creates new form. */,11,"  public JHarmonicColorWheel() {\n    super(new HSLRYBColorSystem());\n    initComponents();\n    setRadialComponentIndex(2);\n    setVerticalComponentIndex(1);\n    getModel().setComponentValue(1, 1f);\n    setWheelInsets(new Insets(5, 5, 5, 5));\n    modelHandler = new ModelHandler();\n    DefaultHarmonicColorModel p = new DefaultHarmonicColorModel();\n    setHarmonicColorModel(p);\n    setToolTipText("""");\n"
675,draw,BezierNodeHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierNodeHandle.java,67,93,3,/**\n   * Draws this handle.\n   */,27,"  @Override\n  public void draw(Graphics2D g) {\n    BezierFigure f = getOwner();\n    int size = f.getNodeCount();\n    boolean isClosed = f.isClosed();\n    Color fillColor;\n    Color strokeColor;\n    if (getEditor().getTool().supportsHandleInteraction()) {\n      fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR);\n      strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR);\n    } else {\n      fillColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_FILL_COLOR_DISABLED);\n      strokeColor = (Color) getEditor().getHandleAttribute(HandleAttributeKeys.BEZIER_NODE_HANDLE_STROKE_COLOR_DISABLED);\n    }\n    if (size > index) {\n      BezierPath.Node v = f.getNode(index);\n      if (v.mask == 0 ||\n          index == 0 && v.mask == BezierPath.C1_MASK && !isClosed ||\n          index == size - 1 && v.mask == BezierPath.C2_MASK && !isClosed) {\n        drawRectangle(g, fillColor, strokeColor);\n      } else if (v.mask == BezierPath.C1_MASK ||\n          v.mask == BezierPath.C2_MASK ||\n          index == 0 && !isClosed ||\n          index == size - 1 && !isClosed) {\n        drawDiamond(g, fillColor, strokeColor);\n      } else {\n        drawCircle(g, fillColor, strokeColor);\n"
676,BezierNodeHandle,BezierNodeHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierNodeHandle.java,46,47,1,/** Creates a new instance. */,2,"  public BezierNodeHandle(BezierFigure owner, int index) {\n    this(owner, index, owner);\n"
677,ConnectorHandle,ConnectorHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java,63,66,1,/** Creates a new instance. */,4,"  public ConnectorHandle(Connector connector, ConnectionFigure prototype) {\n    super(connector.getOwner());\n    this.connector = connector;\n    this.prototype = prototype;\n"
678,createConnection,ConnectorHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java,193,194,4,/**\n   * Creates the ConnectionFigure. By default the figure prototype is\n   * cloned.\n   */,2,  protected ConnectionFigure createConnection() {\n    return (ConnectionFigure) prototype.clone();\n
679,findConnectableConnector,ConnectorHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectorHandle.java,228,234,3,/**\n   * Finds a connection end figure.\n   */,6,"  protected Connector findConnectableConnector(Figure connectableFigure, Point2D.Double p) {\n    Connector target = (connectableFigure == null) ? null : connectableFigure.findConnector(p, getConnection());\n    if ((connectableFigure != null) && connectableFigure.isConnectable() && !connectableFigure.includes(getOwner()) && getConnection().canConnect(connector, target)) {\n      return target;\n    }\n    return null;\n"
680,draw,CloseHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java,47,51,3,/**\n   * Draws this handle.\n   */,5,"  public void draw(Graphics2D g) {\n    drawRectangle(g, (pressed) ? Color.orange : Color.white, Color.black);\n    Rectangle r = getBounds();\n    g.drawLine(r.x, r.y, r.x+r.width, r.y+r.height);\n    g.drawLine(r.x+r.width, r.y, r.x, r.y+r.height);\n"
681,CloseHandle,CloseHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java,32,33,1,/** Creates a new instance. */,2,"  public CloseHandle(Figure owner) {\n    this(owner, new RelativeLocator(1.0, 0.0));\n"
682,CloseHandle,CloseHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/CloseHandle.java,36,37,1,/** Creates a new instance. */,2,"  public CloseHandle(Figure owner, Locator locator) {\n    super(owner, locator);\n"
683,FontSizeHandle,FontSizeHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/FontSizeHandle.java,40,41,1,/** Creates a new instance. */,2,"  public FontSizeHandle(TextHolderFigure owner) {\n    super(owner, new FontSizeLocator());\n"
684,draw,BezierScaleHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierScaleHandle.java,55,58,3,/**\n   * Draws this handle.\n   */,4,"  public void draw(Graphics2D g) {\n    drawCircle(g, \n        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_FILL_COLOR),\n        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.SCALE_HANDLE_STROKE_COLOR)\n"
685,BezierScaleHandle,BezierScaleHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BezierScaleHandle.java,43,44,1,/** Creates a new instance. */,2,  public BezierScaleHandle(BezierFigure owner) {\n    super(owner);\n
687,DragHandle,DragHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/DragHandle.java,44,45,1,/** Creates a new instance. */,2,  public DragHandle(Figure owner) {\n    super(owner);\n
688,setLocation,ConnectionEndHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java,59,62,3,/**\n   * Sets the start point of the connection.\n   */,4,  protected void setLocation(Point2D.Double p) {\n    getOwner().willChange();\n    getOwner().setEndPoint(p);\n    getOwner().changed();\n
689,disconnect,ConnectionEndHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java,47,48,3,/**\n   * Disconnects the start figure.\n   */,2,  protected void disconnect() {\n    getOwner().setEndConnector(null);\n
690,ConnectionEndHandle,ConnectionEndHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java,33,34,3,/**\n   * Constructs the connection handle for the given start figure.\n   */,2,  public ConnectionEndHandle(ConnectionFigure owner) {\n    super(owner);\n
691,connect,ConnectionEndHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionEndHandle.java,40,41,3,/**\n   * Sets the start of the connection.\n   */,2,  protected void connect(Connector c) {\n    getOwner().setEndConnector(c);\n
692,BoundsOutlineHandle,BoundsOutlineHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java,53,86,5,/**\n   * Creates a bounds outline handle for resizing or transforming a component.\n   * \n   * @param owner\n   */,34,"  public BoundsOutlineHandle(Figure owner, boolean isTransformHandle, boolean isHoverHandle) {\n    super(owner);\n    if (isTransformHandle) {\n      if (isHoverHandle) {\n        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;\n        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;\n        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;\n        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;\n      } else {\n        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;\n        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;\n        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;\n        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;\n      }\n      stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;\n      strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;\n      stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;\n      strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;\n    } else {\n      if (isHoverHandle) {\n        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;\n        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;\n        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;\n        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;\n      } else {\n        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;\n        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;\n        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;\n        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;\n      }\n      stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;\n      strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;\n      stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;\n      strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;\n"
693,BoundsOutlineHandle,BoundsOutlineHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java,95,109,5,/**\n   * Creates a bounds outline handle for resizing or transforming a component.\n   *\n   * @param owner\n   */,15,"  public BoundsOutlineHandle(Figure owner, //\n      AttributeKey<Stroke> stroke1Enabled, AttributeKey<Color> strokeColor1Enabled,//\n      AttributeKey<Stroke> stroke2Enabled, AttributeKey<Color> strokeColor2Enabled,//\n      AttributeKey<Stroke> stroke1Disabled, AttributeKey<Color> strokeColor1Disabled,//\n      AttributeKey<Stroke> stroke2Disabled, AttributeKey<Color> strokeColor2Disabled\n      ) {\n    super(owner);\n    this.stroke1Enabled = stroke1Enabled;\n    this.strokeColor1Enabled = strokeColor1Enabled;\n    this.stroke2Enabled = stroke2Enabled;\n    this.strokeColor2Enabled = strokeColor2Enabled;\n    this.stroke1Disabled = stroke1Disabled;\n    this.strokeColor1Disabled = strokeColor1Disabled;\n    this.stroke2Disabled = stroke2Disabled;\n    this.strokeColor2Disabled = strokeColor2Disabled;\n"
694,BoundsOutlineHandle,BoundsOutlineHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/BoundsOutlineHandle.java,44,45,5,/**\n   * Creates a bounds outline handle for resizing a component.\n   * \n   * @param owner\n   */,2,"  public BoundsOutlineHandle(Figure owner) {\n    this(owner, false, false);\n"
695,disconnect,ConnectionStartHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java,47,48,3,/**\n   * Disconnects the start figure.\n   */,2,  protected void disconnect() {\n    getOwner().setStartConnector(null);\n
696,setLocation,ConnectionStartHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java,59,62,3,/**\n   * Sets the start point of the connection.\n   */,4,  protected void setLocation(Point2D.Double p) {\n    getOwner().willChange();\n    getOwner().setStartPoint(p);\n    getOwner().changed();\n
697,removeFromSource,WeakPropertyChangeListener,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/WeakPropertyChangeListener.java,76,84,4,/**\n   *  Method that can be subclassed to provide additional remove\n   *  support.  Default implementation only supports StandardBeans.\n   */,9,"  protected void removeFromSource(PropertyChangeEvent event) {\n    // Remove ourselves from the source\n    Object src = event.getSource();\n    try {\n      src.getClass().getMethod(""removePropertyChangeListener"", new Class[] {PropertyChangeListener.class}).invoke(src, this);\n    } catch (Exception ex) {\n      InternalError ie = new InternalError(""Could not remove WeakPropertyChangeListener from ""+src+""."");\n      ie.initCause(ex);\n      throw ie;\n"
698,connect,ConnectionStartHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java,40,41,3,/**\n   * Sets the start of the connection.\n   */,2,  protected void connect(Connector c) {\n    getOwner().setStartConnector(c);\n
699,ConnectionStartHandle,ConnectionStartHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ConnectionStartHandle.java,33,34,3,/**\n   * Constructs the connection handle for the given start figure.\n   */,2,  public ConnectionStartHandle(ConnectionFigure owner) {\n    super(owner);\n
700,setOpenFileHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,190,205,8,/**\n   * Pass this method an {@code ActionListener} equipped to\n   * handle document events from the Finder.\n   * Documents are registered with the Finder via the\n   * CFBundleDocumentTypes dictionary in the application bundle\'s Info.plist.\n   * <p>\n   * The filename is passed as the {@code actionCommand}.\n   */,15,"  public static void setOpenFileHandler(ActionListener fileHandler) {\n    setHandler(new OSXAdapter(""handleOpenFile"", fileHandler) {\n      // Override OSXAdapter.callTarget to send information on the\n      // file to be opened\n      @Override\n      public boolean callTarget(Object appleEvent) {\n        if (appleEvent != null) {\n          try {\n            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod(""getFilename"", (Class[]) null);\n            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);\n            targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, filename));\n          } catch (Exception ex) {\n          }\n        }\n        return true;\n"
701,setHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,241,257,4,/** \n   * {@code setHandler} creates a Proxy object from the passed\n   * {@code OSXAdapter} and adds it as an {@code ApplicationListener}.\n   */,17,"  @SuppressWarnings(""unchecked"")\n  public static void setHandler(OSXAdapter adapter) {\n    try {\n      Class applicationClass = Class.forName(""com.apple.eawt.Application"");\n      if (macOSXApplication == null) {\n        macOSXApplication = applicationClass.getConstructor((Class[]) null).newInstance((Object[]) null);\n      }\n      Class applicationListenerClass = Class.forName(""com.apple.eawt.ApplicationListener"");\n      Method addListenerMethod = applicationClass.getDeclaredMethod(""addApplicationListener"", new Class[]{applicationListenerClass});\n      // Create a proxy object around this handler that can be reflectively added as an Apple ApplicationListener\n      Object osxAdapterProxy = Proxy.newProxyInstance(OSXAdapter.class.getClassLoader(), new Class[]{applicationListenerClass}, adapter);\n      addListenerMethod.invoke(macOSXApplication, new Object[]{osxAdapterProxy});\n    } catch (ClassNotFoundException cnfe) {\n      System.err.println(""This version of Mac OS X does not support the Apple EAWT.  ApplicationEvent handling has been disabled ("" + cnfe + "")"");\n    } catch (Exception ex) {  // Likely a NoSuchMethodException or an IllegalAccessException loading/invoking eawt.Application methods\n      System.err.println(""Mac OS X Adapter could not talk to EAWT:"");\n      ex.printStackTrace();\n"
702,callTarget,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,286,295,4,/** Override this method to perform any operations on the event\n   * that comes with the various callbacks.\n   * See setOpenFileHandler above for an example.\n   */,10,"  public boolean callTarget(Object appleEvent) throws InvocationTargetException, IllegalAccessException {\n    if (targetAction != null) {\n      targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, proxySignature));\n      return true;\n    } else {\n      Object result = targetMethod.invoke(targetObject, (Object[]) null);\n      if (result == null) {\n        return true;\n      }\n      return Boolean.valueOf(result.toString()).booleanValue();\n"
703,setAboutHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,144,156,4,/**\n   * The action listener will be called when the user selects the About item\n   * in the application menu.\n   */,13,"  public static void setAboutHandler(ActionListener aboutHandler) {\n    boolean enableAboutMenu = (aboutHandler != null);\n    if (enableAboutMenu) {\n      setHandler(new OSXAdapter(""handleAbout"", aboutHandler));\n    }\n    // If we\'re setting a handler, enable the About menu item by calling\n    // com.apple.eawt.Application reflectively\n    try {\n      Method enableAboutMethod = macOSXApplication.getClass().getDeclaredMethod(""setEnabledAboutMenu"", new Class[]{boolean.class});\n      enableAboutMethod.invoke(macOSXApplication, new Object[]{Boolean.valueOf(enableAboutMenu)});\n    } catch (Exception ex) {\n      System.err.println(""OSXAdapter could not access the About Menu"");\n      ex.printStackTrace();\n"
704,setPreferencesHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,166,178,6,/**\n   * Pass this method an {@code ActionListener} equipped to\n   * display application options.\n   * They will be called when the Preferences menu item is selected from the\n   * application menu.\n   */,13,"  public static void setPreferencesHandler(ActionListener prefsHandler) {\n    boolean enablePrefsMenu = (prefsHandler != null);\n    if (enablePrefsMenu) {\n      setHandler(new OSXAdapter(""handlePreferences"", prefsHandler));\n    }\n    // If we\'re setting a handler, enable the Preferences menu item by calling\n    // com.apple.eawt.Application reflectively\n    try {\n      Method enablePrefsMethod = macOSXApplication.getClass().getDeclaredMethod(""setEnabledPreferencesMenu"", new Class[]{boolean.class});\n      enablePrefsMethod.invoke(macOSXApplication, new Object[]{Boolean.valueOf(enablePrefsMenu)});\n    } catch (Exception ex) {\n      System.err.println(""OSXAdapter could not access the Preferences Menu"");\n      ex.printStackTrace();\n"
705,isCorrectMethod,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,320,321,5,"/**\n   * Compare the method that was called to the intended method when the\n   * OSXAdapter instance was created (e.g. handleAbout, handleQuit,\n   * handleOpenFile, etc.).\n   */",2,"  protected boolean isCorrectMethod(Method method, Object[] args) {\n    return (proxySignature.equals(method.getName()) && args.length == 1);\n"
706,setReOpenApplicationHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,121,122,8,"/**\n   * Called when the application receives a Reopen Application event from the\n   * Finder or another application. Usually this will come when a user clicks\n   * on your application icon in the Dock. If there is any special code that\n   * needs to run when your user clicks on your application icon in the Dock\n   * or when a Reopen Application event is sent from another application,\n   * include that code as part of this handler.\n   */",2,"  public static void setReOpenApplicationHandler(ActionListener reopenHandler) {\n    setHandler(new OSXAdapter(""handleReOpenApplication"", reopenHandler));\n"
707,setQuitHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,128,135,4,/**\n   * The action listener will be called when the Quit menu item is selected\n   * from the application menu.\n   */,7,"  public static void setQuitHandler(ActionListener aboutHandler) {\n    setHandler(new OSXAdapter(""handleQuit"", aboutHandler) {\n      // Override OSXAdapter.callTarget to always return false.\n      @Override\n      public boolean callTarget(Object appleEvent)  throws InvocationTargetException, IllegalAccessException {\n        super.callTarget(appleEvent);\n        return false;\n"
708,OSXAdapter,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,266,269,5,"/** \n   * Each OSXAdapter has the name of the EAWT method it intends to listen for\n   * (handleAbout, for example), the Object that will ultimately perform the\n   * task, and the Method to be called on that Object.\n   */",4,"  protected OSXAdapter(String proxySignature, Object target, Method handler) {\n    this.proxySignature = proxySignature;\n    this.targetObject = target;\n    this.targetMethod = handler;\n"
709,setApplicationEventHandled,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,330,338,6,/** \n   * It is important to mark the ApplicationEvent as handled and cancel the\n   * default behavior.\n   * This method checks for a boolean result from the proxy method and sets \n   * the event accordingly.\n   */,9,"  protected void setApplicationEventHandled(Object event, boolean handled) {\n    if (event != null) {\n      try {\n        Method setHandledMethod = event.getClass().getDeclaredMethod(""setHandled"", new Class[]{boolean.class});\n        // If the target method returns a boolean, use that as a hint\n        setHandledMethod.invoke(event, new Object[]{Boolean.valueOf(handled)});\n      } catch (Exception ex) {\n        System.err.println(""OSXAdapter was unable to handle an ApplicationEvent: "" + event);\n        ex.printStackTrace();\n"
710,setPrintFileHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,217,232,8,/**\n   * Pass this method an {@code ActionListener} equipped to\n   * handle document events from the Finder.\n   * Documents are registered with the Finder via the\n   * CFBundleDocumentTypes dictionary in the application bundle\'s Info.plist.\n   * <p>\n   * The filename is passed as the {@code actionCommand}.\n   */,15,"  public static void setPrintFileHandler(ActionListener fileHandler) {\n    setHandler(new OSXAdapter(""handlePrintFile"", fileHandler) {\n      // Override OSXAdapter.callTarget to send information on the\n      // file to be opened\n      @Override\n      public boolean callTarget(Object appleEvent) {\n        if (appleEvent != null) {\n          try {\n            Method getFilenameMethod = appleEvent.getClass().getDeclaredMethod(""getFilename"", (Class[]) null);\n            String filename = (String) getFilenameMethod.invoke(appleEvent, (Object[]) null);\n            targetAction.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, filename));\n          } catch (Exception ex) {\n          }\n        }\n        return true;\n"
711,setOpenApplicationHandler,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,110,111,9,"/**\n   * The action listener will be called when the application receives an Open\n   * Application event from the Finder or another application. Usually this\n   * will come from the Finder when a user double-clicks your application\n   * icon. If there is any special code that you want to run when you user\n   * launches your application from the Finder or by sending an Open\n   * Application event from another application, include that code as part of\n   * this handler. The Open Application event is sent after AWT has been loaded.\n   */",2,"  public static void setOpenApplicationHandler(ActionListener openHandler) {\n    setHandler(new OSXAdapter(""handleOpenApplication"", openHandler));\n"
712,OSXAdapter,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,277,279,5,"/**\n   * Each OSXAdapter has the name of the EAWT method it intends to listen for\n   * (handleAbout, for example), the Object that will ultimately perform the\n   * task, and the Method to be called on that Object.\n   */",3,"  protected OSXAdapter(String proxySignature, ActionListener handler) {\n    this.proxySignature = proxySignature;\n    this.targetAction = handler;\n"
713,invoke,OSXAdapter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/app/osx/OSXAdapter.java,304,312,5,/**\n   * InvocationHandler implementation.\n   * This is the entry point for our proxy object; it is called every time an \n   * ApplicationListener method is invoked.\n   */,9,"  @Override\n  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    if (isCorrectMethod(method, args)) {\n      boolean handled = callTarget(args[0]);\n      setApplicationEventHandled(args[0], handled);\n    }\n    // All of the ApplicationListener methods are void;\n    // return null regardless of what happens\n    return null;\n"
714,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,65,66,1,/** Creates a new PropertyChangeEdit. */,2,"  public PropertyChangeEdit(Object source, String propertyName, int oldValue, int newValue) {\n    this(source, propertyName, Integer.TYPE, oldValue, newValue);\n"
715,addEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,156,166,6,"/** Adds the specified edit to this one, if it is a {@code PropertyChangeEdit}\n   * from the same owner and the same property.\n   *\n   * @param anEdit Edit to be added.\n   * @return True if added.\n   */",10,  @Override\n  public boolean addEdit(UndoableEdit anEdit) {\n    if (anEdit instanceof PropertyChangeEdit) {\n      PropertyChangeEdit that = (PropertyChangeEdit) anEdit;\n      if (that.source == this.source && that.propertyName.equals(this.propertyName)) {\n        this.newValue = that.newValue;\n        return true;\n      }\n    }\n    return false;\n
716,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,85,86,1,/** Creates a new PropertyChangeEdit. */,2,"  public PropertyChangeEdit(Object source, String propertyName, char oldValue, char newValue) {\n    this(source, propertyName, Character.TYPE, oldValue, newValue);\n"
717,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,75,76,1,/** Creates a new PropertyChangeEdit. */,2,"  public PropertyChangeEdit(Object source, String propertyName, float oldValue, float newValue) {\n    this(source, propertyName, Float.TYPE, oldValue, newValue);\n"
718,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,60,61,1,/** Creates a new PropertyChangeEdit. */,2,"  public PropertyChangeEdit(Object source, String propertyName, boolean oldValue, boolean newValue) {\n    this(source, propertyName, Boolean.TYPE, oldValue, newValue);\n"
719,undo,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,110,118,1,/** Undoes the change. */,9,"  @Override\n  public void undo() throws CannotRedoException {\n    super.undo();\n    try {\n      getSetter().invoke(source, oldValue);\n    } catch (Exception e) {\n      InternalError ie = new InternalError(""Couldn\'t invoke setter for property \\"""" + propertyName + ""\\"" in "" + source);\n      ie.initCause(e);\n      throw ie;\n"
720,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,70,71,1,/** Creates a new PropertyChangeEdit. */,2,"  public PropertyChangeEdit(Object source, String propertyName, long oldValue, long newValue) {\n    this(source, propertyName, Long.TYPE, oldValue, newValue);\n"
721,redo,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,123,131,1,/** Redoes the change. */,9,"  @Override\n  public void redo() throws CannotRedoException {\n    super.redo();\n    try {\n      getSetter().invoke(source, newValue);\n    } catch (Exception e) {\n      InternalError ie = new InternalError(""Couldn\'t invoke setter for property \\"""" + propertyName + ""\\"" in "" + source);\n      ie.initCause(e);\n      throw ie;\n"
722,getSetter,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,99,105,5,/**\n   * Returns the setter for the property.\n   *\n   * @return the setter method.\n   */,7,"  protected Method getSetter() {\n    try {\n      return source.getClass().getMethod(""set"" + Character.toUpperCase(propertyName.charAt(0)) + propertyName.substring(1), type);\n    } catch (Exception e) {\n      InternalError ie = new InternalError(""Couldn\'t find setter for property \\"""" + propertyName + ""\\"" in "" + source);\n      ie.initCause(e);\n      throw ie;\n"
723,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,80,81,1,/** Creates a new PropertyChangeEdit. */,2,"  public PropertyChangeEdit(Object source, String propertyName, double oldValue, double newValue) {\n    this(source, propertyName, Double.TYPE, oldValue, newValue);\n"
724,getPresentationName,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,139,141,4,"/** Returns the presentation name of the undoable edit.\n   * This is the same as the property name, unless you have set a different\n   * presentation name.\n   */",3,  @Override\n  public String getPresentationName() {\n    return presentationName;\n
725,setPresentationName,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,146,147,2,/** Sets the presentation name of the undoable edit.\n   */,2,  public void setPresentationName(String presentationName) {\n    this.presentationName = presentationName;\n
726,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,90,91,1,/** Creates a new PropertyChangeEdit. */,2,"  public PropertyChangeEdit(Object source, String propertyName, String oldValue, String newValue) {\n    this(source, propertyName, String.class, oldValue, newValue);\n"
727,PropertyChangeEdit,PropertyChangeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/PropertyChangeEdit.java,50,55,1,/** Creates a new PropertyChangeEdit. */,6,"  public <T> PropertyChangeEdit(Object source, String propertyName, Class<T> type, T oldValue, T newValue) {\n    this.source = source;\n    this.propertyName = this.presentationName = propertyName;\n    this.type = type;\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n"
728,removePropertyChangeListener,AbstractBean,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java,79,93,6,"/** Removes a {@code PropertyChangeListener}. If the listener was added\n   * wrapped into a {@code WeakPropertyChangeListener}, the\n   * {@code WeakPropertyChangeListener} is removed.\n   *\n   * @param listener\n   */",15,"  public void removePropertyChangeListener(String propertyName, PropertyChangeListener listener) {\n    // Removes a property change listener from our list.\n    // We need a somewhat complex procedure here in case a listener\n    // has been registered using addPropertyChangeListener(propertyName, new WeakPropertyChangeListener(listener));\n    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners(propertyName)) {\n      if (l == listener) {\n        propertySupport.removePropertyChangeListener(propertyName, l);\n        break;\n      }\n      if (l instanceof WeakPropertyChangeListener) {\n        WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;\n        PropertyChangeListener target = wl.getTarget();\n        if (target == listener) {\n          propertySupport.removePropertyChangeListener(propertyName, l);\n          break;\n"
729,addPropertyChangeListener,AbstractBean,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java,43,44,4,/** Adds a {@code PropertyChangeListener} which can optionally be wrapped\n   * into a {@code WeakPropertyChangeListener}.\n   * @param listener\n   */,2,"  public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener) {\n    propertySupport.addPropertyChangeListener(propertyName, listener);\n"
730,addPropertyChangeListener,AbstractBean,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java,35,36,4,/** Adds a {@code PropertyChangeListener} which can optionally be wrapped\n   * into a {@code WeakPropertyChangeListener}.\n   * @param listener\n   */,2,  public void addPropertyChangeListener(PropertyChangeListener listener) {\n    propertySupport.addPropertyChangeListener(listener);\n
731,removePropertyChangeListener,AbstractBean,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/beans/AbstractBean.java,53,67,6,"/** Removes a {@code PropertyChangeListener}. If the listener was added\n   * wrapped into a {@code WeakPropertyChangeListener}, the\n   * {@code WeakPropertyChangeListener} is removed.\n   *\n   * @param listener\n   */",15,  public void removePropertyChangeListener(PropertyChangeListener listener) {\n    // Removes a property change listener from our list.\n    // We need a somewhat complex procedure here in case a listener\n    // has been registered using addPropertyChangeListener(new WeakPropertyChangeListener(listener));\n    for (PropertyChangeListener l : propertySupport.getPropertyChangeListeners()) {\n      if (l == listener) {\n        propertySupport.removePropertyChangeListener(l);\n        break;\n      }\n      if (l instanceof WeakPropertyChangeListener) {\n        WeakPropertyChangeListener wl = (WeakPropertyChangeListener) l;\n        PropertyChangeListener target = wl.getTarget();\n        if (target == listener) {\n          propertySupport.removePropertyChangeListener(l);\n          break;\n
732,addEdgeResizeHandles,ResizeHandleKit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ResizeHandleKit.java,58,62,4,"/**\n   * Fills the given Vector with handles at each\n   * the north, south, east, and west of the figure.\n   */",5,"  static public void addEdgeResizeHandles(Figure f, Collection<Handle> handles) {\n    handles.add(south(f));\n    handles.add(north(f));\n    handles.add(east(f));\n    handles.add(west(f));\n"
734,addCornerResizeHandles,ResizeHandleKit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/ResizeHandleKit.java,47,51,4,/**\n   * Creates handles for each corner of a\n   * figure and adds them to the provided collection.\n   */,5,"  static public void addCornerResizeHandles(Figure f, Collection<Handle> handles) {\n    handles.add(southEast(f));\n    handles.add(southWest(f));\n    handles.add(northEast(f));\n    handles.add(northWest(f));\n"
753,NullHandle,NullHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/NullHandle.java,34,35,1,/** Creates a new instance. */,2,"  public NullHandle(Figure owner, Locator locator) {\n    super(owner, locator);\n"
754,addLeadHandles,NullHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/NullHandle.java,56,60,4,/**\n   * Creates handles for each lead of a\n   * figure and adds them to the provided collection.\n   */,5,"  static public void addLeadHandles(Figure f, Collection<Handle> handles) {\n    handles.add(new NullHandle(f, new RelativeLocator(0f,0f)));\n    handles.add(new NullHandle(f, new RelativeLocator(0f,1f)));\n    handles.add(new NullHandle(f, new RelativeLocator(1f,0f)));\n    handles.add(new NullHandle(f, new RelativeLocator(1f,1f)));\n"
755,RotateHandle,RotateHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RotateHandle.java,30,31,1,/** Creates a new instance. */,2,  public RotateHandle(Figure owner) {\n    super(owner);\n
756,draw,MoveHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java,63,72,7,"/**\n   * Draws this handle.\n   * <p>\n   * If the figure is transformable, the handle is drawn as a filled rectangle.\n   * If the figure is not transformable, the handle is drawn as an unfilled\n   * rectangle.\n   */",10,"  @Override\n  public void draw(Graphics2D g) {\n    if (getOwner().isTransformable()) {\n      drawRectangle(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_FILL_COLOR),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.MOVE_HANDLE_STROKE_COLOR));\n    } else {\n      drawRectangle(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_FILL_COLOR),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.NULL_HANDLE_STROKE_COLOR));\n"
757,addMoveHandles,MoveHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java,49,53,4,/**\n   * Creates handles for each corner of a\n   * figure and adds them to the provided collection.\n   */,5,"  static public void addMoveHandles(Figure f, Collection<Handle> handles) {\n    handles.add(southEast(f));\n    handles.add(southWest(f));\n    handles.add(northEast(f));\n    handles.add(northWest(f));\n"
758,MoveHandle,MoveHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/MoveHandle.java,41,42,1,/** Creates a new instance. */,2,"  public MoveHandle(Figure owner, Locator locator) {\n    super(owner, locator);\n"
759,TextOverflowHandle,TextOverflowHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TextOverflowHandle.java,35,36,1,/** Creates a new instance. */,2,  public TextOverflowHandle(TextHolderFigure owner) {\n    super(owner);\n
760,draw,TextOverflowHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TextOverflowHandle.java,50,59,3,/**\n   * Draws this handle.\n   */,10,"  @Override public void draw(Graphics2D g) {\n    if (getOwner().isTextOverflow()) {\n    drawRectangle(g, \n        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_FILL_COLOR),\n        (Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR)\n        );\n      g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));\n      Rectangle r = basicGetBounds();\n      g.drawLine(r.x+1, r.y+1, r.x+r.width-2, r.y+r.height-2);\n      g.drawLine(r.x+r.width-2, r.y+1, r.x+1, r.y+r.height-2);\n"
763,CMYKICCColorSystem,CMYKICCColorSystem,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/CMYKICCColorSystem.java,39,45,3,/**\n   * Creates a new instance.\n   */,7,"  public CMYKICCColorSystem() {\n    try {\n      read(getClass().getResourceAsStream(""Generic CMYK Profile.icc""));\n    } catch (IOException e) {\n      InternalError err = new InternalError(""Couldn\'t load \\""Generic CMYK Profile.icc\\""."");\n      err.initCause(e);\n      throw err;\n"
764,RoundRectangleRadiusHandle,RoundRectangleRadiusHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RoundRectangleRadiusHandle.java,41,42,1,/** Creates a new instance. */,2,  public RoundRectangleRadiusHandle(Figure owner) {\n    super(owner);\n
765,draw,RoundRectangleRadiusHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/RoundRectangleRadiusHandle.java,48,57,3,/**\n   * Draws this handle.\n   */,10,"  @Override\n  public void draw(Graphics2D g) {\n    if (getEditor().getTool().supportsHandleInteraction()) {\n      drawDiamond(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));\n    } else {\n      drawDiamond(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));\n"
766,ColorTrackImageProducer,ColorTrackImageProducer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/ColorTrackImageProducer.java,41,56,1,/** Creates a new instance. */,16,"  public ColorTrackImageProducer(int w, int h, int trackBuffer, boolean isHorizontal) {\n    super(w, h, null, 0, w);\n    pixels = new int[w*h];\n    this.w = w;\n    this.h = h;\n    // trackBuffer must be even\n    this.trackBuffer = (trackBuffer % 2 == 1) ? trackBuffer - 1 : trackBuffer;\n    this.componentIndex = componentIndex;\n    this.isHorizontal = isHorizontal;\n    newPixels(pixels, new DirectColorModel(24,\n              0x00ff0000,  // Red\n              0x0000ff00,  // Green\n              0x000000ff  // Blue\n              )\n              , 0, w);\n    setAnimated(true);\n"
770,getTickLength,ColorSliderUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java,361,362,6,"/**\n   * Gets the height of the tick area for horizontal sliders and the width of the\n   * tick area for vertical sliders.  BasicSliderUI uses the returned value to\n   * determine the tick area rectangle.  If you want to give your ticks some room,\n   * make this larger than you need and paint your ticks away from the sides in paintTicks().\n   */",2,  protected int getTickLength() {\n    return 4;\n
771,ColorSliderUI,ColorSliderUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java,47,48,1,/** Creates a new instance. */,2,  public ColorSliderUI(JSlider b)   {\n    super(b);\n
772,mousePressed,QuaquaTrackListener,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/ColorSliderUI.java,438,462,7,"/**\n     * If the mouse is pressed above the ""thumb"" component\n     * then reduce the scrollbars value by one page (""page up""),\n     * otherwise increase it by one page.  If there is no\n     * thumb then page up if the mouse is in the upper half\n     * of the track.\n     */",25,"    public void mousePressed(MouseEvent e) {\n      if ( !slider.isEnabled() )\n        return;\n      \n      currentMouseX = e.getX();\n      currentMouseY = e.getY();\n      \n      if (slider.isRequestFocusEnabled()) {\n        slider.requestFocus();\n      }\n      \n      // Clicked inside the Thumb area?\n      if (thumbRect.contains(currentMouseX, currentMouseY) ) {\n        super.mousePressed(e);\n      } else {\n        Dimension sbSize = slider.getSize();\n        int direction = POSITIVE_SCROLL;\n        \n        switch ( slider.getOrientation() ) {\n          case JSlider.VERTICAL:\n            slider.setValue(valueForYPosition(currentMouseY));\n            break;\n          case JSlider.HORIZONTAL:\n            slider.setValue(valueForXPosition(currentMouseX));\n            break;\n"
773,ColorWheelChooser,ColorWheelChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelChooser.java,39,56,3,/**\n   * Creates a new instance.\n   */,18,"  public ColorWheelChooser() {\n    initComponents();\n    \n        int textSliderGap = UIManager.getInt(""ColorChooser.textSliderGap"");\n    if (textSliderGap != 0) {\n      BorderLayout layout = (BorderLayout) getLayout();\n      layout.setHgap(textSliderGap);\n}\n    \n    colorWheel = new JColorWheel();\n    add(colorWheel);\n    \n    ccModel.configureSlider(2, brightnessSlider);\n    colorWheel.setModel(ccModel);\n    \n    ccModel.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent evt) {\n        setColorToModel(ccModel.getColor());\n"
774,initComponents,ColorWheelChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/color/ColorWheelChooser.java,66,74,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,7,"  private void initComponents() {//GEN-BEGIN:initComponents\n    brightnessSlider = new javax.swing.JSlider();\n    setLayout(new java.awt.BorderLayout());\n    brightnessSlider.setMajorTickSpacing(50);\n    brightnessSlider.setOrientation(javax.swing.JSlider.VERTICAL);\n    brightnessSlider.setPaintTicks(true);\n    add(brightnessSlider, java.awt.BorderLayout.EAST);\n"
788,SerializationInputOutputFormat,SerializationInputOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/SerializationInputOutputFormat.java,73,74,3,"/** Creates a new instance with format name ""Drawing"", file extension ""xml""\n   * and mime type ""image/x-jhotdraw"".\n   */",2,"  public SerializationInputOutputFormat() {\n    this(""Drawing"", ""ser"", new DefaultDrawing());\n"
789,ImageInputFormat,ImageInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageInputFormat.java,93,95,8,/** Creates a new image input format for the specified image format.\n   *\n   * @param formatName The format name for the javax.imageio.ImageIO object.\n   * @param description The format description to be used for the file filter.\n   * @param fileExtension The file extension to be used for the file filter.\n   * @param mimeType The mime type used for filtering data flavors from\n   * Transferable objects.\n   */,3,"  public ImageInputFormat(ImageHolderFigure prototype, String formatName, String description, String fileExtension,\n      String mimeType) {\n    this(prototype, formatName, description, new String[]{fileExtension}, new String[]{mimeType});\n"
790,ImageInputFormat,ImageInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageInputFormat.java,81,82,2,/** Creates a new image input format for all formats supported by\n   * {@code javax.imageio.ImageIO}. */,2,"  public ImageInputFormat(ImageHolderFigure prototype) {\n    this(prototype, ""Image"", ""Image"", ImageIO.getReaderFileSuffixes(), ImageIO.getReaderMIMETypes());\n"
803,north,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,81,82,3,/**\n   * North.\n   */,2,"  static public Locator north() {\n    return new RelativeDecoratorLocator(0.5, 0.0);\n"
804,addCornerTransformHandles,TransformHandleKit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java,47,51,4,/**\n   * Creates handles for each corner of a\n   * figure and adds them to the provided collection.\n   */,5,"  static public void addCornerTransformHandles(Figure f, Collection<Handle> handles) {\n    handles.add(southEast(f));\n    handles.add(southWest(f));\n    handles.add(northEast(f));\n    handles.add(northWest(f));\n"
805,RelativeDecoratorLocator,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,46,47,1,/** Creates a new instance. */,2,"  public RelativeDecoratorLocator(double relativeX, double relativeY) {\n    super(relativeX, relativeY);\n"
806,addScaleMoveTransformHandles,TransformHandleKit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java,68,70,3,/**\n   * Adds handles for scaling and moving a Figure.\n   */,3,"  static public void addScaleMoveTransformHandles(Figure f, Collection<Handle> handles) {\n    addCornerTransformHandles(f, handles);\n    addEdgeTransformHandles(f, handles);\n"
807,northWest,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,102,103,3,/**\n   * North west.\n   */,2,"  static public Locator northWest() {\n    return new RelativeDecoratorLocator(0.0, 0.0);\n"
808,addEdgeTransformHandles,TransformHandleKit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java,58,62,4,"/**\n   * Fills the given Vector with handles at each\n   * the north, south, east, and west of the figure.\n   */",5,"  static public void addEdgeTransformHandles(Figure f, Collection<Handle> handles) {\n    handles.add(south(f));\n    handles.add(north(f));\n    handles.add(east(f));\n    handles.add(west(f));\n"
809,west,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,88,89,3,/**\n   * West.\n   */,2,"  static public Locator west() {\n    return new RelativeDecoratorLocator(0.0, 0.5);\n"
810,northEast,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,95,96,3,/**\n   * North east.\n   */,2,"  static public Locator northEast() {\n    return new RelativeDecoratorLocator(1.0, 0.0);\n"
811,addGroupTransformHandles,TransformHandleKit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java,86,95,3,"/**\n   * Adds handles for scaling, moving, rotating and shearing a Figure.\n   */",10,"  static public void addGroupTransformHandles(Figure f, Collection<Handle> handles) {\n    handles.add(new BoundsOutlineHandle(f,\n        GROUP_BOUNDS_STROKE_1, GROUP_BOUNDS_COLOR_1,\n        GROUP_BOUNDS_STROKE_2, GROUP_BOUNDS_COLOR_2,\n        GROUP_BOUNDS_STROKE_1_DISABLED, GROUP_BOUNDS_COLOR_1_DISABLED,\n        GROUP_BOUNDS_STROKE_2_DISABLED, GROUP_BOUNDS_COLOR_2_DISABLED\n        ));\n    addCornerTransformHandles(f, handles);\n    addEdgeTransformHandles(f, handles);\n    handles.add(new RotateHandle(f));\n"
812,south,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,109,110,3,/**\n   * South.\n   */,2,"  static public Locator south() {\n    return new RelativeDecoratorLocator(0.5, 1.0);\n"
813,addTransformHandles,TransformHandleKit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java,76,80,3,"/**\n   * Adds handles for scaling, moving, rotating and shearing a Figure.\n   */",5,"  static public void addTransformHandles(Figure f, Collection<Handle> handles) {\n    handles.add(new BoundsOutlineHandle(f, true, false));\n    addCornerTransformHandles(f, handles);\n    addEdgeTransformHandles(f, handles);\n    handles.add(new RotateHandle(f));\n"
814,southWest,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,123,124,3,/**\n   * South west.\n   */,2,"  static public Locator southWest() {\n    return new RelativeDecoratorLocator(0.0, 1.0);\n"
815,southEast,RelativeDecoratorLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeDecoratorLocator.java,116,117,3,/**\n   * South east.\n   */,2,"  static public Locator southEast() {\n    return new RelativeDecoratorLocator(1.0, 1.0);\n"
817,draw,TransformHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/handle/TransformHandleKit.java,159,170,3,/**\n     * Draws this handle.\n     */,12,"    public void draw(Graphics2D g) {\n      if (getEditor().getTool().supportsHandleInteraction()) {\n        //drawArc(g);\n        \n        drawDiamond(g,\n            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR),\n            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR));\n        \n        } else {\n        drawDiamond(g,\n            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_FILL_COLOR_DISABLED),\n            (Color) getEditor().getHandleAttribute(HandleAttributeKeys.TRANSFORM_HANDLE_STROKE_COLOR_DISABLED));        \n"
818,BezierTool,BezierTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/BezierTool.java,60,61,1,/** Creates a new instance. */,2,"  public BezierTool(BezierFigure prototype) {\n    this(prototype, null);\n"
819,BezierTool,BezierTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/BezierTool.java,65,66,1,/** Creates a new instance. */,2,"  public BezierTool(BezierFigure prototype, Map<AttributeKey, Object> attributes) {\n    this(prototype, attributes, null);\n"
820,AbstractTool,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,74,77,1,/** Creates a new instance. */,4,  public AbstractTool() {\n    editorProxy = new DrawingEditorProxy();\n    setInputMap(createInputMap());\n    setActionMap(createActionMap());\n
821,fireToolStarted,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,316,329,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireToolStarted(DrawingView view) {\n    ToolEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == ToolListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new ToolEvent(this, view, new Rectangle(0, 0, -1, -1));\n        }\n        ((ToolListener) listeners[i + 1]).toolStarted(event);\n"
822,createInputMap,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,264,265,5,"/** Override this method to create a tool-specific input map, which\n   * overrides the input map of the drawing edtior.\n   * <p>\n   * The implementation of this class returns null.\n   */",2,  protected InputMap createInputMap() {\n    return null;\n
823,createActionMap,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,273,274,5,"/** Override this method to create a tool-specific action map, which\n   * overrides the action map of the drawing edtior.\n   * <p>\n   * The implementation of this class returns null.\n   */",2,  protected ActionMap createActionMap() {\n    return null;\n
825,editDelete,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,170,171,5,"/**\n   * Deletes the selection.\n   * Depending on the tool, this could be selected figures, selected points\n   * or selected text.\n   */",2,  public void editDelete() {\n    getView().getDrawing().removeAll(getView().getSelectedFigures());\n
826,fireToolDone,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,338,351,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireToolDone() {\n    ToolEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == ToolListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new ToolEvent(this, getView(), new Rectangle(0, 0, -1, -1));\n        }\n        ((ToolListener) listeners[i + 1]).toolDone(event);\n"
827,DOMStorableInputOutputFormat,DOMStorableInputOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/DOMStorableInputOutputFormat.java,81,92,7,/** Creates a new instance using the specified parameters.\n   *\n   * @param factory The factory for creating Figures from XML elements.\n   * @param description The format description to be used for the file filter.\n   * @param fileExtension The file extension to be used for file filter.\n   * @param mimeType The Mime Type is used for clipboard access.\n   */,12,"  public DOMStorableInputOutputFormat(\n      DOMFactory factory,\n      String description, String fileExtension, String mimeType) {\n    this.factory = factory;\n    this.fileExtension = fileExtension;\n    this.mimeType = mimeType;\n    try {\n      this.dataFlavor = new DataFlavor(mimeType);\n    } catch (ClassNotFoundException ex) {\n      InternalError error = new InternalError(""Unable to create data flavor for mime type:"" + mimeType);\n      error.initCause(ex);\n      throw error;\n"
828,fireAreaInvalidated,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,371,384,4,/**\n   * Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireAreaInvalidated(Rectangle invalidatedArea) {\n    ToolEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == ToolListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new ToolEvent(this, getView(), invalidatedArea);\n        }\n        ((ToolListener) listeners[i + 1]).areaInvalidated(event);\n"
829,DOMStorableInputOutputFormat,DOMStorableInputOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/DOMStorableInputOutputFormat.java,70,71,3,"/** Creates a new instance with format name ""Drawing"", file extension ""xml""\n   * and mime type ""image/x-jhotdraw"".\n   */",2,"  public DOMStorableInputOutputFormat(DOMFactory factory) {\n    this(factory, ""Drawing"", ""xml"", ""image/x-jhotdraw"");\n"
830,getInputMap,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,146,147,3,/**\n   * Gets the input map of the Tool\n   */,2,  public InputMap getInputMap() {\n    return inputMap;\n
832,fireBoundsInvalidated,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,414,428,4,/**\n   * Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,14,"  protected void fireBoundsInvalidated(Rectangle invalidatedArea) {\n    ToolEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == ToolListener.class) {\n        // Lazily create the event:\n        if (event == null) {\n          event = new ToolEvent(this, getView(), invalidatedArea);\n        }\n        ((ToolListener) listeners[i + 1]).boundsInvalidated(event);\n"
834,setActionMap,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,154,155,4,/**\n   * Sets the ActionMap for the Tool.\n   * @see #keyPressed\n   */,2,  public void setActionMap(ActionMap newValue) {\n    actionMap = newValue;\n
836,keyPressed,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,220,254,7,"/**\n   * The Tool uses the InputMap to determine what to do, when a key is pressed.\n   * If the corresponding value of the InputMap is a String, the ActionMap\n   * of the tool is used, to find the action to be performed.\n   * If the corresponding value of the InputMap is a ActionListener, the\n   * actionPerformed method of the ActionListener is performed.\n   */",34,"  public void keyPressed(KeyEvent evt) {\n    if (!evt.isConsumed()) {\n      if (evt.getSource() instanceof Container) {\n        editor.setActiveView(editor.findView((Container) evt.getSource()));\n      }\n      Object obj = null;\n      if (inputMap != null) {\n        // Lookup the input map of the tool\n        obj = inputMap.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));\n      }\n      if (obj == null) {\n        // Fall back to the input map of the drawing editor\n        InputMap im = editor.getInputMap();\n        if (im != null) {\n          obj = im.get(KeyStroke.getKeyStroke(evt.getKeyCode(), evt.getModifiers(), false));\n        }\n      }\n      ActionListener al = null;\n      if (obj instanceof ActionListener) {\n        al = (ActionListener) obj;\n      } else if (obj != null) {\n        // Lookup the action map of the tool\n        if (actionMap != null) {\n          al = actionMap.get(obj);\n        }\n        if (al == null) {\n          // Fall back to the action map of the drawing editor\n          al = editor.getActionMap().get(obj);\n        }\n      }\n      if (al != null) {\n        evt.consume();\n        al.actionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ""tool"", evt.getWhen(), evt.getModifiers()));\n        fireToolDone();\n"
838,fireAreaInvalidated,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,360,364,4,/**\n   * Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,5,"  protected void fireAreaInvalidated(Rectangle2D.Double r) {\n    Point p1 = getView().drawingToView(new Point2D.Double(r.x, r.y));\n    Point p2 = getView().drawingToView(new Point2D.Double(r.x + r.width, r.y + r.height));\n    fireAreaInvalidated(\n        new Rectangle(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y));\n"
839,getActionMap,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,161,162,3,/**\n   * Gets the action map of the Tool\n   */,2,  public ActionMap getActionMap() {\n    return actionMap;\n
840,maybeFireBoundsInvalidated,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,396,406,7,"/**\n   * Notify all listenerList that have registered interest for\n   * notification on this event type.\n   *\n   * Note: This method only fires an event, if the invalidated area\n   * is outside of the canvas bounds.\n   */",11,"  protected void maybeFireBoundsInvalidated(Rectangle invalidatedArea) {\n    Drawing d = getDrawing();\n    Rectangle2D.Double canvasBounds = new Rectangle2D.Double(0, 0, 0, 0);\n    if (d.get(CANVAS_WIDTH) != null) {\n      canvasBounds.width += d.get(CANVAS_WIDTH);\n    }\n    if (d.get(CANVAS_HEIGHT) != null) {\n      canvasBounds.height += d.get(CANVAS_HEIGHT);\n    }\n    if (!canvasBounds.contains(invalidatedArea)) {\n       fireBoundsInvalidated(invalidatedArea);\n"
841,setInputMap,AbstractTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/AbstractTool.java,139,140,6,/**\n   * Sets the InputMap for the Tool.\n   *\n   * @see #keyPressed\n   * @see #setActionMap\n   */,2,  public void setInputMap(InputMap newValue) {\n    inputMap = newValue;\n
842,ImageOutputFormat,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,56,57,1,/** Creates a new image output format for Portable Network Graphics PNG. */,2,"  public ImageOutputFormat() {\n    this(""PNG"", ""Portable Network Graphics (PNG)"", ""png"", BufferedImage.TYPE_INT_ARGB);\n"
843,write,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,115,117,5,"/**\n   * Writes the drawing to the specified output stream.\n   * This method applies the specified transform to the drawing, and draws\n   * it on an image of the specified size.\n   */",3,"  public void write(OutputStream out, Drawing drawing,\n      AffineTransform drawingTransform, Dimension imageSize) throws IOException {\n    write(out, drawing, drawing.getChildren(), drawingTransform, imageSize);\n"
844,createTransferable,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,125,126,5,/**\n   * Writes the drawing to the specified output stream.\n   * This method ensures that all figures of the drawing are visible on\n   * the image.\n   */,2,"  public Transferable createTransferable(Drawing drawing, java.util.List<Figure> figures, double scaleFactor) throws IOException {\n    return new ImageTransferable(toImage(drawing, figures, scaleFactor, true));\n"
845,ImageOutputFormat,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,68,73,8,/** Creates a new image output format for the specified image format.\n   *\n   * @param formatName The format name for the javax.imageio.ImageIO object.\n   * @param description The format description to be used for the file filter.\n   * @param fileExtension The file extension to be used for file filter.\n   * @param bufferedImageType The BufferedImage type used to produce the image.\n   *      The value of this parameter must match with the format name.\n   */,6,"  public ImageOutputFormat(String formatName, String description, String fileExtension,\n      int bufferedImageType) {\n    this.formatName = formatName;\n    this.description = description;\n    this.fileExtension = fileExtension;\n    this.imageType = bufferedImageType;\n"
846,write,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,107,108,5,/**\n   * Writes the drawing to the specified output stream.\n   * This method ensures that all figures of the drawing are visible on\n   * the image.\n   */,2,"  public void write(OutputStream out, Drawing drawing) throws IOException {\n    write(out, drawing, drawing.getChildren(), null, null);\n"
847,toImage,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,221,272,9,/**\n   * Creates a BufferedImage from the specified list of figures.\n   *\n   * @param drawing The drawing.\n   * @param figures A list of figures of the drawing.\n   * @param transform The AffineTransform to be used when drawing\n   * the figures.\n   * @param imageSize The width and height of the image.\n   */,51,"  public BufferedImage toImage(\n      Drawing drawing,\n      java.util.List<Figure> figures,\n      AffineTransform transform,\n      Dimension imageSize) {\n    \n    // Create the buffered image and clear it\n    Color background = drawing.get(CANVAS_FILL_COLOR);\n    double opacity = drawing.get(CANVAS_FILL_OPACITY);\n    if (background == null) {\n      background = new Color(0xff, 0xff, 0xff, 0x0);\n    } else {\n      background = new Color(background.getRed(), background.getGreen(), background.getBlue(), (int)(background.getAlpha() * opacity));\n    }\n    BufferedImage buf = new BufferedImage(\n        Math.max(1,imageSize.width), Math.max(1,imageSize.height),\n        (background.getAlpha() == 255) ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB\n        );\n    Graphics2D g = buf.createGraphics();\n    \n    // Clear the buffered image with the background color\n    Composite savedComposite = g.getComposite();\n    g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));\n    g.setColor(background);\n    g.fillRect(0,0,buf.getWidth(),buf.getHeight());\n    g.setComposite(savedComposite);\n    \n    // Draw the figures onto the buffered image\n    setRenderingHints(g);\n    g.transform(transform);\n    for (Figure f : figures) {\n      f.draw(g);\n    }\n    g.dispose();\n    \n    // Convert the image, if it does not have the specified image type\n    if (imageType != BufferedImage.TYPE_INT_ARGB) {\n      BufferedImage buf2 = new BufferedImage(\n          buf.getWidth(), buf.getHeight(),\n          imageType\n          );\n      g = buf2.createGraphics();\n      setRenderingHints(g);\n      g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC));\n      g.drawImage(buf, 0, 0, null);\n      g.dispose();\n      buf.flush();\n      buf = buf2;\n    }\n    \n    return buf;\n"
848,north,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,135,136,5,"/**\n   * North.\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator north(boolean isTransform) {\n    return new RelativeLocator(0.5, 0.0, isTransform);\n"
849,RelativeLocator,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,56,57,1,/** Creates a new instance. */,2,"  public RelativeLocator(double relativeX, double relativeY) {\n    this(relativeX, relativeY, false);\n"
850,east,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,112,113,3,/**\n   * Non-transforming East.\n   */,2,  static public Locator east() {\n    return east(false);\n
851,toImage,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,168,206,14,"/**\n   * Creates a BufferedImage from the specified list of figures.\n   * <p>\n   * The images are drawn using the specified scale factor. If some figures\n   * have a drawing area located at negative coordinates, then the drawing\n   * coordinates are translated, so that all figures are visible on the\n   * image.\n   *\n   * @param drawing The drawing.\n   * @param figures A list of figures of the drawing.\n   * @param scaleFactor The scale factor used when drawing the figures.\n   * @param clipToFigures If this is true, the image is clipped to the figures.\n   * If this is false, the image includes the drawing area,  \n   */",37,"  public BufferedImage toImage(Drawing drawing,\n      java.util.List<Figure> figures,\n      double scaleFactor, boolean clipToFigures) {\n    \n    // Determine the draw bounds of the figures\n    Rectangle2D.Double drawBounds = null;\n    for (Figure f : figures) {\n      if (drawBounds == null) {\n        drawBounds = f.getDrawingArea();\n      } else {\n        drawBounds.add(f.getDrawingArea());\n      }\n    }\n    if (clipToFigures) {\n    AffineTransform transform = new AffineTransform();\n      transform.translate(-drawBounds.x * scaleFactor, \n          -drawBounds.y * scaleFactor);\n    transform.scale(scaleFactor, scaleFactor);\n    return toImage(drawing, figures, transform,\n        new Dimension(\n        (int) (drawBounds.width * scaleFactor),\n        (int) (drawBounds.height * scaleFactor)\n        )\n        );\n    } else {\n    AffineTransform transform = new AffineTransform();\n    if (drawBounds.x < 0) {\n      transform.translate(-drawBounds.x * scaleFactor, 0);\n    }\n    if (drawBounds.y < 0) {\n      transform.translate(0, -drawBounds.y * scaleFactor);\n    }\n    transform.scale(scaleFactor, scaleFactor);\n     return toImage(drawing, figures, transform,\n        new Dimension(\n        (int) ((Math.max(0, drawBounds.x)+drawBounds.width) * scaleFactor),\n        (int) ((Math.max(0, drawBounds.y)+drawBounds.height) * scaleFactor)\n"
852,southWest,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,217,218,3,/**\n   * Non-transforming South west.\n   */,2,  static public Locator southWest() {\n    return southWest(false);\n
853,center,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,233,234,3,/**\n   * Non-transforming Center.\n   */,2,  static public Locator center() {\n    return center(false);\n
854,write,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,93,98,5,/**\n   * Writes the drawing to the specified file.\n   * This method ensures that all figures of the drawing are visible on\n   * the image.\n   */,6,"  public void write(File file, Drawing drawing) throws IOException {\n    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n    try {\n      write(out, drawing);\n    } finally {\n        out.close();\n"
855,south,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,195,196,5,"/**\n   * South.\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator south(boolean isTransform) {\n    return new RelativeLocator(0.5, 1.0, isTransform);\n"
856,north,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,127,128,3,/**\n   * Non-transforming North.\n   */,2,  static public Locator north() {\n    return north(false);\n
857,write,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,134,135,5,/**\n   * Writes the figures to the specified output stream.\n   * This method ensures that all figures of the drawing are visible on\n   * the image.\n   */,2,"  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {\n    write(out, drawing, figures, null, null);\n"
858,southEast,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,202,203,3,/**\n   * Non-transforming South east.\n   */,2,  static public Locator southEast() {\n    return southEast(false);\n
859,RelativeLocator,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,51,52,1,/** Creates a new instance. */,2,"  public RelativeLocator() {\n    this(0, 0, false);\n"
860,write,ImageOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/ImageOutputFormat.java,142,151,5,"/**\n   * Writes the figures to the specified output stream.\n   * This method applies the specified transform to the drawing, and draws\n   * it on an image of the specified size.\n   */",10,"  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures,\n      AffineTransform drawingTransform, Dimension imageSize) throws IOException {\n    BufferedImage img;\n    if (drawingTransform == null || imageSize == null) {\n      img = toImage(drawing, figures, 1d, false);\n    } else {\n      img = toImage(drawing, figures, drawingTransform, imageSize);\n    }\n    ImageIO.write(img, formatName, out);\n    img.flush();\n"
861,southEast,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,210,211,5,"/**\n   * South East.\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator southEast(boolean isTransform) {\n    return new RelativeLocator(1.0, 1.0, isTransform);\n"
862,west,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,142,143,3,/**\n   * Non-transforming West.\n   */,2,  static public Locator west() {\n    return west(false);\n
863,northEast,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,157,158,3,/**\n   * Non-transforming North east.\n   */,2,  static public Locator northEast() {\n    return northEast(false);\n
864,east,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,120,121,5,"/**\n   * East.\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator east(boolean isTransform) {\n    return new RelativeLocator(1.0, 0.5, isTransform);\n"
865,west,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,150,151,5,"/**\n   * West.\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator west(boolean isTransform) {\n    return new RelativeLocator(0.0, 0.5, isTransform);\n"
866,RelativeLocator,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,67,70,8,"/**\n   * @param relativeX x-position relative to bounds expressed as a value\n   * between 0 and 1.\n   * @param relativeY y-position relative to bounds expressed as a value\n   * between 0 and 1.\n   * @param isTransform Set this to true, if the locator shall honor the\n   * TRANSFORM attribute of the Figure.\n   */",4,"  public RelativeLocator(double relativeX, double relativeY, boolean isTransform) {\n    this.relativeX = relativeX;\n    this.relativeY = relativeY;\n    this.isTransform = isTransform;\n"
867,south,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,187,188,3,/**\n   * Non-transforming South.\n   */,2,  static public Locator south() {\n    return south(false);\n
868,northWest,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,180,181,5,"/**\n   * North West.\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator northWest(boolean isTransform) {\n    return new RelativeLocator(0.0, 0.0, isTransform);\n"
869,northWest,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,172,173,3,/**\n   * Non-transforming North west.\n   */,2,  static public Locator northWest() {\n    return northWest(false);\n
870,northEast,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,165,166,5,"/**\n   * Norht East.\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator northEast(boolean isTransform) {\n    return new RelativeLocator(1.0, 0.0, isTransform);\n"
871,southWest,RelativeLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/RelativeLocator.java,226,227,6,"/**\n   * South West.\n   *\n   * @param isTransform Set this to true, if RelativeLocator shall honour\n   * the AttributesKey.TRANSFORM attribute of the Figure.\n   */",2,"  static public Locator southWest(boolean isTransform) {\n    return new RelativeLocator(0.0, 1.0, isTransform);\n"
872,TextInputFormat,TextInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/io/TextInputFormat.java,77,78,3,"/** Creates a new image output format for text, for a figure that can not.\n   * hold multiple lines of text.\n   */",2,"  public TextInputFormat(TextHolderFigure prototype) {\n    this(prototype, ""Text"", ""Text"", ""txt"", false);\n"
873,mouseDragged,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,236,254,3,/**\n   * Adjust the created connection.\n   */,17,"  public void mouseDragged(java.awt.event.MouseEvent e) {\n    repaintConnectors(e);\n    if (createdFigure != null) {\n      createdFigure.willChange();\n      Point2D.Double endPoint = viewToDrawing(new Point(e.getX(), e.getY()));\n      getView().getConstrainer().constrainPoint(endPoint);\n      Figure endFigure = getDrawing().findFigureExcept(endPoint, createdFigure);\n      endConnector = (endFigure == null) ? null : endFigure.findConnector(endPoint, prototype);\n      if (endConnector != null && canConnect(createdFigure, startConnector, endConnector)) {\n        endPoint = endConnector.getAnchor();\n      }\n      Rectangle r = new Rectangle(getView().drawingToView(createdFigure.getEndPoint()));\n      createdFigure.setEndPoint(endPoint);\n      r.add(getView().drawingToView(endPoint));\n      r.grow(ANCHOR_WIDTH + 2, ANCHOR_WIDTH + 2);\n      getView().getComponent().repaint(r);\n      createdFigure.changed();\n"
874,repaintConnectors,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,170,199,4,/**\n   * Updates the list of connectors that we draw when the user\n   * moves or drags the mouse over a figure to which can connect.\n   */,30,"  public void repaintConnectors(MouseEvent evt) {\n    Rectangle2D.Double invalidArea = null;\n    Point2D.Double targetPoint = viewToDrawing(new Point(evt.getX(), evt.getY()));\n    Figure aFigure = getDrawing().findFigureExcept(targetPoint, createdFigure);\n    if (aFigure != null && !aFigure.isConnectable()) {\n      aFigure = null;\n    }\n    if (targetFigure != aFigure) {\n      for (Connector c : connectors) {\n        if (invalidArea == null) {\n          invalidArea = c.getDrawingArea();\n        } else {\n          invalidArea.add(c.getDrawingArea());\n        }\n      }\n      targetFigure = aFigure;\n      if (targetFigure != null) {\n        connectors = targetFigure.getConnectors(getPrototype());\n        for (Connector c : connectors) {\n          if (invalidArea == null) {\n            invalidArea = c.getDrawingArea();\n          } else {\n            invalidArea.add(c.getDrawingArea());\n          }\n        }\n      }\n    }\n    if (invalidArea != null) {\n      getView().getComponent().repaint(\n          getView().drawingToView(invalidArea));\n"
875,mouseReleased,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,262,305,4,/**\n   * Connects the figures if the mouse is released over another\n   * figure.\n   */,40,"  @Override\n  public void mouseReleased(MouseEvent e) {\n    if (createdFigure != null &&\n        startConnector != null && endConnector != null &&\n        createdFigure.canConnect(startConnector, endConnector)) {\n      createdFigure.willChange();\n      createdFigure.setStartConnector(startConnector);\n      createdFigure.setEndConnector(endConnector);\n      createdFigure.updateConnection();\n      createdFigure.changed();\n      final Figure addedFigure = createdFigure;\n      final Drawing addedDrawing = getDrawing();\n      getDrawing().fireUndoableEditHappened(new AbstractUndoableEdit() {\n        public String getPresentationName() {\n          return presentationName;\n        }\n        public void undo() throws CannotUndoException {\n          super.undo();\n          addedDrawing.remove(addedFigure);\n        }\n        public void redo() throws CannotRedoException {\n          super.redo();\n          addedDrawing.add(addedFigure);\n        }\n      });\n      targetFigure = null;\n      Point2D.Double anchor = startConnector.getAnchor();\n      Rectangle r = new Rectangle(getView().drawingToView(anchor));\n      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);\n      fireAreaInvalidated(r);\n      anchor = endConnector.getAnchor();\n      r = new Rectangle(getView().drawingToView(anchor));\n      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);\n      fireAreaInvalidated(r);\n      startConnector = endConnector = null;\n      createdFigure = null;\n      creationFinished(createdFigure);\n    } else {\n      if (isToolDoneAfterCreation()) {\n        fireToolDone();\n"
876,mousePressed,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,208,230,5,/**\n   * Manipulates connections in a context dependent way. If the\n   * mouse down hits a figure start a new connection. If the mousedown\n   * hits a connection split a segment or join two segments.\n   */,20,"  public void mousePressed(MouseEvent evt) {\n    super.mousePressed(evt);\n    getView().clearSelection();\n    Point2D.Double startPoint = viewToDrawing(anchor);\n    Figure startFigure = getDrawing().findFigure(startPoint);\n    startConnector = (startFigure == null) ? null : startFigure.findConnector(startPoint, prototype);\n    if (startConnector != null && canConnect(prototype, startConnector)) {\n      Point2D.Double anchor = startConnector.getAnchor();\n      createdFigure = createFigure();\n      createdFigure.setStartPoint(anchor);\n      createdFigure.setEndPoint(anchor);\n      getDrawing().add(createdFigure);\n      Rectangle r = new Rectangle(getView().drawingToView(anchor));\n      r.grow(ANCHOR_WIDTH, ANCHOR_WIDTH);\n      fireAreaInvalidated(r);\n    } else {\n      startConnector = null;\n      createdFigure = null;\n    }\n    endConnector = null;\n"
877,setToolDoneAfterCreation,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,389,391,5,"/**\n   * If this is set to false, the CreationTool does not fire toolDone\n   * after a new Figure has been created. This allows to create multiple\n   * figures consecutively.\n   */",3,  public void setToolDoneAfterCreation(boolean newValue) {\n    boolean oldValue = isToolDoneAfterCreation;\n    isToolDoneAfterCreation = newValue;\n
878,canConnect,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,158,159,9,"/**\n   * This method is called on the Figure, onto which the user wants\n   * to end a new connection.\n   * \n   * @param f The ConnectionFigure.\n   * @param startConnector The Connector of the start Figure.\n   * @param endConnector The Connector of the end Figure.\n   * @return True, if a connection can be made.\n   */",2,"  protected boolean canConnect(ConnectionFigure f, Connector startConnector, Connector endConnector) {\n    return f.canConnect(startConnector, endConnector);\n"
879,ConnectionTool,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,91,92,2,/** Creates a new instance.\n   */,2,"  public ConnectionTool(ConnectionFigure prototype) {\n    this(prototype, null, null);\n"
880,createFigure,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,329,338,4,/**\n   * Creates the ConnectionFigure. By default the figure prototype is\n   * cloned.\n   */,10,"  @SuppressWarnings(""unchecked"")\n  protected ConnectionFigure createFigure() {\n    ConnectionFigure f = (ConnectionFigure) prototype.clone();\n    getEditor().applyDefaultAttributesTo(f);\n    if (prototypeAttributes != null) {\n      for (Map.Entry<AttributeKey, Object> entry : prototypeAttributes.entrySet()) {\n        f.set(entry.getKey(), entry.getValue());\n      }\n    }\n    return f;\n"
881,creationFinished,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,378,380,5,/**\n   * This method allows subclasses to do perform additonal user interactions\n   * after the new figure has been created.\n   * The implementation of this class just invokes fireToolDone.\n   */,3,  protected void creationFinished(Figure createdFigure) {\n    if (isToolDoneAfterCreation()) {\n      fireToolDone();\n
882,canConnect,ConnectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ConnectionTool.java,145,146,8,"/**\n   * This method is called on the Figure, onto which the user wants\n   * to start a new connection.\n   * \n   * @param f The ConnectionFigure.\n   * @param startConnector The Connector of the start Figure.\n   * @return True, if a connection can be made.\n   */",2,"  protected boolean canConnect(ConnectionFigure f, Connector startConnector) {\n    return f.canConnect(startConnector);\n"
883,DrawingPageable,DrawingPageable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/print/DrawingPageable.java,50,54,1,/** Creates a new instance. */,5,  public DrawingPageable(Drawing drawing) {\n    this.drawing = drawing;\n    Paper paper = new Paper();\n    pageFormat = new PageFormat();\n    pageFormat.setPaper(paper);\n
884,createOverlay,FloatingTextArea,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java,88,89,4,/**\n   * Creates the overlay within the given container.\n   * @param view the DrawingView\n   */,2,"  public void createOverlay(DrawingView view) {\n    createOverlay(view, null);\n"
885,getText,FloatingTextArea,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java,139,140,4,/**\n   * Gets the text contents of the overlay.\n   * @return The text value\n   */,2,  public String getText() {\n    return textArea.getText();\n
886,FloatingTextArea,FloatingTextArea,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java,73,81,3,/**\n   * Constructor for the FloatingTextArea object\n   */,9,"  public FloatingTextArea() {\n    textArea = new JTextArea();\n    textArea.setWrapStyleWord(true);\n    textArea.setLineWrap(true);\n    editScrollContainer = new JScrollPane(textArea,\n        JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,\n        JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n    editScrollContainer.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));\n    editScrollContainer.setBorder(BorderFactory.createLineBorder(Color.black));\n"
887,getPreferredSize,FloatingTextArea,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java,148,149,5,/**\n   * Gets the preferred size of the overlay.\n   * @param cols Description of the Parameter\n   * @return The preferredSize value\n   */,2,"  public Dimension getPreferredSize(int cols) {\n    return new Dimension(textArea.getWidth(), textArea.getHeight());\n"
888,createOverlay,FloatingTextArea,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java,102,108,6,/**\n   * Creates the overlay for the given Container using a\n   * specific font.\n   * @param view the DrawingView\n   * @param figure the figure holding the text\n   */,7,"  public void createOverlay(DrawingView view, TextHolderFigure figure) {\n    view.getComponent().add(editScrollContainer, 0);\n    editedFigure = figure;\n    this.view = view;\n    if (editedFigure != null) {\n      editedFigure.addFigureListener(figureHandler);\n      updateWidget();\n"
889,setBounds,FloatingTextArea,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextArea.java,127,132,5,/**\n   * Positions and sizes the overlay.\n   * @param r the bounding Rectangle2D.Double for the overlay\n   * @param text the text to edit\n   */,6,"  public void setBounds(Rectangle2D.Double r, String text) {\n    textArea.setText(text);\n    editScrollContainer.setBounds(view.drawingToView(r));\n    editScrollContainer.setVisible(true);\n    textArea.setCaretPosition(0);\n    textArea.requestFocus();\n"
891,createOverlay,FloatingTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java,70,71,3,/**\n   * Creates the overlay for the given Component.\n   */,2,"  public void createOverlay(DrawingView view) {\n    createOverlay(view, null);\n"
892,getText,FloatingTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java,144,145,3,/**\n   * Gets the text contents of the overlay.\n   */,2,  public String getText() {\n    return textField.getText();\n
893,createOverlay,FloatingTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java,82,91,4,/**\n   * Creates the overlay for the given Container using a\n   * specific font.\n   */,10,"  public void createOverlay(DrawingView view, TextHolderFigure figure) {\n    view.getComponent().add(textField, 0);\n    textField.setText(figure.getText());\n    textField.setColumns(figure.getTextColumns());\n    textField.selectAll();\n    textField.setVisible(true);\n    editedFigure = figure;\n    editedFigure.addFigureListener(figureHandler);\n    this.view = view;\n    updateWidget();\n"
894,removeActionListener,FloatingTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java,136,137,3,/**\n   * Remove an action listener\n   */,2,  public void removeActionListener(ActionListener listener) {\n    textField.removeActionListener(listener);\n
895,getPreferredSize,FloatingTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java,151,153,3,/**\n   * Gets the preferred size of the overlay.\n   */,3,  public Dimension getPreferredSize(int cols) {\n    textField.setColumns(cols);\n    return textField.getPreferredSize();\n
896,addActionListener,FloatingTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/text/FloatingTextField.java,129,130,3,/**\n   * Adds an action listener\n   */,2,  public void addActionListener(ActionListener listener) {\n    textField.addActionListener(listener);\n
897,ElbowLiner,ElbowLiner,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/liner/ElbowLiner.java,41,42,1,/** Creates a new instance. */,2,  public ElbowLiner() {\n    this(20);\n
898,CurvedLiner,CurvedLiner,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/liner/CurvedLiner.java,40,41,1,/** Creates a new instance. */,2,  public CurvedLiner() {\n    this(20);\n
900,BezierLabelLocator,BezierLabelLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java,55,58,9,"/** Creates a new locator.\n   *\n   * @param relativePosition The relative position of the label on the polyline.\n   * 0.0 specifies the start of the bezier path, 1.0 the\n   * end of the polyline. Values between 0.0 and 1.0 are relative positions\n   * on the bezier path.\n   * @param angle The angle of the distance vector.\n   * @param distance The length of the distance vector.\n   */",4,"  public BezierLabelLocator(double relativePosition, double angle, double distance) {\n    this.relativePosition = relativePosition;\n    this.angle = angle;\n    this.distance = distance;\n"
901,getRelativePoint,BezierLabelLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java,73,92,4,/**\n   * Returns the coordinates of the relative point on the path\n   * of the specified bezier figure.\n   */,20,"  public Point2D.Double getRelativePoint(BezierFigure owner) {\n    Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);\n    Point2D.Double nextPoint = owner.getPointOnPath(\n        (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,\n        3);\n    \n    double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);\n    if (relativePosition >= 0.5) {\n      dir += Math.PI;\n    }\n    double alpha = dir + angle;\n    \n    Point2D.Double p = new Point2D.Double(\n        point.x + distance * Math.cos(alpha),\n        point.y + distance * Math.sin(alpha)\n        );\n    \n    if (Double.isNaN(p.x)) p = point;\n    \n    return p;\n"
903,getRelativeLabelPoint,BezierLabelLocator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/locator/BezierLabelLocator.java,100,148,4,/**\n   * Returns a Point2D.Double on the polyline that is at the provided relative position.\n   * XXX - Implement this and move it to BezierPath\n   */,49,"  public Point2D.Double getRelativeLabelPoint(BezierFigure owner, Figure label) {\n    // Get a point on the path an the next point on the path\n    Point2D.Double point = owner.getPointOnPath((float) relativePosition, 3);\n    if (point == null) {\n      return new Point2D.Double(0,0);\n    }\n    Point2D.Double nextPoint = owner.getPointOnPath(\n        (relativePosition < 0.5) ? (float) relativePosition + 0.1f : (float) relativePosition - 0.1f,\n        3);\n    \n    double dir = Math.atan2(nextPoint.y - point.y, nextPoint.x - point.x);\n    if (relativePosition >= 0.5) {\n      dir += Math.PI;\n    }\n    double alpha = dir + angle;\n    \n    Point2D.Double p = new Point2D.Double(\n        point.x + distance * Math.cos(alpha),\n        point.y + distance * Math.sin(alpha)\n        );\n    if (Double.isNaN(p.x)) p = point;\n    \n    Dimension2DDouble labelDim = label.getPreferredSize();\n    if (relativePosition == 0.5 && \n        p.x >= point.x - distance / 2 && \n        p.x <= point.x + distance / 2) {\n      if (p.y >= point.y) {\n        // South East\n        return new Point2D.Double(p.x - labelDim.width / 2, p.y);\n      } else {\n        // North East\n        return new Point2D.Double(p.x - labelDim.width / 2, p.y - labelDim.height);\n      }\n    } else {\n      if (p.x >= point.x) {\n        if (p.y >= point.y) {\n          // South East\n          return new Point2D.Double(p.x, p.y);\n        } else {\n          // North East\n          return new Point2D.Double(p.x, p.y - labelDim.height);\n        }\n      } else {\n        if (p.y >= point.y) {\n          // South West\n          return new Point2D.Double(p.x - labelDim.width,  p.y);\n        } else {\n          // North West\n          return new Point2D.Double(p.x - labelDim.width, p.y - labelDim.height);\n"
905,SlantedLiner,SlantedLiner,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/liner/SlantedLiner.java,41,42,1,/** Creates a new instance. */,2,  public SlantedLiner() {\n    this(20);\n
906,getBeanDescriptor,JDisclosureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java,81,82,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
908,getPropertyDescriptors,JDisclosureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java,97,98,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
909,getMethodDescriptors,JDisclosureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java,119,120,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
911,getDefaultEventIndex,JDisclosureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java,142,143,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
913,getDefaultPropertyIndex,JDisclosureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java,131,132,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
914,getEventSetDescriptors,JDisclosureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JDisclosureToolBarBeanInfo.java,108,109,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
916,getBeanDescriptor,JAttributeTextAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java,81,82,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
917,getEventSetDescriptors,JAttributeTextAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java,108,109,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
919,getDefaultEventIndex,JAttributeTextAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java,142,143,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
920,getPropertyDescriptors,JAttributeTextAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java,97,98,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
921,getDefaultPropertyIndex,JAttributeTextAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java,131,132,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
922,getMethodDescriptors,JAttributeTextAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextAreaBeanInfo.java,119,120,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
927,getPropertyDescriptors,JAttributeTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java,97,98,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
928,getDefaultPropertyIndex,JAttributeTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java,131,132,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
929,getEventSetDescriptors,JAttributeTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java,108,109,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
931,getDefaultEventIndex,JAttributeTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java,142,143,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
932,getMethodDescriptors,JAttributeTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java,119,120,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
934,getBeanDescriptor,JAttributeTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeTextFieldBeanInfo.java,81,82,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
935,JAttributeSlider,JAttributeSlider,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSlider.java,30,31,1,/** Creates new instance. */,2,"  public JAttributeSlider() {\n    this(JSlider.VERTICAL, 0, 100, 50);\n"
939,getDefaultEventIndex,JAttributeSliderBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java,150,151,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
940,getBeanDescriptor,JAttributeSliderBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java,89,90,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
941,getPropertyDescriptors,JAttributeSliderBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java,105,106,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
942,getDefaultPropertyIndex,JAttributeSliderBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java,139,140,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
943,getMethodDescriptors,JAttributeSliderBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java,127,128,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
945,getEventSetDescriptors,JAttributeSliderBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JAttributeSliderBeanInfo.java,116,117,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
948,outcode,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,173,188,16,"/**\n   * This method computes a binary OR of the appropriate mask values\n   * indicating, for each side of Rectangle r1, whether or not the\n   * Rectangle r2 is on the same side of the edge as the rest\n   * of this Rectangle.\n   *\n   *\n   *\n   *\n   *\n   *\n   *\n   *\n   * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,\n   * OUT_TOP.\n   */",13,"  public static int outcode(Rectangle r1, Rectangle r2) {\n    int outcode = 0;\n    if (r2.x > r1.x + r1.width) {\n      outcode = OUT_RIGHT;\n    } else if (r2.x + r2.width < r1.x) {\n      outcode = OUT_LEFT;\n    }\n    if (r2.y > r1.y + r1.height) {\n      outcode |= OUT_BOTTOM;\n    } else if (r2.y + r2.height < r1.y) {\n      outcode |= OUT_TOP;\n    }\n    return outcode;\n"
949,range,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,360,367,4,/**\n   * Constains a value to the given range.\n   * @return the constrained value\n   */,8,"  public static int range(int min, int max, int value) {\n    if (value < min) {\n      value = min;\n    }\n    if (value > max) {\n      value = max;\n    }\n    return value;\n"
950,length,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,408,409,3,/**\n   * Gets the distance between to points\n   */,2,"  public static double length(double x1, double y1, double x2, double y2) {\n    return sqrt(length2(x1, y1, x2, y2));\n"
951,length2,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,401,402,3,/**\n   * Gets the square distance between two points.\n   */,2,"  public static double length2(double x1, double y1, double x2, double y2) {\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n"
952,ovalAngleToPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,535,538,3,/**\n   * Gets the point on an oval that corresponds to the given angle.\n   */,4,"  public static Point2D.Double ovalAngleToPoint(Rectangle2D.Double r, double angle) {\n    Point2D.Double center = Geom.center(r);\n    Point2D.Double p = Geom.polarToPoint2D(angle, r.width / 2, r.height / 2);\n    return new Point2D.Double(center.x + p.x, center.y + p.y);\n"
953,ovalAngleToPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,526,529,3,/**\n   * Gets the point on an oval that corresponds to the given angle.\n   */,4,"  public static Point ovalAngleToPoint(Rectangle r, double angle) {\n    Point center = Geom.center(r);\n    Point p = Geom.polarToPoint(angle, r.width / 2, r.height / 2);\n    return new Point(center.x + p.x, center.y + p.y);\n"
954,length,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,415,416,3,/**\n   * Gets the distance between to points\n   */,2,"  public static double length(Point2D.Double p1, Point2D.Double p2) {\n    return sqrt(length2(p1.x, p1.y, p2.x, p2.y));\n"
955,lineContainsPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,43,68,4,/**\n   * Tests if a point is on a line.\n   * <p>changed Werner Randelshofer 2003-11-26\n   */,21,"  public static boolean lineContainsPoint(int x1, int y1,\n      int x2, int y2,\n      int px, int py, double tolerance) {\n    Rectangle r = new Rectangle(new Point(x1, y1));\n    r.add(x2, y2);\n    r.grow(max(2, (int) ceil(tolerance)), max(2, (int) ceil(tolerance)));\n    if (!r.contains(px, py)) {\n      return false;\n    }\n    double a, b, x, y;\n    if (x1 == x2) {\n      return (abs(px - x1) <= tolerance);\n    }\n    if (y1 == y2) {\n      return (abs(py - y1) <= tolerance);\n    }\n    a = (double) (y1 - y2) / (double) (x1 - x2);\n    b = (double) y1 - a * (double) x1;\n    x = (py - b) / a;\n    y = a * px + b;\n    return (min(abs(x - px), abs(y - py)) <= tolerance);\n"
956,polarToPoint2D,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,517,520,3,/**\n   * Converts a polar to a point\n   */,4,"  public static Point2D.Double polarToPoint2D(double angle, double fx, double fy) {\n    double si = sin(angle);\n    double co = cos(angle);\n    return new Point2D.Double(fx * co + 0.5, fy * si + 0.5);\n"
957,pointToAngle,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,435,438,3,/**\n   * Gets the angle of a point relative to a rectangle.\n   */,4,"  public static double pointToAngle(Rectangle r, Point p) {\n    int px = p.x - (r.x + r.width / 2);\n    int py = p.y - (r.y + r.height / 2);\n    return atan2(py * r.width, px * r.height);\n"
958,contains,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,833,837,11,"/**\n   * Returns true, if rectangle 1 contains rectangle 2.\n   * <p>\n   * This method is similar to Rectangle2D.contains, but also returns true,\n   * when rectangle1 contains rectangle2 and either or both of them\n   * are empty.\n   *\n   * @param r1 Rectangle 1.\n   * @param r2 Rectangle 2.\n   * @return true if r1 contains r2.\n   */",5,"  public static boolean contains(Rectangle2D.Double r1, Rectangle2D.Double r2) {\n    return (r2.x >= r1.x &&\n        r2.y >= r1.y &&\n        (r2.x + max(0, r2.width)) <= r1.x + max(0, r1.width) &&\n        (r2.y + max(0, r2.height)) <= r1.y + max(0, r1.height));\n"
959,angleToPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,484,502,3,/**\n   * Gets the point on a rectangle that corresponds to the given angle.\n   */,18,"  public static Point2D.Double angleToPoint(Rectangle2D.Double r, double angle) {\n    double si = sin(angle);\n    double co = cos(angle);\n    double e = 0.0001;\n    double x = 0, y = 0;\n    if (abs(si) > e) {\n      x = (1.0 + co / abs(si)) / 2.0 * r.width;\n      x = range(0, r.width, x);\n    } else if (co >= 0.0) {\n      x = r.width;\n    }\n    if (abs(co) > e) {\n      y = (1.0 + si / abs(co)) / 2.0 * r.height;\n      y = range(0, r.height, y);\n    } else if (si >= 0.0) {\n      y = r.height;\n    }\n    return new Point2D.Double(r.x + x, r.y + y);\n"
960,direction,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,140,154,4,"/**\n   * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from\n   * one point to another one.\n   */",14,"  public static int direction(double x1, double y1, double x2, double y2) {\n    int direction = 0;\n    double vx = x2 - x1;\n    double vy = y2 - y1;\n    if (vy < vx && vx > -vy) {\n      direction = OUT_RIGHT;\n    } else if (vy > vx && vy > -vx) {\n      direction = OUT_TOP;\n    } else if (vx < vy && vx < -vy) {\n      direction = OUT_LEFT;\n    } else {\n      direction = OUT_BOTTOM;\n    }\n    return direction;\n"
961,angleToPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,460,478,3,/**\n   * Gets the point on a rectangle that corresponds to the given angle.\n   */,18,"  public static Point angleToPoint(Rectangle r, double angle) {\n    double si = sin(angle);\n    double co = cos(angle);\n    double e = 0.0001;\n    int x = 0, y = 0;\n    if (abs(si) > e) {\n      x = (int) ((1.0 + co / abs(si)) / 2.0 * r.width);\n      x = range(0, r.width, x);\n    } else if (co >= 0.0) {\n      x = r.width;\n    }\n    if (abs(co) > e) {\n      y = (int) ((1.0 + si / abs(co)) / 2.0 * r.height);\n      y = range(0, r.height, y);\n    } else if (si >= 0.0) {\n      y = r.height;\n    }\n    return new Point(r.x + x, r.y + y);\n"
962,chop,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,246,329,5,"/**\n   * Returns a point on the edge of the bezier path which crosses the line\n   * from the center of the bezier path to the specified point.\n   * If no edge crosses the line, the nearest C0 control point is returned.\n   */",77,"  public static Point2D.Double chop(Shape shape, Point2D.Double p) {\n    Rectangle2D bounds = shape.getBounds2D();\n    Point2D.Double ctr = new Point2D.Double(bounds.getCenterX(), bounds.getCenterY());\n    // Chopped point\n    double cx = -1;\n    double cy = -1;\n    double len = Double.MAX_VALUE;\n    // Try for points along edge\n    PathIterator i = shape.getPathIterator(new AffineTransform(), 1);\n    double[] coords = new double[6];\n    int type = i.currentSegment(coords);\n    double prevX = coords[0];\n    double prevY = coords[1];\n    double moveToX = prevX;\n    double moveToY = prevY;\n    i.next();\n    for (; !i.isDone(); i.next()) {\n      switch (i.currentSegment(coords)) {\n        case PathIterator.SEG_MOVETO:\n          moveToX = coords[0];\n          moveToY = coords[1];\n          break;\n        case PathIterator.SEG_CLOSE:\n          coords[0] = moveToX;\n          coords[1] = moveToY;\n          break;\n      }\n      Point2D.Double chop = Geom.intersect(\n          prevX, prevY,\n          coords[0], coords[1],\n          p.x, p.y,\n          ctr.x, ctr.y);\n      if (chop != null) {\n        double cl = Geom.length2(chop.x, chop.y, p.x, p.y);\n        if (cl < len) {\n          len = cl;\n          cx = chop.x;\n          cy = chop.y;\n        }\n      }\n      prevX = coords[0];\n      prevY = coords[1];\n    }\n    /*\n    if (isClosed() && size() > 1) {\n    Node first = get(0);\n    Node last = get(size() - 1);\n    Point2D.Double chop = Geom.intersect(\n    first.x[0], first.y[0],\n    last.x[0], last.y[0],\n    p.x, p.y,\n    ctr.x, ctr.y\n    );\n    if (chop != null) {\n    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);\n    if (cl < len) {\n    len = cl;\n    cx = chop.x;\n    cy = chop.y;\n    }\n    }\n    }*/\n\n    // if none found, pick closest vertex\n    if (len == Double.MAX_VALUE) {\n      i = shape.getPathIterator(new AffineTransform(), 1);\n      for (; !i.isDone(); i.next()) {\n        i.currentSegment(coords);\n        double l = Geom.length2(ctr.x, ctr.y, coords[0], coords[1]);\n        if (l < len) {\n          len = l;\n          cx = coords[0];\n          cy = coords[1];\n        }\n      }\n    }\n    return new Point2D.Double(cx, cy);\n"
963,length,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,394,395,3,/**\n   * Gets the distance between to points\n   */,2,"  public static long length(int x1, int y1, int x2, int y2) {\n    return (long) sqrt(length2(x1, y1, x2, y2));\n"
964,grow,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,815,819,23,"/**\n   * Resizes the <code>Rectangle2D.Double</code> both horizontally and vertically.\n   * <p>\n   * This method modifies the <code>Rectangle2D.Double</code> so that it is\n   * <code>h</code> units larger on both the left and right side,\n   * and <code>v</code> units larger at both the top and bottom.\n   * <p>\n   * The new <code>Rectangle2D.Double</code> has (<code>x&nbsp;-&nbsp;h</code>,\n   * <code>y&nbsp;-&nbsp;v</code>) as its top-left corner, a\n   * width of\n   * <code>width</code>&nbsp;<code>+</code>&nbsp;<code>2h</code>,\n   * and a height of\n   * <code>height</code>&nbsp;<code>+</code>&nbsp;<code>2v</code>.\n   * <p>\n   * If negative values are supplied for <code>h</code> and\n   * <code>v</code>, the size of the <code>Rectangle2D.Double</code>\n   * decreases accordingly.\n   * The <code>grow</code> method does not check whether the resulting\n   * values of <code>width</code> and <code>height</code> are\n   * non-negative.\n   * @param h the horizontal expansion\n   * @param v the vertical expansion\n   */",5,"  public static void grow(Rectangle2D.Double r, double h, double v) {\n    r.x -= h;\n    r.y -= v;\n    r.width += h * 2d;\n    r.height += v * 2d;\n"
965,outcode,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,207,222,16,"/**\n   * This method computes a binary OR of the appropriate mask values\n   * indicating, for each side of Rectangle r1, whether or not the\n   * Rectangle r2 is on the same side of the edge as the rest\n   * of this Rectangle.\n   *\n   *\n   *\n   *\n   *\n   *\n   *\n   *\n   * @return the logical OR of all appropriate out codes OUT_RIGHT, OUT_LEFT, OUT_BOTTOM,\n   * OUT_TOP.\n   */",13,"  public static int outcode(Rectangle2D.Double r1, Rectangle2D.Double r2) {\n    int outcode = 0;\n    if (r2.x > r1.x + r1.width) {\n      outcode = OUT_RIGHT;\n    } else if (r2.x + r2.width < r1.x) {\n      outcode = OUT_LEFT;\n    }\n    if (r2.y > r1.y + r1.height) {\n      outcode |= OUT_BOTTOM;\n    } else if (r2.y + r2.height < r1.y) {\n      outcode |= OUT_TOP;\n    }\n    return outcode;\n"
966,direction,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,119,133,4,"/**\n   * Returns the direction OUT_TOP, OUT_BOTTOM, OUT_LEFT, OUT_RIGHT from\n   * one point to another one.\n   */",14,"  public static int direction(int x1, int y1, int x2, int y2) {\n    int direction = 0;\n    int vx = x2 - x1;\n    int vy = y2 - y1;\n    if (vy < vx && vx > -vy) {\n      direction = OUT_RIGHT;\n    } else if (vy > vx && vy > -vx) {\n      direction = OUT_TOP;\n    } else if (vx < vy && vx < -vy) {\n      direction = OUT_LEFT;\n    } else {\n      direction = OUT_BOTTOM;\n    }\n    return direction;\n"
968,range,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,374,381,4,/**\n   * Constains a value to the given range.\n   * @return the constrained value\n   */,8,"  public static double range(double min, double max, double value) {\n    if (value < min) {\n      value = min;\n    }\n    if (value > max) {\n      value = max;\n    }\n    return value;\n"
969,angle,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,453,454,3,/**\n   * Gets the angle of the specified line.\n   */,2,"  public static double angle(double x1, double y1, double x2, double y2) {\n    return atan2(y2 - y1, x2 - x1);\n"
970,lineContainsPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,75,104,4,/**\n   * Tests if a point is on a line.\n   * <p>changed Werner Randelshofer 2003-11-26\n   */,25,"  public static boolean lineContainsPoint(double x1, double y1,\n      double x2, double y2,\n      double px, double py, double tolerance) {\n    Rectangle2D.Double r = new Rectangle2D.Double(x1, y1, 0, 0);\n    r.add(x2, y2);\n    double grow = max(2, (int) ceil(tolerance));\n    r.x -= grow;\n    r.y -= grow;\n    r.width += grow * 2;\n    r.height += grow * 2;\n    if (!r.contains(px, py)) {\n      return false;\n    }\n    double a, b, x, y;\n    if (x1 == x2) {\n      return (abs(px - x1) <= tolerance);\n    }\n    if (y1 == y2) {\n      return (abs(py - y1) <= tolerance);\n    }\n    a = (double) (y1 - y2) / (double) (x1 - x2);\n    b = (double) y1 - a * (double) x1;\n    x = (py - b) / a;\n    y = a * px + b;\n    return (min(abs(x - px), abs(y - py)) <= tolerance);\n"
971,lineContainsPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,33,36,3,/**\n   * Tests if a point is on a line.\n   */,4,"  public static boolean lineContainsPoint(int x1, int y1,\n      int x2, int y2,\n      int px, int py) {\n    return lineContainsPoint(x1, y1, x2, y2, px, py, 3d);\n"
972,polarToPoint,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,508,511,3,/**\n   * Converts a polar to a point\n   */,4,"  public static Point polarToPoint(double angle, double fx, double fy) {\n    double si = sin(angle);\n    double co = cos(angle);\n    return new Point((int) (fx * co + 0.5), (int) (fy * si + 0.5));\n"
973,pointToAngle,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,444,447,3,/**\n   * Gets the angle of a point relative to a rectangle.\n   */,4,"  public static double pointToAngle(Rectangle2D.Double r, Point2D.Double p) {\n    double px = p.x - (r.x + r.width / 2);\n    double py = p.y - (r.y + r.height / 2);\n    return atan2(py * r.width, px * r.height);\n"
975,cap,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,424,429,5,/**\n   * Caps the line defined by p1 and p2 by the number of units\n   * specified by radius.\n   * @return A new end point for the line.\n   */,6,"  public static Point2D.Double cap(Point2D.Double p1, Point2D.Double p2, double radius) {\n    double angle = PI / 2 - atan2(p2.x - p1.x, p2.y - p1.y);\n    Point2D.Double p3 = new Point2D.Double(\n        p2.x + radius * cos(angle),\n        p2.y + radius * sin(angle));\n    return p3;\n"
976,length2,Geom,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Geom.java,387,388,3,/**\n   * Gets the square distance between two points.\n   */,2,"  public static long length2(int x1, int y1, int x2, int y2) {\n    return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n"
991,reset,Polygon2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,79,81,17,"/**\n   * Resets this <code>Polygon</code> object to an empty polygon.\n   * The coordinate arrays and the data in them are left untouched\n   * but the number of points is reset to zero to mark the old\n   * vertex data as invalid and to start accumulating new vertex\n   * data at the beginning.\n   * All internally-cached data relating to the old vertices\n   * are discarded.\n   * Note that since the coordinate arrays from before the reset\n   * are reused, creating a new empty <code>Polygon</code> might\n   * be more memory efficient than resetting the current one if\n   * the number of vertices in the new polygon data is significantly\n   * smaller than the number of vertices in the data from before the\n   * reset.\n   * @see     java.awt.Polygon#invalidate\n   * \n   */",3,  public void reset() {\n    npoints = 0;\n    invalidate();\n
993,contains,Polygon2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,149,150,9,"/**\n   * Determines whether the specified {@link Point} is inside this \n   * <code>Polygon</code>.\n   * @param p the specified <code>Point</code> to be tested\n   * @return <code>true</code> if the <code>Polygon</code> contains the\n   *       <code>Point</code>; <code>false</code> otherwise.\n   * @see #contains(double, double)\n   * \n   */",2,"  public boolean contains(Point p) {\n    return contains(p.x, p.y);\n"
994,getBounds,Polygon2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,136,137,9,"/**\n   * Gets the bounding box of this <code>Polygon</code>. \n   * The bounding box is the smallest {@link Rectangle} whose\n   * sides are parallel to the x and y axes of the \n   * coordinate space, and can completely contain the <code>Polygon</code>.\n   * @return a <code>Rectangle</code> that defines the bounds of this \n   * <code>Polygon</code>.\n   * \n   */",2,  public Rectangle getBounds() {\n    return getBounds2D().getBounds();\n
998,inside,Polygon2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,182,184,13,"/**\n   * Determines whether the specified coordinates are contained in this \n   * <code>Polygon</code>.\n   * @param x the specified X coordinate to be tested\n   * @param y the specified Y coordinate to be tested\n   * @return {@code true} if this {@code Polygon} contains\n   *     the specified coordinates {@code (x,y)};\n   *     {@code false} otherwise.\n   * @see #contains(double, double)\n   * @deprecated As of JDK version 1.1,\n   * replaced by <code>contains(int, int)</code>.\n   * \n   */",3,"  @Deprecated\n  public boolean inside(int x, int y) {\n    return contains((double) x, (double) y);\n"
1001,contains,Polygon2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,165,166,12,"/**\n   * Determines whether the specified coordinates are inside this \n   * <code>Polygon</code>.   \n   * <p>\n   * @param x the specified X coordinate to be tested\n   * @param y the specified Y coordinate to be tested\n   * @return {@code true} if this {@code Polygon} contains\n   *     the specified coordinates {@code (x,y)};\n   *     {@code false} otherwise.\n   * @see #contains(double, double)\n   * \n   */",2,"  public boolean contains(int x, int y) {\n    return contains((double) x, (double) y);\n"
1004,translate,Double,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,362,370,8,/**\n     * Translates the vertices of the <code>Polygon</code> by\n     * <code>deltaX</code> along the x axis and by\n     * <code>deltaY</code> along the y axis.\n     * @param deltaX the amount to translate along the X axis\n     * @param deltaY the amount to translate along the Y axis\n     * \n     */,9,"    @Override\n    public void translate(double deltaX, double deltaY) {\n      for (int i = 0; i < npoints; i++) {\n        xpoints[i] += deltaX;\n        ypoints[i] += deltaY;\n      }\n      if (bounds != null) {\n        bounds.x += deltaX;\n        bounds.y += deltaY;\n"
1005,calculateBounds,Double,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,385,401,7,/*\n     * Calculates the bounding box of the points passed to the constructor.\n     * Sets <code>bounds</code> to the result.\n     * @param xpoints[] array of <i>x</i> coordinates\n     * @param ypoints[] array of <i>y</i> coordinates\n     * @param npoints the total number of points\n     */,16,"    void calculateBounds(double xpoints[], double ypoints[], int npoints) {\n      double boundsMinX = java.lang.Double.MAX_VALUE;\n      double boundsMinY = java.lang.Double.MAX_VALUE;\n      double boundsMaxX = -java.lang.Double.MAX_VALUE;\n      double boundsMaxY = -java.lang.Double.MAX_VALUE;\n      for (int i = 0; i < npoints; i++) {\n        double x = xpoints[i];\n        boundsMinX = Math.min(boundsMinX, x);\n        boundsMaxX = Math.max(boundsMaxX, x);\n        double y = ypoints[i];\n        boundsMinY = Math.min(boundsMinY, y);\n        boundsMaxY = Math.max(boundsMaxY, y);\n      }\n      bounds = new Rectangle2D.Double(boundsMinX, boundsMinY,\n          boundsMaxX - boundsMinX,\n          boundsMaxY - boundsMinY);\n"
1006,updateBounds,Double,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,408,421,4,"/*\n     * Resizes the bounding box to accomodate the specified coordinates.\n     * @param x,&nbsp;y the specified coordinates\n     */",13,"    void updateBounds(double x, double y) {\n      if (x < bounds.x) {\n        bounds.width = bounds.width + (bounds.x - x);\n        bounds.x = x;\n      } else {\n        bounds.width = Math.max(bounds.width, x - bounds.x);\n      // bounds.x = bounds.x;\n      }\n      if (y < bounds.y) {\n        bounds.height = bounds.height + (bounds.y - y);\n        bounds.y = y;\n      } else {\n        bounds.height = Math.max(bounds.height, y - bounds.y);\n"
1007,updateBounds,Float,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,717,730,4,"/*\n     * Resizes the bounding box to accomodate the specified coordinates.\n     * @param x,&nbsp;y the specified coordinates\n     */",13,"    void updateBounds(float x, float y) {\n      if (x < bounds.x) {\n        bounds.width = bounds.width + (bounds.x - x);\n        bounds.x = x;\n      } else {\n        bounds.width = Math.max(bounds.width, x - bounds.x);\n      // bounds.x = bounds.x;\n      }\n      if (y < bounds.y) {\n        bounds.height = bounds.height + (bounds.y - y);\n        bounds.y = y;\n      } else {\n        bounds.height = Math.max(bounds.height, y - bounds.y);\n"
1009,Float,Float,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,635,656,16,/**\n     * Constructs and initializes a <code>Polygon</code> from the specified\n     * parameters.\n     * @param xpoints an array of X coordinates\n     * @param ypoints an array of Y coordinates\n     * @param npoints the total number of points in the\n     *        <code>Polygon</code>\n     * @exception  NegativeArraySizeException if the value of\n     *             <code>npoints</code> is negative.\n     * @exception  IndexOutOfBoundsException if <code>npoints</code> is\n     *       greater than the length of <code>xpoints</code>\n     *       or the length of <code>ypoints</code>.\n     * @exception  NullPointerException if <code>xpoints</code> or\n     *       <code>ypoints</code> is <code>null</code>.\n     * \n     */,21,"    public Float(float xpoints[], float ypoints[], int npoints) {\n      // Fix 4489009: should throw IndexOutofBoundsException instead\n      // of OutofMemoryException if npoints is huge and > {x,y}points.length\n      if (npoints > xpoints.length || npoints > ypoints.length) {\n        throw new IndexOutOfBoundsException(""npoints > xpoints.length || "" +\n            ""npoints > ypoints.length"");\n      }\n      // Fix 6191114: should throw NegativeArraySizeException with\n      // negative npoints\n      if (npoints < 0) {\n        throw new NegativeArraySizeException(""npoints < 0"");\n      }\n      // Fix 6343431: Applet compatibility problems if arrays are not\n      // exactly npoints in length\n      this.npoints = npoints;\n      this.xpoints = new float[npoints];\n      System.arraycopy(xpoints, 0, this.xpoints, 0,\n          npoints);\n      this.ypoints = new float[npoints];\n      System.arraycopy(ypoints, 0, this.ypoints, 0,\n          npoints);\n"
1010,calculateBounds,Float,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,694,710,7,/*\n     * Calculates the bounding box of the points passed to the constructor.\n     * Sets <code>bounds</code> to the result.\n     * @param xpoints[] array of <i>x</i> coordinates\n     * @param ypoints[] array of <i>y</i> coordinates\n     * @param npoints the total number of points\n     */,16,"    void calculateBounds(float xpoints[], float ypoints[], int npoints) {\n      float boundsMinX = java.lang.Float.MAX_VALUE;\n      float boundsMinY = java.lang.Float.MAX_VALUE;\n      float boundsMaxX = -java.lang.Float.MAX_VALUE;\n      float boundsMaxY = -java.lang.Float.MAX_VALUE;\n      for (int i = 0; i < npoints; i++) {\n        float x = xpoints[i];\n        boundsMinX = Math.min(boundsMinX, x);\n        boundsMaxX = Math.max(boundsMaxX, x);\n        float y = ypoints[i];\n        boundsMinY = Math.min(boundsMinY, y);\n        boundsMaxY = Math.max(boundsMaxY, y);\n      }\n      bounds = new Rectangle2D.Float(boundsMinX, boundsMinY,\n          boundsMaxX - boundsMinX,\n          boundsMaxY - boundsMinY);\n"
1011,translate,Float,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,667,669,8,/**\n     * Translates the vertices of the <code>Polygon</code> by\n     * <code>deltaX</code> along the x axis and by\n     * <code>deltaY</code> along the y axis.\n     * @param deltaX the amount to translate along the X axis\n     * @param deltaY the amount to translate along the Y axis\n     * \n     */,3,"    @Override\n    public void translate(double deltaX, double deltaY) {\n      translate((float) deltaX, (float) deltaY);\n"
1012,getWindingRule,PolygonPathIteratorDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,926,927,6,/**\n     * Returns the winding rule for determining the interior of the\n     * path.\n     * @return an integer representing the current winding rule.\n     * @see PathIterator#WIND_NON_ZERO\n     */,2,    public int getWindingRule() {\n      return WIND_EVEN_ODD;\n
1013,next,PolygonPathIteratorDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,944,945,5,"/**\n     * Moves the iterator forwards, along the primary direction of\n     * traversal, to the next segment of the path when there are\n     * more points in that direction.\n     */",2,    public void next() {\n      index++;\n
1014,isDone,PolygonPathIteratorDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,935,936,5,/**\n     * Tests if there are more points to read.\n     * @return <code>true</code> if there are more points to read;\n     *      <code>false</code> otherwise.\n     */,2,    public boolean isDone() {\n      return index > poly.npoints;\n
1015,currentSegment,PolygonPathIteratorDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,966,975,18,"/**\n     * Returns the coordinates and type of the current path segment in\n     * the iteration.\n     * The return value is the path segment type:\n     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.\n     * A <code>float</code> array of length 2 must be passed in and\n     * can be used to store the coordinates of the point(s).\n     * Each point is stored as a pair of <code>float</code> x,&nbsp;y\n     * coordinates.  SEG_MOVETO and SEG_LINETO types return one\n     * point, and SEG_CLOSE does not return any points.\n     * @param coords a <code>float</code> array that specifies the\n     * coordinates of the point(s)\n     * @return an integer representing the type and coordinates of the\n     *     current path segment.\n     * @see PathIterator#SEG_MOVETO\n     * @see PathIterator#SEG_LINETO\n     * @see PathIterator#SEG_CLOSE\n     */",10,"    public int currentSegment(float[] coords) {\n      if (index >= poly.npoints) {\n        return SEG_CLOSE;\n      }\n      coords[0] = (float) poly.xpoints[index];\n      coords[1] = (float) poly.ypoints[index];\n      if (transform != null) {\n        transform.transform(coords, 0, coords, 0, 1);\n      }\n      return (index == 0 ? SEG_MOVETO : SEG_LINETO);\n"
1016,getWindingRule,PolygonPathIteratorFloat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,1031,1032,6,/**\n     * Returns the winding rule for determining the interior of the\n     * path.\n     * @return an integer representing the current winding rule.\n     * @see PathIterator#WIND_NON_ZERO\n     */,2,    public int getWindingRule() {\n      return WIND_EVEN_ODD;\n
1017,currentSegment,PolygonPathIteratorFloat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,1071,1080,18,"/**\n     * Returns the coordinates and type of the current path segment in\n     * the iteration.\n     * The return value is the path segment type:\n     * SEG_MOVETO, SEG_LINETO, or SEG_CLOSE.\n     * A <code>float</code> array of length 2 must be passed in and\n     * can be used to store the coordinates of the point(s).\n     * Each point is stored as a pair of <code>float</code> x,&nbsp;y\n     * coordinates.  SEG_MOVETO and SEG_LINETO types return one\n     * point, and SEG_CLOSE does not return any points.\n     * @param coords a <code>float</code> array that specifies the\n     * coordinates of the point(s)\n     * @return an integer representing the type and coordinates of the\n     *     current path segment.\n     * @see PathIterator#SEG_MOVETO\n     * @see PathIterator#SEG_LINETO\n     * @see PathIterator#SEG_CLOSE\n     */",10,"    public int currentSegment(float[] coords) {\n      if (index >= poly.npoints) {\n        return SEG_CLOSE;\n      }\n      coords[0] = (float) poly.xpoints[index];\n      coords[1] = (float) poly.ypoints[index];\n      if (transform != null) {\n        transform.transform(coords, 0, coords, 0, 1);\n      }\n      return (index == 0 ? SEG_MOVETO : SEG_LINETO);\n"
1018,isDone,PolygonPathIteratorFloat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,1040,1041,5,/**\n     * Tests if there are more points to read.\n     * @return <code>true</code> if there are more points to read;\n     *      <code>false</code> otherwise.\n     */,2,    public boolean isDone() {\n      return index > poly.npoints;\n
1019,next,PolygonPathIteratorFloat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Polygon2D.java,1049,1050,5,"/**\n     * Moves the iterator forwards, along the primary direction of\n     * traversal, to the next segment of the path when there are\n     * more points in that direction.\n     */",2,    public void next() {\n      index++;\n
1021,hashCode,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,188,194,5,/**\n   * Returns the hash code for this Insets2DDouble.\n   *\n   * @return  a hash code for this Insets2DDouble.\n   */,7,  public int hashCode() {\n    double sum1 = getLeft() + getBottom();\n    double sum2 = getRight() + getTop();\n    double val1 = sum1 * (sum1 + 1)/2 + getLeft();\n    double val2 = sum2 * (sum2 + 1)/2 + getTop();\n    double sum3 = val1 + val2;\n    return java.lang.Float.floatToIntBits((float) (sum3 * (sum3 + 1)/2 + val2));\n
1023,clone,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,199,204,3,/**\n   * Creates a new object of the same class as this object.\n   */,6,"  public Object clone() {\n    try {\n      return super.clone();\n    } catch (CloneNotSupportedException e) {\n      // this shouldn't happen, since we are Cloneable\n      throw new InternalError();\n"
1024,add,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,97,102,5,/**\n   * Adds the specified insets to the current insets.\n   *\n   * @param i The insets to be added.\n   */,6,"  public void add(Insets2D i) {\n    set(\n        getTop() + i.getTop(),\n        getLeft() + i.getLeft(),\n        getBottom() + i.getBottom(),\n        getRight() + i.getRight()\n"
1027,subtractTo,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,155,160,6,/**\n   * Subtracts the current insets to the specified Rectangle2D making the\n   * rectangle smaller.\n   *\n   * @param r The Rectangle2D.\n   */,6,"  public void subtractTo(Rectangle2D r) {\n    r.setRect(\n        r.getX() + getLeft(),\n        r.getY() + getTop(),\n        r.getWidth() - getLeft() - getRight(),\n        r.getHeight() - getTop() - getBottom()\n"
1029,subtract,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,141,146,5,/**\n   * Subtracts the specified insets from the current insets.\n   *\n   * @param i The insets to be subtracted.\n   */,6,"  public void subtract(Insets2D i) {\n    set(\n        getTop() - i.getTop(),\n        getLeft() - i.getLeft(),\n        getBottom() - i.getBottom(),\n        getRight() - i.getRight()\n"
1030,subtract,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,128,133,8,/**\n   * Subtracts the specified insets from the current insets.\n   *\n   * @param top The top insets.\n   * @param left The left insets.\n   * @param bottom The bottom insets.\n   * @param right The right insets.\n   */,6,"  public void subtract(double top, double left, double bottom, double right) {\n    set(\n        getTop() - top,\n        getLeft() - left,\n        getBottom() - bottom,\n        getRight() - right\n"
1031,add,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,84,89,8,/**\n   * Adds the specified insets to the current insets.\n   *\n   * @param top The top insets.\n   * @param left The left insets.\n   * @param bottom The bottom insets.\n   * @param right The right insets.\n   */,6,"  public void add(double top, double left, double bottom, double right) {\n    set(\n        getTop() + top,\n        getLeft() + left,\n        getBottom() + bottom,\n        getRight() + right\n"
1032,set,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,72,73,5,/**\n   * Sets the insets.\n   *\n   * @param i The new insets.\n   */,2,"  public void set(Insets2D i) {\n    set(i.getTop(), i.getLeft(), i.getBottom(), i.getRight());\n"
1033,addTo,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,112,117,6,/**\n   * Adds the current insets to the specified Rectangle2D making the\n   * rectangle larger.\n   *\n   * @param r The Rectangle2D.\n   */,6,"  public void addTo(Rectangle2D r) {\n    r.setRect(\n        r.getX() - getLeft(),\n        r.getY() - getTop(),\n        r.getWidth() + getLeft() + getRight(),\n        r.getHeight() + getTop() + getBottom()\n"
1035,equals,Insets2D,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Insets2D.java,172,180,9,"/**\n   * Checks whether two insets objects are equal. Two instances\n   * of <code>Insets2DDouble</code> are equal if the four integer values\n   * of the fields <code>top</code>, <code>left</code>,\n   * <code>bottom</code>, and <code>right</code> are all equal.\n   * @return    <code>true</code> if the two insets are equal;\n   *              otherwise <code>false</code>.\n   * @since     JDK1.1\n   */",9,  public boolean equals(Object obj) {\n    if (obj instanceof Insets2D) {\n      Insets2D that = (Insets2D)obj;\n      return ((getTop() == that.getTop()) &&\n          (getLeft() == that.getLeft()) &&\n          (getBottom() == that.getBottom()) &&\n          (getRight() == that.getRight()));\n    }\n    return false;\n
1038,Dimension2DDouble,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,72,74,7,/** \n   * Constructs a <code>Dimension2DDouble</code> and initializes\n   * it to the specified width and specified height.\n   *\n   * @param width the specified width \n   * @param height the specified height\n   */,3,"  public Dimension2DDouble(double width, double height) {\n  this.width = width;\n  this.height = height;\n"
1039,Dimension2DDouble,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,61,62,8,/** \n   * Creates an instance of <code>Dimension2DDouble</code> whose width  \n   * and height are the same as for the specified dimension. \n   *\n   * @param  d   the specified dimension for the \n   *         <code>width</code> and \n   *         <code>height</code> values\n   */,2,"  public Dimension2DDouble(Dimension2DDouble d) {\n  this(d.width, d.height);\n"
1040,hashCode,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,152,154,5,/**\n   * Returns the hash code for this <code>Dimension2DDouble</code>.\n   *\n   * @return  a hash code for this <code>Dimension2DDouble</code>\n   */,3,  public int hashCode() {\n    float sum = (float) (width + height);\n    return Float.floatToIntBits(sum * (sum + 1)/2 + (float) width);\n
1041,setSize,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,103,105,10,"/**\n   * Sets the size of this <code>Dimension2DDouble</code> object to\n   * the specified width and height in double precision.\n   * Note that if <code>width</code> or <code>height</code>\n   * are larger than <code>Integer.MAX_VALUE</code>, they will\n   * be reset to <code>Integer.MAX_VALUE</code>.\n   *\n   * @param width  the new width for the <code>Dimension2DDouble</code> object\n   * @param height the new height for the <code>Dimension2DDouble</code> object\n   */",3,"  public void setSize(double width, double height) {\n    this.width = width;\n    this.height = height;\n"
1042,Dimension2DDouble,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,49,50,4,/** \n   * Creates an instance of <code>Dimension2DDouble</code> with a width \n   * of zero and a height of zero. \n   */,2,"  public Dimension2DDouble() {\n  this(0, 0);\n"
1043,setSize,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,132,133,9,"/**\n   * Sets the size of this <code>Dimension2DDouble</code> object to the specified size.\n   * This method is included for completeness, to parallel the\n   * <code>setSize</code> method defined by <code>Component</code>.\n   * @param  d  the new size for this <code>Dimension2DDouble</code> object\n   * @see    Dimension2DDouble#getSize\n   * @see    java.awt.Component#setSize\n   * @since  JDK1.1\n   */",2,"  public void setSize(Dimension2DDouble d) {\n  setSize(d.width, d.height);\n"
1044,getWidth,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,81,82,4,/**\n   * Returns the width of this dimension in double precision.\n   * @return the width of this dimension in double precision\n   */,2,  public double getWidth() {\n  return width;\n
1045,getHeight,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,89,90,4,/**\n   * Returns the height of this dimension in double precision.\n   * @return the height of this dimension in double precision\n   */,2,  public double getHeight() {\n  return height;\n
1046,getSize,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,119,120,11,"/**\n   * Gets the size of this <code>Dimension2DDouble</code> object.\n   * This method is included for completeness, to parallel the\n   * <code>getSize</code> method defined by <code>Component</code>.\n   *\n   * @return   the size of this dimension, a new instance of \n   *       <code>Dimension2DDouble</code> with the same width and height\n   * @see    Dimension2DDouble#setSize\n   * @see    java.awt.Component#getSize\n   * @since  JDK1.1\n   */",2,"  public Dimension2DDouble getSize() {\n  return new Dimension2DDouble(width, height);\n"
1047,equals,Dimension2DDouble,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Dimension2DDouble.java,139,144,3,/**\n   * Checks whether two dimension objects have equal values.\n   */,6,  public boolean equals(Object obj) {\n  if (obj instanceof Dimension2DDouble) {\n    Dimension2DDouble d = (Dimension2DDouble)obj;\n    return (width == d.width) && (height == d.height);\n  }\n  return false;\n
1049,isSelectable,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,536,538,4,/**\n   * Checks whether this figure is selectable. By default\n   * {@code AbstractFigure} can be selected.\n   */,3,  @Override\n  public boolean isSelectable() {\n    return isSelectable;\n
1050,fireFigureRemoved,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,204,218,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,15,"  protected void fireFigureRemoved() {\n    if (listenerList.getListenerCount() > 0) {\n      FigureEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (listeners[i] == FigureListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureEvent(this, getBounds());\n          }\n          ((FigureListener) listeners[i + 1]).figureRemoved(event);\n"
1051,willChange,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,409,415,4,/**\n   * Informs that a figure is about to change something that\n   * affects the contents of its display box.\n   */,7,  @Override\n  public void willChange() {\n    if (changingDepth == 0) {\n      fireAreaInvalidated();\n      invalidate();\n    }\n    changingDepth++;\n
1052,getTool,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,477,479,4,"/**\n   * Returns a specialized tool for the given coordinate.\n   * <p>Returns null, if no specialized tool is available.\n   */",3,  @Override\n  public Tool getTool(Point2D.Double p) {\n    return null;\n
1053,handleMouseClick,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,485,487,3,/**\n   * Handles a mouse click.\n   */,3,"  @Override\n  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {\n    return false;\n"
1054,changed,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,424,432,3,/**\n   * Informs that a figure changed the area of its display box.\n   */,9,"  @Override\n  public void changed() {\n    if (changingDepth == 1) {\n      validate();\n      fireFigureChanged(getDrawingArea());\n    } else if (changingDepth < 0) {\n      throw new InternalError(""changed was called without a prior call to willChange. ""+changingDepth);\n    }\n    changingDepth--;\n"
1055,isTransformable,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,566,568,4,/**\n   * Checks whether this figure is transformable. By default\n   * {@code AbstractFigure} can be transformed.\n   */,3,  @Override\n  public boolean isTransformable() {\n    return isTransformable;\n
1057,fireFigureAdded,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,180,194,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,15,"  protected void fireFigureAdded() {\n    if (listenerList.getListenerCount() > 0) {\n      FigureEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (listeners[i] == FigureListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureEvent(this, getBounds());\n          }\n          ((FigureListener) listeners[i + 1]).figureAdded(event);\n"
1058,findConnector,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,442,444,7,/**\n   * Returns the Figures connector for the specified location.\n   * By default a ChopBoxConnector is returned.\n   *\n   *\n   * @see ChopRectangleConnector\n   */,3,"  @Override\n  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {\n    return new ChopRectangleConnector(this);\n"
1059,fireFigureHandlesChanged,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,297,312,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,16,"  protected void fireFigureHandlesChanged() {\n    Rectangle2D.Double changedArea = getDrawingArea();\n    if (listenerList.getListenerCount() > 0) {\n      FigureEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (listeners[i] == FigureListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureEvent(this, changedArea);\n          }\n          ((FigureListener) listeners[i + 1]).figureHandlesChanged(event);\n"
1060,fireAttributeChanged,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,272,287,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,16,"  protected void fireAttributeChanged(AttributeKey attribute, Object oldValue, Object newValue) {\n    if (listenerList.getListenerCount() > 0 &&\n        (oldValue == null || newValue == null || !oldValue.equals(newValue))) {\n      FigureEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (listeners[i] == FigureListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureEvent(this, attribute, oldValue, newValue);\n          }\n          ((FigureListener) listeners[i + 1]).attributeChanged(event);\n"
1061,fireAreaInvalidated,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,115,129,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,15,"  protected void fireAreaInvalidated(Rectangle2D.Double invalidatedArea) {\n    if (listenerList.getListenerCount() > 0) {\n      FigureEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (listeners[i] == FigureListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureEvent(this, invalidatedArea);\n          }\n          ((FigureListener) listeners[i + 1]).areaInvalidated(event);\n"
1062,fireFigureRequestRemove,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,156,170,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,15,"  protected void fireFigureRequestRemove() {\n    if (listenerList.getListenerCount() > 0) {\n      FigureEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (listeners[i] == FigureListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureEvent(this, getBounds());\n          }\n          ((FigureListener) listeners[i + 1]).figureRequestRemove(event);\n"
1063,fireAreaInvalidated,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,107,108,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,2,  public void fireAreaInvalidated() {\n    fireAreaInvalidated(getDrawingArea());\n
1066,getActions,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,468,470,6,/**\n   * Returns a collection of actions which are presented to the user\n   * in a popup menu.\n   * <p>The collection may contain null entries. These entries are used\n   * interpreted as separators in the popup menu.\n   */,3,  @Override\n  public Collection<Action> getActions(Point2D.Double p) {\n    return Collections.emptyList();\n
1067,fireFigureChanged,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,232,246,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,15,"  protected void fireFigureChanged(Rectangle2D.Double changedArea) {\n    if (listenerList.getListenerCount() > 0) {\n      FigureEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (listeners[i] == FigureListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureEvent(this, changedArea);\n          }\n          ((FigureListener) listeners[i + 1]).figureChanged(event);\n"
1068,isConnectable,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,521,523,4,/**\n   * Checks whether this figure is connectable. By default\n   * {@code AbstractFigure} can be connected.\n   */,3,  @Override\n  public boolean isConnectable() {\n    return isConnectable;\n
1069,fireUndoableEditHappened,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,323,325,5,"/**\n   * Notify all UndoableEditListener of the Drawing, to which this Figure has\n   * been added to. If this Figure is not part of a Drawing, the event is\n   * lost.\n   */",3,  protected void fireUndoableEditHappened(UndoableEdit edit) {\n    if (getDrawing() != null) {\n      getDrawing().fireUndoableEditHappened(edit);\n
1071,isRemovable,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,551,553,4,/**\n   * Checks whether this figure is removable. By default\n   * {@code AbstractFigure} can be removed.\n   */,3,  @Override\n  public boolean isRemovable() {\n    return isRemovable;\n
1072,fireAreaInvalidated,AbstractFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractFigure.java,139,147,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,9,"  protected void fireAreaInvalidated(FigureEvent event) {\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == FigureListener.class) {\n        ((FigureListener) listeners[i + 1]).areaInvalidated(event);\n"
1094,getKey,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,104,105,4,/**\n   * Returns the key string.\n   * @return key string.\n   */,2,  public String getKey() {\n    return key;\n
1095,setUndoable,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,188,219,8,"/**\n   * Sets the attribute and returns an UndoableEditEvent which can be used\n   * to undo it.\n   * <p>\n   * Note: Unlike in previous versions of JHotDraw 7, this method does\n   * not call {@code f.willChange()} before setting the value, and\n   * {@code f.changed()} afterwards.\n   */",27,"  public UndoableEdit setUndoable(final Figure f, final T value) {\n    if (value == null && !isNullValueAllowed) {\n      throw new NullPointerException(""Null value not allowed for AttributeKey "" + key);\n    }\n    final Object restoreData = f.getAttributesRestoreData();\n    f.set(this, value);\n    UndoableEdit edit = new AbstractUndoableEdit() {\n      @Override\n      public String getPresentationName() {\n        return AttributeKey.this.getPresentationName();\n      }\n      @Override\n      public void undo() {\n        super.undo();\n        f.willChange();\n        f.restoreAttributesTo(restoreData);\n        f.changed();\n      }\n      @Override\n      public void redo() {\n        super.redo();\n        f.willChange();\n        f.set(AttributeKey.this, value);\n        f.changed();\n      }\n    };\n    return edit;\n"
1096,getDefaultValue,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,121,122,5,/**\n   * Returns the default value of the attribute.\n   *\n   * @return the default value.\n   */,2,  public T getDefaultValue() {\n    return defaultValue;\n
1097,put,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,269,274,8,/**\n   * Use this method to perform a type-safe put operation of an attribute\n   * into a Map.\n   *\n   * @param a An attribute map.\n   * @param value The new value.\n   * @return The old value.\n   */,6,"  @SuppressWarnings(""unchecked"")\n  public T put(Map<AttributeKey, Object> a, T value) {\n    if (value == null && !isNullValueAllowed) {\n      throw new NullPointerException(""Null value not allowed for AttributeKey "" + key);\n    }\n    return (T) a.put(this, value);\n"
1098,get,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,158,160,7,/**\n   * Gets the value of the attribute denoted by this AttributeKey from\n   * a Map.\n   * \n   * @param a A Map.\n   * @return The value of the attribute.\n   */,3,"  @SuppressWarnings(""unchecked"")\n  public T get(Map<AttributeKey, Object> a) {\n    return a.containsKey(this) ? (T) a.get(this) : defaultValue;\n"
1099,AttributeKey,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,77,78,2,"/** Creates a new instance with the specified attribute key, type token class,\n   * default value, and allowing or disallowing null values. */",2,"  public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed) {\n    this(key, clazz, defaultValue, isNullValueAllowed, null);\n"
1100,putClone,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,250,257,6,/**\n   * Convenience method for putting a clone of a value on a map.\n   *\n   * @param a the map\n   * @param value the attribute value\n   */,7,"  public void putClone(Map<AttributeKey, Object> a, T value) {\n    try {\n       put(a, value == null ? null : clazz.cast(Methods.invoke(value, ""clone"")));\n    } catch (NoSuchMethodException ex) {\n      InternalError e = new InternalError();\n      e.initCause(ex);\n      throw e;\n"
1101,getClone,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,128,136,3,/**\n   * Gets a clone of the value from the Figure.\n   */,9,"  @SuppressWarnings(""unchecked"")\n  public T getClone(Figure f) {\n    T value = f.get(this);\n    try {\n      return value == null ? null : clazz.cast(Methods.invoke(value, ""clone""));\n    } catch (NoSuchMethodException ex) {\n      InternalError e = new InternalError();\n      e.initCause(ex);\n      throw e;\n"
1102,setClone,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,233,240,10,"/**\n   * Convenience method for setting a clone of a value on a figure.\n   * <p>\n   * Note: Unlike in previous versions of JHotDraw 7, this method does\n   * not call {@code f.willChange()} before setting the value, and\n   * {@code f.changed()} afterwards.\n   *\n   * @param f the Figure\n   * @param value the attribute value\n   */",7,"  public void setClone(Figure f, T value) {\n    try {\n       f.set(this, value == null ? null : clazz.cast(Methods.invoke(value, ""clone"")));\n    } catch (NoSuchMethodException ex) {\n      InternalError e = new InternalError();\n      e.initCause(ex);\n      throw e;\n"
1103,getPresentationName,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,112,113,4,/**\n   * Returns a localized human friendly presentation of the key.\n   * @return the presentation name of the key.\n   */,2,"  public String getPresentationName() {\n    return (labels == null) ? key : labels.getString(""attribute."" + key + "".text"");\n"
1104,get,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,147,148,7,/**\n   * Gets the value of the attribute denoted by this AttributeKey from\n   * a Figure.\n   * \n   * @param f A figure.\n   * @return The value of the attribute.\n   */,2,  public T get(Figure f) {\n    return f.get(this);\n
1105,isAssignable,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,291,296,6,/**\n   * Returns true if the specified value is assignable with this key.\n   *\n   * @param value\n   * @return True if assignable.\n   */,5,  public boolean isAssignable(Object value) {\n    if (value == null) {\n      return isNullValueAllowed();\n    }\n    return clazz.isInstance(value);\n
1106,AttributeKey,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,65,66,2,"/** Creates a new instance with the specified attribute key, type token class,\n   * default value null, and allowing null values. */",2,"  public AttributeKey(String key, Class<T> clazz) {\n    this(key, clazz, null, true);\n"
1107,set,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,173,177,10,"/**\n   * Convenience method for setting a value on a Figure.\n   * <p>\n   * Note: Unlike in previous versions of JHotDraw 7, this method does\n   * not call {@code f.willChange()} before setting the value, and\n   * {@code f.changed()} afterwards.\n   *\n   * @param f the Figure\n   * @param value the attribute value\n   */",5,"  public void set(Figure f, T value) {\n    if (value == null && !isNullValueAllowed) {\n      throw new NullPointerException(""Null value not allowed for AttributeKey "" + key);\n    }\n    f.set(this, value);\n"
1108,AttributeKey,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,71,72,2,"/** Creates a new instance with the specified attribute key, type token class,\n   * and default value, and allowing null values. */",2,"  public AttributeKey(String key, Class<T> clazz, T defaultValue) {\n    this(key, clazz, defaultValue, true);\n"
1109,AttributeKey,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,92,97,11,"/** Creates a new instance with the specified attribute key, type token class,\n   * default value, and allowing or disallowing null values. \n   * \n   * @param key The key string. \n   * @param clazz This is used as a ""type token"" for assignability checks\n   * at runtime.\n   * @param isNullValueAllowed whether null values are allowed.\n   * @param labels ResourceBundle for human friendly representation of this\n   * attribute key. The ResourceBundle must have a property named\n   * {@code ""attribute."" + key + "".text""}.\n   */",6,"  public AttributeKey(String key, Class<T> clazz, T defaultValue, boolean isNullValueAllowed, ResourceBundleUtil labels) {\n    this.key = key;\n    this.clazz = clazz;\n    this.defaultValue = defaultValue;\n    this.isNullValueAllowed = isNullValueAllowed;\n    this.labels = (labels == null) ? ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"") : labels;\n"
1110,isNullValueAllowed,AttributeKey,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AttributeKey.java,281,282,4,/**\n   * Returns true if null values are allowed.\n   * @return true if null values are allowed.\n   */,2,  public boolean isNullValueAllowed() {\n    return isNullValueAllowed;\n
1111,getPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,425,426,4,/**\n   * Convenience method for getting the point coordinate of\n   * the first control point of the specified node.\n   */,2,  public Point2D.Double getPoint(int index) {\n    return path.get(index).getControlPoint(0);\n
1112,BezierFigure,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,97,99,9,"/**\n   * Creates an empty BezierFigure, for example without any\n   * <code>BezierPath.Node</code>s.\n   * The BezierFigure will not draw anything, unless at least two nodes\n   * are added to it.\n   *\n   * @param isClosed Specifies whether the <code>BezierPath</code> shall\n   * be closed.\n   */",3,"  public BezierFigure(boolean isClosed) {\n    path = new BezierPath();\n    set(PATH_CLOSED, isClosed);\n"
1113,getNode,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,418,419,3,/**\n   * Gets a control point.\n   */,2,  public BezierPath.Node getNode(int index) {\n    return (BezierPath.Node) path.get(index).clone();\n
1114,setStartPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,460,465,5,"/**\n   * Convenience method for setting the point coordinate of the start point.\n   * If the BezierFigure has not at least two nodes, nodes are added\n   * to the figure until the BezierFigure has at least two nodes.\n   */",6,"  public void setStartPoint(Point2D.Double p) {\n    // Add two nodes if we haven't at least two nodes\n    for (int i=getNodeCount(); i < 2; i++) {\n      addNode(0, new BezierPath.Node(p.x, p.y));\n    }\n    setPoint(0, p);\n"
1115,findNode,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,498,506,5,/**\n   * Finds a control point index.\n   * Returns -1 if no control point could be found.\n   * FIXME - Move this to BezierPath\n   */,9,  public int findNode(Point2D.Double p) {\n    BezierPath tp = path;\n    for (int i=0; i < tp.size(); i++) {\n      BezierPath.Node p2 = tp.get(i);\n      if (p2.x[0] == p.x && p2.y[0] == p.y) {\n        return i;\n      }\n    }\n    return -1;\n
1116,getEndPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,489,491,3,/**\n   * Convenience method for getting the end point.\n   */,3,"  @Override\n  public Point2D.Double getEndPoint() {\n    return getPoint(getNodeCount() - 1, 0);\n"
1117,setPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,450,453,3,/**\n   * Sets the point coordinate of a control point.\n   */,4,"  public void setPoint(int index, int coord, Point2D.Double p) {\n    BezierPath.Node cp = new BezierPath.Node(path.get(index));\n    cp.setControlPoint(coord, p);\n    setNode(index, cp);\n"
1118,getStartPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,482,484,3,/**\n   * Convenience method for getting the start point.\n   */,3,"  @Override\n  public Point2D.Double getStartPoint() {\n    return getPoint(0, 0);\n"
1119,splitSegment,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,624,625,4,/**\n   * Splits the segment at the given Point2D.Double if a segment was hit.\n   * @return the index of the segment or -1 if no segment was hit.\n   */,2,"  public int splitSegment(Point2D.Double split, float tolerance) {\n    return path.splitSegment(split, tolerance);\n"
1120,getCappedPath,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,344,388,7,"/**\n   * Returns a path which is cappedPath at the ends, to prevent\n   * it from drawing under the end caps.\n   */\n --------------\n// EDITING\n --------------",45,"  protected BezierPath getCappedPath() {\n    if (cappedPath == null) {\n      cappedPath = (BezierPath) path.clone();\n      if (isClosed()) {\n        cappedPath.setClosed(true);\n      } else {\n        if (cappedPath.size() > 1) {\n          if (get(START_DECORATION) != null) {\n            BezierPath.Node p0 = cappedPath.get(0);\n            BezierPath.Node p1 = cappedPath.get(1);\n            Point2D.Double pp;\n            if ((p0.getMask() & BezierPath.C2_MASK) != 0) {\n              pp = p0.getControlPoint(2);\n            } else if ((p1.getMask() & BezierPath.C1_MASK) != 0) {\n              pp = p1.getControlPoint(1);\n            } else {\n              pp = p1.getControlPoint(0);\n            }\n            double radius = get(START_DECORATION).getDecorationRadius(this);\n            double lineLength = Geom.length(p0.getControlPoint(0), pp);\n            cappedPath.set(0,0, Geom.cap(pp, p0.getControlPoint(0), - Math.min(radius, lineLength)));\n          }\n          if (get(END_DECORATION) != null) {\n            BezierPath.Node p0 = cappedPath.get(cappedPath.size() - 1);\n            BezierPath.Node p1 = cappedPath.get(cappedPath.size() - 2);\n            \n            Point2D.Double pp;\n            if ((p0.getMask() & BezierPath.C1_MASK) != 0) {\n              pp = p0.getControlPoint(1);\n            } else if ((p1.getMask() & BezierPath.C2_MASK) != 0) {\n              pp = p1.getControlPoint(2);\n            } else {\n              pp = p1.getControlPoint(0);\n            }\n            \n            \n            double radius = get(END_DECORATION).getDecorationRadius(this);\n            double lineLength = Geom.length(p0.getControlPoint(0), pp);\n            cappedPath.set(cappedPath.size() - 1, 0, Geom.cap(pp, p0.getControlPoint(0), -Math.min(radius, lineLength)));\n          }\n          cappedPath.invalidatePath();\n        }\n      }\n    }\n    return cappedPath;\n"
1121,joinSegments,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,617,618,5,/**\n   * Joins two segments into one if the given Point2D.Double hits a node\n   * of the polyline.\n   * @return true if the two segments were joined.\n   */,2,"  public int joinSegments(Point2D.Double join, float tolerance) {\n    return path.joinSegments(join, tolerance);\n"
1122,BezierFigure,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,85,86,7,"/**\n   * Creates an empty <code>BezierFigure</code>, for example without any\n   * <code>BezierPath.Node</code>s.\n   * The BezierFigure will not draw anything, if at least two nodes\n   * are added to it. The <code>BezierPath</code> created by this constructor\n   * is not closed.\n   */",2,  public BezierFigure() {\n    this(false);\n
1123,getNodeCount,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,567,568,3,/**\n   * Gets the node count.\n   */,2,  public int getNodeCount() {\n    return path.size();\n
1124,setPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,437,445,3,/**\n   * Sets the point coordinate of control point 0 at the specified node.\n   */,9,"  public void setPoint(int index, Point2D.Double p) {\n    BezierPath.Node node = path.get(index);\n    double dx = p.x - node.x[0];\n    double dy = p.y - node.y[0];\n    for (int i=0; i < node.x.length; i++) {\n      node.x[i] += dx;\n      node.y[i] += dy;\n    }\n    invalidate();\n"
1125,findConnector,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,112,114,4,/**\n   * Returns the Figures connector for the specified location.\n   * By default a {@link ChopBezierConnector} is returned.\n   */,3,"  @Override\n  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {\n    return new ChopBezierConnector(this);\n"
1126,removeNode,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,555,556,3,/**\n   * Removes the Node at the specified index.\n   */,2,  public BezierPath.Node removeNode(int index) {\n     return path.remove(index);\n
1127,findSegment,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,517,518,9,"/**\n   * Gets the segment of the polyline that is hit by\n   * the given Point2D.Double.\n   * \n   * @param find a Point on the bezier path\n   * @param tolerance a tolerance, tolerance should take into account\n   * the line width, plus 2 divided by the zoom factor. \n   * @return the index of the segment or -1 if no segment was hit.\n   */",2,"  public int findSegment(Point2D.Double find, double tolerance) {\n    return getBezierPath().findSegment(find, tolerance);\n"
1128,setBounds,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,322,326,6,"/**\n   * Sets the location of the first and the last <code>BezierPath.Node</code>\n   * of the BezierFigure.\n   * If the BezierFigure has not at least two nodes, nodes are added\n   * to the figure until the BezierFigure has at least two nodes.\n   */",5,"  @Override\n  public void setBounds(Point2D.Double anchor, Point2D.Double lead) {\n    setStartPoint(anchor);\n    setEndPoint(lead);\n    invalidate();\n"
1129,addNode,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,402,405,6,/**\n   * Adds a node to the list of points.\n   */\n --------------\n// COMPOSITE FIGURES\n --------------,4,"  public void addNode(final int index, BezierPath.Node p) {\n    final BezierPath.Node newPoint = new BezierPath.Node(p);\n    path.add(index, p);\n    invalidate();\n"
1130,getBezierPath,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,286,287,6,/**\n   * Returns a clone of the bezier path of this figure.\n   */\n --------------\n// SHAPE AND BOUNDS\n --------------,2,  public BezierPath getBezierPath() {\n    return (BezierPath) path.clone();\n
1131,getPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,431,432,3,/**\n   * Gets the point coordinate of a control point.\n   */,2,"  public Point2D.Double getPoint(int index, int coord) {\n    return path.get(index).getControlPoint(coord);\n"
1132,setNode,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,410,412,6,/**\n   * Sets a control point.\n   */\n --------------\n// CLONING\n --------------,3,"  public void setNode(int index, BezierPath.Node p) {\n    path.set(index, p);\n    invalidate();\n"
1133,addNode,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,396,397,6,/**\n   * Adds a control point.\n   */\n --------------\n// CONNECTING\n --------------,2,"  public void addNode(BezierPath.Node p) {\n    addNode(getNodeCount(), p);\n"
1134,joinSegments,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,529,535,9,"/**\n   * Joins two segments into one if the given Point2D.Double hits a node\n   * of the polyline.\n   * @return true if the two segments were joined.\n   *\n   * @param join a Point at a node on the bezier path\n   * @param tolerance a tolerance, tolerance should take into account\n   * the line width, plus 2 divided by the zoom factor. \n   */",7,"  public boolean joinSegments(Point2D.Double join, double tolerance) {\n    int i = findSegment(join, tolerance);\n    if (i != -1 && i > 1) {\n      removeNode(i);\n      return true;\n    }\n    return false;\n"
1135,splitSegment,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,545,550,8,"/**\n   * Splits the segment at the given Point2D.Double if a segment was hit.\n   * @return the index of the segment or -1 if no segment was hit.\n   *\n   * @param split a Point on (or near) a line segment on the bezier path\n   * @param tolerance a tolerance, tolerance should take into account\n   * the line width, plus 2 divided by the zoom factor. \n   */",6,"  public int splitSegment(Point2D.Double split, double tolerance) {\n    int i = findSegment(split, tolerance);\n    if (i != -1) {\n      addNode(i + 1, new BezierPath.Node(split));\n    }\n    return i+1;\n"
1136,removeAllNodes,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,561,562,3,/**\n   * Removes the Point2D.Double at the specified index.\n   */,2,  protected void removeAllNodes() {\n    path.clear();\n
1138,setEndPoint,BezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/BezierFigure.java,472,477,5,"/**\n   * Convenience method for setting the point coordinate of the end point.\n   * If the BezierFigure has not at least two nodes, nodes are added\n   * to the figure until the BezierFigure has at least two nodes.\n   */",6,"  public void setEndPoint(Point2D.Double p) {\n    // Add two nodes if we haven't at least two nodes\n    for (int i=getNodeCount(); i < 2; i++) {\n      addNode(0, new BezierPath.Node(p.x, p.y));\n    }\n    setPoint(getNodeCount() - 1, p);\n"
1139,addChangeListener,AbstractConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractConstrainer.java,44,45,3,/**\n   * Adds a <code>ChangeListener</code>.\n   */,2,"  public void addChangeListener(ChangeListener l) {\n    listenerList.add(ChangeListener.class, l);\n"
1140,removeChangeListener,AbstractConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractConstrainer.java,51,52,3,/**\n   * Removes a <code>ChangeListener</code>.\n   */,2,"  public void removeChangeListener(ChangeListener l) {\n    listenerList.remove(ChangeListener.class, l);\n"
1169,fireUndoableEditHappened,AbstractDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractDrawing.java,55,69,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,15,"  @Override\n  public void fireUndoableEditHappened(UndoableEdit edit) {\n    UndoableEditEvent event = null;\n    if (listenerList.getListenerCount() > 0) {\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >= 0; i -= 2) {\n        if (event == null) {\n          event = new UndoableEditEvent(this, edit);\n        }\n        if (listeners[i] == UndoableEditListener.class) {\n          ((UndoableEditListener) listeners[i + 1]).undoableEditHappened(event);\n"
1171,getLock,AbstractDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/AbstractDrawing.java,105,107,3,/**\n   * The drawing view synchronizes on the lock when drawing a drawing.\n   */,3,  @Override\n  public Object getLock() {\n    return lock;\n
1174,invalidateSortOrder,DefaultDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java,202,203,3,/**\n   * Invalidates the sort order.\n   */,2,  private void invalidateSortOrder() {\n    needsSorting = true;\n
1175,ensureSorted,DefaultDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java,210,213,4,/**\n   * Ensures that the children are sorted in z-order sequence from back to\n   * front.\n   */,4,"  private void ensureSorted() {\n    if (needsSorting) {\n      Collections.sort(children, FigureLayerComparator.INSTANCE);\n      needsSorting = false;\n"
1176,getFiguresFrontToBack,DefaultDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawing.java,194,196,4,/**\n   * Returns an iterator to iterate in\n   * Z-order front to back over the children.\n   */,3,  public java.util.List<Figure> getFiguresFrontToBack() {\n    ensureSorted();\n    return new ReversedList<Figure>(getChildren());\n
1177,createInputMap,DefaultDrawingEditor,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingEditor.java,303,341,16,"/** Override this method to create a tool-specific input map, which\n   * overrides the input map of the drawing edtior.\n   * <p>\n   * The implementation of this class creates an input map for the following\n   * action ID's:\n   * <ul>\n   * <li>DeleteAction</li>\n   * <li>SelectAllAction/li>\n   * <li>IncreaseHandleDetailLevelAction</li>\n   * <li>MoveConstrainedAction.West, .East, .North, .South</li>\n   * <li>MoveAction.West, .East, .North, .South</li>\n   * <li>CutAction</li>\n   * <li>CopyAction</li>\n   * <li>PasteAction</li>\n   * </ul>\n   */",32,"  protected InputMap createInputMap() {\n    InputMap m = new InputMap();\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), DeleteAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_BACK_SPACE, 0), DeleteAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, 0), SelectAllAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_DOWN_MASK), SelectAllAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.META_DOWN_MASK), SelectAllAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0), IncreaseHandleDetailLevelAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), MoveConstrainedAction.West.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), MoveConstrainedAction.East.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), MoveConstrainedAction.North.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), MoveConstrainedAction.South.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.ALT_DOWN_MASK), MoveAction.West.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.ALT_DOWN_MASK), MoveAction.East.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.ALT_DOWN_MASK), MoveAction.North.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.ALT_DOWN_MASK), MoveAction.South.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.SHIFT_DOWN_MASK), MoveAction.West.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.SHIFT_DOWN_MASK), MoveAction.East.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.SHIFT_DOWN_MASK), MoveAction.North.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.SHIFT_DOWN_MASK), MoveAction.South.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK), MoveAction.West.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK), MoveAction.East.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.CTRL_DOWN_MASK), MoveAction.North.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, InputEvent.CTRL_DOWN_MASK), MoveAction.South.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_DOWN_MASK), CopyAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.META_DOWN_MASK), CopyAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK), PasteAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.META_DOWN_MASK), PasteAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.CTRL_DOWN_MASK), CutAction.ID);\n    m.put(KeyStroke.getKeyStroke(KeyEvent.VK_X, InputEvent.META_DOWN_MASK), CutAction.ID);\n\n    return m;\n"
1178,DefaultDrawingEditor,DefaultDrawingEditor,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingEditor.java,108,116,1,/** Creates a new instance. */,8,"  public DefaultDrawingEditor() {\n    toolHandler = new ToolHandler();\n    setDefaultAttribute(FILL_COLOR, Color.white);\n    setDefaultAttribute(STROKE_COLOR, Color.black);\n    setDefaultAttribute(TEXT_COLOR, Color.black);\n    views = new HashSet<DrawingView>();\n    inputMap = createInputMap();\n    actionMap = createActionMap();\n"
1179,setTarget,DrawingEditorProxy,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DrawingEditorProxy.java,62,68,3,/**\n   * Sets the target of the proxy.\n   */,7,  public void setTarget(DrawingEditor newValue) {\n    if (target != null) {\n      target.removePropertyChangeListener(forwarder);\n    }\n    this.target = newValue;\n    if (target != null) {\n      target.addPropertyChangeListener(forwarder);\n
1180,DrawingEditorProxy,DrawingEditorProxy,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DrawingEditorProxy.java,55,56,1,/** Creates a new instance. */,2,  public DrawingEditorProxy() {\n    forwarder = new Forwarder();\n
1203,getDefaultEventIndex,DefaultDrawingViewBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java,145,146,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1204,getDefaultPropertyIndex,DefaultDrawingViewBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java,134,135,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1207,getEventSetDescriptors,DefaultDrawingViewBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java,111,112,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1208,getPropertyDescriptors,DefaultDrawingViewBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java,100,101,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1210,getMethodDescriptors,DefaultDrawingViewBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java,122,123,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1211,getBeanDescriptor,DefaultDrawingViewBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewBeanInfo.java,84,85,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1228,createEditorColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,559,637,31,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button works like the color button in Microsoft Office:\n   * <ul>\n   * <li>When the user clicks on the action region, the default color of the\n   * DrawingEditor is applied to the selected figures.</li>\n   * <li>When the user opens the popup menu, a color palette is displayed.\n   * Choosing a color from the palette changes the default color of the\n   * editor and also changes the color of the selected figures.</li>\n   * <li>A shape on the color button displays the current default color of the\n   * DrawingEditor.</li>\n   * </ul>\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan\'t the gradient attribute\n   * of the Figure to be cleared.\n   * @param colorShape This shape is superimposed on the icon of the button.\n   * The shape is drawn with the default color of the DrawingEditor.\n   */",73,"  public static JPopupButton createEditorColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes,\n      Shape colorShape) {\n    final JPopupButton popupButton = new JPopupButton();\n    popupButton.setPopupAlpha(1f);\n    if (defaultAttributes == null) {\n      defaultAttributes = new HashMap<AttributeKey, Object>();\n    }\n    popupButton.setAction(\n        new DefaultAttributeAction(editor, attributeKey, defaultAttributes),\n        new Rectangle(0, 0, 22, 22));\n    popupButton.setColumnCount(columnCount, false);\n    boolean hasNullColor = false;\n    for (ColorIcon swatch : swatches) {\n      AttributeAction a;\n      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);\n      attributes.put(attributeKey, swatch.getColor());\n      if (swatch.getColor() == null) {\n        hasNullColor = true;\n      }\n      popupButton.add(a =\n          new AttributeAction(\n          editor,\n          attributes,\n          labels.getToolTipTextProperty(labelKey),\n          swatch));\n      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());\n      a.setUpdateEnabledState(false);\n    }\n    // No color\n    if (!hasNullColor) {\n      AttributeAction a;\n      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);\n      attributes.put(attributeKey, null);\n      popupButton.add(a =\n          new AttributeAction(\n          editor,\n          attributes,\n          labels.getToolTipTextProperty(""attribute.color.noColor""),\n          new ColorIcon(null, labels.getToolTipTextProperty(""attribute.color.noColor""), swatches.get(0).getIconWidth(), swatches.get(0).getIconHeight())));\n      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty(""attribute.color.noColor""));\n      a.setUpdateEnabledState(false);\n    }\n    // Color chooser\n    ImageIcon chooserIcon = new ImageIcon(\n        Images.createImage(\n        ButtonFactory.class, ""/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png""));\n    Action a;\n    popupButton.add(\n        a = new EditorColorChooserAction(\n        editor,\n        attributeKey,\n        ""color"",\n        chooserIcon,\n        defaultAttributes));\n    labels.configureToolBarButton(popupButton, labelKey);\n    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty(""attribute.color.colorChooser""));\n    Icon icon = new EditorColorIcon(editor,\n        attributeKey,\n        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),\n        colorShape);\n    popupButton.setIcon(icon);\n    popupButton.setDisabledIcon(icon);\n    popupButton.setFocusable(false);\n    editor.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        popupButton.repaint();\n      }\n    });\n    return popupButton;\n"
1235,createSelectionColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,748,756,31,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button works like the color button in Adobe Fireworks:\n   * <ul>\n   * <li>When the user clicks at the button a popup menu with a color palette\n   * is displayed.\n   * Choosing a color from the palette changes the default color of the\n   * editor and also changes the color of the selected figures.</li>\n   * <li>A shape on the color button displays the color of the selected\n   * figures. If no figures are selected, the default color of the\n   * DrawingEditor is displayed.</li>\n   * </ul>\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan't the gradient attribute\n   * of the Figure to be cleared.\n   * @param colorShape This shape is superimposed on the icon of the button.\n   * The shape is drawn with the default color of the DrawingEditor.\n   */",9,"  public static JPopupButton createSelectionColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes,\n      Shape colorShape) {\n    return createSelectionColorButton(editor, attributeKey,\n        swatches, columnCount, labelKey, labels, defaultAttributes,\n        colorShape, new LinkedList<Disposable>());\n"
1238,createDrawingColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,879,887,16,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button acts on attributes of the Drawing object in the current DrawingView\n   * of the DrawingEditor.\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   */",9,"  public static JPopupButton createDrawingColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels) {\n    return createDrawingColorButton(\n        editor, attributeKey,\n        swatches, columnCount,\n        labelKey, labels,\n        null);\n"
1245,addAlignmentButtonsTo,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,1499,1528,3,/**\n   * Creates toolbar buttons and adds them to the specified JToolBar.\n   */,29,"  public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor, java.util.List<Disposable> dsp) {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    AbstractSelectedAction d;\n    bar.add(d = new AlignAction.West(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new AlignAction.East(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new AlignAction.Horizontal(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new AlignAction.North(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new AlignAction.South(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new AlignAction.Vertical(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.addSeparator();\n    bar.add(d = new MoveAction.West(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new MoveAction.East(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new MoveAction.North(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(d = new MoveAction.South(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.addSeparator();\n    bar.add(new BringToFrontAction(editor)).setFocusable(false);\n    dsp.add(d);\n    bar.add(new SendToBackAction(editor)).setFocusable(false);\n    dsp.add(d);\n"
1249,createSelectionColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,667,675,27,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button works like the color button in Adobe Fireworks:\n   * <ul>\n   * <li>When the user clicks at the button a popup menu with a color palette\n   * is displayed.\n   * Choosing a color from the palette changes the default color of the\n   * editor and also changes the color of the selected figures.</li>\n   * <li>A shape on the color button displays the color of the selected\n   * figures. If no figures are selected, the default color of the\n   * DrawingEditor is displayed.</li>\n   * <li>A rectangle on the color button displays the current default color of\n   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,\n   * width, height).</li>\n   * </ul>\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   */",9,"  public static JPopupButton createSelectionColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels) {\n    return createSelectionColorButton(\n        editor, attributeKey,\n        swatches, columnCount,\n        labelKey, labels,\n        null);\n"
1252,createDrawingColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,911,918,21,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button acts on attributes of the Drawing object in the current DrawingView\n   * of the DrawingEditor.\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan't the gradient attribute\n   * of the Figure to be cleared.\n   */",8,"  public static JPopupButton createDrawingColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes) {\n    return createDrawingColorButton(editor, attributeKey,\n        swatches, columnCount, labelKey, labels, defaultAttributes,\n        new Rectangle(1, 17, 20, 4));\n"
1253,createDrawingColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,944,952,23,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button acts on attributes of the Drawing object in the current DrawingView\n   * of the DrawingEditor.\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan't the gradient attribute\n   * of the Figure to be cleared.\n   * @param colorShape This shape is superimposed on the icon of the button.\n   * The shape is drawn with the default color of the DrawingEditor.\n   */",9,"  public static JPopupButton createDrawingColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes,\n      Shape colorShape) {\n    return createDrawingColorButton(editor, attributeKey,\n        swatches, columnCount, labelKey, labels, defaultAttributes,\n        colorShape, new LinkedList<Disposable>());\n"
1254,addAttributesButtonsTo,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,422,436,3,/**\n   * Creates toolbar buttons and adds them to the specified JToolBar\n   */,13,"  public static void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    JButton b;\n    b = bar.add(new PickAttributesAction(editor));\n    b.setFocusable(false);\n    b = bar.add(new ApplyAttributesAction(editor));\n    b.setFocusable(false);\n    bar.addSeparator();\n    addColorButtonsTo(bar, editor);\n    bar.addSeparator();\n    addStrokeButtonsTo(bar, editor);\n    bar.addSeparator();\n    addFontButtonsTo(bar, editor);\n"
1255,addAlignmentButtonsTo,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,1492,1493,3,/**\n   * Creates toolbar buttons and adds them to the specified JToolBar\n   */,2,"  public static void addAlignmentButtonsTo(JToolBar bar, final DrawingEditor editor) {\n    addAlignmentButtonsTo(bar, editor, new LinkedList<Disposable>());\n"
1256,createSelectionColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,707,714,29,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button works like the color button in Adobe Fireworks:\n   * <ul>\n   * <li>When the user clicks at the button a popup menu with a color palette\n   * is displayed.\n   * Choosing a color from the palette changes the default color of the\n   * editor and also changes the color of the selected figures.</li>\n   * <li>A rectangle on the color button displays the current default color of\n   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,\n   * width, height).</li>\n   * </ul>\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan't the gradient attribute\n   * of the Figure to be cleared.\n   */",8,"  public static JPopupButton createSelectionColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes) {\n    return createSelectionColorButton(editor, attributeKey,\n        swatches, columnCount, labelKey, labels, defaultAttributes,\n        new Rectangle(1, 17, 20, 4));\n"
1257,createEditorColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,477,485,25,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button works like the color button in Microsoft Office:\n   * <ul>\n   * <li>When the user clicks on the action region, the default color of the\n   * DrawingEditor is applied to the selected figures.</li>\n   * <li>When the user opens the popup menu, a color palette is displayed.\n   * Choosing a color from the palette changes the default color of the\n   * editor and also changes the color of the selected figures.</li>\n   * <li>A rectangle on the color button displays the current default color of\n   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,\n   * width, height).</li>\n   * </ul>\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   */",9,"  public static JPopupButton createEditorColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels) {\n    return createEditorColorButton(\n        editor, attributeKey,\n        swatches, columnCount,\n        labelKey, labels,\n        null);\n"
1258,addToolTo,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,313,328,5,/**\n   * Method addSelectionToolTo must have been invoked prior to this on the\n   * JToolBar.\n   *\n   */,13,"  public static JToggleButton addToolTo(JToolBar tb, DrawingEditor editor,\n      Tool tool, String labelKey,\n      ResourceBundleUtil labels) {\n    ButtonGroup group = (ButtonGroup) tb.getClientProperty(""toolButtonGroup"");\n    ToolListener toolHandler = (ToolListener) tb.getClientProperty(""toolHandler"");\n    JToggleButton t = new JToggleButton();\n    labels.configureToolBarButton(t, labelKey);\n    t.addItemListener(new ToolButtonListener(tool, editor));\n    t.setFocusable(false);\n    tool.addToolListener(toolHandler);\n    group.add(t);\n    tb.add(t);\n    return t;\n"
1259,createDrawingColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,978,1052,23,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button acts on attributes of the Drawing object in the current DrawingView\n   * of the DrawingEditor.\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan\'t the gradient attribute\n   * of the Figure to be cleared.\n   * @param colorShape This shape is superimposed on the icon of the button.\n   * The shape is drawn with the default color of the DrawingEditor.\n   */",70,"  public static JPopupButton createDrawingColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes,\n      Shape colorShape, java.util.List<Disposable> dsp) {\n    final JPopupButton popupButton = new JPopupButton();\n    popupButton.setPopupAlpha(1f);\n    if (defaultAttributes == null) {\n      defaultAttributes = new HashMap<AttributeKey, Object>();\n    }\n    popupButton.setColumnCount(columnCount, false);\n    boolean hasNullColor = false;\n    for (ColorIcon swatch : swatches) {\n      DrawingAttributeAction a;\n      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);\n      attributes.put(attributeKey, swatch.getColor());\n      if (swatch.getColor() == null) {\n        hasNullColor = true;\n      }\n      popupButton.add(a =\n          new DrawingAttributeAction(\n          editor,\n          attributes,\n          labels.getToolTipTextProperty(labelKey),\n          swatch));\n      dsp.add(a);\n      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());\n      a.setUpdateEnabledState(false);\n    }\n    // No color\n    if (!hasNullColor) {\n      DrawingAttributeAction a;\n      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);\n      attributes.put(attributeKey, null);\n      popupButton.add(a =\n          new DrawingAttributeAction(\n          editor,\n          attributes,\n          labels.getToolTipTextProperty(""attribute.color.noColor""),\n          new ColorIcon(null, labels.getToolTipTextProperty(""attribute.color.noColor""))));\n      dsp.add(a);\n      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty(""attribute.color.noColor""));\n      a.setUpdateEnabledState(false);\n    }\n    // Color chooser\n    ImageIcon chooserIcon = new ImageIcon(\n        Images.createImage(ButtonFactory.class, ""/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png""));\n    DrawingColorChooserAction a;\n    popupButton.add(\n        a = new DrawingColorChooserAction(\n        editor,\n        attributeKey,\n        ""color"",\n        chooserIcon,\n        defaultAttributes));\n    dsp.add(a);\n    labels.configureToolBarButton(popupButton, labelKey);\n    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty(""attribute.color.colorChooser""));\n    Icon icon = new DrawingColorIcon(editor,\n        attributeKey,\n        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),\n        colorShape);\n    popupButton.setIcon(icon);\n    popupButton.setDisabledIcon(icon);\n    popupButton.setFocusable(false);\n    if (editor != null) {\n      dsp.add(new SelectionComponentRepainter(editor, popupButton));\n    }\n    return popupButton;\n"
1260,createEditorColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,518,525,30,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button works like the color button in Microsoft Office:\n   * <ul>\n   * <li>When the user clicks on the action region, the default color of the\n   * DrawingEditor is applied to the selected figures.</li>\n   * <li>When the user opens the popup menu, a color palette is displayed.\n   * Choosing a color from the palette changes the default color of the\n   * editor and also changes the color of the selected figures.</li>\n   * <li>A rectangle on the color button displays the current default color of\n   * the DrawingEditor. The rectangle has the dimensions 1, 17, 20, 4 (x, y,\n   * width, height).</li>\n   * </ul>\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan't the gradient attribute\n   * of the Figure to be cleared.\n   */",8,"  public static JPopupButton createEditorColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes) {\n    return createEditorColorButton(editor, attributeKey,\n        swatches, columnCount, labelKey, labels, defaultAttributes,\n        new Rectangle(1, 17, 20, 4));\n"
1261,createToggleGridButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,1536,1560,4,/**\n   * Creates a button which toggles between two GridConstrainer for\n   * a DrawingView.\n   */,21,"  public static AbstractButton createToggleGridButton(final DrawingView view) {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    final JToggleButton toggleButton;\n    toggleButton = new JToggleButton();\n    labels.configureToolBarButton(toggleButton, ""view.toggleGrid"");\n    toggleButton.setFocusable(false);\n    toggleButton.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent event) {\n        view.setConstrainerVisible(toggleButton.isSelected());\n      //view.getComponent().repaint();\n      }\n    });\n    view.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        // String constants are interned\n        if (evt.getPropertyName() == DrawingView.CONSTRAINER_VISIBLE_PROPERTY) {\n          toggleButton.setSelected(view.isConstrainerVisible());\n        }\n      }\n    });\n    return toggleButton;\n"
1262,createSelectionColorButton,ButtonFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ButtonFactory.java,790,860,31,"/**\n   * Creates a color button, with an action region and a popup menu. The\n   * button works like the color button in Adobe Fireworks:\n   * <ul>\n   * <li>When the user clicks at the button a popup menu with a color palette\n   * is displayed.\n   * Choosing a color from the palette changes the default color of the\n   * editor and also changes the color of the selected figures.</li>\n   * <li>A shape on the color button displays the color of the selected\n   * figures. If no figures are selected, the default color of the\n   * DrawingEditor is displayed.</li>\n   * </ul>\n   *\n   * @param editor The DrawingEditor.\n   * @param attributeKey The AttributeKey of the color.\n   * @param swatches A list with labeled colors containing the color palette\n   * of the popup menu. The actual labels are retrieved from the supplied\n   * resource bundle. This is usually a LinkedHashMap, so that the colors have\n   * a predictable order.\n   * @param columnCount The number of columns of the color palette.\n   * @param labelKey The resource bundle key used for retrieving the icon and\n   * the tooltip of the button.\n   * @param labels The resource bundle.\n   * @param defaultAttributes A set of attributes which are also applied to\n   * the selected figures, when a color is selected. This can be used, to\n   * set attributes that otherwise prevent the color from being shown. For\n   * example, when the color attribute is set, we wan\'t the gradient attribute\n   * of the Figure to be cleared.\n   * @param colorShape This shape is superimposed on the icon of the button.\n   * The shape is drawn with the default color of the DrawingEditor.\n   */",68,"  public static JPopupButton createSelectionColorButton(\n      DrawingEditor editor, AttributeKey<Color> attributeKey,\n      java.util.List<ColorIcon> swatches, int columnCount,\n      String labelKey, ResourceBundleUtil labels,\n      Map<AttributeKey, Object> defaultAttributes,\n      Shape colorShape, java.util.List<Disposable> dsp) {\n    final JPopupButton popupButton = new JPopupButton();\n    popupButton.setPopupAlpha(1f);\n    if (defaultAttributes == null) {\n      defaultAttributes = new HashMap<AttributeKey, Object>();\n    }\n    popupButton.setColumnCount(columnCount, false);\n    boolean hasNullColor = false;\n    for (ColorIcon swatch : swatches) {\n      AttributeAction a;\n      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);\n      attributes.put(attributeKey, swatch.getColor());\n      if (swatch.getColor() == null) {\n        hasNullColor = true;\n      }\n      popupButton.add(a =\n          new AttributeAction(\n          editor,\n          attributes,\n          labels.getToolTipTextProperty(labelKey),\n          swatch));\n      a.putValue(Action.SHORT_DESCRIPTION, swatch.getName());\n      a.setUpdateEnabledState(false);\n      dsp.add(a);\n    }\n    // No color\n    if (!hasNullColor) {\n      AttributeAction a;\n      HashMap<AttributeKey, Object> attributes = new HashMap<AttributeKey, Object>(defaultAttributes);\n      attributes.put(attributeKey, null);\n      popupButton.add(a =\n          new AttributeAction(\n          editor,\n          attributes,\n          labels.getToolTipTextProperty(""attribute.color.noColor""),\n          new ColorIcon(null, labels.getToolTipTextProperty(""attribute.color.noColor""))));\n      a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty(""attribute.color.noColor""));\n      a.setUpdateEnabledState(false);\n      dsp.add(a);\n    }\n    // Color chooser\n    ImageIcon chooserIcon = new ImageIcon(\n        Images.createImage(ButtonFactory.class, ""/org/jhotdraw/draw/action/images/attribute.color.colorChooser.png""));\n    AttributeAction a;\n    popupButton.add(\n        a = new SelectionColorChooserAction(\n        editor,\n        attributeKey,\n        labels.getToolTipTextProperty(""attribute.color.colorChooser""),\n        chooserIcon,\n        defaultAttributes));\n    a.putValue(Action.SHORT_DESCRIPTION, labels.getToolTipTextProperty(""attribute.color.colorChooser""));\n    dsp.add(a);\n    labels.configureToolBarButton(popupButton, labelKey);\n    Icon icon = new SelectionColorIcon(editor,\n        attributeKey,\n        labels.getIconProperty(labelKey, ButtonFactory.class).getImage(),\n        colorShape);\n    popupButton.setIcon(icon);\n    popupButton.setDisabledIcon(icon);\n    popupButton.setFocusable(false);\n    dsp.add(new SelectionComponentRepainter(editor, popupButton));\n    return popupButton;\n"
1264,DefaultAttributeAction,DefaultAttributeAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/DefaultAttributeAction.java,38,39,1,/** Creates a new instance. */,2,"  public DefaultAttributeAction(DrawingEditor editor, AttributeKey key) {\n    this(editor, key, null, null);\n"
1265,DefaultAttributeAction,DefaultAttributeAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/DefaultAttributeAction.java,48,49,1,/** Creates a new instance. */,2,"  public DefaultAttributeAction(DrawingEditor editor, AttributeKey key, Icon icon) {\n    this(editor, key, null, icon);\n"
1266,setDrawing,EditCanvasPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java,71,76,5,/**\n   * Sets the GridConstrainer to be edited by this panel.\n   * \n   * @param newValue The GridConstrainer.\n   */,6,"  public void setDrawing(Drawing newValue) {\n    drawing = newValue;\n    // XXX - This does not work, we must pass the drawing editor here!\n    opacitySliderHandler.setDrawing(drawing);\n    opacityFieldHandler.setDrawing(drawing);\n    updatePanel();\n"
1268,updateDrawing,EditCanvasPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java,82,88,3,/**\n   * Updates the drawing due to changes made on this panel.\n   */,7,"  private void updateDrawing() {\n    if (drawing != null) {\n      drawing.willChange();\n      drawing.fireUndoableEditHappened(\n          CANVAS_FILL_COLOR.setUndoable(drawing, colorButton.getBackground())\n          );\n      drawing.changed();\n"
1269,EditCanvasPanel,EditCanvasPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java,44,57,1,/** Creates new form. */,14,"  public EditCanvasPanel() {\n    labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    initComponents();\n    colorButton.putClientProperty(""Quaqua.Button.style"", ""colorWell"");\n    opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);\n    opacityPopupButton.add(opacitySlider);\n    opacityPopupButton.putClientProperty(""JButton.buttonType"", ""toolbar"");\n    add(opacityPopupButton);\n    NumberFormatter nf = new NumberFormatter();\n    nf.setMaximum(1d);\n    nf.setMinimum(0d);\n    opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));\n    opacityFieldHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacityField, null);\n    opacitySliderHandler=new DrawingAttributeEditorHandler<Double>(CANVAS_FILL_OPACITY, opacitySlider, null);\n"
1270,initComponents,EditCanvasPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java,129,165,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,30,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    bgColorButtonGroup = new javax.swing.ButtonGroup();\n    colorLabel = new javax.swing.JLabel();\n    colorButton = new javax.swing.JButton();\n    opacityLabel = new javax.swing.JLabel();\n    opacityField = new org.jhotdraw.gui.JAttributeTextField<Double>();\n    opacityPopupButton = new org.jhotdraw.gui.JPopupButton();\n    setLayout(new java.awt.GridBagLayout());\n    colorLabel.setText(labels.getString(""attribute.canvasFillColor.text"")); // NOI18N\n    colorLabel.setToolTipText(labels.getString(""attribute.backgroundColor.toolTipText"")); // NOI18N\n    add(colorLabel, new java.awt.GridBagConstraints());\n    colorButton.setText("" "");\n    colorButton.setToolTipText(labels.getString(""attribute.backgroundColor.toolTipText"")); // NOI18N\n    colorButton.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        colorButtonPerformed(evt);\n      }\n    });\n    add(colorButton, new java.awt.GridBagConstraints());\n    opacityLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/org/jhotdraw/draw/action/images/attributeOpacity.png""))); // NOI18N\n    opacityLabel.setToolTipText(labels.getString(""attribute.opacity.toolTipText"")); // NOI18N\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);\n    add(opacityLabel, gridBagConstraints);\n    opacityField.setColumns(3);\n    add(opacityField, new java.awt.GridBagConstraints());\n    opacityPopupButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/org/jhotdraw/draw/action/images/popupIcon.png""))); // NOI18N\n    opacityPopupButton.setToolTipText(labels.getString(""attribute.opacity.toolTipText"")); // NOI18N\n    add(opacityPopupButton, new java.awt.GridBagConstraints());\n"
1271,getDrawing,EditCanvasPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java,106,107,5,/**\n   * Returns the GridConstrainer currently being edited by this panel.\n   * \n   * @return The GridConstrainer.\n   */,2,  public Drawing getDrawing() {\n    return drawing;\n
1272,updatePanel,EditCanvasPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditCanvasPanel.java,95,97,3,/**\n   * Updates the panel due to changes made on the drawing.\n   */,3,  private void updatePanel() {\n    if (drawing != null) {\n      colorButton.setBackground(drawing.get(CANVAS_FILL_COLOR));\n
1273,DrawingAttributeAction,DrawingAttributeAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingAttributeAction.java,40,41,1,/** Creates a new instance. */,2,"  public DrawingAttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {\n    this(editor, key, value, null, icon);\n"
1274,DrawingAttributeAction,DrawingAttributeAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingAttributeAction.java,35,36,1,/** Creates a new instance. */,2,"  public DrawingAttributeAction(DrawingEditor editor, AttributeKey key, Object value) {\n    this(editor, key, value, null, null);\n"
1275,ColorIcon,ColorIcon,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ColorIcon.java,36,37,1,/** Creates a new instance. */,2,  public ColorIcon(int rgb) {\n    this(new Color(rgb));\n
1276,DrawingColorChooserAction,DrawingColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java,34,35,1,/** Creates a new instance. */,2,"  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {\n    this(editor, key, null, null);\n"
1277,DrawingColorChooserAction,DrawingColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java,42,43,1,/** Creates a new instance. */,2,"  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, String name) {\n    this(editor, key, name, null);\n"
1278,DrawingColorChooserAction,DrawingColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/DrawingColorChooserAction.java,38,39,1,/** Creates a new instance. */,2,"  public DrawingColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {\n    this(editor, key, null, icon);\n"
1279,initComponents,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,271,273,7,"/** This method is called from within the constructor to\n   * initialize the form.<p>\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.<p>\n   * NOTE: To prevent undesired layout effects when using floating\n   * text fields, the DefaultDrawingView must not use a layout manager.\n   */",2,  private void initComponents() {\n    setLayout(null);\n
1280,toggleSelection,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,833,838,4,/**\n   * If a figure isn't selected it is added to the selection.\n   * Otherwise it is removed from the selection.\n   */,6,  @Override\n  public void toggleSelection(Figure figure) {\n    if (selectedFigures.contains(figure)) {\n      removeFromSelection(figure);\n    } else {\n      addToSelection(figure);\n
1281,getBackgroundPaint,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1547,1561,4,/**\n   * Returns a paint for drawing the background of the drawing area.\n   * @return Paint.\n   */,14,"  protected Paint getBackgroundPaint(\n      int x, int y) {\n    if (backgroundTile == null) {\n      backgroundTile = new BufferedImage(16, 16, BufferedImage.TYPE_INT_RGB);\n      Graphics2D g = backgroundTile.createGraphics();\n      g.setColor(Color.white);\n      g.fillRect(0, 0, 16, 16);\n      g.setColor(new Color(0xdfdfdf));\n      g.fillRect(0, 0, 8, 8);\n      g.fillRect(8, 8, 8, 8);\n      g.dispose();\n    }\n    return new TexturePaint(backgroundTile,\n        new Rectangle(x, y, backgroundTile.getWidth(), backgroundTile.getHeight()));\n"
1282,invalidateHandles,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,931,962,3,/**\n   * Invalidates the handles.\n   */,27,  private void invalidateHandles() {\n    if (handlesAreValid) {\n      handlesAreValid = false;\n      Rectangle invalidatedArea = null;\n      for (Handle handle : selectionHandles) {\n        handle.removeHandleListener(eventHandler);\n        if (invalidatedArea == null) {\n          invalidatedArea = handle.getDrawingArea();\n        } else {\n          invalidatedArea.add(handle.getDrawingArea());\n        }\n        handle.dispose();\n      }\n      for (Handle handle : secondaryHandles) {\n        handle.removeHandleListener(eventHandler);\n        if (invalidatedArea == null) {\n          invalidatedArea = handle.getDrawingArea();\n        } else {\n          invalidatedArea.add(handle.getDrawingArea());\n        }\n        handle.dispose();\n      }\n      selectionHandles.clear();\n      secondaryHandles.clear();\n      setActiveHandle(null);\n      if (invalidatedArea != null) {\n        repaint(invalidatedArea);\n
1284,selectAll,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,852,868,3,/**\n   * Selects all selectable figures.\n   */,13,"  @Override\n  public void selectAll() {\n    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);\n    selectedFigures.clear();\n    for (Figure figure : drawing.getChildren()) {\n      if (figure.isSelectable()) {\n        selectedFigures.add(figure);\n      }\n    }\n    Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);\n    invalidateHandles();\n    fireSelectionChanged(oldSelection, newSelection);\n    repaint();\n"
1285,drawCanvas,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,589,611,4,"/** Draws the canvas. If the {@code AttributeKeys.CANVAS_FILL_OPACITY} is\n   * not fully opaque, the canvas area is filled with the background paint\n   * before the {@code AttributeKeys.CANVAS_FILL_COLOR} is drawn.\n   */",19,"  protected void drawCanvas(Graphics2D g) {\n    Rectangle cb = getCanvasViewBounds();\n    // Retrieve the canvasColor color from the drawing\n    Color canvasColor;\n    if (drawing == null) {\n      canvasColor = CANVAS_FILL_COLOR.getDefaultValue();\n    } else {\n      canvasColor = drawing.get(CANVAS_FILL_COLOR);\n      if (canvasColor != null) {\n        canvasColor = new Color((canvasColor.getRGB() & 0xffffff) | ((int) (drawing.get(CANVAS_FILL_OPACITY) * 255) << 24), true);\n      }\n    }\n    if (canvasColor == null || canvasColor.getAlpha() != 255) {\n      g.setPaint(getBackgroundPaint(cb.x, cb.y));\n      g.fillRect(cb.x, cb.y, cb.width, cb.height);\n    }\n    if (canvasColor != null) {\n      g.setColor(canvasColor);\n      g.fillRect(cb.x, cb.y, cb.width, cb.height);\n"
1286,drawDrawingNonvolatileBuffered,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,435,522,1,/** Draws the drawing double buffered using a buffered image. */,78,"  protected void drawDrawingNonvolatileBuffered(Graphics2D g) {\n    Rectangle vr = getVisibleRect();\n    Point shift = new Point(0, 0);\n    if (bufferedArea.contains(vr) ||\n        bufferedArea.width >= vr.width && bufferedArea.height >= vr.height) {\n      // The visible rect fits into the buffered area, but may be shifted; shift the buffered area.\n      shift.x = bufferedArea.x - vr.x;\n      shift.y = bufferedArea.y - vr.y;\n      if (shift.x > 0) {\n        dirtyArea.add(new Rectangle(bufferedArea.x - shift.x, vr.y, shift.x + bufferedArea.width - vr.width, bufferedArea.height));\n      } else if (shift.x < 0) {\n        dirtyArea.add(new Rectangle(bufferedArea.x + vr.width, vr.y, -shift.x + bufferedArea.width - vr.width, bufferedArea.height));\n      }\n      if (shift.y > 0) {\n        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y - shift.y, bufferedArea.width, shift.y + bufferedArea.height - vr.height));\n      } else if (shift.y < 0) {\n        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y + vr.height, bufferedArea.width, -shift.y + bufferedArea.height - vr.height));\n      }\n      bufferedArea.x = vr.x;\n      bufferedArea.y = vr.y;\n    } else {\n      // The buffered drawing area does not match the visible rect;\n      // resize it, and mark everything as dirty.\n      bufferedArea.setBounds(vr);\n      dirtyArea.setBounds(vr);\n      if (drawingBufferNV != null && //\n          (drawingBufferNV.getWidth() != vr.width ||\n          drawingBufferNV.getHeight() != vr.height)) {\n        // The dimension of the drawing buffer does not fit into the visible rect;\n        // throw the buffer away.\n        drawingBufferNV.flush();\n        drawingBufferNV = null;\n      }\n    }\n    // Update the contents of the buffer if necessary\n    int valid = (drawingBufferNV == null) ? //\n        VolatileImage.IMAGE_INCOMPATIBLE : VolatileImage.IMAGE_OK;\n    switch (valid) {\n      case VolatileImage.IMAGE_INCOMPATIBLE:\n        // old buffer doesn't work with new GraphicsConfig; (re-)create it\n        try {\n          drawingBufferNV = getGraphicsConfiguration().createCompatibleImage(vr.width, vr.height, Transparency.TRANSLUCENT);\n        } catch (OutOfMemoryError e) {\n          drawingBufferNV = null;\n        }\n        dirtyArea.setBounds(bufferedArea);\n        break;\n    }\n    if (drawingBufferNV == null) {\n      // There is not enough memory available for a drawing buffer;\n      // draw without buffering.\n      drawDrawing(g);\n      return;\n    }\n    if (!dirtyArea.isEmpty()) {\n      // An area of the drawing buffer is dirty; repaint it\n      Graphics2D gBuf = drawingBufferNV.createGraphics();\n      setViewRenderingHints(gBuf);\n      // For shifting and cleaning, we need to erase everything underneath\n      gBuf.setComposite(AlphaComposite.Src);\n      // Perform shifting if needed\n      if (shift.x != 0 || shift.y != 0) {\n        gBuf.copyArea(Math.max(0, -shift.x), Math.max(0, -shift.y), drawingBufferNV.getWidth() - Math.abs(shift.x), drawingBufferNV.getHeight() - Math.abs(shift.y), shift.x, shift.y);\n        shift.x = shift.y = 0;\n      }\n      // Clip the dirty area\n      gBuf.translate(-bufferedArea.x, -bufferedArea.y);\n      gBuf.clip(dirtyArea);\n      // Clear the dirty area\n      gBuf.setBackground(new Color(0x0, true));\n      gBuf.clearRect(dirtyArea.x, dirtyArea.y, dirtyArea.width, dirtyArea.height);\n      gBuf.setComposite(AlphaComposite.SrcOver);\n      // Repaint the dirty area\n      drawDrawing(gBuf);\n      gBuf.dispose();\n    }\n    g.drawImage(drawingBufferNV, bufferedArea.x, bufferedArea.y, null);\n    dirtyArea.setSize(-1, -1);\n"
1287,printComponent,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,530,543,5,"/**\n   * Prints the drawing view.\n   * Uses high quality rendering hints for printing. Only prints the drawing.\n   * Doesn't print the canvasColor, the grid, the handles and the tool.\n   */",12,"  @Override\n  public void printComponent(Graphics gr) {\n    Graphics2D g = (Graphics2D) gr;\n    // Set rendering hints for quality\n    g.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);\n    g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n    g.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n    g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n    g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n    g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);\n    g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n    drawDrawing(g);\n"
1288,isDrawingDoubleBuffered,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1539,1540,2,"/** Returns true, if the the drawing is double buffered.\n   */",2,  public boolean isDrawingDoubleBuffered() {\n    return isDrawingDoubleBuffered;\n
1289,viewToDrawing,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1266,1270,3,/**\n   * Converts view coordinates to drawing coordinates.\n   */,5,"  @Override\n  public Point2D.Double viewToDrawing(Point p) {\n    return new Point2D.Double(\n        (p.x + translation.x) / scaleFactor,\n        (p.y + translation.y) / scaleFactor);\n"
1290,addToSelection,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,737,762,3,/**\n   * Adds a figure to the current selection.\n   */,24,"  public void addToSelection(Figure figure) {\n    if (DEBUG) {\n      System.out.println(""DefaultDrawingView"" + "".addToSelection("" + figure + "")"");\n    }\n    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);\n    if (selectedFigures.add(figure)) {\n      figure.addFigureListener(handleInvalidator);\n      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);\n      Rectangle invalidatedArea = null;\n      if (handlesAreValid && getEditor() != null) {\n        for (Handle h : figure.createHandles(detailLevel)) {\n          h.setView(this);\n          selectionHandles.add(h);\n          h.addHandleListener(eventHandler);\n          if (invalidatedArea == null) {\n            invalidatedArea = h.getDrawingArea();\n          } else {\n            invalidatedArea.add(h.getDrawingArea());\n          }\n        }\n      }\n      fireSelectionChanged(oldSelection, newSelection);\n      if (invalidatedArea != null) {\n        repaint(invalidatedArea);\n"
1291,paintComponent,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,309,327,5,"/**\n   * Paints the drawing view.\n   * Uses rendering hints for fast painting. Paints the canvasColor, the\n   * grid, the drawing, the handles and the current tool.\n   */",19,  @Override\n  public void paintComponent(Graphics gr) {\n    long start = System.currentTimeMillis();\n    Graphics2D g = (Graphics2D) gr;\n    setViewRenderingHints(g);\n    drawBackground(g);\n    drawCanvas(g);\n    drawConstrainer(g);\n    if (isDrawingDoubleBuffered()) {\n      if (isWindows) {\n        drawDrawingNonvolatileBuffered(g);\n      } else {\n        drawDrawingVolatileBuffered(g);\n      }\n    } else {\n      drawDrawing(g);\n    }\n    drawHandles(g);\n    drawTool(g);\n
1292,drawBackground,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,135,137,1,/** Draws the background of the drawing view. */,3,"  protected void drawBackground(Graphics2D g) {\n    g.setColor(getBackground());\n    g.fillRect(0, 0, getWidth(), getHeight());\n"
1293,setBounds,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1167,1170,3,/**\n   * Side effect: Changes view Translation.\n   */,4,"  @Override\n  public void setBounds(int x, int y, int width, int height) {\n    super.setBounds(x, y, width, height);\n    validateViewTranslation();\n"
1294,removeFromSelection,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,808,816,3,/**\n   * Removes a figure from the selection.\n   */,8,"  public void removeFromSelection(Figure figure) {\n    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);\n    if (selectedFigures.remove(figure)) {\n      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);\n      invalidateHandles();\n      figure.removeFigureListener(handleInvalidator);\n      fireSelectionChanged(oldSelection, newSelection);\n      repaint();\n"
1295,drawDrawingVolatileBuffered,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,331,429,1,/** Draws the drawing double buffered using a volatile image. */,90,"  protected void drawDrawingVolatileBuffered(Graphics2D g) {\n    Rectangle vr = getVisibleRect();\n    Point shift = new Point(0, 0);\n    if (bufferedArea.contains(vr) ||\n        bufferedArea.width >= vr.width && bufferedArea.height >= vr.height) {\n      // The visible rect fits into the buffered area, but may be shifted; shift the buffered area.\n      shift.x = bufferedArea.x - vr.x;\n      shift.y = bufferedArea.y - vr.y;\n      if (shift.x > 0) {\n        dirtyArea.add(new Rectangle(bufferedArea.x - shift.x, vr.y, shift.x + bufferedArea.width - vr.width, bufferedArea.height));\n      } else if (shift.x < 0) {\n        dirtyArea.add(new Rectangle(bufferedArea.x + vr.width, vr.y, -shift.x + bufferedArea.width - vr.width, bufferedArea.height));\n      }\n      if (shift.y > 0) {\n        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y - shift.y, bufferedArea.width, shift.y + bufferedArea.height - vr.height));\n      } else if (shift.y < 0) {\n        dirtyArea.add(new Rectangle(vr.x, bufferedArea.y + vr.height, bufferedArea.width, -shift.y + bufferedArea.height - vr.height));\n      }\n      bufferedArea.x = vr.x;\n      bufferedArea.y = vr.y;\n    } else {\n      // The buffered drawing area does not match the visible rect;\n      // resize it, and mark everything as dirty.\n      bufferedArea.setBounds(vr);\n      dirtyArea.setBounds(vr);\n      if (drawingBufferV != null && //\n          (drawingBufferV.getWidth() != vr.width ||\n          drawingBufferV.getHeight() != vr.height)) {\n        // The dimension of the drawing buffer does not fit into the visible rect;\n        // throw the buffer away.\n        drawingBufferV.flush();\n        drawingBufferV = null;\n      }\n    }\n    // Update the contents of the buffer if necessary\n    while (true) {\n      int valid = (drawingBufferV == null) ? //\n          VolatileImage.IMAGE_INCOMPATIBLE : //\n          drawingBufferV.validate(getGraphicsConfiguration());\n      switch (valid) {\n        case VolatileImage.IMAGE_INCOMPATIBLE:\n          // old buffer doesn't work with new GraphicsConfig; (re-)create it\n          try {\n            drawingBufferV = getGraphicsConfiguration().createCompatibleVolatileImage(vr.width, vr.height, Transparency.TRANSLUCENT);\n          } catch (OutOfMemoryError e) {\n            drawingBufferV = null;\n          }\n          dirtyArea.setBounds(bufferedArea);\n          break;\n        case VolatileImage.IMAGE_RESTORED:\n          // image was restored, but buffer lost; redraw everything\n          dirtyArea.setBounds(bufferedArea);\n          break;\n      }\n      if (drawingBufferV == null) {\n        // There is not enough memory available for a drawing buffer;\n        // draw without buffering.\n        drawDrawing(g);\n        break;\n      }\n      if (!dirtyArea.isEmpty()) {\n        // An area of the drawing buffer is dirty; repaint it\n        Graphics2D gBuf = drawingBufferV.createGraphics();\n        setViewRenderingHints(gBuf);\n        // For shifting and cleaning, we need to erase everything underneath\n        gBuf.setComposite(AlphaComposite.Src);\n        // Perform shifting if needed\n        if (shift.x != 0 || shift.y != 0) {\n          gBuf.copyArea(Math.max(0, -shift.x), Math.max(0, -shift.y), drawingBufferV.getWidth() - Math.abs(shift.x), drawingBufferV.getHeight() - Math.abs(shift.y), shift.x, shift.y);\n          shift.x = shift.y = 0;\n        }\n        // Clip the dirty area\n        gBuf.translate(-bufferedArea.x, -bufferedArea.y);\n        gBuf.clip(dirtyArea);\n        // Clear the dirty area\n        gBuf.setBackground(new Color(0x0, true));\n        gBuf.clearRect(dirtyArea.x, dirtyArea.y, dirtyArea.width, dirtyArea.height);\n        gBuf.setComposite(AlphaComposite.SrcOver);\n        // Repaint the dirty area\n        drawDrawing(gBuf);\n        gBuf.dispose();\n      }\n      if (!drawingBufferV.contentsLost()) {\n        g.drawImage(drawingBufferV, bufferedArea.x, bufferedArea.y, null);\n      }\n      if (drawingBufferV.contentsLost()) {\n        dirtyArea.setBounds(bufferedArea);\n      } else {\n        dirtyArea.setSize(-1, -1);\n        break;\n"
1296,getCanvasViewBounds,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,562,582,5,/**\n   * Returns the bounds of the canvas on the drawing view.\n   *\n   * @return The current bounds of the canvas on the drawing view.\n   */,17,"  protected Rectangle getCanvasViewBounds() {\n    // Position of the zero coordinate point on the view\n    int x = -translation.x;\n    int y = -translation.y;\n    int w = getWidth();\n    int h = getHeight();\n    if (getDrawing() != null) {\n      Double cw = getDrawing().get(CANVAS_WIDTH);\n      Double ch = getDrawing().get(CANVAS_HEIGHT);\n      if (cw != null && ch != null) {\n        Point lowerRight = drawingToView(\n            new Point2D.Double(cw, ch));\n        w = lowerRight.x - x;\n        h = lowerRight.y - y;\n      }\n    }\n    return new Rectangle(x, y, w, h);\n"
1297,isFigureSelected,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,890,892,3,/**\n   * Test whether a given figure is selected.\n   */,3,  @Override\n  public boolean isFigureSelected(Figure checkFigure) {\n    return selectedFigures.contains(checkFigure);\n
1298,setDrawingDoubleBuffered,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1521,1534,9,"/** Sets whether the drawing is double buffered.\n   * <p>\n   * The default value is true.\n   * <p>\n   * This is a bound property.\n   * <p>\n   * If the drawing view is used for editing, you should leave this to true.\n   * If the drawing view is used for viewing only, you should set this to false.\n   */",13,"  public void setDrawingDoubleBuffered(boolean newValue) {\n    boolean oldValue = isDrawingDoubleBuffered;\n    isDrawingDoubleBuffered =\n        newValue;\n    if (!isDrawingDoubleBuffered && drawingBufferV != null) {\n      drawingBufferV.flush();\n      drawingBufferV = null;\n    }\n    if (!isDrawingDoubleBuffered && drawingBufferNV != null) {\n      drawingBufferNV.flush();\n      drawingBufferNV = null;\n    }\n    firePropertyChange(DRAWING_DOUBLE_BUFFERED_PROPERTY, oldValue, newValue);\n"
1299,getSecondaryHandles,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,923,925,3,/**\n   * Gets the currently active secondary handles.\n   */,3,  private java.util.List<Handle> getSecondaryHandles() {\n    validateHandles();\n    return Collections.unmodifiableList(secondaryHandles);\n
1300,getSelectedFigures,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,899,901,4,"/**\n   * Gets the current selection as a FigureSelection. A FigureSelection\n   * can be cut, copied, pasted.\n   */",3,  @Override\n  public Set<Figure> getSelectedFigures() {\n    return Collections.unmodifiableSet(selectedFigures);\n
1301,findHandle,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1014,1031,4,"/**\n   * Finds a handle at a given coordinates.\n   * @return A handle, null if no handle is found.\n   */",15,  @Override\n  public Handle findHandle(\n      Point p) {\n    validateHandles();\n    for (Handle handle : new ReversedList<Handle>(getSecondaryHandles())) {\n      if (handle.contains(p)) {\n        return handle;\n      }\n    }\n    for (Handle handle : new ReversedList<Handle>(getSelectionHandles())) {\n      if (handle.contains(p)) {\n        return handle;\n      }\n    }\n    return null;\n
1302,addToSelection,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,771,799,3,/**\n   * Adds a collection of figures to the current selection.\n   */,28,"  public void addToSelection(Collection<Figure> figures) {\n    Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);\n    Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);\n    boolean selectionChanged = false;\n    Rectangle invalidatedArea = null;\n    for (Figure figure : figures) {\n      if (selectedFigures.add(figure)) {\n        selectionChanged = true;\n        newSelection.add(figure);\n        figure.addFigureListener(handleInvalidator);\n        if (handlesAreValid && getEditor() != null) {\n          for (Handle h : figure.createHandles(detailLevel)) {\n            h.setView(this);\n            selectionHandles.add(h);\n            h.addHandleListener(eventHandler);\n            if (invalidatedArea == null) {\n              invalidatedArea = h.getDrawingArea();\n            } else {\n              invalidatedArea.add(h.getDrawingArea());\n            }\n          }\n        }\n      }\n    }\n    if (selectionChanged) {\n      fireSelectionChanged(oldSelection, newSelection);\n      if (invalidatedArea != null) {\n        repaint(invalidatedArea);\n"
1303,findFigure,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1062,1065,4,"/**\n   * Finds a figure at a given coordinates.\n   * @return A figure, null if no figure is found.\n   */",4,  @Override\n  public Figure findFigure(\n      Point p) {\n    return getDrawing().findFigure(viewToDrawing(p));\n
1304,drawingToView,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1245,1250,3,/**\n   * Converts drawing coordinates to view coordinates.\n   */,6,"  @Override\n  public Point drawingToView(\n      Point2D.Double p) {\n    return new Point(\n        (int) (p.x * scaleFactor) - translation.x,\n        (int) (p.y * scaleFactor) - translation.y);\n"
1305,clearSelection,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,875,883,3,/**\n   * Clears the current selection.\n   */,8,"  @Override\n  public void clearSelection() {\n    if (getSelectionCount() > 0) {\n      Set<Figure> oldSelection = new HashSet<Figure>(selectedFigures);\n      selectedFigures.clear();\n      Set<Figure> newSelection = new HashSet<Figure>(selectedFigures);\n      invalidateHandles();\n      fireSelectionChanged(oldSelection, newSelection);\n"
1306,validateViewTranslation,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1177,1238,4,"/**\n   * Updates the view translation taking into account the current dimension\n   * of the view JComponent, the size of the drawing, and the scale factor.\n   */",52,"  private void validateViewTranslation() {\n    if (getDrawing() == null) {\n      translation.x = translation.y = 0;\n      return;\n    }\n    Point oldTranslation = (Point) translation.clone();\n    int width = getWidth();\n    int height = getHeight();\n    Insets insets = getInsets();\n    Rectangle2D.Double da = getDrawingArea();\n    Rectangle r = new Rectangle((int) (da.x * scaleFactor), (int) (da.y * scaleFactor), (int) (da.width * scaleFactor), (int) (da.height * scaleFactor));\n    int cw, ch;\n    Double cwd = getDrawing().get(CANVAS_WIDTH);\n    Double chd = getDrawing().get(CANVAS_HEIGHT);\n    if (cwd == null || chd == null) {\n      // The canvas size is not explicitly specified.\n      cw = Math.max(width - insets.left - insets.right, (int) ((Math.max(0, da.x) + da.width) * scaleFactor));\n      ch = Math.max(height - insets.top - insets.bottom, (int) ((Math.max(0, da.y) + da.height) * scaleFactor));\n      //Place the canvas at the top left\n      translation.x = insets.top;\n      translation.y = insets.left;\n    } else {\n      // The canvas size is explicitly specified.\n      cw = (int) (cwd * scaleFactor);\n      ch = (int) (chd * scaleFactor);\n      //Place the canvas at the center\n      if (cw < width) {\n        translation.x = insets.left + (width - insets.left - insets.right - cw) / -2;\n      }\n      if (ch < height) {\n        translation.y = insets.top + (height - insets.top - insets.bottom - ch) / -2;\n      }\n    }\n    if (r.y + r.height - translation.y > (height - insets.bottom)) {\n      // We cut off the lower part of the drawing -> shift the canvas up\n      translation.y = r.y + r.height - (height - insets.bottom);\n    }\n    if (Math.min(0, r.y) - translation.y < insets.top) {\n      // We cut off the upper part of the drawing -> shift the canvas down\n      translation.y = Math.min(0, r.y) - insets.top;\n    }\n    if (r.x + r.width - translation.x > (width - insets.right)) {\n      // We cut off the right part of the drawing -> shift the canvas left\n      translation.x = r.x + r.width - (width - insets.right);\n    }\n    if (Math.min(0, r.x) - translation.x < insets.left) {\n      // We cut off the left part of the drawing -> shift the canvas right\n      translation.x = Math.min(0, r.x) - insets.left;\n    }\n    if (!oldTranslation.equals(translation)) {\n      bufferedArea.translate(oldTranslation.x - translation.x, oldTranslation.y - translation.y);\n      fireViewTransformChanged();\n"
1307,fireSelectionChanged,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1094,1118,6,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   * Also notify listeners who listen for\n   * {@link EditableComponent#SELECTION_EMPTY_PROPERTY}.\n   */,23,"  protected void fireSelectionChanged(\n      Set<Figure> oldValue,\n      Set<Figure> newValue) {\n    if (listenerList.getListenerCount() > 0) {\n      FigureSelectionEvent event = null;\n      // Notify all listeners that have registered interest for\n      // Guaranteed to return a non-null array\n      Object[] listeners = listenerList.getListenerList();\n      // Process the listeners last to first, notifying\n      // those that are interested in this event\n      for (int i = listeners.length - 2; i >=\n          0; i -=\n              2) {\n        if (listeners[i] == FigureSelectionListener.class) {\n          // Lazily create the event:\n          if (event == null) {\n            event = new FigureSelectionEvent(this, oldValue, newValue);\n          }\n          ((FigureSelectionListener) listeners[i + 1]).selectionChanged(event);\n        }\n      }\n    }\n    firePropertyChange(EditableComponent.SELECTION_EMPTY_PROPERTY, oldValue.isEmpty(), newValue.isEmpty());\n"
1308,getSelectionCount,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,907,909,3,/**\n   * Gets the number of selected figures.\n   */,3,  @Override\n  public int getSelectionCount() {\n    return selectedFigures.size();\n
1309,DefaultDrawingView,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,240,249,1,/** Creates new instance. */,9,"  public DefaultDrawingView() {\n    initComponents();\n    eventHandler = createEventHandler();\n    setToolTipText(""dummy""); // Set a dummy tool tip text to turn tooltips on\n    setFocusable(true);\n    addFocusListener(eventHandler);\n    setTransferHandler(new DefaultDrawingViewTransferHandler());\n    setBackground(new Color(0xb0b0b0));\n    setOpaque(true);\n"
1310,getCompatibleHandles,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,1038,1054,4,/**\n   * Gets compatible handles.\n   * @return A collection containing the handle and all compatible handles.\n   */,14,  @Override\n  public Collection<Handle> getCompatibleHandles(Handle master) {\n    validateHandles();\n    HashSet<Figure> owners = new HashSet<Figure>();\n    LinkedList<Handle> compatibleHandles = new LinkedList<Handle>();\n    owners.add(master.getOwner());\n    compatibleHandles.add(master);\n    for (Handle handle : getSelectionHandles()) {\n      if (!owners.contains(handle.getOwner()) && handle.isCombinableWith(master)) {\n        owners.add(handle.getOwner());\n        compatibleHandles.add(handle);\n      }\n    }\n    return compatibleHandles;\n
1311,getSelectionHandles,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,915,917,3,/**\n   * Gets the currently active selection handles.\n   */,3,  private java.util.List<Handle> getSelectionHandles() {\n    validateHandles();\n    return Collections.unmodifiableList(selectionHandles);\n
1312,validateHandles,DefaultDrawingView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingView.java,971,1003,3,/**\n   * Validates the handles.\n   */,30,"  private void validateHandles() {\n    // Validate handles only, if they are invalid, and if\n    // the DrawingView has a DrawingEditor.\n    if (!handlesAreValid && getEditor() != null) {\n      handlesAreValid = true;\n      selectionHandles.clear();\n      Rectangle invalidatedArea = null;\n      while (true) {\n        for (Figure figure : getSelectedFigures()) {\n          for (Handle handle : figure.createHandles(detailLevel)) {\n            handle.setView(this);\n            selectionHandles.add(handle);\n            handle.addHandleListener(eventHandler);\n            if (invalidatedArea == null) {\n              invalidatedArea = handle.getDrawingArea();\n            } else {\n              invalidatedArea.add(handle.getDrawingArea());\n            }\n          }\n        }\n        if (selectionHandles.size() == 0 && detailLevel != 0) {\n          // No handles are available at the desired detail level.\n          // Retry with detail level 0.\n          detailLevel = 0;\n          continue;\n        }\n        break;\n      }\n      if (invalidatedArea != null) {\n        repaint(invalidatedArea);\n"
1365,importData,DefaultDrawingViewTransferHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewTransferHandler.java,74,295,1,/** Imports data and stores the transferred figures into the supplied transferFigures collection. */,204,"  @SuppressWarnings(""unchecked"")\n  protected boolean importData(final JComponent comp, Transferable t, final HashSet<Figure> transferFigures, final Point dropPoint) {\n    if (DEBUG) {\n      System.out.println(""DefaultDrawingViewTransferHandler.importData(comp,t)"");\n    }\n    boolean retValue;\n    if (comp instanceof DrawingView) {\n      final DrawingView view = (DrawingView) comp;\n      final Drawing drawing = view.getDrawing();\n      if (drawing.getInputFormats() == null ||\n          drawing.getInputFormats().size() == 0) {\n        if (DEBUG) {\n          System.out.println(""DefaultDrawingViewTransferHandler  import failed; drawing has no import formats"");\n        }\n        retValue = false;\n      } else {\n        retValue = false;\n        try {\n          DataFlavor[] transferFlavors = t.getTransferDataFlavors();\n          // Workaround for Mac OS X:\n          // The Apple JVM messes up the sequence of the data flavors.\n          if (System.getProperty(""os.name"").toLowerCase().startsWith(""mac"")) {\n            // Search for a suitable input format\n            SearchLoop:\n            for (InputFormat format : drawing.getInputFormats()) {\n              if (DEBUG) {\n                System.out.println(""DefaultDrawingViewTransferHandler  trying format:"" + format);\n              }\n              for (DataFlavor flavor : transferFlavors) {\n                if (DEBUG) {\n                  System.out.println(""DefaultDrawingViewTransferHandler  trying flavor:"" + flavor.getMimeType());\n                }\n                if (format.isDataFlavorSupported(flavor)) {\n                  LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());\n                  try {\n                    format.read(t, drawing, false);\n                    if (DEBUG) {\n                      System.out.println(""DefaultDrawingViewTransferHandler  import succeeded"");\n                    }\n                    final LinkedList<Figure> importedFigures = new LinkedList<Figure>(drawing.getChildren());\n                    importedFigures.removeAll(existingFigures);\n                    view.clearSelection();\n                    view.addToSelection(importedFigures);\n                    transferFigures.addAll(importedFigures);\n                    moveToDropPoint(comp, transferFigures, dropPoint);\n                    drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {\n                      @Override\n                      public String getPresentationName() {\n                        ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n                        return labels.getString(""edit.paste.text"");\n                      }\n                      @Override\n                      public void undo() throws CannotUndoException {\n                        super.undo();\n                        drawing.removeAll(importedFigures);\n                      }\n                      @Override\n                      public void redo() throws CannotRedoException {\n                        super.redo();\n                        drawing.addAll(importedFigures);\n                      }\n                    });\n                    retValue = true;\n                    break SearchLoop;\n                  } catch (IOException e) {\n                    if (DEBUG) {\n                      System.out.println(""  import failed"");\n                      e.printStackTrace();\n                    }\n                    // failed to read transferalbe, try with next InputFormat\n                  }\n                }\n              }\n            }\n          } else {\n            // Search for a suitable input format\n            SearchLoop:\n            for (DataFlavor flavor : transferFlavors) {\n              if (DEBUG) {\n                System.out.println(""DefaultDrawingViewTransferHandler  trying flavor:"" + flavor.getMimeType());\n              }\n              for (InputFormat format : drawing.getInputFormats()) {\n                if (format.isDataFlavorSupported(flavor)) {\n                  if (DEBUG) {\n                    System.out.println(""DefaultDrawingViewTransferHandler  trying format:"" + format);\n                  }\n                  LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());\n                  try {\n                    format.read(t, drawing, false);\n                    if (DEBUG) {\n                      System.out.println(""DefaultDrawingViewTransferHandler  import succeeded"");\n                    }\n                    final LinkedList<Figure> importedFigures = new LinkedList<Figure>(drawing.getChildren());\n                    importedFigures.removeAll(existingFigures);\n                    view.clearSelection();\n                    view.addToSelection(importedFigures);\n                    transferFigures.addAll(importedFigures);\n                    moveToDropPoint(comp, transferFigures, dropPoint);\n                    drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {\n                      @Override\n                      public String getPresentationName() {\n                        ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n                        return labels.getString(""edit.paste.text"");\n                      }\n                      @Override\n                      public void undo() throws CannotUndoException {\n                        super.undo();\n                        drawing.removeAll(importedFigures);\n                      }\n                      @Override\n                      public void redo() throws CannotRedoException {\n                        super.redo();\n                        drawing.addAll(importedFigures);\n                      }\n                    });\n                    retValue = true;\n                    break SearchLoop;\n                  } catch (IOException e) {\n                    if (DEBUG) {\n                      System.out.println(""  import failed"");\n                      e.printStackTrace();\n                    }\n                    // failed to read transferalbe, try with next InputFormat\n                  }\n                }\n              }\n            }\n          }\n          // No input format found? Lets see if we got files - we\n          // can handle these\n          if (retValue == false && t.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {\n            final java.util.List<File> files = (java.util.List<File>) t.getTransferData(DataFlavor.javaFileListFlavor);\n            retValue = true;\n            final LinkedList<Figure> existingFigures = new LinkedList<Figure>(drawing.getChildren());\n            view.getEditor().setEnabled(false);\n            // FIXME - We should perform the following code in a\n            // worker thread.\n            new Worker<LinkedList<Figure>>() {\n              @Override\n              public LinkedList<Figure> construct() throws Exception {\n                for (File file : files) {\n                  FileFormatLoop:\n                  for (InputFormat format : drawing.getInputFormats()) {\n                    if (file.isFile() &&\n                        format.getFileFilter().accept(file)) {\n                      if (DEBUG) {\n                        System.out.println(""DefaultDrawingViewTransferHandler  importing file "" + file);\n                      }\n                      format.read(file, drawing, false);\n                    }\n                  }\n                }\n                return new LinkedList<Figure>(drawing.getChildren());\n              }\n              @Override\n              public void failed(Throwable error) {\n                error.printStackTrace();\n              }\n              @Override\n              public void done(final LinkedList<Figure> importedFigures) {\n                importedFigures.removeAll(existingFigures);\n                if (importedFigures.size() > 0) {\n                  view.clearSelection();\n                  view.addToSelection(importedFigures);\n                  transferFigures.addAll(importedFigures);\n                  moveToDropPoint(comp, transferFigures, dropPoint);\n                  drawing.fireUndoableEditHappened(new AbstractUndoableEdit() {\n                    @Override\n                    public String getPresentationName() {\n                      ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n                      return labels.getString(""edit.paste.text"");\n                    }\n                    @Override\n                    public void undo() throws CannotUndoException {\n                      super.undo();\n                      drawing.removeAll(importedFigures);\n                    }\n                    @Override\n                    public void redo() throws CannotRedoException {\n                      super.redo();\n                      drawing.addAll(importedFigures);\n                    }\n                  });\n                }\n              }\n              @Override\n              public void finished() {\n                view.getEditor().setEnabled(true);\n              }\n            }.start();\n          }\n        } catch (Throwable e) {\n          if (DEBUG) {\n            e.printStackTrace();\n          }\n        }\n      }\n    } else {\n      retValue = super.importData(comp, t);\n    }\n    if (DEBUG) {\n      System.out.println(""DefaultDrawingViewTransferHandler .importData(comp,t):"" + retValue);\n    }\n    return retValue;\n"
1367,dragGestureRecognized,DragHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DefaultDrawingViewTransferHandler.java,629,655,3,/**\n     * a Drag gesture has been recognized\n     */,26,"    public void dragGestureRecognized(DragGestureEvent dge) {\n      JComponent c = (JComponent) dge.getComponent();\n      DefaultDrawingViewTransferHandler th = (DefaultDrawingViewTransferHandler) c.getTransferHandler();\n      Transferable t = transferable;\n      if (t != null) {\n        scrolls = c.getAutoscrolls();\n        c.setAutoscrolls(false);\n        try {\n//          dge.startDrag(null, t, this);\n          Icon icon = th.getVisualRepresentation(t);\n          Image dragImage;\n          if (icon instanceof ImageIcon) {\n            dragImage = ((ImageIcon) icon).getImage();\n          } else {\n            dragImage = new BufferedImage(icon.getIconWidth(), icon.getIconHeight(), BufferedImage.TYPE_INT_ARGB);\n            Graphics g = ((BufferedImage) dragImage).createGraphics();\n            icon.paintIcon(c, g, 0, 0);\n            g.dispose();\n          }\n          dge.startDrag(null, dragImage, imageOffset, t, this);\n          return;\n        } catch (RuntimeException re) {\n          c.setAutoscrolls(scrolls);\n        }\n      }\n      th.exportDone(c, t, NONE);\n"
1372,findConnector,DiamondFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java,245,246,5,/**\n   * Returns the Figures connector for the specified location.\n   * By default a ChopDiamondConnector is returned.\n   * @see ChopDiamondConnector\n   */,2,"  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {\n    return new ChopDiamondConnector(this);\n"
1374,DiamondFigure,DiamondFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java,46,47,1,/** Creates a new instance. */,2,"  public DiamondFigure() {\n    this(0, 0, 0, 0);\n"
1375,transform,DiamondFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java,217,222,4,/**\n   * Moves the Figure to a new location.\n   * @param tx the transformation matrix.\n   */,6,"  public void transform(AffineTransform tx) {\n    Point2D.Double anchor = getStartPoint();\n    Point2D.Double lead = getEndPoint();\n    setBounds(\n        (Point2D.Double) tx.transform(anchor, anchor),\n        (Point2D.Double) tx.transform(lead, lead));\n"
1376,contains,DiamondFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/DiamondFigure.java,169,203,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,31,"  public boolean contains(Point2D.Double p) {\n    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();\n    if (get(IS_QUADRATIC)) {\n      double side = Math.max(r.width, r.height);\n      r.x -= (side - r.width) / 2;\n      r.y -= (side - r.height) / 2;\n      r.width = r.height = side;\n    }\n    //   if (r.contains(p)) {\n    double grow = AttributeKeys.getPerpendicularFillGrowth(this);\n    double growx, growy;\n    if (grow == 0d) {\n      growx = growy = 0d;\n    } else {\n      double w = r.width / 2d;\n      double h = r.height / 2d;\n      double lineLength = Math.sqrt(w * w + h * h);\n      double scale = grow / lineLength;\n      double yb = scale * w;\n      double xa = scale * h;\n      growx = ((yb * yb) / xa + xa);\n      growy = ((xa * xa) / yb + yb);\n      Geom.grow(r, growx, growy);\n    }\n    Path2D.Double diamond = new Path2D.Double();\n    diamond.moveTo((r.x + r.width / 2), r.y);\n    diamond.lineTo((r.x + r.width), (r.y + r.height / 2));\n    diamond.lineTo((r.x + r.width / 2), (r.y + r.height));\n    diamond.lineTo(r.x, (r.y + r.height / 2));\n    diamond.closePath();\n    return diamond.contains(p);\n"
1377,ToolBarLayout,ToolBarLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/ToolBarLayout.java,46,47,4,/**\n   * Creates a layout manager that will lay out components along the\n   * X-axis.  \n   */,2,  public ToolBarLayout() {\n    this(X_AXIS);\n
1378,AbstractTransferable,AbstractTransferable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AbstractTransferable.java,29,30,1,/** Creates a new instance. */,2,  public AbstractTransferable(DataFlavor flavor) {\n    this.flavors = new DataFlavor[] {flavor};\n
1379,getDefaultPropertyIndex,JLifeFormattedTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java,131,132,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1381,getBeanDescriptor,JLifeFormattedTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java,81,82,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1382,getPropertyDescriptors,JLifeFormattedTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java,97,98,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1385,getMethodDescriptors,JLifeFormattedTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java,119,120,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1386,getDefaultEventIndex,JLifeFormattedTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java,142,143,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1387,getEventSetDescriptors,JLifeFormattedTextFieldBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextFieldBeanInfo.java,108,109,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1388,getColumns,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,135,136,5,/**\n   * Gets the number of columns in this layout.\n   * @return   the number of columns in this layout\n   * @since    JDK1.1\n   */,2,  public int getColumns() {\n    return cols;\n
1389,VerticalGridLayout,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,89,97,24,"/**\n   * Creates a grid layout with the specified number of rows and\n   * columns. All components in the layout are given equal size.\n   * <p>\n   * In addition, the horizontal and vertical gaps are set to the\n   * specified values. Horizontal gaps are placed at the left and\n   * right edges, and between each of the columns. Vertical gaps are\n   * placed at the top and bottom edges, and between each of the rows.\n   * <p>\n   * One, but not both, of <code>rows</code> and <code>cols</code> can\n   * be zero, which means that any number of objects can be placed in a\n   * row or in a column.\n   * <p>\n   * All <code>VerticalGridLayout</code> constructors defer to this one.\n   * @param   rows   the rows, with the value zero meaning\n   *           any number of rows\n   * @param   cols   the columns, with the value zero meaning\n   *           any number of columns\n   * @param   hgap   the horizontal gap\n   * @param   vgap   the vertical gap\n   * @exception   IllegalArgumentException  if the value of both\n   *      <code>rows</code> and <code>cols</code> is\n   *      set to zero\n   */",9,"  public VerticalGridLayout(int rows, int cols, int hgap, int vgap, boolean isVertical) {\n    if ((rows == 0) && (cols == 0)) {\n      throw new IllegalArgumentException(""rows and cols cannot both be zero"");\n    }\n    this.rows = rows;\n    this.cols = cols;\n    this.hgap = hgap;\n    this.vgap = vgap;\n    this.isVertical = isVertical;\n"
1390,setRows,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,116,120,7,/**\n   * Sets the number of rows in this layout to the specified value.\n   * @param    rows   the number of rows in this layout\n   * @exception  IllegalArgumentException  if the value of both\n   *         <code>rows</code> and <code>cols</code> is set to zero\n   * @since    JDK1.1\n   */,5,"  public void setRows(int rows) {\n    if ((rows == 0) && (this.cols == 0)) {\n      throw new IllegalArgumentException(""rows and cols cannot both be zero"");\n    }\n    this.rows = rows;\n"
1391,minimumLayoutSize,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,274,299,18,"/**\n   * Determines the minimum size of the container argument using this\n   * grid layout.\n   * <p>\n   * The minimum width of a grid layout is the largest minimum width\n   * of any of the components in the container times the number of columns,\n   * plus the horizontal padding times the number of columns plus one,\n   * plus the left and right insets of the target container.\n   * <p>\n   * The minimum height of a grid layout is the largest minimum height\n   * of any of the components in the container times the number of rows,\n   * plus the vertical padding times the number of rows plus one, plus\n   * the top and bottom insets of the target container.\n   *\n   * @param     parent   the container in which to do the layout\n   * @return    the minimum dimensions needed to lay out the\n   *            subcomponents of the specified container\n   */",26,"  public Dimension minimumLayoutSize(Container parent) {\n    synchronized (parent.getTreeLock()) {\n      Insets insets = parent.getInsets();\n      int ncomponents = parent.getComponentCount();\n      int nrows = rows;\n      int ncols = cols;\n      \n      if (nrows > 0) {\n        ncols = (ncomponents + nrows - 1) / nrows;\n      } else {\n        nrows = (ncomponents + ncols - 1) / ncols;\n      }\n      int w = 0;\n      int h = 0;\n      for (int i = 0 ; i < ncomponents ; i++) {\n        Component comp = parent.getComponent(i);\n        Dimension d = comp.getMinimumSize();\n        if (w < d.width) {\n          w = d.width;\n        }\n        if (h < d.height) {\n          h = d.height;\n        }\n      }\n      return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,\n      insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);\n"
1393,getRows,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,105,106,5,/**\n   * Gets the number of rows in this layout.\n   * @return  the number of rows in this layout\n   * @since   JDK1.1\n   */,2,  public int getRows() {\n    return rows;\n
1394,setColumns,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,151,155,12,"/**\n   * Sets the number of columns in this layout to the specified value.\n   * Setting the number of columns has no affect on the layout\n   * if the number of rows specified by a constructor or by\n   * the <tt>setRows</tt> method is non-zero. In that case, the number\n   * of columns displayed in the layout is determined by the total\n   * number of components and the number of rows specified.\n   * @param    cols   the number of columns in this layout\n   * @exception  IllegalArgumentException  if the value of both\n   *         <code>rows</code> and <code>cols</code> is set to zero\n   * @since    JDK1.1\n   */",5,"  public void setColumns(int cols) {\n    if ((cols == 0) && (this.rows == 0)) {\n      throw new IllegalArgumentException(""rows and cols cannot both be zero"");\n    }\n    this.cols = cols;\n"
1395,setVgap,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,190,191,5,/**\n   * Sets the vertical gap between components to the specified value.\n   * @param     vgap  the vertical gap between components\n   * @since    JDK1.1\n   */,2,  public void setVgap(int vgap) {\n    this.vgap = vgap;\n
1396,VerticalGridLayout,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,39,40,4,"/**\n   * Creates a grid layout with a default of one column per component,\n   * in a single row.\n   */",2,"  public VerticalGridLayout() {\n    this(1, 0, 0, 0);\n"
1397,getHgap,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,163,164,5,/**\n   * Gets the horizontal gap between components.\n   * @return     the horizontal gap between components\n   * @since    JDK1.1\n   */,2,  public int getHgap() {\n    return hgap;\n
1398,getVgap,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,181,182,5,/**\n   * Gets the vertical gap between components.\n   * @return     the vertical gap between components\n   * @since    JDK1.1\n   */,2,  public int getVgap() {\n    return vgap;\n
1400,layoutContainer,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,321,365,18,/**\n   * Lays out the specified container using this layout.\n   * <p>\n   * This method reshapes the components in the specified target\n   * container in order to satisfy the constraints of the\n   * <code>VerticalGridLayout</code> object.\n   * <p>\n   * The grid layout manager determines the size of individual\n   * components by dividing the free space in the container into\n   * equal-sized portions according to the number of rows and columns\n   * in the layout. The container's free space equals the container's\n   * size minus any insets and any specified horizontal or vertical\n   * gap. All components in a grid layout are given the same size.\n   *\n   * @param    parent   the container in which to do the layout\n   * @see    java.awt.Container\n   * @see    java.awt.Container#doLayout\n   */,45,"  public void layoutContainer(Container parent) {\n    synchronized (parent.getTreeLock()) {\n      Insets insets = parent.getInsets();\n      int ncomponents = parent.getComponentCount();\n      int nrows = rows;\n      int ncols = cols;\n      boolean ltr = parent.getComponentOrientation().isLeftToRight();\n      \n      if (ncomponents == 0) {\n        return;\n      }\n      if (nrows > 0) {\n        ncols = (ncomponents + nrows - 1) / nrows;\n      } else {\n        nrows = (ncomponents + ncols - 1) / ncols;\n      }\n      int w = parent.getWidth() - (insets.left + insets.right);\n      int h = parent.getHeight() - (insets.top + insets.bottom);\n      w = (w - (ncols - 1) * hgap) / ncols;\n      h = (h - (nrows - 1) * vgap) / nrows;\n      \n      int i;\n      if (ltr) {\n        for (int c = 0, x = insets.left ; c < ncols ; c++, x += w + hgap) {\n          for (int r = 0, y = insets.top ; r < nrows ; r++, y += h + vgap) {\n            if (isVertical) {\n              i = r + c * nrows;\n            } else {\n              i = r * ncols + c;\n            }\n            if (i < ncomponents) {\n              parent.getComponent(i).setBounds(x, y, w, h);\n            }\n          }\n        }\n      } else {\n        for (int c = 0, x = parent.getWidth() - insets.right - w; c < ncols ; c++, x -= w + hgap) {\n          for (int r = 0, y = insets.top ; r < nrows ; r++, y += h + vgap) {\n            if (isVertical) {\n              i = r + c * nrows;\n            } else {\n              i = r * ncols + c;\n            }\n            if (i < ncomponents) {\n              parent.getComponent(i).setBounds(x, y, w, h);\n"
1401,setHgap,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,172,173,5,/**\n   * Sets the horizontal gap between components to the specified value.\n   * @param    hgap   the horizontal gap between components\n   * @since    JDK1.1\n   */,2,  public void setHgap(int hgap) {\n    this.hgap = hgap;\n
1402,VerticalGridLayout,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,55,56,12,"/**\n   * Creates a grid layout with the specified number of rows and\n   * columns. All components in the layout are given equal size.\n   * <p>\n   * One, but not both, of <code>rows</code> and <code>cols</code> can\n   * be zero, which means that any number of objects can be placed in a\n   * row or in a column.\n   * @param   rows   the rows, with the value zero meaning\n   *           any number of rows.\n   * @param   cols   the columns, with the value zero meaning\n   *           any number of columns.\n   */",2,"  public VerticalGridLayout(int rows, int cols) {\n    this(rows, cols, 0, 0);\n"
1403,preferredLayoutSize,VerticalGridLayout,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/VerticalGridLayout.java,227,252,18,"/**\n   * Determines the preferred size of the container argument using\n   * this grid layout.\n   * <p>\n   * The preferred width of a grid layout is the largest preferred\n   * width of any of the components in the container times the number of\n   * columns, plus the horizontal padding times the number of columns\n   * plus one, plus the left and right insets of the target container.\n   * <p>\n   * The preferred height of a grid layout is the largest preferred\n   * height of any of the components in the container times the number of\n   * rows, plus the vertical padding times the number of rows plus one,\n   * plus the top and bottom insets of the target container.\n   *\n   * @param   parent   the container in which to do the layout\n   * @return  the preferred dimensions to lay out the\n   *            subcomponents of the specified container\n   */",26,"  public Dimension preferredLayoutSize(Container parent) {\n    synchronized (parent.getTreeLock()) {\n      Insets insets = parent.getInsets();\n      int ncomponents = parent.getComponentCount();\n      int nrows = rows;\n      int ncols = cols;\n      \n      if (nrows > 0) {\n        ncols = (ncomponents + nrows - 1) / nrows;\n      } else {\n        nrows = (ncomponents + ncols - 1) / ncols;\n      }\n      int w = 0;\n      int h = 0;\n      for (int i = 0 ; i < ncomponents ; i++) {\n        Component comp = parent.getComponent(i);\n        Dimension d = comp.getPreferredSize();\n        if (w < d.width) {\n          w = d.width;\n        }\n        if (h < d.height) {\n          h = d.height;\n        }\n      }\n      return new Dimension(insets.left + insets.right + ncols*w + (ncols-1)*hgap,\n      insets.top + insets.bottom + nrows*h + (nrows-1)*vgap);\n"
1404,getClipboard,ClipboardUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/ClipboardUtil.java,36,59,6,"/** Returns the ClipboardService instance. If none is set, creates\n   * a new one which tries to access the system clipboard. If this fails,\n   * an instance with a JVM local clipboard is created.\n   *\n   * @return system clipboard or a proxy.\n   */",20,"  @SuppressWarnings(""unchecked"")\n  public static Clipboard getClipboard() {\n    if (instance != null) {\n      return instance;\n    }\n    // Try to access the system clipboard\n    try {\n//      instance = new AWTClipboard(Toolkit.getDefaultToolkit().getSystemClipboard());\n      instance = new OSXClipboard(Toolkit.getDefaultToolkit().getSystemClipboard());\n    } catch (SecurityException e1) {\n      // Fall back to JNLP ClipboardService\n      try {\n        Class serviceManager = Class.forName(""javax.jnlp.ServiceManager"");\n        instance = new JNLPClipboard(serviceManager.getMethod(""lookup"", String.class).invoke(null, ""javax.jnlp.ClipboardService""));\n      } catch (Exception e2) {\n        // Fall back to JVM local clipboard\n        instance = new AWTClipboard(new Clipboard(""JVM Local Clipboard""));\n      }\n    }\n    return instance;\n"
1422,getTarget,AWTClipboard,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AWTClipboard.java,50,51,1,/** Returns the proxy target. */,2,  public Clipboard getTarget() {\n    return target;\n
1423,AWTClipboard,AWTClipboard,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/AWTClipboard.java,45,46,5,/**\n   * Creates a new proxy for the specified target object.\n   *\n   * @param target A Clipboard object.\n   */,2,  public AWTClipboard(Clipboard target) {\n    this.target = target;\n
1425,setError,Worker,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java,127,128,3,/**\n   * Set the error thrown by constrct.\n   */,2,  private synchronized void setError(Throwable x) {\n    error = x;\n
1426,getError,Worker,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java,120,121,4,"/**\n   * Get the error produced by the worker thread, or null if it\n   * hasn't thrown one.\n   */",2,  protected synchronized Throwable getError() {\n    return error;\n
1428,run,Worker,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java,36,54,4,/**\n   * Calls #construct on the current thread and invokes\n   * #done on the AWT event dispatcher thread.\n   */,17,  public final void run() {\n    try {\n      setValue(construct());\n    } catch (Throwable e) {\n      setError(e);\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          failed(getError());\n          finished();\n        }\n      });\n      return;\n    }\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        done(getValue());\n        finished();\n
1429,getValue,Worker,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java,105,106,4,"/**\n   * Get the value produced by the worker thread, or null if it\n   * hasn't been constructed yet.\n   */",2,  protected synchronized T getValue() {\n    return value;\n
1430,failed,Worker,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java,86,87,9,/**\n   * Called on the event dispatching thread (not on the worker thread)\n   * after the <code>construct</code> method has thrown an error.\n   * <p>\n   * The default implementation prints a stack trace. Subclasses may override\n   * this method to perform failure actions on the Event Dispatch Thread.\n   *\n   * @param error The error thrown by construct.\n   */,2,  protected void failed(Throwable error) {\n    error.printStackTrace();\n
1432,setValue,Worker,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/Worker.java,112,113,3,/**\n   * Set the value produced by construct.\n   */,2,  private synchronized void setValue(T x) {\n    value = x;\n
1433,getTransferData,CompositeTransferable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/CompositeTransferable.java,53,56,11,/**\n   * Returns an object which represents the data to be transferred.  The class\n   * of the object returned is defined by the representation class of the flavor.\n   *\n   * @param flavor the requested flavor for the data\n   * @see DataFlavor#getRepresentationClass\n   * @exception IOException        if the data is no longer available\n   *       in the requested flavor.\n   * @exception UnsupportedFlavorException if the requested data flavor is\n   *       not supported.\n   */,4,"  public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {\n    Transferable t = (Transferable) transferables.get(flavor);\n    if (t == null) throw new UnsupportedFlavorException(flavor);\n    return t.getTransferData(flavor);\n"
1435,getTransferDataFlavors,CompositeTransferable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/CompositeTransferable.java,65,66,6,/**\n   * Returns an array of DataFlavor objects indicating the flavors the data\n   * can be provided in.  The array should be ordered according to preference\n   * for providing the data (from most richly descriptive to least descriptive).\n   * @return an array of data flavors in which this data can be transferred\n   */,2,  public DataFlavor[] getTransferDataFlavors() {\n    return (DataFlavor[]) flavors.toArray(new DataFlavor[transferables.size()]);\n
1437,fireOptionSelected,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,530,542,6,/**\n   * Notify all listeners that have registered interest for\n   *   notification on this event type.  The event instance\n   *   is lazily created using the parameters passed into\n   *   the fire method.\n   */,13,"  protected void fireOptionSelected(JOptionPane pane, int option, Object value, Object inputValue) {\n    SheetEvent sheetEvent = null;\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == SheetListener.class) {\n        // Lazily create the event:\n        if (sheetEvent == null) {\n          sheetEvent = new SheetEvent(this, pane, option, value, inputValue);\n        }\n        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);\n"
1438,JSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,117,119,3,/**\n   * Creates a new JSheet.\n   */,3,  public JSheet(Dialog owner) {\n    super(owner);\n    init();\n
1439,isDocumentModalitySupported,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,297,298,4,"/**\n   * If this returns true, the JSheet uses native support for\n   * sheet display.\n   */",2,  private static boolean isDocumentModalitySupported() {\n    return isDocumentModalitySupported;\n
1440,showMessageSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,883,885,17,"/**\n   * Brings up a sheet that displays a message using a default\n   * icon determined by the <code>messageType</code> parameter.\n   *\n   * @param parentComponent determines the <code>Frame</code>\n   *    in which the dialog is displayed; if <code>null</code>,\n   *    or if the <code>parentComponent</code> has no\n   *    <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param messageType the type of message to be displayed:\n   *          <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *      <code>JOptionPane.WARNING_MESSAGE</code>,\n   *          <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   * @param listener This listener is notified when the sheet is dismissed.\n   */",3,"  public static void showMessageSheet(Component parentComponent,\n      Object message, int messageType, SheetListener listener) {\n    showMessageSheet(parentComponent, message, messageType, null, listener);\n"
1441,isNativeSheetSupported,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,289,290,4,"/**\n   * If this returns true, the JSheet uses native support for\n   * sheet display.\n   */",2,  private static boolean isNativeSheetSupported() {\n    return isNativeSheetSupported;\n
1442,showOptionSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,956,972,44,"/**\n   * Brings up a sheet with a specified icon, where the initial\n   * choice is determined by the <code>initialValue</code> parameter and\n   * the number of choices is determined by the <code>optionType</code>\n   * parameter.\n   * <p>\n   * If <code>optionType</code> is <code>YES_NO_OPTION</code>,\n   * or <code>YES_NO_CANCEL_OPTION</code>\n   * and the <code>options</code> parameter is <code>null</code>,\n   * then the options are\n   * supplied by the look and feel.\n   * <p>\n   * The <code>messageType</code> parameter is primarily used to supply\n   * a default icon from the look and feel.\n   *\n   * @param parentComponent determines the <code>Frame</code>\n   *      in which the dialog is displayed;  if\n   *          <code>null</code>, or if the\n   *      <code>parentComponent</code> has no\n   *      <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param optionType an integer designating the options available on the\n   *      dialog: <code>YES_NO_OPTION</code>,\n   *      or <code>YES_NO_CANCEL_OPTION</code>\n   * @param messageType an integer designating the kind of message this is,\n   *          primarily used to determine the icon from the\n   *      pluggable Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *          <code>JOptionPane.WARNING_MESSAGE</code>,\n   *          <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   * @param icon    the icon to display in the dialog\n   * @param options   an array of objects indicating the possible choices\n   *          the user can make; if the objects are components, they\n   *          are rendered properly; non-<code>String</code>\n   *      objects are\n   *          rendered using their <code>toString</code> methods;\n   *          if this parameter is <code>null</code>,\n   *      the options are determined by the Look and Feel\n   * @param initialValue the object that represents the default selection\n   *          for the dialog; only meaningful if <code>options</code>\n   *      is used; can be <code>null</code>\n   * @param listener The listener for SheetEvents.\n   */",14,"  public static void showOptionSheet(Component parentComponent,\n      Object message, int optionType, int messageType,\n      Icon icon, Object[] options, Object initialValue, SheetListener listener) {\n    JOptionPane pane = new JOptionPane(message, messageType,\n        optionType, icon,\n        options, initialValue);\n    pane.setInitialValue(initialValue);\n    pane.setComponentOrientation(((parentComponent == null) ? JOptionPane.getRootFrame() : parentComponent).getComponentOrientation());\n    int style = styleFromMessageType(messageType);\n    JSheet sheet = createSheet(pane, parentComponent, style);\n    pane.selectInitialValue();\n    sheet.addSheetListener(listener);\n    sheet.show();\n    sheet.toFront();\n"
1443,isAnimated,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,281,282,4,"/**\n   * If this returns true, the JSheet uses a transition effect when shown\n   * and when hidden.\n   */",2,  public boolean isAnimated() {\n    return isAnimated;\n
1444,showMessageSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,861,863,16,"/**\n   * Brings up a sheet that displays a message using a default\n   * icon determined by the <code>messageType</code> parameter.\n   *\n   * @param parentComponent determines the <code>Frame</code>\n   *    in which the dialog is displayed; if <code>null</code>,\n   *    or if the <code>parentComponent</code> has no\n   *    <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param messageType the type of message to be displayed:\n   *          <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *      <code>JOptionPane.WARNING_MESSAGE</code>,\n   *          <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   */",3,"  public static void showMessageSheet(Component parentComponent,\n      Object message, int messageType) {\n    showMessageSheet(parentComponent, message, messageType, null, null);\n"
1445,uninstallSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,237,256,4,/**\n   * Uninstalls the sheet on the owner.\n   * This method is invoked immediately after the JSheet is hidden.\n   */,19,  protected void uninstallSheet() {\n    if (isInstalled) {\n      Window owner = getOwner();\n      if (owner != null) {\n        // Note: We mustn't change the windows focusable state because\n        // this also affects the focusable state of the JSheet.\n        //owner.setFocusableWindowState(true);\n        owner.setEnabled(true);\n        //((JFrame) owner).setResizable(true);\n        owner.removeComponentListener(ownerMovementHandler);\n        if (shiftBackLocation != null) {\n          owner.setLocation(shiftBackLocation);\n        }\n        if (oldFocusOwner != null) {\n          owner.toFront();\n          oldFocusOwner.requestFocus();\n        }\n      }\n      isInstalled = false;\n
1446,showMessageSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,839,842,10,"/**\n   * Brings up an information-message sheet.\n   *\n   * @param parentComponent determines the <code>Frame</code> in\n   *    which the dialog is displayed; if <code>null</code>,\n   *    or if the <code>parentComponent</code> has no\n   *    <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param listener This listener is notified when the sheet is dismissed.\n   */",4,"  public static void showMessageSheet(Component parentComponent,\n      Object message, SheetListener listener) {\n    showMessageSheet(parentComponent, message,\n        JOptionPane.INFORMATION_MESSAGE, listener);\n"
1447,showConfirmSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,616,618,11,"/**\n   * Brings up a sheet with the options <i>Yes</i>,\n   * <i>No</i> and <i>Cancel</i>.\n   *\n   * @param parentComponent determines the <code>Frame</code> in which the\n   *      sheet is displayed; if <code>null</code>,\n   *      or if the <code>parentComponent</code> has no\n   *      <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param listener The listener for SheetEvents.\n   */",3,"  public static void showConfirmSheet(Component parentComponent, Object message, SheetListener listener) {\n    showConfirmSheet(parentComponent, message,\n        JOptionPane.YES_NO_CANCEL_OPTION, listener);\n"
1448,showInputSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,750,753,15,"/**\n   * Shows a sheet requesting input from the user parented to\n   * <code>parentComponent</code> and message type <code>messageType</code>.\n   *\n   * @param parentComponent  the parent <code>Component</code> for the\n   *      dialog\n   * @param message  the <code>Object</code> to display\n   * @param messageType the type of message that is to be displayed:\n   *           <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *      <code>JOptionPane.WARNING_MESSAGE</code>,\n   *           <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   * @param listener The listener for SheetEvents.\n   */",4,"  public static void showInputSheet(Component parentComponent,\n      Object message, int messageType, SheetListener listener) {\n    showInputSheet(parentComponent, message,\n        messageType, null, null, null, listener);\n"
1449,fireOptionSelected,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,553,565,6,/**\n   * Notify all listeners that have registered interest for\n   *   notification on this event type.  The event instance\n   *   is lazily created using the parameters passed into\n   *   the fire method.\n   */,13,"  protected void fireOptionSelected(JFileChooser pane, int option) {\n    SheetEvent sheetEvent = null;\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == SheetListener.class) {\n        // Lazily create the event:\n        if (sheetEvent == null) {\n          sheetEvent = new SheetEvent(this, pane, option, null);\n        }\n        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);\n"
1450,fireOptionSelected,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,493,521,6,/**\n   * Notify all listeners that have registered interest for\n   *   notification on this event type.  The event instance\n   *   is lazily created using the parameters passed into\n   *   the fire method.\n   */,27,"  protected void fireOptionSelected(JOptionPane pane) {\n    Object value = pane.getValue();\n    int option;\n    if (value == null) {\n      option = JOptionPane.CLOSED_OPTION;\n    } else {\n      if (pane.getOptions() == null) {\n        if (value instanceof Integer) {\n          option = ((Integer) value).intValue();\n        } else {\n          option = JOptionPane.CLOSED_OPTION;\n        }\n      } else {\n        option = JOptionPane.CLOSED_OPTION;\n        Object[] options = pane.getOptions();\n        for (int i = 0, n = options.length; i < n; i++) {\n          if (options[i].equals(value)) {\n            option = i;\n            break;\n          }\n        }\n        if (option == JOptionPane.CLOSED_OPTION) {\n          value = null;\n        }\n      }\n    }\n    fireOptionSelected(pane, option, value, pane.getInputValue());\n"
1451,showSaveSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,1100,1102,9,"/**\n   * Displays a ""Save File"" file chooser sheet. Note that the\n   * text that appears in the approve button is determined by\n   * the L&F.\n   *\n   * @param  parent  the parent component of the dialog,\n   *      can be <code>null</code>.\n   * @param listener The listener for SheetEvents.\n   */",3,"  public static void showSaveSheet(JFileChooser chooser, Component parent, SheetListener listener) {\n    chooser.setDialogType(JFileChooser.SAVE_DIALOG);\n    showSheet(chooser, parent, null, listener);\n"
1452,showOpenSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,1114,1116,9,"/**\n   * Displays an ""Open File"" file chooser sheet. Note that the\n   * text that appears in the approve button is determined by\n   * the L&F.\n   *\n   * @param  parent  the parent component of the dialog,\n   *      can be <code>null</code>.\n   * @param listener The listener for SheetEvents.\n   */",3,"  public static void showOpenSheet(JFileChooser chooser, Component parent, SheetListener listener) {\n    chooser.setDialogType(JFileChooser.OPEN_DIALOG);\n    showSheet(chooser, parent, null, listener);\n"
1453,installSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,165,229,4,/**\n   * Installs the sheet on the owner.\n   * This method is invoked just before the JSheet is shown.\n   */,61,"  protected void installSheet() {\n    if (!isNativeSheetSupported() && !isInstalled) {\n      Window owner = getOwner();\n      if (owner != null) {\n        // Determine the location for the sheet and its owner while\n        // the sheet will be visible.\n        // In case we have to shift the owner to fully display the\n        // dialog, we remember the shift back position.\n        Point ownerLoc = owner.getLocation();\n        Point sheetLoc;\n        if (isShowAsSheet()) {\n          if (owner instanceof JFrame) {\n            sheetLoc = new Point(\n                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,\n                ownerLoc.y + owner.getInsets().top + ((JFrame) owner).getRootPane().getContentPane().getY());\n          } else if (owner instanceof JDialog) {\n            sheetLoc = new Point(\n                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,\n                ownerLoc.y + owner.getInsets().top + ((JDialog) owner).getRootPane().getContentPane().getY());\n          } else {\n            sheetLoc = new Point(\n                ownerLoc.x + (owner.getWidth() - getWidth()) / 2,\n                ownerLoc.y + owner.getInsets().top);\n          }\n          if (sheetLoc.x < 0) {\n            owner.setLocation(ownerLoc.x - sheetLoc.x, ownerLoc.y);\n            sheetLoc.x = 0;\n            shiftBackLocation = ownerLoc;\n            oldLocation = owner.getLocation();\n          } else {\n            shiftBackLocation = null;\n            oldLocation = ownerLoc;\n          }\n        } else {\n          sheetLoc = new Point(\n              ownerLoc.x + (owner.getWidth() - getWidth()) / 2,\n              ownerLoc.y + (owner.getHeight() - getHeight()) / 3);\n        }\n        setLocation(sheetLoc);\n        oldFocusOwner = owner.getFocusOwner();\n        // Note: We mustn't change the windows focusable state because\n        // this also affects the focusable state of the JSheet.\n        //owner.setFocusableWindowState(false);\n        owner.setEnabled(false);\n        // ((JFrame) owner).setResizable(false);\n        if (isShowAsSheet()) {\n          owner.addComponentListener(ownerMovementHandler);\n        } else {\n          if (owner instanceof Frame) {\n            setTitle(((Frame) owner).getTitle());\n          }\n        }\n      }\n      isInstalled = true;\n    } else {\n      Window owner = getOwner();\n      Point ownerLoc = owner.getLocation();\n      Point sheetLoc = new Point(\n          ownerLoc.x + (owner.getWidth() - getWidth()) / 2,\n          ownerLoc.y + (owner.getHeight() - getHeight()) / 3);\n        setLocation(sheetLoc);\n"
1454,showSaveSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,1128,1130,9,"/**\n   * Displays a ""Save File"" file chooser sheet. Note that the\n   * text that appears in the approve button is determined by\n   * the L&F.\n   *\n   * @param  parent  the parent component of the dialog,\n   *      can be <code>null</code>.\n   * @param listener The listener for SheetEvents.\n   */",3,"  public static void showSaveSheet(URIChooser chooser, Component parent, SheetListener listener) {\n    chooser.setDialogType(JFileChooser.SAVE_DIALOG);\n    showSheet(chooser, parent, null, listener);\n"
1455,showSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,1212,1261,8,/**\n   * Displays a custom file chooser sheet with a custom approve button.\n   *\n   * @param   parent  the parent component of the dialog;\n   *      can be <code>null</code>\n   * @param   approveButtonText the text of the <code>ApproveButton</code>\n   * @param listener The listener for SheetEvents.\n   */,43,"  public static void showSheet(final URIChooser chooser, Component parent,\n      String approveButtonText, SheetListener listener) {\n    if (approveButtonText != null) {\n      chooser.setApproveButtonText(approveButtonText);\n      chooser.setDialogType(URIChooser.CUSTOM_DIALOG);\n    }\n    // Begin Create Dialog\n    Frame frame = parent instanceof Frame ? (Frame) parent\n        : (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parent);\n    if (chooser instanceof JFileChooser) {\n    String title = ((JFileChooser) chooser).getUI().getDialogTitle((JFileChooser) chooser);\n    ((JFileChooser) chooser).getAccessibleContext().setAccessibleDescription(title);\n    }\n    final JSheet sheet = new JSheet(frame);\n    sheet.addSheetListener(listener);\n    Container contentPane = sheet.getContentPane();\n    contentPane.setLayout(new BorderLayout());\n    contentPane.add(chooser.getComponent(), BorderLayout.CENTER);\n    // End Create Dialog\n    final ActionListener actionListener = new ActionListener() {\n      public void actionPerformed(ActionEvent evt) {\n        int option;\n        if (evt.getActionCommand().equals(""ApproveSelection"")) {\n          option = JFileChooser.APPROVE_OPTION;\n        } else {\n          option = JFileChooser.CANCEL_OPTION;\n        }\n        sheet.hide();\n        sheet.fireOptionSelected(chooser, option);\n        chooser.removeActionListener(this);\n      }\n    };\n    chooser.addActionListener(actionListener);\n    sheet.addWindowListener(new WindowAdapter() {\n      public void windowClosing(WindowEvent e) {\n        sheet.fireOptionSelected(chooser, JFileChooser.CANCEL_OPTION);\n        chooser.removeActionListener(actionListener);\n      }\n    });\n    chooser.rescanCurrentDirectory();\n    sheet.pack();\n    sheet.show();\n    sheet.toFront();\n"
1456,setAnimated,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,271,274,7,"/**\n   * If this is set to true, the JSheet uses a transition effect when shown\n   * and when hidden.\n   */\n --------------\n// QuaquaUtilities.setWindowAlpha(this, 240);\n --------------",4,"  public void setAnimated(boolean newValue) {\n    boolean oldValue = isAnimated;\n    isAnimated = newValue;\n    firePropertyChange(""animated"", oldValue, newValue);\n"
1457,showConfirmSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,696,700,24,"/**\n   * Brings up a sheet with a specified icon, where the number of\n   * choices is determined by the <code>optionType</code> parameter.\n   * The <code>messageType</code> parameter is primarily used to supply\n   * a default icon from the look and feel.\n   *\n   * @param parentComponent determines the <code>Frame</code> in which the\n   *      dialog is displayed; if <code>null</code>,\n   *      or if the <code>parentComponent</code> has no\n   *      <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the Object to display\n   * @param optionType an int designating the options available on the dialog:\n   *          <code>YES_NO_OPTION</code>,\n   *      or <code>YES_NO_CANCEL_OPTION</code>\n   * @param messageType an int designating the kind of message this is,\n   *          primarily used to determine the icon from the pluggable\n   *          Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *          <code>JOptionPane.WARNING_MESSAGE</code>,\n   *          <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   * @param icon    the icon to display in the dialog\n   * @param listener The listener for SheetEvents.\n   */",5,"  public static void showConfirmSheet(Component parentComponent,\n      Object message, int optionType,\n      int messageType, Icon icon, SheetListener listener) {\n    showOptionSheet(parentComponent, message, optionType,\n        messageType, icon, null, null, listener);\n"
1458,showInputSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,711,713,8,/**\n   * Shows a question-message sheet requesting input from the user\n   * parented to <code>parentComponent</code>.\n   *\n   * @param parentComponent  the parent <code>Component</code> for the\n   *    dialog\n   * @param listener The listener for SheetEvents.\n   */,3,"  public static void showInputSheet(Component parentComponent,\n      Object message, SheetListener listener) {\n    showInputSheet(parentComponent, message, JOptionPane.QUESTION_MESSAGE, listener);\n"
1459,fireOptionSelected,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,575,587,6,/**\n   * Notify all listeners that have registered interest for\n   *   notification on this event type.  The event instance\n   *   is lazily created using the parameters passed into\n   *   the fire method.\n   */,13,"  protected void fireOptionSelected(URIChooser pane, int option) {\n    SheetEvent sheetEvent = null;\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == SheetListener.class) {\n        // Lazily create the event:\n        if (sheetEvent == null) {\n          sheetEvent = new SheetEvent(this, pane, option, null);\n        }\n        ((SheetListener) listeners[i + 1]).optionSelected(sheetEvent);\n"
1460,removeSheetListener,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,483,484,3,/**\n   * Removes a sheet listener.\n   */,2,"  public void removeSheetListener(SheetListener l) {\n    listenerList.remove(SheetListener.class, l);\n"
1461,showConfirmSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,635,638,14,"/**\n   * Brings up a sheet where the number of choices is determined\n   * by the <code>optionType</code> parameter.\n   *\n   * @param parentComponent determines the <code>Frame</code> in which the\n   *      sheet is displayed; if <code>null</code>,\n   *      or if the <code>parentComponent</code> has no\n   *      <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param optionType an int designating the options available on the dialog:\n   *          <code>YES_NO_OPTION</code>, or\n   *      <code>YES_NO_CANCEL_OPTION</code>\n   * @param listener The listener for SheetEvents.\n   */",4,"  public static void showConfirmSheet(Component parentComponent,\n      Object message, int optionType, SheetListener listener) {\n    showConfirmSheet(parentComponent, message, optionType,\n        JOptionPane.QUESTION_MESSAGE, listener);\n"
1462,JSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,109,111,3,/**\n   * Creates a new JSheet.\n   */,3,  public JSheet(Frame owner) {\n    super(owner);\n    init();\n
1464,showConfirmSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,666,669,25,"/**\n   * Brings up a sheet where the number of choices is determined\n   * by the <code>optionType</code> parameter, where the\n   * <code>messageType</code>\n   * parameter determines the icon to display.\n   * The <code>messageType</code> parameter is primarily used to supply\n   * a default icon from the Look and Feel.\n   *\n   * @param parentComponent determines the <code>Frame</code> in\n   *      which the dialog is displayed; if <code>null</code>,\n   *      or if the <code>parentComponent</code> has no\n   *      <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param optionType an integer designating the options available\n   *      on the dialog: <code>YES_NO_OPTION</code>,\n   *      or <code>YES_NO_CANCEL_OPTION</code>\n   * @param messageType an integer designating the kind of message this is;\n   *          primarily used to determine the icon from the pluggable\n   *          Look and Feel: <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *          <code>JOptionPane.WARNING_MESSAGE</code>,\n   *          <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   * @param listener The listener for SheetEvents.\n   */",4,"  public static void showConfirmSheet(Component parentComponent,\n      Object message, int optionType, int messageType, SheetListener listener) {\n    showConfirmSheet(parentComponent, message, optionType,\n        messageType, null, listener);\n"
1465,showSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,1155,1202,8,/**\n   * Displays a custom file chooser sheet with a custom approve button.\n   *\n   * @param   parent  the parent component of the dialog;\n   *      can be <code>null</code>\n   * @param   approveButtonText the text of the <code>ApproveButton</code>\n   * @param listener The listener for SheetEvents.\n   */,41,"  public static void showSheet(final JFileChooser chooser, Component parent,\n      String approveButtonText, SheetListener listener) {\n    if (approveButtonText != null) {\n      chooser.setApproveButtonText(approveButtonText);\n      chooser.setDialogType(JFileChooser.CUSTOM_DIALOG);\n    }\n    // Begin Create Dialog\n    Frame frame = parent instanceof Frame ? (Frame) parent\n        : (Frame) SwingUtilities.getAncestorOfClass(Frame.class, parent);\n    String title = chooser.getUI().getDialogTitle(chooser);\n    chooser.getAccessibleContext().setAccessibleDescription(title);\n    final JSheet sheet = new JSheet(frame);\n    sheet.addSheetListener(listener);\n    Container contentPane = sheet.getContentPane();\n    contentPane.setLayout(new BorderLayout());\n    contentPane.add(chooser, BorderLayout.CENTER);\n    // End Create Dialog\n    final ActionListener actionListener = new ActionListener() {\n      public void actionPerformed(ActionEvent evt) {\n        int option;\n        if (evt.getActionCommand().equals(""ApproveSelection"")) {\n          option = JFileChooser.APPROVE_OPTION;\n        } else {\n          option = JFileChooser.CANCEL_OPTION;\n        }\n        sheet.hide();\n        sheet.fireOptionSelected(chooser, option);\n        chooser.removeActionListener(this);\n      }\n    };\n    chooser.addActionListener(actionListener);\n    sheet.addWindowListener(new WindowAdapter() {\n      public void windowClosing(WindowEvent e) {\n        sheet.fireOptionSelected(chooser, JFileChooser.CANCEL_OPTION);\n        chooser.removeActionListener(actionListener);\n      }\n    });\n    chooser.rescanCurrentDirectory();\n    sheet.pack();\n    sheet.show();\n    sheet.toFront();\n"
1466,showSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,599,602,7,/**\n   * Displays an option pane as a sheet on its parent window.\n   *\n   * @param pane The option pane.\n   * @param parentComponent The parent of the option pane.\n   * @param listener The listener for SheetEvents.\n   */,4,"  public static void showSheet(JOptionPane pane, Component parentComponent, SheetListener listener) {\n    final JSheet sheet = createSheet(pane, parentComponent, styleFromMessageType(pane.getMessageType()));\n    sheet.addSheetListener(listener);\n    sheet.show();\n"
1467,showMessageSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,906,909,18,"/**\n   * Brings up a sheet displaying a message, specifying all parameters.\n   *\n   * @param parentComponent determines the <code>Frame</code> in which the\n   *      sheet is displayed; if <code>null</code>,\n   *      or if the <code>parentComponent</code> has no\n   *      <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   * @param messageType the type of message to be displayed:\n   *          <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *      <code>JOptionPane.WARNING_MESSAGE</code>,\n   *          <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   * @param icon    an icon to display in the sheet that helps the user\n   *          identify the kind of message that is being displayed\n   * @param listener This listener is notified when the sheet is dismissed.\n   */",4,"  public static void showMessageSheet(Component parentComponent,\n      Object message, int messageType, Icon icon, SheetListener listener) {\n    showOptionSheet(parentComponent, message, JOptionPane.DEFAULT_OPTION,\n        messageType, icon, null, null, listener);\n"
1468,getWindowForComponent,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,1081,1088,12,"/**\n   * Returns the specified component's toplevel <code>Frame</code> or\n   * <code>Dialog</code>.\n   *\n   * @param parentComponent the <code>Component</code> to check for a\n   *    <code>Frame</code> or <code>Dialog</code>\n   * @return the <code>Frame</code> or <code>Dialog</code> that\n   *    contains the component, or the default\n   *       frame if the component is <code>null</code>,\n   *    or does not have a valid\n   *       <code>Frame</code> or <code>Dialog</code> parent\n   */",8,  static Window getWindowForComponent(Component parentComponent) {\n    if (parentComponent == null) {\n      return JOptionPane.getRootFrame();\n    }\n    if (parentComponent instanceof Frame || parentComponent instanceof Dialog) {\n      return (Window) parentComponent;\n    }\n    return getWindowForComponent(parentComponent.getParent());\n
1469,showOpenSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,1142,1144,9,"/**\n   * Displays an ""Open File"" file chooser sheet. Note that the\n   * text that appears in the approve button is determined by\n   * the L&F.\n   *\n   * @param  parent  the parent component of the dialog,\n   *      can be <code>null</code>.\n   * @param listener The listener for SheetEvents.\n   */",3,"  public static void showOpenSheet(URIChooser chooser, Component parent, SheetListener listener) {\n    chooser.setDialogType(JFileChooser.OPEN_DIALOG);\n    showSheet(chooser, parent, null, listener);\n"
1470,addSheetListener,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,476,477,3,/**\n   * Adds a sheet listener.\n   */,2,"  public void addSheetListener(SheetListener l) {\n    listenerList.add(SheetListener.class, l);\n"
1471,showMessageSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,823,826,9,"/**\n   * Brings up an information-message sheet.\n   *\n   * @param parentComponent determines the <code>Frame</code> in\n   *    which the dialog is displayed; if <code>null</code>,\n   *    or if the <code>parentComponent</code> has no\n   *    <code>Frame</code>, the sheet is displayed as a dialog.\n   * @param message   the <code>Object</code> to display\n   */",4,"  public static void showMessageSheet(Component parentComponent,\n      Object message) {\n    showMessageSheet(parentComponent, message,\n        JOptionPane.INFORMATION_MESSAGE);\n"
1472,showInputSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,728,732,12,/**\n   * Shows a question-message sheet requesting input from the user and\n   * parented to <code>parentComponent</code>. The input value will be\n   * initialized to <code>initialSelectionValue</code>.\n   *\n   * @param parentComponent  the parent <code>Component</code> for the\n   *    dialog\n   * @param message the <code>Object</code> to display\n   * @param initialSelectionValue the value used to initialize the input\n   *         field\n   * @param listener The listener for SheetEvents.\n   */,5,"  public static void showInputSheet(Component parentComponent, Object message,\n      Object initialSelectionValue, SheetListener listener) {\n    showInputSheet(parentComponent, message,\n        JOptionPane.QUESTION_MESSAGE, null, null,\n        initialSelectionValue, listener);\n"
1473,showInputSheet,JSheet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JSheet.java,785,811,29,"/**\n   * Prompts the user for input in a sheet where the\n   * initial selection, possible selections, and all other options can\n   * be specified. The user will able to choose from\n   * <code>selectionValues</code>, where <code>null</code> implies the\n   * user can input\n   * whatever they wish, usually by means of a <code>JTextField</code>.\n   * <code>initialSelectionValue</code> is the initial value to prompt\n   * the user with. It is up to the UI to decide how best to represent\n   * the <code>selectionValues</code>, but usually a\n   * <code>JComboBox</code>, <code>JList</code>, or\n   * <code>JTextField</code> will be used.\n   *\n   * @param parentComponent  the parent <code>Component</code> for the\n   *      dialog\n   * @param message  the <code>Object</code> to display\n   * @param messageType the type of message to be displayed:\n   *          <code>JOptionPane.ERROR_MESSAGE</code>,\n   *      <code>JOptionPane.INFORMATION_MESSAGE</code>,\n   *      <code>JOptionPane.WARNING_MESSAGE</code>,\n   *          <code>JOptionPane.QUESTION_MESSAGE</code>,\n   *      or <code>JOptionPane.PLAIN_MESSAGE</code>\n   * @param icon   the <code>Icon</code> image to display\n   * @param selectionValues an array of <code>Object</code>s that\n   *      gives the possible selections\n   * @param initialSelectionValue the value used to initialize the input\n   *         field\n   * @param listener The listener for SheetEvents.\n   */",22,"  public static void showInputSheet(Component parentComponent,\n      Object message, int messageType, Icon icon,\n      Object[] selectionValues, Object initialSelectionValue, SheetListener listener) {\n    JOptionPane pane = new JOptionPane(message, messageType,\n        JOptionPane.OK_CANCEL_OPTION, icon,\n        null, null);\n    pane.setWantsInput(true);\n    pane.setSelectionValues(selectionValues);\n    pane.setInitialSelectionValue(initialSelectionValue);\n    pane.setComponentOrientation(((parentComponent == null) ? JOptionPane.getRootFrame() : parentComponent).getComponentOrientation());\n    int style = styleFromMessageType(messageType);\n    JSheet sheet = createSheet(pane, parentComponent, style);\n    pane.selectInitialValue();\n    /*\n    sheet.addWindowListener(new WindowAdapter() {\n    public void windowClosed(WindowEvent evt) {\n    sheet.dispose();\n    }\n    });*/\n    sheet.addSheetListener(listener);\n    sheet.show();\n    sheet.toFront();\n"
1477,updateText,JLifeFormattedTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java,125,144,3,/**\n   * Updates the text of the field from the value.\n   */,20,"  protected void updateText() {\n    if (updatingDepth++ == 0) {\n      if (getFormatter() != null) {\n        try {\n          String newText = getFormatter().valueToString(getValue());\n          setText(newText);\n          if (!isFocusOwner()) {\n            // This is like selectAll(), but we set the\n            // cursor at the start of the field, because\n            // the start of the field contains the most\n            // significant part of the field content.\n            setCaretPosition(getDocument().getLength());\n            moveCaretPosition(0);\n          }\n        } catch (ParseException ex) {\n          //ex.printStackTrace(); do nothing\n        }\n      }\n    }\n    updatingDepth--;\n"
1478,updateValue,JLifeFormattedTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java,108,119,3,/**\n   * Updates the value from the text of the field.\n   */,12,  protected void updateValue() {\n    if (updatingDepth++ == 0) {\n      if (getFormatter() != null) {\n        try {\n          Object newValue = getFormatter().stringToValue(getText());\n          setValue(newValue);\n        } catch (ParseException ex) {\n          //ex.printStackTrace();// do nothing\n        }\n      }\n    }\n    updatingDepth--;\n
1479,getDefaultFormatterFactory,JLifeFormattedTextField,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTextField.java,151,181,4,/**\n   * Returns an AbstractFormatterFactory suitable for the passed in\n   * Object type.\n   */,25,"  private AbstractFormatterFactory getDefaultFormatterFactory(Object type) {\n    if (type instanceof DateFormat) {\n      return new DefaultFormatterFactory(new DateFormatter((DateFormat) type));\n    }\n    if (type instanceof NumberFormat) {\n      return new DefaultFormatterFactory(new NumberFormatter(\n          (NumberFormat) type));\n    }\n    if (type instanceof Format) {\n      return new DefaultFormatterFactory(new InternationalFormatter(\n          (Format) type));\n    }\n    if (type instanceof Date) {\n      return new DefaultFormatterFactory(new DateFormatter());\n    }\n    if (type instanceof Number) {\n      AbstractFormatter displayFormatter = new NumberFormatter();\n      ((NumberFormatter) displayFormatter).setValueClass(type.getClass());\n      AbstractFormatter editFormatter = new NumberFormatter(\n          new DecimalFormat(""#.#""));\n      ((NumberFormatter) editFormatter).setValueClass(type.getClass());\n      return new DefaultFormatterFactory(displayFormatter,\n          displayFormatter, editFormatter);\n    }\n    return new DefaultFormatterFactory(new DefaultFormatter());\n"
1480,arrangeFramesVertically,JMDIDesktopPane,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java,163,212,5,/**\n   * Arranges the frames as efficiently as possibly with preference for\n   * keeping vertical size maximal.<br>\n   *\n   */,50,"  public void arrangeFramesVertically() {\n    Component[] allFrames = getAllFrames();\n    // do nothing if no frames to work with\n    if (allFrames.length == 0) {\n      return;\n    }\n    \n    manager.setNormalSize();\n    \n    int vertFrames = (int)Math.floor(Math.sqrt(allFrames.length));\n    int horFrames = (int)Math.ceil(Math.sqrt(allFrames.length));\n    \n    // first arrange the windows that have equal size\n    int frameWidth = getBounds().width / horFrames;\n    int frameHeight = getBounds().height / vertFrames;\n    int x = 0;\n    int y = 0;\n    int frameIdx = 0;\n    for (int horCnt = 0; horCnt < horFrames-1; horCnt++) {\n      y = 0;\n      for (int vertCnt = 0; vertCnt < vertFrames; vertCnt++) {\n        try {\n          ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);\n        } catch (PropertyVetoException e) {\n          e.printStackTrace();\n        }\n        \n        allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);\n        frameIdx++;\n        y = y + frameHeight;\n      }\n      x = x + frameWidth;\n    }\n    \n    // the rest of the frames are tiled down on the last column with equal\n    // height\n    frameHeight = getBounds().height / (allFrames.length - frameIdx);\n    y = 0;\n    for (; frameIdx < allFrames.length; frameIdx++) {\n      try {\n        ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);\n      } catch (PropertyVetoException e) {\n        e.printStackTrace();\n      }\n      \n      allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);\n      y = y + frameHeight;\n    }\n    \n    checkDesktopSize();\n"
1481,arrangeFramesHorizontally,JMDIDesktopPane,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java,220,269,5,/**\n   * Arranges the frames as efficiently as possibly with preference for\n   * keeping horizontal size maximal.<br>\n   *\n   */,50,"  public void arrangeFramesHorizontally() {\n    Component[] allFrames = getAllFrames();\n    // do nothing if no frames to work with\n    if (allFrames.length == 0) {\n      return;\n    }\n    \n    manager.setNormalSize();\n    \n    int vertFrames = (int)Math.ceil(Math.sqrt(allFrames.length));\n    int horFrames = (int)Math.floor(Math.sqrt(allFrames.length));\n    \n    // first arrange the windows that have equal size\n    int frameWidth = getBounds().width / horFrames;\n    int frameHeight = getBounds().height / vertFrames;\n    int x = 0;\n    int y = 0;\n    int frameIdx = 0;\n    for (int vertCnt = 0; vertCnt < vertFrames-1; vertCnt++) {\n      x = 0;\n      for (int horCnt = 0; horCnt < horFrames; horCnt++) {\n        try {\n          ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);\n        } catch (PropertyVetoException e) {\n          e.printStackTrace();\n        }\n        \n        allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);\n        frameIdx++;\n        x = x + frameWidth;\n      }\n      y = y + frameHeight;\n    }\n    \n    // the rest of the frames are tiled down on the last column with equal\n    // height\n    frameWidth = getBounds().width / (allFrames.length - frameIdx);\n    x = 0;\n    for (; frameIdx < allFrames.length; frameIdx++) {\n      try {\n        ((JInternalFrame)allFrames[frameIdx]).setMaximum(false);\n      } catch (PropertyVetoException e) {\n        e.printStackTrace();\n      }\n      \n      allFrames[frameIdx].setBounds(x, y, frameWidth, frameHeight);\n      x = x + frameWidth;\n    }\n    \n    checkDesktopSize();\n"
1482,setAllSize,JMDIDesktopPane,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java,276,280,4,"/**\n   * Sets all component size properties ( maximum, minimum, preferred)\n   * to the given dimension.\n   */",5,"  public void setAllSize(Dimension d) {\n    setMinimumSize(d);\n    setMaximumSize(d);\n    setPreferredSize(d);\n    setBounds(0, 0, d.width, d.height);\n"
1483,arrangeFramesCascading,JMDIDesktopPane,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JMDIDesktopPane.java,73,104,3,/**\n   * Cascade all internal frames\n   */,32,"  private void arrangeFramesCascading() {\n    JInternalFrame[] allFrames = getAllFrames();\n    \n    // do nothing if no frames to work with\n    if (allFrames.length == 0) {\n      return;\n    }\n    \n    manager.setNormalSize();\n    Insets insets = getInsets();\n    int x = insets.left;\n    int y = insets.top;\n    int frameOffset=0;\n    for (int i = allFrames.length - 1; i >= 0; i--) {\n      Point p=SwingUtilities.convertPoint(allFrames[i].getContentPane(),0,0,allFrames[i]);\n      frameOffset=Math.max(frameOffset,Math.max(p.x,p.y));\n    }\n    int frameHeight = (getBounds().height-insets.top-insets.bottom) - allFrames.length * frameOffset;\n    int frameWidth = (getBounds().width-insets.left-insets.right) - allFrames.length * frameOffset;\n    for (int i = allFrames.length - 1; i >= 0; i--) {\n      try {\n        allFrames[i].setMaximum(false);\n      } catch (PropertyVetoException e) {\n        e.printStackTrace();\n      }\n      \n      allFrames[i].setBounds(x, y, frameWidth, frameHeight);\n      x = x + frameOffset;\n      y = y + frameOffset;\n    }\n    \n    checkDesktopSize();\n"
1501,JPopupButton,JPopupButton,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java,51,54,1,/** Creates new form JToolBarMenu */,4,  public JPopupButton() {\n    initComponents();\n    setFocusable(false);\n    itemFont = ITEM_FONT;\n
1503,setPopupAnchor,JPopupButton,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java,164,165,12,/**\n   * Sets the popup anchor.\n   * <p>\n   * <ul>\n   * <li>SOUTH_WEST places the popup below the button and aligns it with its \n   * left bound.</li>\n   * <li>SOUTH_EAST places the popup below the button and aligns it with its \n   * right bound.</li>\n   * </ul> \n   * \n   * @param newValue SwingConstants.SOUTH_WEST or SOUTH_EAST.\n   */,2,  public void setPopupAnchor(int newValue) {\n    popupAnchor = newValue;\n
1505,getPopupAnchor,JPopupButton,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java,148,149,5,/**\n   * Gets the popup anchor.\n   * \n   * @return SwingConstants.SOUTH_WEST or SOUTH_EAST.\n   */,2,  public int getPopupAnchor() {\n    return popupAnchor;\n
1510,initComponents,JPopupButton,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButton.java,212,219,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,7,  private void initComponents() {\n    addMouseListener(new java.awt.event.MouseAdapter() {\n      public void mousePressed(java.awt.event.MouseEvent evt) {\n        handleMousePressed(evt);\n      }\n      public void mouseReleased(java.awt.event.MouseEvent evt) {\n        performAction(evt);\n
1534,getSelectionPath,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,282,283,6,"/**\n   * Gets the selected Font.\n   * This is a bound property.\n   * \n   * @return The selected font, or null, if no font is selected.\n   */",2,  public TreePath getSelectionPath() {\n    return selectionPath;\n
1535,addActionListener,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,229,230,8,/**\n   * Adds an <code>ActionListener</code> to the font chooser.\n   *\n   * @param l  the listener to be added\n   * \n   * @see #approveSelection\n   * @see #cancelSelection\n   */,2,"  public void addActionListener(ActionListener l) {\n    listenerList.add(ActionListener.class, l);\n"
1536,setSelectedFont,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,377,381,12,"/**\n   * Sets the selected Font.\n   * <p>\n   * Changing the selected font, causes a change of the\n   * selection path, if the selected font is not the last\n   * path segment of the selection path.\n   * \n   * This is a bound property.\n   * \n   * @param newValue The new selected font, or null if no font is to be\n   * selected.\n   */",5,"  public void setSelectedFont(Font newValue) {\n    Font oldValue = selectedFont;\n    this.selectedFont = newValue;\n    firePropertyChange(SELECTED_FONT_PROPERTY, oldValue, newValue);\n    updateSelectionPath(newValue);\n"
1537,setSelectionPath,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,297,302,11,"/**\n   * Sets the selected Font.\n   * This is a bound property.\n   * <p>\n   * Changing the selection path, causes a change of the\n   * selected font, if the selected font is not the last\n   * path segment of the selection path.\n   * \n   * @param newValue The new selected font, or null if no font is to be\n   * selected..\n   */",6,"  public void setSelectionPath(TreePath newValue) {\n    TreePath oldValue = selectionPath;\n    this.selectionPath = newValue;\n    firePropertyChange(SELECTION_PATH_PROPERTY, oldValue, newValue);\n    if (selectionPath != null && selectionPath.getPathCount() == 4) {\n      setSelectedFont(((FontFaceNode) selectionPath.getLastPathComponent()).getFont());\n"
1538,LabelFigure,LabelFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabelFigure.java,40,41,1,/** Creates a new instance. */,2,"  public LabelFigure() {\n    this(""Label"");\n"
1539,cancelSelection,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,213,218,9,/**\n   * Called by the UI when the user chooses the Cancel button.\n   * This can also be called by the programmer.\n   * This method causes an action event to fire\n   * with the command string equal to\n   * <code>CANCEL_SELECTION</code>.\n   *\n   * @see #CANCEL_SELECTION\n   */,6,  public void cancelSelection() {\n    returnValue = CANCEL_OPTION;\n    if (dialog != null) {\n      dialog.setVisible(false);\n    }\n    fireActionPerformed(CANCEL_SELECTION);\n
1540,getUIClassID,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,181,183,8,"/**\n   * Returns a string that specifies the name of the L&F class\n   * that renders this component.\n   *\n   * @return ""FontChooserUI""\n   * @see JComponent#getUIClassID\n   * @see UIDefaults#getUI\n   */",3,  @Override\n  public String getUIClassID() {\n    return uiClassID;\n
1541,getSelectedFont,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,361,362,6,"/**\n   * Gets the selected Font.\n   * This is a bound property.\n   * \n   * @return The selected font, or null, if no font is selected.\n   */",2,  public Font getSelectedFont() {\n    return selectedFont;\n
1542,getUI,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,159,160,6,/**\n   * Returns the look and feel (L&F) object that renders this component.\n   *\n   * @return the PanelUI object that renders this component\n   * @since 1.4\n   */,2,  public FontChooserUI getUI() {\n    return (FontChooserUI) ui;\n
1543,loadAllFonts,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,310,332,4,/**\n   * Starts loading all fonts from the local graphics environment \n   * using a worker thread.\n   */,21,"  public synchronized static void loadAllFonts() {\n    if (future == null) {\n      future = new FutureTask<Font[]>(new Callable<Font[]>() {\n        public Font[] call() throws Exception {\n          long start = System.currentTimeMillis();\n          Font[] fonts = GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();\n          long end = System.currentTimeMillis();\n          //System.out.println(""JFontChooser has loaded all fonts. Elapsed:""+(end-start));\n          // get rid of bogus fonts\n          ArrayList<Font> goodFonts = new ArrayList<Font>(fonts.length);\n          for (Font f : fonts) {\n            Font decoded = Font.decode(f.getFontName());\n            if (decoded.getFontName().equals(f.getFontName()) || decoded.getFontName().endsWith(""-Derived"")) {\n              goodFonts.add(f);\n            }\n          }\n          return goodFonts.toArray(new Font[goodFonts.size()]);\n        // return fonts;\n        }\n      });\n      new Thread(future).start();\n"
1544,getAllFonts,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,344,351,8,"/**\n   * Gets all fonts from the graphics environment. This may take a long\n   * time. It is recommended to call loadAllFonts during the startup \n   * of an application. If you do this, you can retrieve the fonts from\n   * this method from the AWT Event Dispatcher Thread.\n   * \n   * @return All fonts.\n   */",8,  public static synchronized Font[] getAllFonts() {\n    loadAllFonts();\n    try {\n      return future.get().clone();\n    } catch (InterruptedException ex) {\n      return new Font[0];\n    } catch (ExecutionException ex) {\n      return new Font[0];\n
1545,updateUI,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,142,149,5,/**\n   * Resets the UI property with a value from the current look and feel.\n   *\n   * @see JComponent#updateUI\n   */,8,"  @Override\n  public void updateUI() {\n    // Try to get a browser UI from the UIManager.\n    // Fall back to BasicBrowserUI, if none is available.\n    if (UIManager.get(getUIClassID()) != null) {\n      setUI((FontChooserUI) UIManager.getUI(this));\n    } else {\n      setUI(PaletteFontChooserUI.createUI(this));\n"
1546,removeActionListener,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,240,241,7,/**\n   * Removes an <code>ActionListener</code> from the font chooser.\n   *\n   * @param l  the listener to be removed\n   *\n   * @see #addActionListener\n   */,2,"  public void removeActionListener(ActionListener l) {\n    listenerList.remove(ActionListener.class, l);\n"
1547,setUI,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,169,170,6,/**\n   * Sets the look and feel (L&F) object that renders this component.\n   *\n   * @param ui  the PanelUI L&F object\n   * @see UIDefaults#getUI\n   */,2,  public void setUI(FontChooserUI ui) {\n    super.setUI(ui);\n
1548,approveSelection,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,196,201,10,"/**\n   * Called by the UI when the user hits the Approve button\n   * (labeled ""Open"" or ""Save"", by default). This can also be\n   * called by the programmer.\n   * This method causes an action event to fire\n   * with the command string equal to\n   * <code>APPROVE_SELECTION</code>.\n   *\n   * @see #APPROVE_SELECTION\n   */",6,  public void approveSelection() {\n    returnValue = APPROVE_OPTION;\n    if (dialog != null) {\n      dialog.setVisible(false);\n    }\n    fireActionPerformed(APPROVE_SELECTION);\n
1549,getModel,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,464,465,6,"/**\n   * Gets the selected Font.\n   * This is a bound property.\n   * \n   * @return The selected font, or null, if no font is selected.\n   */",2,  public FontChooserModel getModel() {\n    return model;\n
1550,updateSelectionPath,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,392,452,8,"/**\n   * Updates the selection path to the selected font.\n   * <p>\n   * This method is invoked, when a font is selected, and when then\n   * structure of the model has changed.\n   * \n   * @param newValue\n   */",58,"  protected void updateSelectionPath(Font newValue) {\n    if (newValue == null || selectionPath == null || selectionPath.getPathCount() != 4 ||\n        !((FontFaceNode) selectionPath.getLastPathComponent()).getFont().getFontName().equals(newValue.getFontName())) {\n      if (newValue == null) {\n        setSelectionPath(null);\n      } else {\n        TreePath path = selectionPath;\n        FontCollectionNode oldCollection = (path != null && path.getPathCount() > 1) ? (FontCollectionNode) path.getPathComponent(1) : null;\n        FontFamilyNode oldFamily = (path != null && path.getPathCount() > 2) ? (FontFamilyNode) path.getPathComponent(2) : null;\n        FontFaceNode oldFace = (path != null && path.getPathCount() > 3) ? (FontFaceNode) path.getPathComponent(3) : null;\n        FontCollectionNode newCollection = oldCollection;\n        FontFamilyNode newFamily = oldFamily;\n        FontFaceNode newFace = null;\n        // search in the current family\n        if (newFace == null && newFamily != null) {\n          for (FontFaceNode face : newFamily.faces()) {\n            if (face.getFont().getFontName().equals(newValue.getFontName())) {\n              newFace = face;\n              break;\n            }\n          }\n        }\n        // search in the current collection\n        if (newFace == null && newCollection != null) {\n          for (FontFamilyNode family : newCollection.families()) {\n            for (FontFaceNode face : family.faces()) {\n              if (face.getFont().getFontName().equals(newValue.getFontName())) {\n                newFamily = family;\n                newFace = face;\n                break;\n              }\n            }\n          }\n        }\n        // search in all collections\n        if (newFace == null) {\n          TreeNode root = (TreeNode) getModel().getRoot();\n          OuterLoop:\n          for (int i = 0, n = root.getChildCount(); i < n; i++) {\n            FontCollectionNode collection = (FontCollectionNode) root.getChildAt(i);\n            for (FontFamilyNode family : collection.families()) {\n              for (FontFaceNode face : family.faces()) {\n                if (face.getFont().getFontName().equals(newValue.getFontName())) {\n                  newCollection = collection;\n                  newFamily = family;\n                  newFace = face;\n                  break OuterLoop;\n                }\n              }\n            }\n          }\n        }\n        if (newFace != null) {\n          setSelectionPath(new TreePath(new Object[]{\n                getModel().getRoot(), newCollection, newFamily, newFace\n              }));\n        } else {\n          setSelectionPath(null);\n"
1551,JFontChooser,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,115,131,1,/** Creates new form JFontChooser */,15,"  public JFontChooser() {\n    loadAllFonts();\n    model = new DefaultFontChooserModel.UIResource();\n    model.addTreeModelListener(modelHandler);\n    updateUI();\n    addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (evt.getPropertyName() == ""ancestor"" && evt.getNewValue() != null) {\n          Component ancestor = (Component) evt.getNewValue();\n          try {\n            ((DefaultFontChooserModel) model).setFonts(getAllFonts());\n          } catch (Exception ex) {\n            ex.printStackTrace();\n          }\n          JFontChooser.this.removePropertyChangeListener(this);\n"
1552,fireActionPerformed,JFontChooser,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JFontChooser.java,249,271,5,/**\n   * Notifies all listeners that have registered interest for\n   * notification on this event type. The event instance\n   * is lazily created using the <code>command</code> parameter.\n   */,23,"  protected void fireActionPerformed(String command) {\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    long mostRecentEventTime = EventQueue.getMostRecentEventTime();\n    int modifiers = 0;\n    AWTEvent currentEvent = EventQueue.getCurrentEvent();\n    if (currentEvent instanceof InputEvent) {\n      modifiers = ((InputEvent) currentEvent).getModifiers();\n    } else if (currentEvent instanceof ActionEvent) {\n      modifiers = ((ActionEvent) currentEvent).getModifiers();\n    }\n    ActionEvent e = null;\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\n      if (listeners[i] == ActionListener.class) {\n        // Lazily create the event:\n        if (e == null) {\n          e = new ActionEvent(this, ActionEvent.ACTION_PERFORMED,\n              command, mostRecentEventTime,\n              modifiers);\n        }\n        ((ActionListener) listeners[i + 1]).actionPerformed(e);\n"
1553,setImageData,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,240,244,4,/**\n   * Sets the image data.\n   * This clears the buffered image.\n   */,5,  public void setImageData(byte[] imageData) {\n    willChange();\n    this.imageData = imageData;\n    this.bufferedImage = null;\n    changed();\n
1554,getBufferedImage,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,262,274,4,"/**\n   * Gets the buffered image. If necessary, this method creates the buffered\n   * image from the image data.\n   */",13,"  public BufferedImage getBufferedImage() {\n    if (bufferedImage == null && imageData != null) {\n      try {\n        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));\n      } catch (IOException e) {\n        e.printStackTrace();\n        // If we can't create a buffered image from the image data,\n        // there is no use to keep the image data and try again, so\n        // we drop the image data.\n        imageData = null;\n      }\n    }\n    return bufferedImage;\n"
1557,PickAttributesAction,PickAttributesAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/PickAttributesAction.java,35,38,1,/** Creates a new instance. */,4,"  public PickAttributesAction(DrawingEditor editor) {\n    super(editor);\n    labels.configureAction(this, ""edit.pickAttributes"");\n    setEnabled(true);\n"
1561,ImageFigure,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,57,58,1,/** Creates a new instance. */,2,"  public ImageFigure() {\n    this(0, 0, 0, 0);\n"
1563,setImage,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,229,233,8,"/**\n   * Sets the image.\n   *\n   * @param imageData The image data. If this is null, a buffered image must\n   * be provided.\n   * @param bufferedImage An image constructed from the imageData. If this\n   * is null, imageData must be provided.\n   */",5,"  public void setImage(byte[] imageData, BufferedImage bufferedImage) {\n    willChange();\n    this.imageData = imageData;\n    this.bufferedImage = bufferedImage;\n    changed();\n"
1566,getEventSetDescriptors,JPopupButtonBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java,116,117,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1567,setBufferedImage,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,251,255,4,/**\n   * Sets the buffered image.\n   * This clears the image data.\n   */,5,  public void setBufferedImage(BufferedImage image) {\n    willChange();\n    this.imageData = null;\n    this.bufferedImage = image;\n    changed();\n
1568,getDefaultEventIndex,JPopupButtonBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java,150,151,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1569,getImageData,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,281,296,4,"/**\n   * Gets the image data. If necessary, this method creates the image\n   * data from the buffered image.\n   */",16,"  public byte[] getImageData() {\n    if (bufferedImage != null && imageData == null) {\n      try {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        ImageIO.write(bufferedImage, ""PNG"", bout);\n        bout.close();\n        imageData = bout.toByteArray();\n      } catch (IOException e) {\n        e.printStackTrace();\n        // If we can\'t create image data from the buffered image,\n        // there is no use to keep the buffered image and try again, so\n        // we drop the buffered image.\n        bufferedImage = null;\n      }\n    }\n    return imageData;\n"
1570,getDefaultPropertyIndex,JPopupButtonBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java,139,140,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1572,transform,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,156,161,4,/**\n   * Transforms the figure.\n   * @param tx The transformation.\n   */,6,"  public void transform(AffineTransform tx) {\n    Point2D.Double anchor = getStartPoint();\n    Point2D.Double lead = getEndPoint();\n    setBounds(\n        (Point2D.Double) tx.transform(anchor, anchor),\n        (Point2D.Double) tx.transform(lead, lead));\n"
1573,getPropertyDescriptors,JPopupButtonBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java,105,106,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1574,getBeanDescriptor,JPopupButtonBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java,89,90,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1575,figureContains,ImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/ImageFigure.java,138,142,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,5,"  public boolean figureContains(Point2D.Double p) {\n    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();\n    double grow = AttributeKeys.getPerpendicularHitGrowth(this) + 1d;\n    Geom.grow(r, grow, grow);\n    return r.contains(p);\n"
1576,getMethodDescriptors,JPopupButtonBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JPopupButtonBeanInfo.java,127,128,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1577,GroupFigure,GroupFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GroupFigure.java,28,29,1,/** Creates a new instance. */,2,  public GroupFigure() {\n    setConnectable(false);\n
1578,getMethodDescriptors,JLifeFormattedTexAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java,119,120,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1579,getDefaultPropertyIndex,JLifeFormattedTexAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java,131,132,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1580,getEventSetDescriptors,JLifeFormattedTexAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java,108,109,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1581,getBeanDescriptor,JLifeFormattedTexAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java,81,82,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1582,ZoomAction,ZoomAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ZoomAction.java,34,36,3,/**\n   * Creates a new instance.\n   */,3,"  public ZoomAction(DrawingEditor editor, double scaleFactor, AbstractButton button) {\n    this((DrawingView) null, scaleFactor, button);\n    setEditor(editor);\n"
1583,getDefaultEventIndex,JLifeFormattedTexAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java,142,143,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1585,getPropertyDescriptors,JLifeFormattedTexAreaBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/JLifeFormattedTexAreaBeanInfo.java,97,98,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1588,GraphicalCompositeFigure,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,105,106,4,/**\n   * Default constructor which uses nothing as presentation\n   * figure. This constructor is needed by the Storable mechanism.\n   */,2,  public GraphicalCompositeFigure() {\n    this(null);\n
1589,getDrawingArea,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,152,157,4,/**\n   * Return the draw area. This method is delegated to the\n   * encapsulated presentation figure.\n   */,6,  public Rectangle2D.Double getDrawingArea() {\n    Rectangle2D.Double r = super.getDrawingArea();\n    if (getPresentationFigure() != null) {\n      r.add(getPresentationFigure().getDrawingArea());\n    }\n    return r;\n
1590,GraphicalCompositeFigure,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,114,116,6,/**\n   * Constructor which creates a GraphicalCompositeFigure with\n   * a given graphical figure for presenting it.\n   *\n   * @param  newPresentationFigure  figure which renders the container\n   */,3,  public GraphicalCompositeFigure(Figure newPresentationFigure) {\n    super();\n    setPresentationFigure(newPresentationFigure);\n
1591,setPresentationFigure,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,236,247,11,/**\n   * Set a figure which renders this BasicCompositeFigure. The presentation\n   * tasks for the BasicCompositeFigure are delegated to this presentation\n   * figure.\n   * \n   * \n   * \n   * \n   * \n   * @param newPresentationFigure  figure takes over the presentation tasks\n   */,12,  public void setPresentationFigure(Figure newPresentationFigure) {\n    if (this.presentationFigure != null) {\n      this.presentationFigure.removeFigureListener(presentationFigureHandler);\n      if (getDrawing() != null) {\n        this.presentationFigure.removeNotify(getDrawing());\n      }\n    }\n    this.presentationFigure = newPresentationFigure;\n    if (this.presentationFigure != null) {\n      this.presentationFigure.addFigureListener(presentationFigureHandler);\n      if (getDrawing() != null) {\n        this.presentationFigure.addNotify(getDrawing());\n
1592,SelectionColorChooserAction,SelectionColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/SelectionColorChooserAction.java,39,40,1,/** Creates a new instance. */,2,"  public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {\n    this(editor, key, null, icon);\n"
1593,SelectionColorChooserAction,SelectionColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/SelectionColorChooserAction.java,35,36,1,/** Creates a new instance. */,2,"  public SelectionColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {\n    this(editor, key, null, null);\n"
1594,setBounds,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,164,176,5,/**\n   * Moves the figure. This is the\n   * method that subclassers override. Clients usually\n   * call displayBox.\n   */,13,"  public void setBounds(Point2D.Double anchor, Point2D.Double lead) {\n    if (getLayouter() == null) {\n      super.setBounds(anchor, lead);\n      basicSetPresentationFigureBounds(anchor, lead);\n    } else {\n      Rectangle2D.Double r = getLayouter().layout(this, anchor, lead);\n      basicSetPresentationFigureBounds(new Point2D.Double(r.getX(), r.getY()),\n          new Point2D.Double(\n          Math.max(lead.x, (int) r.getMaxX()),\n          Math.max(lead.y, (int) r.getMaxY())\n          )\n          );\n      invalidate();\n"
1595,get,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,313,320,3,/**\n   * Gets an attribute from the figure.\n   */,8,  @Override\n  public <T> T get(AttributeKey<T> key) {\n    if (getPresentationFigure() != null) {\n      return getPresentationFigure().get(key);\n    } else {\n      return (! attributes.containsKey(key)) ?\n        key.getDefaultValue() :\n        key.get(attributes);\n
1596,transform,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,193,196,4,/**\n   * Standard presentation method which is delegated to the encapsulated presentation figure.\n   * The presentation figure is moved as well as all contained figures.\n   */,4,  public void transform(AffineTransform tx) {\n    super.transform(tx);\n    if (getPresentationFigure() != null) {\n      getPresentationFigure().transform(tx);\n
1597,getBounds,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,123,125,4,/**\n   * Return the logcal display area. This method is delegated to the encapsulated\n   * presentation figure.\n   */,3,  public Rectangle2D.Double getBounds() {\n    if (getPresentationFigure() == null) return super.getBounds();\n    return getPresentationFigure().getBounds();\n
1598,applyAttributesTo,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,326,329,3,/**\n   * Applies all attributes of this figure to that figure.\n   */,4,"  @SuppressWarnings(""unchecked"")\n  protected void applyAttributesTo(Figure that) {\n    for (Map.Entry<AttributeKey, Object> entry : attributes.entrySet()) {\n      that.set(entry.getKey(), entry.getValue());\n"
1599,createHandles,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,217,222,3,/**\n   * Return default handles from the presentation figure.\n   */,6,"  public Collection<Handle> createHandles(int detailLevel) {\n    LinkedList<Handle> handles = new LinkedList<Handle>();\n    if (detailLevel == 0) {\n    MoveHandle.addMoveHandles(this, handles);\n    }\n    return handles;\n"
1600,getPresentationFigure,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,264,265,11,/**\n   * Get a figure which renders this BasicCompositeFigure. The presentation\n   * tasks for the BasicCompositeFigure are delegated to this presentation\n   * figure.\n   * \n   * \n   * \n   * \n   * \n   * @return figure takes over the presentation tasks\n   */,2,  public Figure getPresentationFigure() {\n    return presentationFigure;\n
1601,draw,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,203,205,3,/**\n   * Draw the figure. This method is delegated to the encapsulated presentation figure.\n   */,3,  public void draw(Graphics2D g) {\n    drawPresentationFigure(g);\n    super.draw(g);\n
1602,set,GraphicalCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GraphicalCompositeFigure.java,289,297,5,/**\n   * Sets an attribute of the figure.\n   * AttributeKey name and semantics are defined by the class implementing\n   * the figure interface.\n   */,9,"  @Override\n  public <T> void set(AttributeKey<T> key, T newValue) {\n    if (forbiddenAttributes == null\n        || ! forbiddenAttributes.contains(key)) {\n      if (getPresentationFigure() != null) {\n        getPresentationFigure().set(key, newValue);\n      }\n      super.set(key, newValue);\n      Object oldValue = attributes.put(key, newValue);\n"
1603,GridConstrainer,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,77,78,8,"/**\n   * Creates a new instance with the specified grid size, \n   * and by 11.25 (in degrees) for rotations.\n   * The grid is visible.\n   *\n   * @param width The width of a grid cell.\n   * @param height The height of a grid cell.\n   */",2,"  public GridConstrainer(double width, double height) {\n    this(width, height, Math.PI / 8d, true);\n"
1604,getMajorGridSpacing,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,366,367,3,/**\n   * Spacing between major grid lines.\n   */,2,  public int getMajorGridSpacing() {\n    return majorGridSpacing;\n
1605,GridConstrainer,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,65,66,3,/**\n   * Creates a new instance with a grid of 1x1.\n   */,2,"  public GridConstrainer() {\n    this(1d, 1d, 0d, false);\n"
1606,translatePoint,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,211,239,3,/**\n   * Moves a point to the closest grid point in a direction.\n   */,27,"  public Point2D.Double translatePoint(Point2D.Double p, TranslationDirection dir) {\n    Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());\n    switch (dir) {\n      case NORTH:\n      case NORTH_WEST:\n      case NORTH_EAST:\n        p.y = p0.y - height;\n        break;\n      case SOUTH:\n      case SOUTH_WEST:\n      case SOUTH_EAST:\n        p.y = p0.y + height;\n        break;\n    }\n    switch (dir) {\n      case WEST:\n      case NORTH_WEST:\n      case SOUTH_WEST:\n        p.x = p0.x - width;\n        break;\n      case EAST:\n      case NORTH_EAST:\n      case SOUTH_EAST:\n        p.x = p0.x + width;\n        break;\n    }\n    return p;\n"
1607,GridConstrainer,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,100,107,8,/**\n   * Creates a new instance with the specified grid size.\n   *\n   * @param width The width of a grid cell.\n   * @param height The height of a grid cell.\n   * @param theta The theta for rotations in radians.\n   * @param visible Wether the grid is visible or not.\n   */,8,"  public GridConstrainer(double width, double height, double theta, boolean visible) {\n    if (width <= 0 || height <= 0) {\n      throw new IllegalArgumentException(""Width or height is <= 0"");\n    }\n    this.width = width;\n    this.height = height;\n    this.theta = theta;\n    this.isVisible = visible;\n"
1608,constrainPoint,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,161,205,9,/**\n   * Constrains the placement of a point towards a direction.\n   * <p>\n   * This method changes the point which is passed as a parameter.\n   *\n   * @param p A point on the drawing.\n   * @param dir A direction.\n   * @return Returns the constrained point.\n   */,43,"  protected Point2D.Double constrainPoint(Point2D.Double p, TranslationDirection dir) {\n    Point2D.Double p0 = constrainPoint((Point2D.Double) p.clone());\n    switch (dir) {\n      case NORTH:\n      case NORTH_WEST:\n      case NORTH_EAST:\n        if (p0.y < p.y) {\n          p.y = p0.y;\n        } else if (p0.y > p.y) {\n          p.y = p0.y - height;\n        }\n        break;\n      case SOUTH:\n      case SOUTH_WEST:\n      case SOUTH_EAST:\n        if (p0.y < p.y) {\n          p.y = p0.y + height;\n        } else if (p0.y > p.y) {\n          p.y = p0.y;\n        }\n        break;\n    }\n    switch (dir) {\n      case WEST:\n      case NORTH_WEST:\n      case SOUTH_WEST:\n        if (p0.x < p.x) {\n          p.x = p0.x;\n        } else if (p0.x > p.x) {\n          p.x = p0.x - width;\n        }\n        break;\n      case EAST:\n      case NORTH_EAST:\n      case SOUTH_EAST:\n        if (p0.x < p.x) {\n          p.x = p0.x + width;\n        } else if (p0.x > p.x) {\n          p.x = p0.x;\n        }\n        break;\n    }\n    return p;\n"
1609,constrainRectangle,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,270,303,10,/**\n   * Constrains the placement of a rectangle towards a direction.\n   * <p>\n   * This method changes the location of the rectangle which is passed as a\n   * parameter. This method does not change the size of the rectangle.\n   *\n   * @param r A rectangle on the drawing.\n   * @param dir A direction.\n   * @return Returns the constrained rectangle.\n   */,31,"  protected Rectangle2D.Double constrainRectangle(Rectangle2D.Double r, TranslationDirection dir) {\n    Point2D.Double p0 = new Point2D.Double(r.x, r.y);\n    switch (dir) {\n      case NORTH:\n      case NORTH_WEST:\n      case WEST:\n        constrainPoint(p0, dir);\n        break;\n      case EAST:\n      case NORTH_EAST:\n        p0.x += r.width;\n        constrainPoint(p0, dir);\n        p0.x -= r.width;\n        break;\n      case SOUTH:\n      case SOUTH_WEST:\n        p0.y += r.height;\n        constrainPoint(p0, dir);\n        p0.y -= r.height;\n        break;\n      case SOUTH_EAST:\n        p0.y += r.height;\n        p0.x += r.width;\n        constrainPoint(p0, dir);\n        p0.y -= r.height;\n        p0.x -= r.width;\n        break;\n    }\n    r.x = p0.x;\n    r.y = p0.y;\n    return r;\n"
1610,GridConstrainer,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,89,90,8,/**\n   * Creates a new instance with the specified grid size.\n   * and by 11.25 (in degrees) for rotations.\n   *\n   * @param width The width of a grid cell.\n   * @param height The height of a grid cell.\n   * @param visible Wether the grid is visible or not.\n   */,2,"  public GridConstrainer(double width, double height, boolean visible) {\n    this(width, height, Math.PI / 8d, visible);\n"
1611,setMajorGridSpacing,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,373,377,3,/**\n   * Spacing between major grid lines.\n   */,5,"  public void setMajorGridSpacing(int newValue) {\n    int oldValue = majorGridSpacing;\n    majorGridSpacing = newValue;\n    firePropertyChange(""majorGridSpacing"", oldValue, newValue);\n    fireStateChanged();\n"
1612,constrainPoint,GridConstrainer,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/GridConstrainer.java,146,149,3,/**\n   * Constrains a point to the closest grid point in any direction.\n   */,4,  public Point2D.Double constrainPoint(Point2D.Double p) {\n    p.x = Math.round(p.x / width) * width;\n    p.y = Math.round(p.y / height) * height;\n    return p;\n
1613,getChildrenFrontToBack,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,183,186,4,/**\n   * Returns an iterator to iterate in\n   * Z-order front to back over the children.\n   */,4,  public java.util.List<Figure> getChildrenFrontToBack() {\n    return children ==  null ?\n      new LinkedList<Figure>() :\n      new ReversedList<Figure>(children);\n
1616,transform,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,102,107,3,/**\n   * Transforms the figure.\n   */,6,  public void transform(AffineTransform tx) {\n    super.transform(tx);\n    for (Figure f : children) {\n      f.transform(tx);\n    }\n    invalidate();\n
1617,fireFigureAdded,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,328,340,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,13,"  protected void fireFigureAdded(Figure f, int zIndex) {\n    CompositeFigureEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length-2; i>=0; i-=2) {\n      if (listeners[i] == CompositeFigureListener.class) {\n        // Lazily create the event:\n        if (event == null)\n          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);\n        ((CompositeFigureListener)listeners[i+1]).figureAdded(event);\n"
1618,set,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,138,143,8,/**\n   * Sets an attribute of the figure.\n   * AttributeKey name and semantics are defined by the class implementing\n   * the figure interface.\n   */\n --------------\n// ATTRIBUTES\n --------------,6,"  public <T> void set(AttributeKey<T> key, T newValue) {\n    super.set(key, newValue);\n    if (isAttributeEnabled(key)) {\n      if (children != null) {\n        for (Figure child : children) {\n          child.set(key, newValue);\n"
1619,fireFigureRemoved,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,349,361,4,/**\n   *  Notify all listenerList that have registered interest for\n   * notification on this event type.\n   */,13,"  protected void fireFigureRemoved(Figure f, int zIndex) {\n    CompositeFigureEvent event = null;\n    // Notify all listeners that have registered interest for\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length-2; i>=0; i-=2) {\n      if (listeners[i] == CompositeFigureListener.class) {\n        // Lazily create the event:\n        if (event == null)\n          event = new CompositeFigureEvent(this, f, f.getDrawingArea(), zIndex);\n        ((CompositeFigureListener)listeners[i+1]).figureRemoved(event);\n"
1622,getLayouter,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,271,272,12,"/**\n   * Get a Layouter object which encapsulated a layout\n   * algorithm for this figure. Typically, a Layouter\n   * accesses the child components of this figure and arranges\n   * their graphical presentation.\n   *\n   *\n   * @return layout strategy used by this figure\n   */\n --------------\n// LAYOUT\n --------------",2,  public Layouter getLayouter() {\n    return layouter;\n
1623,layout,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,284,291,6,/**\n   * A layout algorithm is used to define how the child components\n   * should be laid out in relation to each other. The task for\n   * layouting the child components for presentation is delegated\n   * to a Layouter which can be plugged in at runtime.\n   */,8,"  public void layout() {\n    if (getLayouter() != null) {\n      Rectangle2D.Double bounds = getBounds();\n      Point2D.Double p = new Point2D.Double(bounds.x, bounds.y);\n      Rectangle2D.Double r = getLayouter().layout(\n          this, p, p\n          );\n      invalidate();\n"
1625,draw,LabeledLineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LabeledLineConnectionFigure.java,89,93,3,/**\n   * Draw the figure. This method is delegated to the encapsulated presentation figure.\n   */,5,  public void draw(Graphics2D g) {\n    super.draw(g);\n    for (Figure child : children) {\n      if (child.isVisible()) {\n        child.draw(g);\n
1631,contains,EllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java,111,119,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,8,  public boolean contains(Point2D.Double p) {\n    Ellipse2D.Double r = (Ellipse2D.Double) ellipse.clone();\n    double grow = AttributeKeys.getPerpendicularHitGrowth(this);\n    r.x -= grow;\n    r.y -= grow;\n    r.width += grow * 2;\n    r.height += grow * 2;\n    return r.contains(p);\n
1632,EllipseFigure,EllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java,37,38,4,"/**\n   * Constructs a new {@code EllipseFigure}, initialized to\n   * location (0,&nbsp;0) and size (0,&nbsp;0).\n   */",2,"  public EllipseFigure() {\n    this(0, 0, 0, 0);\n"
1634,EllipseFigure,EllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/EllipseFigure.java,50,51,9,/**\n   * Constructs and initializes an {@code EllipseFigure} from the\n   * specified coordinates.\n   *\n   * @param x the x coordinate of the bounding rectangle\n   * @param y the y coordinate of the bounding rectangle\n   * @param width the width of the rectangle\n   * @param height the height of the rectangle\n   */,2,"  public EllipseFigure(double x, double y, double width, double height) {\n    ellipse = new Ellipse2D.Double(x, y, width, height);\n"
1637,mouseReleased,DelegationSelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java,125,137,4,"/**\n   * MouseListener method for mouseReleased events. If the popup trigger has\n   * been activated, then the appropriate hook method is called.\n   */",12,  public void mouseReleased(MouseEvent evt) {\n    if (popupTimer != null) {\n      popupTimer.stop();\n      popupTimer = null;\n    }\n    if (isMousePressedPopupTrigger) {\n      isMousePressedPopupTrigger = false;\n    } else {\n      if (evt.isPopupTrigger()) {\n        handlePopupMenu(evt);\n      } else {\n        super.mouseReleased(evt);\n
1638,handlePopupMenu,DelegationSelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java,179,185,4,/**\n   * Hook method which can be overriden by subclasses to provide\n   * specialised behaviour in the event of a popup trigger.\n   */,7,"  protected void handlePopupMenu(MouseEvent evt) {\n    Point p = new Point(evt.getX(), evt.getY());\n    Figure figure = getView().findFigure(p);\n    if (figure != null || drawingActions.size() > 0) {\n      showPopupMenu(figure, p, evt.getComponent());\n    } else {\n      popupMenu = null;\n"
1639,DelegationSelectionTool,DelegationSelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java,72,73,1,/** Creates a new instance. */,2,"  public DelegationSelectionTool() {\n    this(new LinkedList<Action>(), new LinkedList<Action>());\n"
1640,DelegationSelectionTool,DelegationSelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java,77,79,1,/** Creates a new instance. */,3,"  public DelegationSelectionTool(Collection<Action> drawingActions, Collection<Action> selectionActions) {\n    this.drawingActions = drawingActions;\n    this.selectionActions = selectionActions;\n"
1641,mousePressed,DelegationSelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java,94,117,4,"/**\n   * MouseListener method for mousePressed events. If the popup trigger has\n   * been activated, then the appropriate hook method is called.\n   */",22,"  public void mousePressed(final MouseEvent evt) {\n    if (popupTimer != null) {\n      popupTimer.stop();\n      popupTimer = null;\n    }\n    // XXX - When we want to support multiple views, we have to\n    //     implement this:\n    //setView((DrawingView)e.getSource());\n    isMousePressedPopupTrigger = evt.isPopupTrigger();\n    if (isMousePressedPopupTrigger) {\n      getView().requestFocus();\n      handlePopupMenu(evt);\n    } else {\n      super.mousePressed(evt);\n      popupTimer = new javax.swing.Timer(1000, new ActionListener() {\n        public void actionPerformed(ActionEvent aevt) {\n          handlePopupMenu(evt);\n          popupTimer = null;\n        }\n      });\n      popupTimer.setRepeats(false);\n      popupTimer.start();\n"
1642,handleDoubleClick,DelegationSelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DelegationSelectionTool.java,266,328,4,/**\n   * Hook method which can be overriden by subclasses to provide\n   * specialised behaviour in the event of a double click.\n   */,60,"  protected void handleDoubleClick(MouseEvent evt) {\n    if (DEBUG) {\n      System.out.println(""DelegationSelectionTool.handleDoubleClick "" + evt);\n    }\n    DrawingView v = getView();\n    Point pos = new Point(evt.getX(), evt.getY());\n    Handle handle = v.findHandle(pos);\n    if (handle != null) {\n      if (DEBUG) {\n        System.out.println(""DelegationSelectionTool.handleDoubleClick by handle"");\n      }\n      handle.trackDoubleClick(pos, evt.getModifiersEx());\n    } else {\n      Point2D.Double p = viewToDrawing(pos);\n      // Note: The search sequence used here, must be\n      // consistent with the search sequence used by the\n      // HandleTracker, the SelectAreaTracker and SelectionTool.\n      // If possible, continue to work with the current selection\n      Figure figure = null;\n      if (isSelectBehindEnabled()) {\n        for (Figure f : v.getSelectedFigures()) {\n          if (f.contains(p)) {\n            figure = f;\n            break;\n          }\n        }\n      }\n      // If the point is not contained in the current selection,\n      // search for a figure in the drawing.\n      if (figure == null) {\n        figure = v.findFigure(pos);\n      }\n      Figure outerFigure = figure;\n      if (figure != null && figure.isSelectable()) {\n        if (DEBUG) {\n          System.out.println(""DelegationSelectionTool.handleDoubleClick by figure"");\n        }\n        Tool figureTool = figure.getTool(p);\n        if (figureTool == null) {\n          figure = getDrawing().findFigureInside(p);\n          if (figure != null) {\n            figureTool = figure.getTool(p);\n          }\n        }\n        if (figureTool != null) {\n          setTracker(figureTool);\n          figureTool.mousePressed(evt);\n        } else {\n          if (outerFigure.handleMouseClick(p, evt, getView())) {\n            v.clearSelection();\n            v.addToSelection(outerFigure);\n          } else {\n            v.clearSelection();\n            v.addToSelection(outerFigure);\n            v.setHandleDetailLevel(v.getHandleDetailLevel() + 1);\n          }\n        }\n      }\n    }\n    evt.consume();\n"
1644,DefaultHandleTracker,DefaultHandleTracker,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/DefaultHandleTracker.java,64,66,1,/** Creates a new instance. */,3,  public DefaultHandleTracker(Handle handle) {\n    masterHandle = handle;\n    multicaster = new HandleMulticaster(handle);\n
1645,ImageTool,ImageTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ImageTool.java,57,58,1,/** Creates a new instance. */,2,  public ImageTool(ImageHolderFigure prototype) {\n    super(prototype);\n
1646,ImageTool,ImageTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/ImageTool.java,62,63,1,/** Creates a new instance. */,2,"  public ImageTool(ImageHolderFigure prototype, Map<AttributeKey, Object> attributes) {\n    super(prototype, attributes);\n"
1647,CreationTool,CreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java,144,145,11,"/** Creates a new instance with the specified prototype but without an\n   * attribute set. The CreationTool clones this prototype each time a new\n   * Figure needs to be created. When a new Figure is created, the\n   * CreationTool applies the default attributes from the DrawingEditor to it,\n   * and then it applies the attributes to it, that have been supplied in\n   * this constructor.\n   *\n   * @param prototype The prototype used to create a new Figure.\n   * @param attributes The CreationTool applies these attributes to the\n   * prototype after having applied the default attributes from the DrawingEditor.\n   */",2,"  public CreationTool(Figure prototype, Map<AttributeKey, Object> attributes) {\n    this(prototype, attributes, null);\n"
1648,CreationTool,CreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java,158,165,10,"/**\n   * Creates a new instance with the specified prototype and attribute set.\n   *\n   * @param prototype The prototype used to create a new Figure.\n   * @param attributes The CreationTool applies these attributes to the\n   * prototype after having applied the default attributes from the DrawingEditor.\n   * @param name The name parameter is currently not used.\n   * @deprecated This constructor might go away, because the name parameter\n   * is not used.\n   */",8,"  public CreationTool(Figure prototype, Map<AttributeKey, Object> attributes, String name) {\n    this.prototype = prototype;\n    this.prototypeAttributes = attributes;\n    if (name == null) {\n      ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n      name = labels.getString(""edit.createFigure.text"");\n    }\n    this.presentationName = name;\n"
1649,CreationTool,CreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java,129,130,7,"/** Creates a new instance with the specified prototype but without an\n   * attribute set. The CreationTool clones this prototype each time a new\n   *  Figure needs to be created. When a new Figure is created, the\n   * CreationTool applies the default attributes from the DrawingEditor to it.\n   *\n   * @param prototype The prototype used to create a new Figure.\n   */",2,"  public CreationTool(Figure prototype) {\n    this(prototype, null, null);\n"
1650,CreationTool,CreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java,98,99,1,/** Creates a new instance. */,2,"  public CreationTool(String prototypeClassName) {\n    this(prototypeClassName, null, null);\n"
1651,setToolDoneAfterCreation,CreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java,310,312,5,"/**\n   * If this is set to false, the CreationTool does not fire toolDone\n   * after a new Figure has been created. This allows to create multiple\n   * figures consecutively.\n   */",3,  public void setToolDoneAfterCreation(boolean newValue) {\n    boolean oldValue = isToolDoneAfterCreation;\n    isToolDoneAfterCreation = newValue;\n
1652,creationFinished,CreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/CreationTool.java,296,301,5,/**\n   * This method allows subclasses to do perform additonal user interactions\n   * after the new figure has been created.\n   * The implementation of this class just invokes fireToolDone.\n   */,6,  protected void creationFinished(Figure createdFigure) {\n    if (createdFigure.isSelectable()) {\n      getView().addToSelection(createdFigure);\n    }\n    if (isToolDoneAfterCreation()) {\n      fireToolDone();\n
1653,ImageTransferable,ImageTransferable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/ImageTransferable.java,44,45,1,/** Creates a new instance. */,2,  public ImageTransferable(Image image) {\n    this.image = image;\n
1654,setUpdateDrawingEditorDefaults,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,242,243,6,/**\n   * Set this to true if you want the attribute editor to update the\n   * default values of the drawing editor.\n   * \n   * @param newValue\n   */,2,  public void setUpdateDrawingEditorDefaults(boolean newValue) {\n    isUpdateDrawingEditorDefaults = newValue;\n
1655,setView,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,222,224,9,"/**\n   * Attaches the FigureAttributeEditorHandler to the specified DrawingView.\n   * <p>\n   * If a non-null value is provided, the FigureAttributeEditorHandler listens only\n   * to selection changes of the specified view. If a null value is provided,\n   * the FigureAttributeEditorHandler listens to all views of the drawing editor.\n   *\n   * @param newValue a drawing view.\n   */",3,  public void setView(DrawingView newValue) {\n    this.view = newValue;\n    updateActiveView();\n
1656,setDrawingEditor,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,193,202,9,/**\n   * Attaches the FigureAttributeEditorHandler to the specified DrawingEditor.\n   * <p>\n   * The FigureAttributeEditorHandler listens to view changes and selection\n   * changes of the drawing editor and calls setEnabled(boolean) and\n   * updateField(Set&lt;Figure&gt;) on the field accordingly.\n   *\n   * @param newValue a drawing editor.\n   */,10,  public void setDrawingEditor(DrawingEditor newValue) {\n    DrawingEditor oldValue = drawingEditor;\n    if (drawingEditor != null) {\n      drawingEditor.removePropertyChangeListener(eventHandler);\n    }\n    this.drawingEditor = newValue;\n    if (drawingEditor != null) {\n      drawingEditor.addPropertyChangeListener(new WeakPropertyChangeListener(eventHandler));\n    }\n    updateActiveView();\n
1657,setAttributeEditor,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,265,271,3,/**\n   * Attaches the FigureAttributeEditorHandler to the specified AttributeEditor.\n   */,7,  public void setAttributeEditor(AttributeEditor<T> newValue) {\n    if (attributeEditor != null) {\n      attributeEditor.removePropertyChangeListener(eventHandler);\n    }\n    this.attributeEditor = newValue;\n    if (attributeEditor != null) {\n      attributeEditor.addPropertyChangeListener(eventHandler);\n
1658,getAttributeEditor,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,279,280,4,/**\n   * Returns the AttributeEditor to which this FigureAttributeEditorHandler is\n   * attached. \n   */,2,  public AttributeEditor<T> getAttributeEditor() {\n    return attributeEditor;\n
1659,getView,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,232,233,5,"/**\n   * Returns the DrawingView to which this FigureAttributeEditorHandler is\n   * attached. Returns null, if the FigureAttributeEditorHandler is attached\n   * to all views of the DrawingEditor.\n   */",2,  public DrawingView getView() {\n    return view;\n
1660,isUpdateDrawingEditorDefaults,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,250,251,4,/**\n   * Returns true if the attribute editor updates the\n   * default values of the drawing editor.\n   */,2,  public boolean isUpdateDrawingEditorDefaults() {\n    return isUpdateDrawingEditorDefaults;\n
1661,getDrawingEditor,AbstractAttributeEditorHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/AbstractAttributeEditorHandler.java,209,210,4,/**\n   * Returns the DrawingEditor to which this FigureAttributeEditorHandler is\n   * attached.\n   */,2,  public DrawingEditor getDrawingEditor() {\n    return drawingEditor;\n
1662,create,GenericListener,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java,104,138,6,"/**\n   * Return an instance of a class that implements the interface that contains\n   * the declaration for <code>listenerMethod</code>.  In this new class,\n   * <code>listenerMethod</code> will apply <code>target.targetMethod</code>\n   * to the incoming Event.\n   */",35,"  public static Object create(\n  final Method listenerMethod,\n  final Object target,\n  final Method targetMethod) {\n    /**\n     * The implementation of the create method uses the Dynamic Proxy API\n     * introduced in JDK 1.3.\n     *\n     * Create an instance of the DefaultInvoker and override the invoke\n     * method to handle the invoking the targetMethod on the target.\n     */\n    InvocationHandler handler = new DefaultInvoker() {\n      @Override\n      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        \n        // Send all methods except for the targetMethod to\n        // the superclass for handling.\n        if (listenerMethod.equals(method)) {\n          if (targetMethod.getParameterTypes().length == 0) {\n            // Special treatment for parameterless target methods:\n            return targetMethod.invoke(target, new Object[0]);\n          } else {\n            // Regular treatment for target methods having the same\n            // argument list as the listener method.\n            return targetMethod.invoke(target, args);\n          }\n        } else {\n          return super.invoke(proxy, method, args);\n        }\n      }\n    };\n    \n    Class cls = listenerMethod.getDeclaringClass();\n    ClassLoader cl = cls.getClassLoader();\n    return Proxy.newProxyInstance(cl, new Class[]{cls}, handler);\n"
1663,getListenerMethod,GenericListener,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java,202,218,7,"/* Helper methods for ""EZ"" version of create(): */\n --------------\n/**\n   * Implementation of the InvocationHandler which handles the basic\n   * object methods.\n   */\n --------------",17,"  private static Method getListenerMethod(Class listenerInterface,\n  String listenerMethodName) {\n    // given the arguments to create(), find out which listener is desired:\n    Method[] m = listenerInterface.getMethods();\n    Method result = null;\n    for (int i = 0; i < m.length; i++) {\n      if (listenerMethodName.equals(m[i].getName())) {\n        if (result != null) {\n          throw new RuntimeException(""ambiguous method: ""+m[i]+"" vs. ""+result);\n        }\n        result = m[i];\n      }\n    }\n    if (result == null) {\n      throw new RuntimeException(""no such method ""+listenerMethodName+"" in ""+listenerInterface);\n    }\n    return result;\n"
1664,create,GenericListener,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/GenericListener.java,73,94,4,"/**\n   * A convenient version of <code>create(listenerMethod, targetObject, targetMethod)</code>.\n   * This version looks up the listener and target Methods, so you don\'t have to.\n   */",22,"  public static Object create(\n  Class listenerInterface,\n  String listenerMethodName,\n  Object target,\n  String targetMethodName) {\n    Method listenerMethod = getListenerMethod(listenerInterface, listenerMethodName);\n    \n    // Search a target method with the same parameter types as the listener method.\n    Method targetMethod =\n    getTargetMethod(target, targetMethodName, listenerMethod.getParameterTypes());\n    \n    // Nothing found? Search a target method with no parameters\n    if (targetMethod == null) {\n      targetMethod = getTargetMethod(target, targetMethodName, new Class[0]);\n    }\n    \n    // Still nothing found? We give up.\n    if (targetMethod == null) {\n      throw new RuntimeException(""no such method ""+targetMethodName+"" in ""+target.getClass());\n    }\n    \n    return create(listenerMethod, target, targetMethod);\n"
1665,JNLPClipboard,JNLPClipboard,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/datatransfer/JNLPClipboard.java,49,50,7,/**\n   * Creates a new proxy for the specified target object.\n   * The target object must have a getContent and a setContent method\n   * as specified by the {@code javax.jnlp.ClipboardService} interface.\n   *\n   * @param target A Clipboard object.\n   */,2,  public JNLPClipboard(Object target) {\n    this.target = target;\n
1666,NetPanel,NetPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetPanel.java,50,115,1,/** Creates new instance. */,66,"  public NetPanel() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    initComponents();\n    undoManager = new UndoRedoManager();\n    editor = new DefaultDrawingEditor();\n    editor.add(view);\n    \n    addCreationButtonsTo(creationToolbar, editor);\n    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);\n    \n    JPopupButton pb = new JPopupButton();\n    pb.setItemFont(UIManager.getFont(""MenuItem.font""));\n    labels.configureToolBarButton(pb, ""actions"");\n    pb.add(new DuplicateAction());\n    pb.addSeparator();\n    pb.add(new GroupAction(editor));\n    pb.add(new UngroupAction(editor));\n    pb.addSeparator();\n    pb.add(new BringToFrontAction(editor));\n    pb.add(new SendToBackAction(editor));\n    pb.addSeparator();\n    pb.add(new CutAction());\n    pb.add(new CopyAction());\n    pb.add(new PasteAction());\n    pb.add(new SelectAllAction());\n    pb.add(new SelectSameAction(editor));\n    pb.addSeparator();\n    pb.add(undoManager.getUndoAction());\n    pb.add(undoManager.getRedoAction());\n     // FIXME - We need a toggle grid action\n     // pb.addSeparator();\n     // pb.add(new ToggleGridAction(editor));\n    \n    JMenu m = new JMenu(labels.getString(""view.zoomFactor.text""));\n    JRadioButtonMenuItem rbmi;\n    ButtonGroup group = new ButtonGroup();\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));\n    rbmi.setSelected(true);\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));\n    group.add(rbmi);\n    pb.add(m);\n    pb.setFocusable(false);\n    creationToolbar.addSeparator();\n    creationToolbar.add(pb);\n    \n    \n    DefaultDrawing drawing = new DefaultDrawing();\n    view.setDrawing(drawing);\n    drawing.addUndoableEditListener(undoManager);\n"
1667,initComponents,NetPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetPanel.java,140,174,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,27,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    toolButtonGroup = new javax.swing.ButtonGroup();\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    jPanel1 = new javax.swing.JPanel();\n    creationToolbar = new javax.swing.JToolBar();\n    attributesToolbar = new javax.swing.JToolBar();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n    jPanel1.setLayout(new java.awt.GridBagLayout());\n    creationToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 0;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(creationToolbar, gridBagConstraints);\n    attributesToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(attributesToolbar, gridBagConstraints);\n    add(jPanel1, java.awt.BorderLayout.SOUTH);\n"
1670,createToolBars,NetApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplicationModel.java,130,156,5,/**\n   * Creates toolbars for the application.\n   * This class always returns an empty list. Subclasses may return other\n   * values.\n   */,25,"  public java.util.List<JToolBar> createToolBars(Application a, View pr) {\n    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.net.Labels"");\n    NetView p = (NetView) pr;\n    DrawingEditor editor;\n    if (p == null) {\n      editor = getSharedEditor();\n    } else {\n      editor = p.getDrawingEditor();\n    }\n    LinkedList<JToolBar> list = new LinkedList<JToolBar>();\n    JToolBar tb;\n    tb = new JToolBar();\n    addCreationButtonsTo(tb, editor);\n    tb.setName(drawLabels.getString(""window.drawToolBar.title""));\n    list.add(tb);\n    tb = new JToolBar();\n    ButtonFactory.addAttributesButtonsTo(tb, editor);\n    tb.setName(drawLabels.getString(""window.attributesToolBar.title""));\n    list.add(tb);\n    tb = new JToolBar();\n    ButtonFactory.addAlignmentButtonsTo(tb, editor);\n    tb.setName(drawLabels.getString(""window.alignmentToolBar.title""));\n    list.add(tb);\n    return list;\n"
1671,initDrawing,NetApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java,170,183,3,/**\n   * Configure Drawing object to support copy and paste.\n   */,11,"  @SuppressWarnings(""unchecked"")\n  private void initDrawing(Drawing d) {\n    d.setInputFormats((java.util.List<InputFormat>) Collections.EMPTY_LIST);\n    d.setOutputFormats((java.util.List<OutputFormat>) Collections.EMPTY_LIST);\n    DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(\n        new NetFactory());\n    d.addInputFormat(ioFormat);\n    d.addInputFormat(new ImageInputFormat(new ImageFigure()));\n    d.addInputFormat(new TextInputFormat(new TextFigure()));\n    d.addOutputFormat(ioFormat);\n    d.addOutputFormat(new ImageOutputFormat());\n"
1673,getParameter,NetApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java,55,59,4,/**\n   * We override getParameter() to make it work even if we have no Applet\n   * context.\n   */,5,  public String getParameter(String name) {\n    try {\n      return super.getParameter(name);\n    } catch (NullPointerException e) {\n      return null;\n
1674,init,NetApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java,70,156,3,/**\n   * Initializes the applet NetApplet\n   */,78,"  public void init() {\n    // Set look and feel\n    // -----------------\n    try {\n      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Throwable e) {\n      // Do nothing.\n      // If we can\'t set the desired look and feel, UIManager does\n      // automaticaly the right thing for us.\n    }\n    // Set our own popup factory, because the one that comes with Mac OS X\n    // creates translucent popups which is not useful for color selection\n    // using pop menus.\n    try {\n      PopupFactory.setSharedInstance(new PopupFactory());\n    } catch (Throwable e) {\n      // If we can\'t set the popup factory, we have to use what is there.\n    }\n\n    // Display copyright info while we are loading the data\n    // ----------------------------------------------------\n    Container c = getContentPane();\n    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));\n    String[] labels = getAppletInfo().split(""\\n"");//Strings.split(getAppletInfo(), \'\\n\');\n    for (int i = 0; i < labels.length; i++) {\n      c.add(new JLabel((labels[i].length() == 0) ? "" "" : labels[i]));\n    }\n    // We load the data using a worker thread\n    // --------------------------------------\n    new Worker<Drawing>() {\n      protected Drawing construct() throws IOException {\n        Drawing result;\n        System.out.println(""getParameter.datafile:"" + getParameter(""datafile""));\n        if (getParameter(""data"") != null) {\n          NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), new StringReader(getParameter(""data"")));\n          result = (Drawing) domi.readObject(0);\n        } else if (getParameter(""datafile"") != null) {\n          URL url = new URL(getDocumentBase(), getParameter(""datafile""));\n          InputStream in = url.openConnection().getInputStream();\n          try {\n            NanoXMLDOMInput domi = new NanoXMLDOMInput(new NetFactory(), in);\n            result = (Drawing) domi.readObject(0);\n          } finally {\n            in.close();\n          }\n        } else {\n          result = null;\n        }\n        return result;\n      }\n      @Override\n      protected void done(Drawing result) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        c.add(drawingPanel = new NetPanel());\n        if (result != null) {\n          Drawing drawing = (Drawing) result;\n          setDrawing(drawing);\n        }\n      }\n      @Override\n      protected void failed(Throwable value) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        c.add(drawingPanel = new NetPanel());\n        value.printStackTrace();\n        getDrawing().add(new TextFigure(value.toString()));\n        value.printStackTrace();\n      }\n      @Override\n      protected void finished() {\n        Container c = getContentPane();\n        initDrawing(getDrawing());\n        c.validate();\n      }\n    }.start();\n"
1675,initComponents,NetApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetApplet.java,247,248,5,/** This method is called from within the init() method to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,2,  private void initComponents() {\n    toolButtonGroup = new javax.swing.ButtonGroup();\n
1676,getOpenChooser,SVGDrawingPanelSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java,203,228,4,/** Lazily creates a JFileChooser and returns it. */\n --------------\n/** Opens a drawing from a file. */\n --------------,25,"  private JFileChooser getOpenChooser() {\n    if (openChooser == null) {\n      openChooser = new JFileChooser();\n      Drawing d = svgPanel.getDrawing();\n      fileFilterInputFormatMap = new HashMap<javax.swing.filechooser.FileFilter, InputFormat>();\n      javax.swing.filechooser.FileFilter firstFF = null;\n      for (InputFormat format : d.getInputFormats()) {\n        javax.swing.filechooser.FileFilter ff = format.getFileFilter();\n        if (firstFF == null) {\n          firstFF = ff;\n        }\n        fileFilterInputFormatMap.put(ff, format);\n        openChooser.addChoosableFileFilter(ff);\n      }\n      openChooser.setFileFilter(firstFF);\n      openChooser.addPropertyChangeListener(new PropertyChangeListener() {\n        public void propertyChange(PropertyChangeEvent evt) {\n          if (evt.getPropertyName().equals(""fileFilterChanged"")) {\n            InputFormat inputFormat = fileFilterInputFormatMap.get(evt.getNewValue());\n            openChooser.setAccessory((inputFormat == null) ? null : inputFormat.getInputFormatAccessory());\n          }\n        }\n      });\n    }\n    return openChooser;\n"
1677,getSaveChooser,SVGDrawingPanelSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java,232,257,4,/** Lazily creates a JFileChooser and returns it. */\n --------------\n//GEN-LAST:event_open\n --------------,25,"  private JFileChooser getSaveChooser() {\n    if (saveChooser == null) {\n      saveChooser = new JFileChooser();\n      Drawing d = svgPanel.getDrawing();\n      fileFilterOutputFormatMap = new HashMap<javax.swing.filechooser.FileFilter, OutputFormat>();\n      javax.swing.filechooser.FileFilter firstFF = null;\n      for (OutputFormat format : d.getOutputFormats()) {\n        javax.swing.filechooser.FileFilter ff = format.getFileFilter();\n        if (firstFF == null) {\n          firstFF = ff;\n        }\n        fileFilterOutputFormatMap.put(ff, format);\n        saveChooser.addChoosableFileFilter(ff);\n      }\n      saveChooser.setFileFilter(firstFF);\n      saveChooser.addPropertyChangeListener(new PropertyChangeListener() {\n        public void propertyChange(PropertyChangeEvent evt) {\n          if (evt.getPropertyName().equals(""fileFilterChanged"")) {\n            OutputFormat outputFormat = fileFilterOutputFormatMap.get(evt.getNewValue());\n            saveChooser.setAccessory((outputFormat == null) ? null : outputFormat.getOutputFormatAccessory());\n          }\n        }\n      });\n    }\n    return saveChooser;\n"
1679,main,SVGDrawingPanelSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java,263,267,6,/**\n   * @param args the command line arguments\n   */\n --------------\n/** Saves a drawing to a file. */\n --------------,4,  public static void main(String args[]) {\n    java.awt.EventQueue.invokeLater(new Runnable() {\n      public void run() {\n        new SVGDrawingPanelSample().setVisible(true);\n
1680,SVGDrawingPanelSample,SVGDrawingPanelSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java,59,61,1,/** Creates new form SVGDrawingPanelSample */,3,"  public SVGDrawingPanelSample() {\n    initComponents();\n    setSize(new Dimension(600, 400));\n"
1682,initComponents,SVGDrawingPanelSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SVGDrawingPanelSample.java,69,98,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,21,"  @SuppressWarnings(""unchecked"")\n  // <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents\n  private void initComponents() {\n    svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();\n    menuBar = new javax.swing.JMenuBar();\n    fileMenu = new javax.swing.JMenu();\n    openMenuItem = new javax.swing.JMenuItem();\n    saveAsMenuItem = new javax.swing.JMenuItem();\n    FormListener formListener = new FormListener();\n    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n    getContentPane().add(svgPanel, java.awt.BorderLayout.CENTER);\n    fileMenu.setText(""File"");\n    openMenuItem.setText(""Open..."");\n    openMenuItem.addActionListener(formListener);\n    fileMenu.add(openMenuItem);\n    saveAsMenuItem.setText(""Save As..."");\n    saveAsMenuItem.addActionListener(formListener);\n    fileMenu.add(saveAsMenuItem);\n    menuBar.add(fileMenu);\n    setJMenuBar(menuBar);\n    pack();\n"
1683,main,Main,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/Main.java,27,47,1,/** Creates a new instance. */,21,"  public static void main(String[] args) {\n    Application app;\n    String os = System.getProperty(""os.name"").toLowerCase();\n    if (os.startsWith(""mac"")) {\n      app = new OSXApplication();\n    } else if (os.startsWith(""win"")) {\n      //  app = new DefaultMDIApplication();\n      app = new SDIApplication();\n    } else {\n      app = new SDIApplication();\n    }\n    \n    \n    DefaultApplicationModel model = new NetApplicationModel();\n    model.setName(""JHotDraw Net"");\n    model.setVersion(Main.class.getPackage().getImplementationVersion());\n    model.setCopyright(""Copyright 2006-2009 (c) by the authors of JHotDraw and all its contributors.\\n"" +\n        ""This software is licensed under LGPL and Creative Commons 3.0 Attribution."");\n    model.setViewClassName(""org.jhotdraw.samples.net.NetView"");\n    app.setModel(model);\n    app.launch(args);\n"
1684,main,QuickAndDirtyDOMStorableSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/QuickAndDirtyDOMStorableSample.java,62,85,1,/** DOM Storable objects must have a non-argument constructor. */,19,"  public static void main(String[] args) {\n    try {\n      // Create a DOMStorable object\n      MyObject obj = new MyObject(""Hello World"");\n      System.out.println(""The name of the original object is:"" + obj.getName());\n      // Write the object into a DOM, and then serialize the DOM into a String\n      NanoXMLDOMOutput out = new NanoXMLDOMOutput(new QuickAndDirtyDOMFactory());\n      out.writeObject(obj);\n      StringWriter writer = new StringWriter();\n      out.save(writer);\n      String serializedString = writer.toString();\n      System.out.println(""\\nThe serialized representation of the object is:\\n"" + serializedString);\n      // Deserialize a DOM from a String, and then read the object from the DOM\n      StringReader reader = new StringReader(serializedString);\n      NanoXMLDOMInput in = new NanoXMLDOMInput(new QuickAndDirtyDOMFactory(), reader);\n      MyObject obj2 = (MyObject) in.readObject();\n      System.out.println(""\\nThe name of the restored object is:"" + obj2.getName());\n    } catch (IOException ex) {\n      Logger.getLogger(QuickAndDirtyDOMStorableSample.class.getName()).log(Level.SEVERE, null, ex);\n"
1685,SelectionToolSample,SelectionToolSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/SelectionToolSample.java,57,98,3,/**\n   * Creates a new instance of SelectionToolSample\n   */,36,"    public SelectionToolSample() {\n      LineFigure lf = new LineFigure();\n      lf.setBounds(new Point2D.Double(40,40), new Point2D.Double(200,\n40));\n      // Add all figures to a drawing \n      Drawing drawing = new DefaultDrawing(); \n      drawing.add(lf);\n      // Show the drawing \n      JFrame f = new JFrame(""UltraMini""); \n      f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); \n      f.setSize(600,300); \n      DrawingView view = new DefaultDrawingView(); \n      view.setDrawing(drawing);\n      f.getContentPane().add(view.getComponent()); \n      // set up the drawing editor\n      DrawingEditor editor = new DefaultDrawingEditor();\n      editor.add(view);\n      \n      \n      // Activate the following line to see the SelectionTool in full\n      // action.\n      editor.setTool(new SelectionTool());\n      // Activate the following line to only see the SelectAreaTracker in \n      // action.\n      //editor.setTool(new SelectAreaTracker());\n      \n      // Activate the following line to only see the DragTracker in \n      // action.\n      //editor.setTool(new DragTracker(lf));\n      \n      // Activate the following lines to only see the HandleTracker in \n      // action.\n      //view.selectAll();\n      //editor.setTool(new HandleTracker(view.findHandle(view.drawingToView(lf.getStartPoint()))));\n      \n      f.show(); \n"
1686,getChooser,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,85,86,3,/**\n   * Returns the URIChooser pane on the sheet.\n   */,2,  public URIChooser getChooser() {\n    return (URIChooser) pane;\n
1687,getOption,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,97,98,3,/**\n   * Returns the option that the JFileChooser or JOptionPane returned.\n   */,2,  public int getOption() {\n    return option;\n
1688,SheetEvent,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,61,66,3,/**\n   * Creates a new instance.\n   */,6,"  public SheetEvent(JSheet source, JOptionPane optionPane, int option, Object value, Object inputValue) {\n    super(source);\n    this.pane = optionPane;\n    this.option = option;\n    this.value = value;\n    this.inputValue = inputValue;\n"
1689,SheetEvent,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,52,56,3,/**\n   * Creates a new instance.\n   */,5,"  public SheetEvent(JSheet source, URIChooser chooser, int option, Object value) {\n    super(source);\n    this.pane = chooser;\n    this.option = option;\n    this.value = value;\n"
1690,getPane,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,73,74,4,"/**\n   * Returns the pane on the sheet. This is either a JFileChooser, a URIChooser or a\n   * JOptionPane.\n   */",2,  public Object getPane() {\n    return pane;\n
1691,getFileChooser,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,79,80,3,/**\n   * Returns the JFileChooser pane on the sheet.\n   */,2,  public JFileChooser getFileChooser() {\n    return (JFileChooser) pane;\n
1692,SheetEvent,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,37,38,3,/**\n   * Creates a new instance.\n   */,2,  public SheetEvent(JSheet source) {\n    super(source);\n
1693,SheetEvent,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,43,47,3,/**\n   * Creates a new instance.\n   */,5,"  public SheetEvent(JSheet source, JFileChooser fileChooser, int option, Object value) {\n    super(source);\n    this.pane = fileChooser;\n    this.option = option;\n    this.value = value;\n"
1694,getValue,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,103,104,3,/**\n   * Returns the value that the JFileChooser or JOptionPane returned.\n   */,2,  public Object getValue() {\n    return value;\n
1695,getOptionPane,SheetEvent,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/event/SheetEvent.java,91,92,3,/**\n   * Returns the JOptionPane pane on the sheet.\n   */,2,  public JOptionPane getOptionPane() {\n    return (JOptionPane) pane;\n
1696,setFonts,DefaultFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/DefaultFontChooserModel.java,66,509,7,/**\n   * Sets the fonts of the DefaultFontChooserModel.\n   * <p>\n   * Fires treeStructureChanged event on the root node.\n   * \n   * @param fonts\n   */,434,"  @SuppressWarnings(""unchecked"")\n  public void setFonts(Font[] fonts) {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.gui.Labels"");\n    // collect families and sort them alphabetically\n    ArrayList<FontFamilyNode> families = new ArrayList<FontFamilyNode>();\n    HashMap<String, FontFamilyNode> familyMap = new HashMap<String, FontFamilyNode>();\n    for (Font f : fonts) {\n      String familyName = f.getFamily();\n      FontFamilyNode family;\n      if (familyMap.containsKey(familyName)) {\n        family = familyMap.get(familyName);\n      } else {\n        family = new FontFamilyNode(familyName);\n        familyMap.put(familyName, family);\n      }\n      family.add(new FontFaceNode(f));\n    }\n    families.addAll(familyMap.values());\n    Collections.sort(families);\n    // group families into collections\n    root.removeAllChildren();\n    root.add(new FontCollectionNode(labels.getString(""FontCollection.allFonts""), (ArrayList<FontFamilyNode>) families.clone()));\n    // Web-save fonts\n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.web""), collectFamiliesNamed(families,\n        ""Arial"",\n        ""Arial Black"",\n        ""Comic Sans MS"",\n        ""Georgia"",\n        ""Impact"",\n        ""Times New Roman"",\n        ""Trebuchet MS"",\n        ""Verdana"",\n        ""Webdings"")));\n    /*\n    // PDF Fonts\n    root.add(\n    new FontCollectionNode(labels.getString(""FontCollection.pdf""), collectFamiliesNamed(families,\n    ""Andale Mono"",\n    ""Courier"",\n    ""Helvetica"",\n    ""Symbol"",\n    ""Times"",\n    ""Zapf Dingbats"")));\n     */\n    // Java System fonts\n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.system""), collectFamiliesNamed(families,\n        ""Dialog"",\n        ""DialogInput"",\n        ""Monospaced"",\n        ""SansSerif"",\n        ""Serif"")));\n    // Serif fonts\n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.serif""), collectFamiliesNamed(families,\n        // Fonts on Mac OS X 10.5:\n        ""Adobe Caslon Pro"",\n        ""Adobe Garamond Pro"",\n        ""American Typewriter"",\n        ""Arno Pro"",\n        ""Baskerville"",\n        ""Baskerville Old Face"",\n        ""Bell MT"",\n        ""Big Caslon"",\n        ""Bodoni SvtyTwo ITC TT"",\n        ""Bodoni SvtyTwo OS ITC TT"",\n        ""Bodoni SvtyTwo SC ITC TT"",\n        ""Book Antiqua"",\n        ""Bookman Old Style"",\n        ""Calisto MT"",\n        ""Chaparral Pro"",\n        ""Century"",\n        ""Century Schoolbook"",\n        ""Cochin"",\n        ""Footlight MT Light"",\n        ""Garamond"",\n        ""Garamond Premier Pro"",\n        ""Georgia"",\n        ""Goudy Old Style"",\n        ""Hoefler Text"",\n        ""Lucida Bright"",\n        ""Lucida Fax"",\n        ""Minion Pro"",\n        ""Palatino"",\n        ""Times"",\n        ""Times New Roman"",\n        // Fonts on Windows XP:\n        ""Palatino Linotype"",\n        ""Bitstream Vera Serif Bold"",\n        ""Bodoni MT"",\n        ""Bodoni MT Black"",\n        ""Bodoni MT Condensed"",\n        ""Californian FB"",\n        ""Cambria"",\n        ""Cambria Math"",\n        ""Centaur"",\n        ""Constantia"",\n        ""High Tower Text"",\n        ""Perpetua"",\n        ""Poor Richard"",\n        ""Rockwell Condensed"",\n        ""Slimbach-Black"",\n        ""Slimbach-BlackItalic"",\n        ""Slimbach-Bold"",\n        ""Slimbach-BoldItalic"",\n        ""Slimbach-Book"",\n        ""Slimbach-BookItalic"",\n        ""Slimbach-Medium"",\n        ""Slimbach-MediumItalic"",\n        ""Sylfaen"",\n        // Fonts on Windows Vista\n        ""Andalus"",\n        ""Angsana New"",\n        ""AngsanaUPC"",\n        ""Arabic Typesetting"",\n        ""Cambria"",\n        ""Cambria Math"",\n        ""Constantia"",\n        ""DaunPenh"",\n        ""David"",\n        ""DilleniaUPC"",\n        ""EucrosiaUPC"",\n        ""Frank Ruehl"",\n        ""IrisUPC"",\n        ""Iskoola Pota"",\n        ""JasmineUPC"",\n        ""KodchiangUPC"",\n        ""Narkisim"")));\n    // Sans Serif\n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.sansSerif""), collectFamiliesNamed(families,\n        // Fonts on Mac OS X 10.5:\n        ""Abadi MT Condensed Extra Bold"",\n        ""Abadi MT Condensed Light"",\n        ""Al Bayan"",\n        ""AppleGothic"",\n        ""Arial"",\n        ""Arial Black"",\n        ""Arial Narrow"",\n        ""Arial Rounded MT Bold"",\n        ""Arial Unicode MS"",\n        ""Bell Gothic Std"",\n        ""Blair MdITC TT"",\n        ""Century Gothic"",\n        ""Frutiger"",\n        ""Futura"",\n        ""Geneva"",\n        ""Gill Sans"",\n        ""Gulim"",\n        ""Helvetica"",\n        ""Helvetica Neue"",\n        ""Lucida Grande"",\n        ""Lucida Sans"",\n        ""Microsoft Sans Serif"",\n        ""Myriad Pro"",\n        ""News Gothic"",\n        ""Tahoma"",\n        ""Trebuchet MS"",\n        ""Verdana"",\n        // Fonts on Windows XP:\n        ""Franklin Gothic Medium"",\n        ""Lucida Sans Unicode"",\n        ""Agency FB"",\n        ""Berlin Sans FB"",\n        ""Berlin Sans FB Demi Bold"",\n        ""Bitstream Vera Sans Bold"",\n        ""Calibri"",\n        ""Candara"",\n        ""Corbel"",\n        ""Estrangelo Edessa"",\n        ""Eras Bold ITC"",\n        ""Eras Demi ITC"",\n        ""Eras Light ITC"",\n        ""Eras Medium ITC"",\n        ""Franklin Gothic Book"",\n        ""Franklin Gothic Demi"",\n        ""Franklin Gothic Demi Cond"",\n        ""Franklin Gothic Heavy"",\n        ""Franklin Gothic Medium Cond"",\n        ""Gill Sans MT"",\n        ""Gill Sans MT Condensed"",\n        ""Gill Sans MT Ext Condensed Bold"",\n        ""Maiandra GD"",\n        ""MS Reference Sans..."",\n        ""Tw Cen MT"",\n        ""Tw Cen MT Condensed"",\n        ""Tw Cen MT Condensed Extra Bold"",\n        // Fonts on Windows Vista:\n        ""Aharoni"",\n        ""Browallia New"",\n        ""BrowalliaUPC"",\n        ""Calibri"",\n        ""Candara"",\n        ""Corbel"",\n        ""Cordia New"",\n        ""CordiaUPC"",\n        ""DokChampa"",\n        ""Dotum"",\n        ""Estrangelo Edessa"",\n        ""Euphemia"",\n        ""Freesia UPC"",\n        ""Gautami"",\n        ""Gisha"",\n        ""Kalinga"",\n        ""Kartika"",\n        ""Levenim MT"",\n        ""LilyUPC"",\n        ""Malgun Gothic"",\n        ""Meiryo"",\n        ""Miriam"",\n        ""Segoe UI"")));\n    // Scripts \n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.script""), collectFamiliesNamed(families,\n        // Fonts on Mac OS X 10.5:\n        ""Apple Chancery"",\n        ""Bickham Script Pro"",\n        ""Blackmoor LET"",\n        ""Bradley Hand ITC TT"",\n        ""Brush Script MT"",\n        ""Brush Script Std"",\n        ""Chalkboard"",\n        ""Charlemagne Std"",\n        ""Comic Sans MS"",\n        ""Curlz MT"",\n        ""Edwardian Script ITC"",\n        ""Footlight MT Light"",\n        ""Giddyup Std"",\n        ""Handwriting - Dakota"",\n        ""Harrington"",\n        ""Herculanum"",\n        ""Kokonor"",\n        ""Lithos Pro"",\n        ""Lucida Blackletter"",\n        ""Lucida Calligraphy"",\n        ""Lucida Handwriting"",\n        ""Marker Felt"",\n        ""Matura MT Script Capitals"",\n        ""Mistral"",\n        ""Monotype Corsiva"",\n        ""Party LET"",\n        ""Papyrus"",\n        ""Santa Fe LET"",\n        ""Savoye LET"",\n        ""SchoolHouse Cursive B"",\n        ""SchoolHouse Printed A"",\n        ""Skia"",\n        ""Snell Roundhand"",\n        ""Tekton Pro"",\n        ""Trajan Pro"",\n        ""Zapfino"",\n        // Fonts on Windows XP\n        ""Blackadder ITC"",\n        ""Bradley Hand ITC"",\n        ""Chiller"",\n        ""Freestyle Script"",\n        ""French Script MT"",\n        ""Gigi"",\n        ""Harlow Solid Italic"",\n        ""Informal Roman"",\n        ""Juice ITC"",\n        ""Kristen ITC"",\n        ""Kunstler Script"",\n        ""Magneto Bold"",\n        ""Maiandra GD"",\n        ""Old English Text"",\n        ""Palace Script MT"",\n        ""Parchment"",\n        ""Pristina"",\n        ""Rage Italic"",\n        ""Ravie"",\n        ""Script MT Bold"",\n        ""Tempus Sans ITC"",\n        ""Viner Hand ITC"",\n        ""Vivaldi Italic"",\n        ""Vladimir Script"",\n        // Fonts on Windows Vista\n        ""Segoe Print"",\n        ""Segoe Script"")));\n    \n    // Monospaced\n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.monospaced""), collectFamiliesNamed(families,\n        // Fonts on Mac OS X 10.5:\n        ""Andale Mono"",\n        ""Courier"",\n        ""Courier New"",\n        ""Letter Gothic Std"",\n        ""Lucida Sans Typewriter"",\n        ""Monaco"",\n        ""OCR A Std"",\n        ""Orator Std"",\n        ""Prestige Elite Std"",\n        // Fonts on Windows XP:\n        ""Lucida Console"",\n        ""Bitstream Vera S..."",\n        ""Consolas"",\n        ""OCR A Extended"",\n        ""OCR B"",\n        // Fonts on Windows Vista\n        ""Consolas"",\n        ""DotumChe"",\n        ""Miriam Fixed"",\n        ""Rod"")));\n    \n    // Decorative\n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.decorative""), collectFamiliesNamed(families,\n        // Fonts on Mac OS X 10.5:\n        ""Academy Engraved LET"",\n        ""Arial Black"",\n        ""Bank Gothic"",\n        ""Bauhaus 93"",\n        ""Bernard MT Condensed"",\n        ""Birch Std"",\n        ""Blackoak Std"",\n        ""BlairMdITC TT"",\n        ""Bordeaux Roman Bold LET"",\n        ""Braggadocio"",\n        ""Britannic Bold"",\n        ""Capitals"",\n        ""Colonna MT"",\n        ""Cooper Black"",\n        ""Cooper Std"",\n        ""Copperplate"",\n        ""Copperplate Gothic Bold"",\n        ""Copperplate Gothic Light"",\n        ""Cracked"",\n        ""Desdemona"",\n        ""Didot"",\n        ""Eccentric Std"",\n        ""Engravers MT"",\n        ""Eurostile"",\n        ""Gill Sans Ultra Bold"",\n        ""Gloucester MT Extra Condensed"",\n        ""Haettenschweiler"",\n        ""Hobo Std"",\n        ""Impact"",\n        ""Imprint MT Shadow"",\n        ""Jazz LET"",\n        ""Kino MT"",\n        ""Matura MT Script Capitals"",\n        ""Mesquite Std"",\n        ""Modern No. 20"",\n        ""Mona Lisa Solid ITC TT"",\n        ""MS Gothic"",\n        ""Nueva Std"",\n        ""Onyx"",\n        ""Optima"",\n        ""Perpetua Titling MT"",\n        ""Playbill"",\n        ""Poplar Std"",\n        ""PortagoITC TT"",\n        ""Princetown LET"",\n        ""Rockwell"",\n        ""Rockwell Extra Bold"",\n        ""Rosewood Std"",\n        ""Santa Fe LET"",\n        ""Stencil"",\n        ""Stencil Std"",\n        ""Stone Sans ITC TT"",\n        ""Stone Sans OS ITC TT"",\n        ""Stone Sans Sem ITC TT"",\n        ""Stone Sans Sem OS ITCTT"",\n        ""Stone Sans Sem OS ITC TT"",\n        ""Synchro LET"",\n        ""Wide Latin"",\n        // Fonts on Windows XP\n        ""Algerian"",\n        ""Bodoni MT Black"",\n        ""Bodoni MT Poster Compressed"",\n        ""Broadway"",\n        ""Castellar"",\n        ""Elephant"",\n        ""Felix Titling"",\n        ""Franklin Gothic Heavy"",\n        ""Gill Sans MT Ext Condensed Bold"",\n        ""Gill Sans Ultra Bold Condensed"",\n        ""Goudy Stout"",\n        ""Jokerman"",\n        ""Juice ITC"",\n        ""Magneto"",\n        ""Magneto Bold"",\n        ""Niagara Engraved"",\n        ""Niagara Solid"",\n        ""Poor Richard"",\n        ""Ravie"",\n        ""Rockwell Condensed"",\n        ""Showcard Gothic"",\n        ""Slimbach-Black"",\n        ""Slimbach-BlackItalic"",\n        ""Snap ITC""\n        // Fonts on Windows Vista:\n        )));\n    root.add(\n        new FontCollectionNode(labels.getString(""FontCollection.symbols""), collectFamiliesNamed(families,\n        // Fonts on Mac OS X 10.5:\n        ""Apple Symbols"",\n        ""Blackoack Std"",\n        ""Bodoni Ornaments ITC TT"",\n        ""EuropeanPi"",\n        ""Monotype Sorts"",\n        ""MT Extra"",\n        ""Symbol"",\n        ""Type Embellishments One LET"",\n        ""Webdings"",\n        ""Wingdings"",\n        ""Wingdings 2"",\n        ""Wingdings 3"",\n        ""Zapf Dingbats"",\n        // Fonts on Windows XP\n        ""Bookshelf Symbol""\n        // Fonts on Windows Vista\n        )));\n    // Collect font families, which are not in one of the other collections\n    // (except the collection AllFonts).\n    FontCollectionNode others = new FontCollectionNode(labels.getString(""FontCollection.other""));\n    HashSet<FontFamilyNode> otherFamilySet = new HashSet<FontFamilyNode>();\n    otherFamilySet.addAll(families);\n    for (int i = 1, n = root.getChildCount(); i < n; i++) {\n      FontCollectionNode fcn = (FontCollectionNode) root.getChildAt(i);\n      for (FontFamilyNode ffn : fcn.families()) {\n        otherFamilySet.remove(ffn);\n      }\n    }\n    ArrayList<FontFamilyNode> otherFamilies = new ArrayList<FontFamilyNode>();\n    for (FontFamilyNode ffn : otherFamilySet) {\n      otherFamilies.add(ffn.clone());\n    }\n    Collections.sort(otherFamilies);\n    others.addAll(otherFamilies);\n    root.add(others);\n    fireTreeStructureChanged(this, new TreePath(root));\n"
1697,fireTreeNodesChanged,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,85,99,12,/**\n   * Notifies all listeners that have registered interest for\n   * notification on this event type.  The event instance \n   * is lazily created using the parameters passed into \n   * the fire method.\n   *\n   * @param source the node being changed\n   * @param path the path to the root node\n   * @param childIndices the indices of the changed elements\n   * @param children the changed elements\n   * @see EventListenerList\n   */,15,"  protected void fireTreeNodesChanged(Object source, Object[] path, \n                    int[] childIndices, \n                    Object[] children) {\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    TreeModelEvent e = null;\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length-2; i>=0; i-=2) {\n      if (listeners[i]==TreeModelListener.class) {\n        // Lazily create the event:\n        if (e == null)\n          e = new TreeModelEvent(source, path, \n                       childIndices, children);\n        ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);\n"
1698,fireTreeNodesRemoved,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,147,161,12,/**\n   * Notifies all listeners that have registered interest for\n   * notification on this event type.  The event instance \n   * is lazily created using the parameters passed into \n   * the fire method.\n   *\n   * @param source the node where elements are being removed\n   * @param path the path to the root node\n   * @param childIndices the indices of the removed elements\n   * @param children the removed elements\n   * @see EventListenerList\n   */,15,"  protected void fireTreeNodesRemoved(Object source, Object[] path, \n                    int[] childIndices, \n                    Object[] children) {\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    TreeModelEvent e = null;\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length-2; i>=0; i-=2) {\n      if (listeners[i]==TreeModelListener.class) {\n        // Lazily create the event:\n        if (e == null)\n          e = new TreeModelEvent(source, path, \n                       childIndices, children);\n        ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);\n"
1699,fireTreeNodesInserted,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,116,130,12,/**\n   * Notifies all listeners that have registered interest for\n   * notification on this event type.  The event instance \n   * is lazily created using the parameters passed into \n   * the fire method.\n   *\n   * @param source the node where new elements are being inserted\n   * @param path the path to the root node\n   * @param childIndices the indices of the new elements\n   * @param children the new elements\n   * @see EventListenerList\n   */,15,"  protected void fireTreeNodesInserted(Object source, Object[] path, \n                    int[] childIndices, \n                    Object[] children) {\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    TreeModelEvent e = null;\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length-2; i>=0; i-=2) {\n      if (listeners[i]==TreeModelListener.class) {\n        // Lazily create the event:\n        if (e == null)\n          e = new TreeModelEvent(source, path, \n                       childIndices, children);\n        ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);\n"
1700,fireTreeStructureChanged,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,178,192,12,/**\n   * Notifies all listeners that have registered interest for\n   * notification on this event type.  The event instance \n   * is lazily created using the parameters passed into \n   * the fire method.\n   *\n   * @param source the node where the tree model has changed\n   * @param path the path to the root node\n   * @param childIndices the indices of the affected elements\n   * @param children the affected elements\n   * @see EventListenerList\n   */,15,"  protected void fireTreeStructureChanged(Object source, Object[] path, \n                    int[] childIndices, \n                    Object[] children) {\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    TreeModelEvent e = null;\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length-2; i>=0; i-=2) {\n      if (listeners[i]==TreeModelListener.class) {\n        // Lazily create the event:\n        if (e == null)\n          e = new TreeModelEvent(source, path, \n                       childIndices, children);\n        ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);\n"
1701,getTreeModelListeners,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,68,70,13,/**\n   * Returns an array of all the tree model listeners\n   * registered on this model.\n   *\n   * @return all of this model's <code>TreeModelListener</code>s\n   *   or an empty\n   *   array if no tree model listeners are currently registered\n   *\n   * @see #addTreeModelListener\n   * @see #removeTreeModelListener\n   *\n   * @since 1.4\n   */,3,  public TreeModelListener[] getTreeModelListeners() {\n    return (TreeModelListener[])listenerList.getListeners(\n        TreeModelListener.class);\n
1702,removeTreeModelListener,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,51,52,9,/**\n   * Removes a listener previously added with <B>addTreeModelListener()</B>.\n   *\n   * @see   #addTreeModelListener\n   * @param   l     the listener to remove\n   */\n --------------\n//  Events\n --------------,2,"  public void removeTreeModelListener(TreeModelListener l) {\n    listenerList.remove(TreeModelListener.class, l);\n"
1703,addTreeModelListener,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,41,42,6,/**\n   * Adds a listener for the TreeModelEvent posted after the tree changes.\n   *\n   * @see   #removeTreeModelListener\n   * @param   l   the listener to add\n   */,2,"  public void addTreeModelListener(TreeModelListener l) {\n    listenerList.add(TreeModelListener.class, l);\n"
1704,fireTreeStructureChanged,AbstractFontChooserModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/fontchooser/AbstractFontChooserModel.java,207,218,10,/*\n   * Notifies all listeners that have registered interest for\n   * notification on this event type.  The event instance \n   * is lazily created using the parameters passed into \n   * the fire method.\n   *\n   * @param source the node where the tree model has changed\n   * @param path the path to the root node\n   * @see EventListenerList\n   */,12,"  protected void fireTreeStructureChanged(Object source, TreePath path) {\n    // Guaranteed to return a non-null array\n    Object[] listeners = listenerList.getListenerList();\n    TreeModelEvent e = null;\n    // Process the listeners last to first, notifying\n    // those that are interested in this event\n    for (int i = listeners.length-2; i>=0; i-=2) {\n      if (listeners[i]==TreeModelListener.class) {\n        // Lazily create the event:\n        if (e == null)\n          e = new TreeModelEvent(source, path);\n        ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);\n"
1705,PathTool,PathTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/PathTool.java,46,47,1,/** Creates a new instance. */,2,"  public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {\n    this(pathPrototype, bezierPrototype, null);\n"
1706,TogglePropertiesPanelAction,TogglePropertiesPanelAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/action/TogglePropertiesPanelAction.java,33,37,1,/** Creates a new instance. */,5,"  public TogglePropertiesPanelAction(Application app, View view) {\n    super(app, view);\n    setPropertyName(""propertiesPanelVisible"");\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.odg.Labels"");\n    putValue(AbstractAction.NAME, labels.getString(""propertiesPanel""));\n"
1708,getPropertyDescriptors,ODGPropertiesPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java,105,106,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1710,getMethodDescriptors,ODGPropertiesPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java,127,128,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1711,getDefaultEventIndex,ODGPropertiesPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java,150,151,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1712,getEventSetDescriptors,ODGPropertiesPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java,116,117,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1713,getDefaultPropertyIndex,ODGPropertiesPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java,139,140,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1716,getBeanDescriptor,ODGPropertiesPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanelBeanInfo.java,89,90,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1717,initComponents,ODGPropertiesPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanel.java,83,113,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,25,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    linkLabel = new javax.swing.JLabel();\n    linkField = new org.jhotdraw.gui.JAttributeTextField();\n    opacityLabel = new javax.swing.JLabel();\n    opacityField = new org.jhotdraw.gui.JAttributeTextField();\n    opacityPopupButton = new org.jhotdraw.gui.JPopupButton();\n    setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    setLayout(new java.awt.GridBagLayout());\n    linkLabel.setLabelFor(linkField);\n    linkLabel.setText(labels.getString(""link"")); // NOI18N\n    add(linkLabel, new java.awt.GridBagConstraints());\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.weightx = 1.0;\n    add(linkField, gridBagConstraints);\n    opacityLabel.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/org/jhotdraw/draw/action/images/attributeOpacity.png""))); // NOI18N\n    opacityLabel.setToolTipText(labels.getString(""opacity"")); // NOI18N\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);\n    add(opacityLabel, gridBagConstraints);\n    opacityField.setColumns(3);\n    add(opacityField, new java.awt.GridBagConstraints());\n    opacityPopupButton.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/org/jhotdraw/draw/action/images/popupIcon.png""))); // NOI18N\n    add(opacityPopupButton, new java.awt.GridBagConstraints());\n"
1718,ODGPropertiesPanel,ODGPropertiesPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGPropertiesPanel.java,42,61,1,/** Creates new instance. */,19,"  @SuppressWarnings(""unchecked"")\n  public ODGPropertiesPanel() {\n    initComponents();\n    \n    opacitySlider = new JAttributeSlider(JSlider.VERTICAL, 0, 100, 100);\n    opacityPopupButton.add(opacitySlider);\n    opacityPopupButton.putClientProperty(""JButton.buttonType"",""toolbar"");\n    add(opacityPopupButton);\n    opacityField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0d, 1d, 100d));\n    opacityFieldHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacityField, editor);\n    opacitySliderHandler = new FigureAttributeEditorHandler<Double>(OPACITY, opacitySlider, editor);\n    linkFieldHandler = new FigureAttributeEditorHandler<String>(LINK, linkField, editor);\n    \n    // set fonts\n    Font font = getFont().deriveFont(11f);\n    for (Component c : getComponents()) {\n      c.setFont(font);\n    }\n    opacitySlider.setFont(font);\n"
1719,ODGBezierFigure,ODGBezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGBezierFigure.java,40,41,1,/** Creates a new instance. */,2,  public ODGBezierFigure() {\n    this(false);\n
1720,write,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,185,186,3,/**\n   * Writes the view to the specified uri.\n   */,2,"  public void write(URI f, URIChooser fc) throws IOException {\n    new SVGOutputFormat().write(new File(f), view.getDrawing());\n"
1721,createDrawing,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,126,141,3,/**\n   * Creates a new Drawing for this view.\n   */,16,"  protected Drawing createDrawing() {\n    Drawing drawing = new ODGDrawing();\n    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();\n    inputFormats.add(new ODGInputFormat());\n    inputFormats.add(new ImageInputFormat(new SVGImageFigure()));\n    inputFormats.add(new TextInputFormat(new SVGTextFigure()));\n    drawing.setInputFormats(inputFormats);\n    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();\n    outputFormats.add(new SVGOutputFormat());\n    outputFormats.add(new SVGZOutputFormat());\n    outputFormats.add(new ImageOutputFormat());\n    outputFormats.add(new ImageOutputFormat(""JPG"", ""Joint Photographics Experts Group (JPEG)"", ""jpg"", BufferedImage.TYPE_INT_RGB));\n    outputFormats.add(new ImageOutputFormat(""BMP"", ""Windows Bitmap (BMP)"", ""bmp"", BufferedImage.TYPE_BYTE_INDEXED));\n    outputFormats.add(new ImageMapOutputFormat());\n    drawing.setOutputFormats(outputFormats);\n    return drawing;\n"
1722,clear,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,271,286,3,/**\n   * Clears the view.\n   */,15,  public void clear() {\n    final Drawing newDrawing = createDrawing();\n    try {\n      SwingUtilities.invokeAndWait(new Runnable() {\n        public void run() {\n          view.getDrawing().removeUndoableEditListener(undo);\n          view.setDrawing(newDrawing);\n          view.getDrawing().addUndoableEditListener(undo);\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InvocationTargetException ex) {\n      ex.printStackTrace();\n    } catch (InterruptedException ex) {\n      ex.printStackTrace();\n
1723,read,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,192,223,3,/**\n   * Reads the view from the specified uri.\n   */,28,"  @SuppressWarnings(""unchecked"")\n  @Override\n  public void read(URI f, URIChooser fc) throws IOException {\n    try {\n      final Drawing drawing = createDrawing();\n      HashMap<FileFilter, InputFormat> fileFilterInputFormatMap = (HashMap<FileFilter, InputFormat>)((JFileURIChooser) fc).getClientProperty(""ffInputFormatMap"");\n      InputFormat sf = fileFilterInputFormatMap.get(((JFileURIChooser) fc).getFileFilter());\n      if (sf == null) {\n        sf = drawing.getInputFormats().get(0);\n      }\n      sf.read(new File(f), drawing, true);\n      System.out.println(""ODCView read("" + f + "") drawing.childCount="" + drawing.getChildCount());\n      SwingUtilities.invokeAndWait(new Runnable() {\n        public void run() {\n          view.getDrawing().removeUndoableEditListener(undo);\n          view.setDrawing(drawing);\n          view.getDrawing().addUndoableEditListener(undo);\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InterruptedException e) {\n      InternalError error = new InternalError();\n      e.initCause(e);\n      throw error;\n    } catch (InvocationTargetException e) {\n      InternalError error = new InternalError();\n      error.initCause(e);\n      throw error;\n"
1724,createPageable,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,147,148,3,/**\n   * Creates a Pageable object for printing the view.\n   */,2,  public Pageable createPageable() {\n    return new DrawingPageable(view.getDrawing());\n
1726,initComponents,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,302,315,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,10,"  private void initComponents() {\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    propertiesPanel = new org.jhotdraw.samples.odg.ODGPropertiesPanel();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n    add(propertiesPanel, java.awt.BorderLayout.SOUTH);\n"
1727,init,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,81,120,3,/**\n   * Initializes the view.\n   */,33,"  public void init() {\n    super.init();\n    initComponents();\n    JPanel zoomButtonPanel = new JPanel(new BorderLayout());\n    scrollPane.setLayout(new PlacardScrollPaneLayout());\n    scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));\n    setEditor(new DefaultDrawingEditor());\n    undo = new UndoRedoManager();\n    view.setDrawing(createDrawing());\n    view.getDrawing().addUndoableEditListener(undo);\n    initActions();\n    undo.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        setHasUnsavedChanges(undo.hasSignificantEdits());\n      }\n    });\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    JPanel placardPanel = new JPanel(new BorderLayout());\n    javax.swing.AbstractButton pButton;\n    pButton = ButtonFactory.createZoomButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"", ""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"", new Insets(0, 0, 0, 0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    placardPanel.add(pButton, BorderLayout.WEST);\n    pButton = ButtonFactory.createToggleGridButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"", ""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"", new Insets(0, 0, 0, 0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    labels.configureToolBarButton(pButton, ""view.toggleGrid.placard"");\n    placardPanel.add(pButton, BorderLayout.EAST);\n    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);\n    propertiesPanel.setVisible(preferences.getBoolean(""propertiesPanelVisible"", false));\n    propertiesPanel.setView(view);\n"
1728,initActions,ODGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGView.java,171,173,3,/**\n   * Initializes view specific actions.\n   */,3,"  private void initActions() {\n    getActionMap().put(UndoAction.ID, undo.getUndoAction());\n    getActionMap().put(RedoAction.ID, undo.getRedoAction());\n"
1730,contains,ODGEllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java,118,120,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,3,  public boolean contains(Point2D.Double p) {\n    // XXX - This does not take the stroke width into account!\n    return getTransformedShape().contains(p);\n
1731,ODGEllipseFigure,ODGEllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java,50,51,1,/** Creates a new instance. */,2,"  public ODGEllipseFigure() {\n    this(0, 0, 0, 0);\n"
1737,transform,ODGEllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGEllipseFigure.java,146,175,5,/**\n   * Transforms the figure.\n   *\n   * @param tx the transformation.\n   */,30,"  public void transform(AffineTransform tx) {\n    if (get(TRANSFORM) != null ||\n        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {\n      if (get(TRANSFORM) == null) {\n        TRANSFORM.setClone(this, tx);\n      } else {\n        AffineTransform t = TRANSFORM.getClone(this);\n        t.preConcatenate(tx);\n        set(TRANSFORM, t);\n      }\n    } else {\n      Point2D.Double anchor = getStartPoint();\n      Point2D.Double lead = getEndPoint();\n      setBounds(\n          (Point2D.Double) tx.transform(anchor, anchor),\n          (Point2D.Double) tx.transform(lead, lead));\n      if (get(FILL_GRADIENT) != null &&\n          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = FILL_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(FILL_GRADIENT, g);\n      }\n      if (get(STROKE_GRADIENT) != null &&\n          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = STROKE_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(STROKE_GRADIENT, g);\n      }\n    }\n    invalidate();\n"
1738,CombineAction,CombineAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/action/CombineAction.java,34,38,1,/** Creates a new instance. */,4,"  public CombineAction(DrawingEditor editor) {\n    super(editor, new ODGPathFigure());\n    labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.odg.Labels"");\n    labels.configureAction(this, ID);\n"
1739,createUI,PaletteFormattedTextFieldUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFormattedTextFieldUI.java,39,40,6,/**\n   * Creates a UI for a JTextField.\n   *\n   * @param c the text field\n   * @return the UI\n   */,2,  public static ComponentUI createUI(JComponent c) {\n    return new PaletteFormattedTextFieldUI();\n
1740,create,PaletteFormattedTextFieldUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFormattedTextFieldUI.java,49,147,6,/**\n   * Creates a view (FieldView) based on an element.\n   *\n   * @param elem the element\n   * @return the view\n   */,94,"  @Override\n  public View create(Element elem) {\n    /* We create our own view here. This view always uses the\n     * text alignment that was specified by the text component. Even\n     * then, when the text is longer than in the text component.\n     *\n     * Draws a wavy line if the value of the field is not valid.\n     */\n    return new FieldView(elem) {\n      /**\n       * Adjusts the allocation given to the view\n       * to be a suitable allocation for a text field.\n       * If the view has been allocated more than the\n       * preferred span vertically, the allocation is\n       * changed to be centered vertically.  Horizontally\n       * the view is adjusted according to the horizontal\n       * alignment property set on the associated JTextField\n       * (if that is the type of the hosting component).\n       *\n       * @param a the allocation given to the view, which may need\n       *  to be adjusted.\n       * @return the allocation that the superclass should use.\n       */\n      protected Shape adjustAllocationXX(Shape a) {\n        if (a != null) {\n          Rectangle bounds = a.getBounds();\n          int vspan = (int) getPreferredSpan(Y_AXIS);\n          int hspan = (int) getPreferredSpan(X_AXIS);\n          if (bounds.height != vspan) {\n            int slop = bounds.height - vspan;\n            bounds.y += slop / 2;\n            bounds.height -= slop;\n          }\n          // horizontal adjustments\n          Component c = getContainer();\n          if (c instanceof JTextField) {\n            JTextField field = (JTextField) c;\n            BoundedRangeModel vis = field.getHorizontalVisibility();\n            int max = Math.max(hspan, bounds.width);\n            int value = vis.getValue();\n            int extent = Math.min(max, bounds.width - 1);\n            if ((value + extent) > max) {\n              value = max - extent;\n            }\n            vis.setRangeProperties(value, extent, vis.getMinimum(),\n                max, false);\n            if (hspan < bounds.width) {\n              // horizontally align the interior\n              int slop = bounds.width - 1 - hspan;\n              int align = ((JTextField) c).getHorizontalAlignment();\n              if (true /*((JComponent) c).isLeftToRight()*/) {\n                if (align == LEADING) {\n                  align = LEFT;\n                } else if (align == TRAILING) {\n                  align = RIGHT;\n                }\n              } else {\n                if (align == LEADING) {\n                  align = RIGHT;\n                } else if (align == TRAILING) {\n                  align = LEFT;\n                }\n              }\n              switch (align) {\n                case SwingConstants.CENTER:\n                  bounds.x += slop / 2;\n                  bounds.width -= slop;\n                  break;\n                case SwingConstants.RIGHT:\n                  bounds.x += slop;\n                  bounds.width -= slop;\n                  break;\n              }\n            } else {\n              // adjust the allocation to match the bounded range.\n              bounds.width = hspan;\n              bounds.x -= vis.getValue();\n            }\n          }\n          return bounds;\n        }\n        return null;\n      }\n      @Override\n      public void paint(Graphics gr, Shape a) {\n        Graphics2D g = (Graphics2D) gr;\n        JFormattedTextField editor = (JFormattedTextField) getComponent();\n        if (!editor.isEditValid()) {\n          Rectangle r = (Rectangle) a;\n          g.setColor(errorIndicatorForeground);\n          g.setStroke(new BasicStroke(2.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{3f,3f},0.5f));\n          g.draw(new Line2D.Float(r.x, r.y+r.height-0.5f, r.x+r.width-1,r.y+r.height-0.5f));\n          }\n          super.paint(g, a);\n"
1742,PaletteFontChooserPreviewPanel,PaletteFontChooserPreviewPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserPreviewPanel.java,28,37,1,/** Creates new form PaletteFontChooserPreviewPanel */,10,"  public PaletteFontChooserPreviewPanel() {\n    initComponents();\n    \n    previewLabel.setUI((LabelUI) PaletteLabelUI.createUI(previewLabel));\n    previewLabel.setBackground(Color.WHITE);\n    previewLabel.setForeground(Color.BLACK);\n    previewLabel.setOpaque(true);\n    \n    setPreferredSize(new Dimension(100,50));\n    setMinimumSize(new Dimension(100,50));\n"
1743,initComponents,PaletteFontChooserPreviewPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserPreviewPanel.java,76,85,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,7,"  @SuppressWarnings(""unchecked"")\n  // <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents\n  private void initComponents() {\n    previewLabel = new javax.swing.JLabel();\n    setLayout(new java.awt.BorderLayout());\n    previewLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\n    add(previewLabel, java.awt.BorderLayout.CENTER);\n"
1744,installUI,PaletteFontChooserUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java,95,98,25,"/**\n   * Configures the specified component appropriate for the look and feel.\n   * This method is invoked when the <code>ComponentUI</code> instance is being installed\n   * as the UI delegate on the specified component.  This method should\n   * completely configure the component for the look and feel,\n   * including the following:\n   * <ol>\n   * <li>Install any default property values for color, fonts, borders,\n   *   icons, opacity, etc. on the component.  Whenever possible, \n   *   property values initialized by the client program should <i>not</i> \n   *   be overridden.\n   * <li>Install a <code>LayoutManager</code> on the component if necessary.\n   * <li>Create/add any required sub-components to the component.\n   * <li>Create/install event listeners on the component.\n   * <li>Create/install a <code>PropertyChangeListener</code> on the component in order\n   *   to detect and respond to component property changes appropriately.\n   * <li>Install keyboard UI (mnemonics, traversal, etc.) on the component.\n   * <li>Initialize any appropriate instance data.\n   * </ol>\n   * @param c the component where this UI delegate is being installed\n   *\n   * @see #uninstallUI\n   * @see javax.swing.JComponent#setUI\n   * @see javax.swing.JComponent#updateUI\n   */",4,  @Override\n  public void installUI(JComponent c) {\n    installComponents(fontChooser);\n    installListeners(fontChooser);\n
1745,createUI,PaletteFontChooserUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java,65,67,10,"/**\n   * Returns an instance of the UI delegate for the specified component.\n   * Each subclass must provide its own static <code>createUI</code>\n   * method that returns an instance of that UI delegate subclass.\n   * If the UI delegate subclass is stateless, it may return an instance\n   * that is shared by multiple components.  If the UI delegate is\n   * stateful, then it should return a new instance per component.\n   * The default implementation of this method throws an error, as it\n   * should never be invoked.\n   */",3,  public static ComponentUI createUI(JComponent c) {\n    PaletteFontChooserUI ui = new PaletteFontChooserUI((JFontChooser) c);\n    return ui;\n
1746,uninstallUI,PaletteFontChooserUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserUI.java,160,162,25,"/**\n   * Reverses configuration which was done on the specified component during\n   * <code>installUI</code>.  This method is invoked when this \n   * <code>UIComponent</code> instance is being removed as the UI delegate \n   * for the specified component.  This method should undo the\n   * configuration performed in <code>installUI</code>, being careful to \n   * leave the <code>JComponent</code> instance in a clean state (no \n   * extraneous listeners, look-and-feel-specific property objects, etc.).\n   * This should include the following:\n   * <ol>\n   * <li>Remove any UI-set borders from the component.\n   * <li>Remove any UI-set layout managers on the component.\n   * <li>Remove any UI-added sub-components from the component.\n   * <li>Remove any UI-added event/property listeners from the component.\n   * <li>Remove any UI-installed keyboard UI from the component.\n   * <li>Nullify any allocated instance data objects to allow for GC.\n   * </ol>\n   * @param c the component from which this UI delegate is being removed;\n   *      this argument is often ignored,\n   *      but might be used if the UI object is stateless\n   *      and shared by multiple components\n   *\n   * @see #installUI\n   * @see javax.swing.JComponent#updateUI\n   */",3,  public void uninstallUI(JComponent c) {\n    uninstallListeners(fontChooser);\n    uninstallComponents(fontChooser);\n
1747,TextCreationTool,TextCreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java,73,74,1,/** Creates a new instance. */,2,"  public TextCreationTool(TextHolderFigure prototype, Map<AttributeKey,Object> attributes) {\n    super(prototype, attributes);\n"
1748,TextCreationTool,TextCreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java,69,70,1,/** Creates a new instance. */,2,  public TextCreationTool(TextHolderFigure prototype) {\n    super(prototype);\n
1749,mousePressed,TextCreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextCreationTool.java,85,133,3,/**\n   * Creates a new figure at the location where the mouse was pressed.\n   */,46,"  @Override\n  public void mousePressed(MouseEvent e) {\n    TextHolderFigure textHolder = null;\n    // Note: The search sequence used here, must be\n    // consistent with the search sequence used by the\n    // HandleTracker, SelectAreaTracker, DelegationSelectionTool, SelectionTool.\n    // If possible, continue to work with the current selection\n    DrawingView v = getView();\n    Point2D.Double p = v.viewToDrawing(e.getPoint());\n    Figure pressedFigure = null;\n    if (true /*isSelectBehindEnabled()*/) {\n      for (Figure f : v.getSelectedFigures()) {\n        if (f.contains(p)) {\n          pressedFigure = f;\n          break;\n        }\n      }\n    }\n    // If the point is not contained in the current selection,\n    // search for a figure in the drawing.\n    if (pressedFigure == null) {\n      pressedFigure = getDrawing().findFigureInside(p);\n    }\n    if (pressedFigure instanceof TextHolderFigure) {\n      textHolder = ((TextHolderFigure) pressedFigure).getLabelFor();\n        textHolder = null;\n    }\n    if (textHolder != null) {\n      beginEdit(textHolder);\n      updateCursor(getView(), e.getPoint());\n          return;\n    }\n    if (typingTarget != null) {\n      endEdit();\n      if (isToolDoneAfterCreation()) {\n        fireToolDone();\n      }\n    } else {\n      super.mousePressed(e);\n      // update view so the created figure is drawn before the floating text\n      // figure is overlaid. \n      textHolder = (TextHolderFigure)getCreatedFigure();\n      getView().clearSelection();\n      getView().addToSelection(textHolder);\n      beginEdit(textHolder);\n      updateCursor(getView(), e.getPoint());\n"
1750,setRubberbandColor,TextAreaCreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java,106,107,6,"/**\n   * Sets the rubberband color for the tool. Setting this to null, disables\n   * the rubberband.\n   *\n   * @param c Rubberband color or null.\n   */",2,  public void setRubberbandColor(Color c) {\n    rubberbandColor = c;\n
1751,mousePressed,TextAreaCreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java,120,164,4,"/**\n   * Creates a new figure at the mouse location.\n   * If editing is in progress, this finishes editing.\n   */",40,"  @Override\n  public void mousePressed(MouseEvent e) {\n    TextHolderFigure textHolder = null;\n    // Note: The search sequence used here, must be\n    // consistent with the search sequence used by the\n    // HandleTracker, SelectAreaTracker, DelegationSelectionTool, SelectionTool.\n    // If possible, continue to work with the current selection\n    DrawingView v = getView();\n    Point2D.Double p = v.viewToDrawing(e.getPoint());\n    Figure pressedFigure = null;\n    if (true /*isSelectBehindEnabled()*/) {\n      for (Figure f : v.getSelectedFigures()) {\n        if (f.contains(p)) {\n          pressedFigure = f;\n          break;\n        }\n      }\n    }\n    // If the point is not contained in the current selection,\n    // search for a figure in the drawing.\n    if (pressedFigure == null) {\n      pressedFigure = getDrawing().findFigureInside(p);\n    }\n    // \n    if (pressedFigure instanceof TextHolderFigure) {\n      textHolder = (TextHolderFigure) pressedFigure;\n        textHolder = null;\n    }\n    if (textHolder != null) {\n      createdFigure = null;\n      beginEdit(textHolder);\n      return;\n    }\n    if (typingTarget != null) {\n      endEdit();\n      if (isToolDoneAfterCreation()) {\n        fireToolDone();\n      }\n    } else {\n      super.mousePressed(e);\n"
1752,creationFinished,TextAreaCreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java,173,177,5,/**\n   * This method allows subclasses to do perform additonal user interactions\n   * after the new figure has been created.\n   * The implementation of this class just invokes fireToolDone.\n   */,5,  @Override\n  protected void creationFinished(Figure createdFigure) {\n    getView().clearSelection();\n    getView().addToSelection(createdFigure);\n    beginEdit((TextHolderFigure) createdFigure);\n
1753,TextAreaCreationTool,TextAreaCreationTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaCreationTool.java,92,93,1,/** Creates a new instance. */,2,  public TextAreaCreationTool(TextHolderFigure prototype) {\n    super(prototype);\n
1755,PaletteFontChooserSelectionPanel,PaletteFontChooserSelectionPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserSelectionPanel.java,30,41,1,/** Creates new form FontChooserPanel */,12,"  public PaletteFontChooserSelectionPanel() {\n     labels = ResourceBundleUtil.getBundle(""org.jhotdraw.gui.Labels"");\n    initComponents();\n    collectionList.setModel(new DefaultListModel());\n    familyList.setModel(new DefaultListModel());\n    faceList.setModel(new DefaultListModel());\n    \n    // Customiziation of Quaqua Look and Feel: Set small scroll bars\n    Font smallSystemFont = new Font(""Dialog"", Font.PLAIN, 11);\n    collectionsScrollPane.setFont(smallSystemFont);\n    familiesScrollPane.setFont(smallSystemFont);\n    facesScrollPane.setFont(smallSystemFont);\n"
1756,initComponents,PaletteFontChooserSelectionPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteFontChooserSelectionPanel.java,59,141,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,63,"  @SuppressWarnings(""unchecked"")\n  // <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents\n  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    collectionsPanel = new javax.swing.JPanel();\n    collectionsScrollPane = new javax.swing.JScrollPane();\n    collectionList = new javax.swing.JList();\n    collectionsLabel = new javax.swing.JLabel();\n    familiesPanel = new javax.swing.JPanel();\n    familiesScrollPane = new javax.swing.JScrollPane();\n    familyList = new javax.swing.JList();\n    familyLabel = new javax.swing.JLabel();\n    facesPanel = new javax.swing.JPanel();\n    facesScrollPane = new javax.swing.JScrollPane();\n    faceList = new javax.swing.JList();\n    faceLabel = new javax.swing.JLabel();\n    setBorder(javax.swing.BorderFactory.createEmptyBorder(3, 3, 3, 3));\n    setLayout(new java.awt.GridBagLayout());\n    collectionsPanel.setPreferredSize(new java.awt.Dimension(80, 200));\n    collectionsPanel.setLayout(new java.awt.BorderLayout());\n    collectionsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    collectionList.setFont(collectionList.getFont().deriveFont((float)11));\n    collectionsScrollPane.setViewportView(collectionList);\n    collectionsPanel.add(collectionsScrollPane, java.awt.BorderLayout.CENTER);\n    collectionsLabel.setFont(collectionsLabel.getFont().deriveFont((float)11));\n    collectionsLabel.setText(labels.getString(""FontCollection.collections"")); // NOI18N\n    collectionsPanel.add(collectionsLabel, java.awt.BorderLayout.PAGE_START);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n    gridBagConstraints.weightx = 0.3;\n    gridBagConstraints.weighty = 1.0;\n    add(collectionsPanel, gridBagConstraints);\n    familiesPanel.setPreferredSize(new java.awt.Dimension(140, 200));\n    familiesPanel.setLayout(new java.awt.BorderLayout());\n    familiesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    familyList.setFont(familyList.getFont().deriveFont((float)11));\n    familiesScrollPane.setViewportView(familyList);\n    familiesPanel.add(familiesScrollPane, java.awt.BorderLayout.CENTER);\n    familyLabel.setFont(familyLabel.getFont().deriveFont((float)11));\n    familyLabel.setText(labels.getString(""FontCollection.family"")); // NOI18N\n    familiesPanel.add(familyLabel, java.awt.BorderLayout.PAGE_START);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n    gridBagConstraints.weightx = 0.4;\n    gridBagConstraints.weighty = 1.0;\n    gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n    add(familiesPanel, gridBagConstraints);\n    facesPanel.setPreferredSize(new java.awt.Dimension(80, 200));\n    facesPanel.setLayout(new java.awt.BorderLayout());\n    facesScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n    facesScrollPane.setPreferredSize(new java.awt.Dimension(130, 240));\n    faceList.setFont(faceList.getFont().deriveFont((float)11));\n    facesScrollPane.setViewportView(faceList);\n    facesPanel.add(facesScrollPane, java.awt.BorderLayout.CENTER);\n    faceLabel.setFont(faceLabel.getFont().deriveFont((float)11));\n    faceLabel.setText(labels.getString(""FontCollection.typeface"")); // NOI18N\n    facesPanel.add(faceLabel, java.awt.BorderLayout.PAGE_START);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n    gridBagConstraints.weightx = 0.3;\n    gridBagConstraints.weighty = 1.0;\n    gridBagConstraints.insets = new java.awt.Insets(0, 3, 0, 0);\n    add(facesPanel, gridBagConstraints);\n"
1757,layoutCL,PaletteLabelUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java,137,157,7,/**\n   * Forwards the call to SwingUtilities.layoutCompoundLabel().\n   * This method is here so that a subclass could do Label specific\n   * layout and to shorten the method name a little.\n   *\n   * @see SwingUtilities#layoutCompoundLabel\n   */,21,"  protected String layoutCL(\n      JLabel label,\n      FontMetrics fontMetrics,\n      String text,\n      Icon icon,\n      Rectangle viewR,\n      Rectangle iconR,\n      Rectangle textR) {\n    return SwingUtilities.layoutCompoundLabel(\n        (JComponent) label,\n        fontMetrics,\n        text,\n        icon,\n        label.getVerticalAlignment(),\n        label.getHorizontalAlignment(),\n        label.getVerticalTextPosition(),\n        label.getHorizontalTextPosition(),\n        viewR,\n        iconR,\n        textR,\n        label.getIconTextGap());\n"
1758,createUI,PaletteLabelUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java,49,50,9,"/**\n   * Preferred spacing between labels and other components.\n   * Pixels from colon and associated controls (RadioButton,\n   * CheckBox)\n   * /\n   * private final static Insets associatedRegularSpacing = new Insets(8,8,8,8);\n   * private final static Insets associatedSmallSpacing = new Insets(6,6,6,6);\n   * private final static Insets associatedMiniSpacing = new Insets(5,5,5,5);\n   */",2,  public static ComponentUI createUI(JComponent c) {\n    return labelUI;\n
1759,paintDisabledText,PaletteLabelUI,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/PaletteLabelUI.java,97,104,6,/**\n   * Paint label with disabled text color.\n   *\n   * @see #paint\n   * @see #paintEnabledText\n   */,6,"  protected void paintDisabledText(JLabel l, Graphics g, String s, int textX, int textY) {\n    Color c = UIManager.getColor(""Label.disabledForeground"");\n    g.setColor((c != null) ? c : l.getForeground());\n    int accChar = -1; //l.getDisplayedMnemonicIndex();\n    PaletteUtilities.drawString(g, s, accChar,\n        textX, textY);\n"
1760,MultiIcon,MultiIcon,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/MultiIcon.java,57,59,6,"/**\n   * Creates a new instance from an array of icons.\n   * All icons must have the same dimensions.\n   * If an icon is null, an icon is derived for the state from the\n   * other icons.\n   */",3,  public MultiIcon(Icon[] icons) {\n    this.icons = icons;\n    generateMissingIcons();\n
1761,MultiIcon,MultiIcon,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/gui/plaf/palette/MultiIcon.java,68,75,6,"/**\n   * Creates a new instance from an array of images.\n   * All icons must have the same dimensions.\n   * If an icon is null, an icon is derived for the state from the\n   * other icons.\n   */",8,"  public MultiIcon(Image[] images) {\n    this.icons = new Icon[images.length];\n    for (int i=0, n = icons.length; i < n; i++) {\n      if (images[i] != null) {\n        icons[i] = new ImageIcon(images[i]);\n      }\n    }\n    generateMissingIcons();\n"
1762,add,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,247,248,10,/**\n   * Convenience method for adding a control point with a single\n   * coordinate C0.\n   */\n --------------\n/**\n     * This mask is used to describe which control points in addition to\n     * C0 are in effect.\n     */\n --------------,2,"  public void add(Point2D.Double c0) {\n    add(new Node(0, c0, c0, c0));\n"
1763,toGeneralPath,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,311,383,1,/** Converts the BezierPath into a Path2D.Double. */,70,"  public Path2D.Double toGeneralPath() {\n    Path2D.Double gp = new Path2D.Double();\n    gp.setWindingRule(windingRule);\n    if (size() == 0) {\n      gp.moveTo(0, 0);\n      gp.lineTo(0, 0 + 1);\n    } else if (size() == 1) {\n      Node current = get(0);\n      gp.moveTo(current.x[0], current.y[0]);\n      gp.lineTo(current.x[0], current.y[0] + 1);\n    } else {\n      Node previous;\n      Node current;\n      previous = current = get(0);\n      gp.moveTo(current.x[0], current.y[0]);\n      for (int i = 1, n = size(); i < n; i++) {\n        previous = current;\n        current = get(i);\n        if ((previous.mask & C2_MASK) == 0) {\n          if ((current.mask & C1_MASK) == 0) {\n            gp.lineTo(\n                current.x[0], current.y[0]);\n          } else {\n            gp.quadTo(\n                current.x[1], current.y[1],\n                current.x[0], current.y[0]);\n          }\n        } else {\n          if ((current.mask & C1_MASK) == 0) {\n            gp.quadTo(\n                previous.x[2], previous.y[2],\n                current.x[0], current.y[0]);\n          } else {\n            gp.curveTo(\n                previous.x[2], previous.y[2],\n                current.x[1], current.y[1],\n                current.x[0], current.y[0]);\n          }\n        }\n      }\n      if (isClosed) {\n        if (size() > 1) {\n          previous = get(size() - 1);\n          current = get(0);\n          if ((previous.mask & C2_MASK) == 0) {\n            if ((current.mask & C1_MASK) == 0) {\n              gp.lineTo(\n                  current.x[0], current.y[0]);\n            } else {\n              gp.quadTo(\n                  current.x[1], current.y[1],\n                  current.x[0], current.y[0]);\n            }\n          } else {\n            if ((current.mask & C1_MASK) == 0) {\n              gp.quadTo(\n                  previous.x[2], previous.y[2],\n                  current.x[0], current.y[0]);\n            } else {\n              gp.curveTo(\n                  previous.x[2], previous.y[2],\n                  current.x[1], current.y[1],\n                  current.x[0], current.y[0]);\n            }\n          }\n        }\n        gp.closePath();\n      }\n    }\n    return gp;\n"
1764,toPolygonArray,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,1259,1264,4,/**\n   * Creates a polygon array of the bezier path.\n   * @return Point array.\n   */,6,"  public Point2D.Double[] toPolygonArray() {\n    Point2D.Double[] points = new Point2D.Double[size()];\n    for (int i = 0, n = size(); i < n; i++) {\n      points[i] = new Point2D.Double(get(i).x[0], get(i).y[0]);\n    }\n    return points;\n"
1765,indexOfOutermostNode,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,790,807,72,"/**\n   * Return the index of the control point that is furthest from the center\n   **/\n --------------\n/*\n    Point2D.Double ctr = getCenter();\n    // Chopped point\n    double cx = -1;\n    double cy = -1;\n    double len = Double.MAX_VALUE;\n    // Try for points along edge\n    validatePath();\n    PathIterator i = generalPath.getPathIterator(new AffineTransform(), 1);\n    double[] coords = new double[6];\n    int type = i.currentSegment(coords);\n    double prevX = coords[0];\n    double prevY = coords[1];\n    i.next();\n    for (; ! i.isDone(); i.next()) {\n    i.currentSegment(coords);\n    Point2D.Double chop = Geom.intersect(\n    prevX, prevY,\n    coords[0], coords[1],\n    p.x, p.y,\n    ctr.x, ctr.y\n    );\n    if (chop != null) {\n    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);\n    if (cl < len) {\n    len = cl;\n    cx = chop.x;\n    cy = chop.y;\n    }\n    }\n    prevX = coords[0];\n    prevY = coords[1];\n    }\n    //\n    if (isClosed() && size() > 1) {\n    Node first = get(0);\n    Node last = get(size() - 1);\n    Point2D.Double chop = Geom.intersect(\n    first.x[0], first.y[0],\n    last.x[0], last.y[0],\n    p.x, p.y,\n    ctr.x, ctr.y\n    );\n    if (chop != null) {\n    double cl = Geom.length2(chop.x, chop.y, p.x, p.y);\n    if (cl < len) {\n    len = cl;\n    cx = chop.x;\n    cy = chop.y;\n    }\n    }\n    }\n\n    // if none found, pick closest vertex\n    if (len == Double.MAX_VALUE) {\n    for (int j = 0, n = size(); j < n; j++) {\n    Node cp = get(j);\n    double l = Geom.length2(cp.x[0], cp.y[0], p.x, p.y);\n    if (l < len) {\n    len = l;\n    cx = cp.x[0];\n    cy = cp.y[0];\n    }\n    }\n    }\n    return new Point2D.Double(cx, cy);\n     */\n --------------",17,"  public int indexOfOutermostNode() {\n    if (outer == -1) {\n      Point2D.Double ctr = getCenter();\n      outer = 0;\n      double dist = 0;\n      for (int i = 0, n = size(); i < n; i++) {\n        Node cp = get(i);\n        double d = Geom.length2(ctr.x, ctr.y,\n            cp.x[0],\n            cp.y[0]);\n        if (d > dist) {\n          dist = d;\n          outer = i;\n        }\n      }\n    }\n    return outer;\n"
1766,get,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,285,289,3,/**\n   * Convenience method for getting a single coordinate of a control point.\n   */,5,"  public Point2D.Double get(int index, int coord) {\n    Node c = get(index);\n    return new Point2D.Double(\n        c.x[coord],\n        c.y[coord]);\n"
1767,getLengthOfPath,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,870,884,5,/**\n   * Returns the length of the path.\n   *\n   * @param flatness the flatness used to approximate the length.\n   */,15,"  public double getLengthOfPath(double flatness) {\n    double len = 0;\n    PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);\n    double[] coords = new double[6];\n    int type = i.currentSegment(coords);\n    double prevX = coords[0];\n    double prevY = coords[1];\n    i.next();\n    for (; !i.isDone(); i.next()) {\n      i.currentSegment(coords);\n      len += Geom.length(prevX, prevY, coords[0], coords[1]);\n      prevX = coords[0];\n      prevY = coords[1];\n    }\n    return len;\n"
1768,transform,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,663,674,4,/**\n   * Transforms the BezierPath.\n   * @param tx the transformation.\n   */,12,"  public void transform(AffineTransform tx) {\n    Point2D.Double p = new Point2D.Double();\n    for (Node cp : this) {\n      for (int i = 0; i < 3; i++) {\n        p.x = cp.x[i];\n        p.y = cp.y[i];\n        tx.transform(p, p);\n        cp.x[i] = p.x;\n        cp.y[i] = p.y;\n      }\n    }\n    invalidatePath();\n"
1769,set,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,276,279,9,"/**\n   * Convenience method for changing a single coordinate of a control point.\n   */\n --------------\n/** This is a hint for editing tools. If this is set to true,\n     * the editing tools shall keep all control points on the same\n     * line.\n     */\n --------------",4,"  public void set(int index, int coord, Point2D.Double p) {\n    Node c = get(index);\n    c.x[coord] = p.x;\n    c.y[coord] = p.y;\n"
1770,add,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,259,260,7,"/**\n   * Convenience method for adding a control point with three\n   * coordinates C0, C1 and C2 with a mask.\n   */\n --------------\n/** Control point x coordinates. */\n --------------",2,"  public void add(int mask, Point2D.Double c0, Point2D.Double c1, Point2D.Double c2) {\n    add(new Node(mask, c0, c1, c2));\n"
1771,getRelativePositionOnPath,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,895,945,8,"/**\n   * Returns the relative position of the specified point on the path.\n   *\n   * @param flatness the flatness used to approximate the length.\n   *\n   * @return relative position on path, this is a number between 0 and 1.\n   * Returns -1, if the point is not on the path.\n   */",50,"  public double getRelativePositionOnPath(Point2D.Double find, double flatness) {\n    // XXX - This method works only for straight lines!\n    double len = getLengthOfPath(flatness);\n    double relativeLen = 0d;\n    Node v1, v2;\n    BezierPath tempPath = new BezierPath();\n    Node t1, t2;\n    tempPath.add(t1 = new Node());\n    tempPath.add(t2 = new Node());\n    for (int i = 0, n = size() - 1; i < n; i++) {\n      v1 = get(i);\n      v2 = get(i + 1);\n      if (v1.mask == 0 && v2.mask == 0) {\n        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {\n          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);\n          return relativeLen / len;\n        } else {\n          relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);\n        }\n      } else {\n        t1.setTo(v1);\n        t2.setTo(v2);\n        tempPath.invalidatePath();\n        if (tempPath.outlineContains(find, flatness)) {\n          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);\n          return relativeLen / len;\n        } else {\n          relativeLen += Geom.length(v1.x[0], v1.y[0], v2.x[0], v2.y[0]);\n        }\n      }\n    }\n    if (isClosed && size() > 1) {\n      v1 = get(size() - 1);\n      v2 = get(0);\n      if (v1.mask == 0 && v2.mask == 0) {\n        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, flatness)) {\n          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);\n          return relativeLen / len;\n        }\n      } else {\n        t1.setTo(v1);\n        t2.setTo(v2);\n        tempPath.invalidatePath();\n        if (tempPath.outlineContains(find, flatness)) {\n          relativeLen += Geom.length(v1.x[0], v1.y[0], find.x, find.y);\n          return relativeLen / len;\n        }\n      }\n    }\n    return -1;\n"
1772,clone,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,651,656,1,/** Creates a deep copy of the BezierPath. */,6,"  public BezierPath clone() {\n    BezierPath that = (BezierPath) super.clone();\n    for (int i = 0, n = this.size(); i < n; i++) {\n      that.set(i, (Node) this.get(i).clone());\n    }\n    return that;\n"
1774,arcTo,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,1117,1251,28,"/**\n   * Adds an elliptical arc, defined by two radii, an angle from the\n   * x-axis, a flag to choose the large arc or not, a flag to\n   * indicate if we increase or decrease the angles and the final\n   * point of the arc.\n   * <p>\n   * As specified in http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n   * <p>\n   * The implementation of this method has been derived from\n   * Apache Batik class org.apache.batik.ext.awt.geom.ExtendedGeneralPath#computArc\n   *\n   * @param rx the x radius of the ellipse\n   * @param ry the y radius of the ellipse\n   *\n   * @param xAxisRotation the angle from the x-axis of the current\n   * coordinate system to the x-axis of the ellipse in degrees.\n   *\n   * @param largeArcFlag the large arc flag. If true the arc\n   * spanning less than or equal to 180 degrees is chosen, otherwise\n   * the arc spanning greater than 180 degrees is chosen\n   *\n   * @param sweepFlag the sweep flag. If true the line joining\n   * center to arc sweeps through decreasing angles otherwise it\n   * sweeps through increasing angles\n   *\n   * @param x the absolute x coordinate of the final point of the arc.\n   * @param y the absolute y coordinate of the final point of the arc.\n   */",122,"  public void arcTo(double rx, double ry,\n      double xAxisRotation,\n      boolean largeArcFlag, boolean sweepFlag,\n      double x, double y) {\n\n    // Ensure radii are valid\n    if (rx == 0 || ry == 0) {\n      lineTo(x, y);\n      return;\n    }\n    // Get the current (x, y) coordinates of the path\n    Node lastPoint = get(size() - 1);\n    double x0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.x[2] : lastPoint.x[0];\n    double y0 = ((lastPoint.mask & C2_MASK) == C2_MASK) ? lastPoint.y[2] : lastPoint.y[0];\n    if (x0 == x && y0 == y) {\n      // If the endpoints (x, y) and (x0, y0) are identical, then this\n      // is equivalent to omitting the elliptical arc segment entirely.\n      return;\n    }\n    // Compute the half distance between the current and the final point\n    double dx2 = (x0 - x) / 2d;\n    double dy2 = (y0 - y) / 2d;\n    // Convert angle from degrees to radians\n    double angle = Math.toRadians(xAxisRotation);\n    double cosAngle = Math.cos(angle);\n    double sinAngle = Math.sin(angle);\n    //\n    // Step 1 : Compute (x1, y1)\n    //\n    double x1 = (cosAngle * dx2 + sinAngle * dy2);\n    double y1 = (-sinAngle * dx2 + cosAngle * dy2);\n    // Ensure radii are large enough\n    rx = Math.abs(rx);\n    ry = Math.abs(ry);\n    double Prx = rx * rx;\n    double Pry = ry * ry;\n    double Px1 = x1 * x1;\n    double Py1 = y1 * y1;\n    // check that radii are large enough\n    double radiiCheck = Px1 / Prx + Py1 / Pry;\n    if (radiiCheck > 1) {\n      rx = Math.sqrt(radiiCheck) * rx;\n      ry = Math.sqrt(radiiCheck) * ry;\n      Prx = rx * rx;\n      Pry = ry * ry;\n    }\n    //\n    // Step 2 : Compute (cx1, cy1)\n    //\n    double sign = (largeArcFlag == sweepFlag) ? -1 : 1;\n    double sq = ((Prx * Pry) - (Prx * Py1) - (Pry * Px1)) / ((Prx * Py1) + (Pry * Px1));\n    sq = (sq < 0) ? 0 : sq;\n    double coef = (sign * Math.sqrt(sq));\n    double cx1 = coef * ((rx * y1) / ry);\n    double cy1 = coef * -((ry * x1) / rx);\n    //\n    // Step 3 : Compute (cx, cy) from (cx1, cy1)\n    //\n    double sx2 = (x0 + x) / 2.0;\n    double sy2 = (y0 + y) / 2.0;\n    double cx = sx2 + (cosAngle * cx1 - sinAngle * cy1);\n    double cy = sy2 + (sinAngle * cx1 + cosAngle * cy1);\n    //\n    // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle)\n    //\n    double ux = (x1 - cx1) / rx;\n    double uy = (y1 - cy1) / ry;\n    double vx = (-x1 - cx1) / rx;\n    double vy = (-y1 - cy1) / ry;\n    double p, n;\n    // Compute the angle start\n    n = Math.sqrt((ux * ux) + (uy * uy));\n    p = ux; // (1 * ux) + (0 * uy)\n    sign = (uy < 0) ? -1d : 1d;\n    double angleStart = Math.toDegrees(sign * Math.acos(p / n));\n    // Compute the angle extent\n    n = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));\n    p = ux * vx + uy * vy;\n    sign = (ux * vy - uy * vx < 0) ? -1d : 1d;\n    double angleExtent = Math.toDegrees(sign * Math.acos(p / n));\n    if (!sweepFlag && angleExtent > 0) {\n      angleExtent -= 360f;\n    } else if (sweepFlag && angleExtent < 0) {\n      angleExtent += 360f;\n    }\n    angleExtent %= 360f;\n    angleStart %= 360f;\n    //\n    // We can now build the resulting Arc2D in double precision\n    //\n    Arc2D.Double arc = new Arc2D.Double(\n        cx - rx, cy - ry,\n        rx * 2d, ry * 2d,\n        -angleStart, -angleExtent,\n        Arc2D.OPEN);\n    // Create a path iterator of the rotated arc\n    PathIterator i = arc.getPathIterator(\n        AffineTransform.getRotateInstance(\n        angle, arc.getCenterX(), arc.getCenterY()));\n    // Add the segments to the bezier path\n    double[] coords = new double[6];\n    i.next(); // skip first moveto\n    while (!i.isDone()) {\n      int type = i.currentSegment(coords);\n      switch (type) {\n        case PathIterator.SEG_CLOSE:\n          // ignore\n          break;\n        case PathIterator.SEG_CUBICTO:\n          curveTo(coords[0], coords[1], coords[2], coords[3], coords[4], coords[5]);\n          break;\n        case PathIterator.SEG_LINETO:\n          lineTo(coords[0], coords[1]);\n          break;\n        case PathIterator.SEG_MOVETO:\n          // ignore\n          break;\n        case PathIterator.SEG_QUADTO:\n          quadTo(coords[0], coords[1], coords[2], coords[3]);\n          break;\n      }\n      i.next();\n"
1775,chop,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,709,711,5,"/**\n   * Returns a point on the edge of the bezier path which crosses the line\n   * from the center of the bezier path to the specified point.\n   * If no edge crosses the line, the nearest C0 control point is returned.\n   */",3,"  public Point2D.Double chop(Point2D.Double p) {\n    validatePath();\n    return Geom.chop(generalPath, p);\n"
1776,setWindingRule,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,1271,1275,4,/**\n   * Sets winding rule for filling the bezier path.\n   * @param newValue Must be Path2D.Double.WIND_EVEN_ODD or Path2D.Double.WIND_NON_ZERO.\n   */,5,  public void setWindingRule(int newValue) {\n    if (newValue != windingRule) {\n      invalidatePath();\n      int oldValue = windingRule;\n      this.windingRule = newValue;\n
1777,validatePath,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,304,306,3,"/**\n   * Recomputes the BezierPath, if it is invalid.\n   */",3,  public void validatePath() {\n    if (generalPath == null) {\n      generalPath = toGeneralPath();\n
1778,findSegment,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,953,993,5,/**\n   * Gets the segment of the polyline that is hit by\n   * the given Point2D.Double.\n   * @return the index of the segment or -1 if no segment was hit.\n   */,40,"  public int findSegment(Point2D.Double find, double tolerance) {\n    // XXX - This works only for straight lines!\n    Node v1, v2;\n    BezierPath tempPath = new BezierPath();\n    Node t1, t2;\n    tempPath.add(t1 = new Node());\n    tempPath.add(t2 = new Node());\n    for (int i = 0, n = size() - 1; i < n; i++) {\n      v1 = get(i);\n      v2 = get(i + 1);\n      if (v1.mask == 0 && v2.mask == 0) {\n        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {\n          return i;\n        }\n      } else {\n        t1.setTo(v1);\n        t2.setTo(v2);\n        tempPath.invalidatePath();\n        if (tempPath.outlineContains(find, tolerance)) {\n          return i;\n        }\n      }\n    }\n    if (isClosed && size() > 1) {\n      v1 = get(size() - 1);\n      v2 = get(0);\n      if (v1.mask == 0 && v2.mask == 0) {\n        if (Geom.lineContainsPoint(v1.x[0], v1.y[0], v2.x[0], v2.y[0], find.x, find.y, tolerance)) {\n          return size() - 1;\n        }\n      } else {\n        t1.setTo(v1);\n        t2.setTo(v2);\n        tempPath.invalidatePath();\n        if (tempPath.outlineContains(find, tolerance)) {\n          return size() - 1;\n        }\n      }\n    }\n    return -1;\n"
1779,getPointOnPath,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,817,862,7,/**\n   * Returns a relative point on the path.\n   * Where 0 is the start point of the path and 1 is the end point of the\n   * path.\n   *\n   * @param relative a value between 0 and 1.\n   */,44,"  public Point2D.Double getPointOnPath(double relative, double flatness) {\n    // This method works only for straight lines\n    if (size() == 0) {\n      return null;\n    } else if (size() == 1) {\n      return get(0).getControlPoint(0);\n    }\n    if (relative <= 0) {\n      return get(0).getControlPoint(0);\n    } else if (relative >= 1) {\n      return get(size() - 1).getControlPoint(0);\n    }\n    validatePath();\n    // Compute the relative point on the path\n    double len = getLengthOfPath(flatness);\n    double relativeLen = len * relative;\n    double pos = 0;\n    double[] coords = new double[6];\n    PathIterator i = generalPath.getPathIterator(new AffineTransform(), flatness);\n    int type = i.currentSegment(coords);\n    double prevX = coords[0];\n    double prevY = coords[1];\n    i.next();\n    for (; !i.isDone(); i.next()) {\n      i.currentSegment(coords);\n      double segLen = Geom.length(prevX, prevY, coords[0], coords[1]);\n      if (pos + segLen >= relativeLen) {\n        //if (true) return new Point2D.Double(coords[0], coords[1]);\n        // Compute the relative Point2D.Double on the line\n        /*\n        return new Point2D.Double(\n        prevX * pos / len + coords[0] * (pos + segLen) / len,\n        prevY * pos / len + coords[1] * (pos + segLen) / len\n        );*/\n        double factor = (relativeLen - pos) / segLen;\n        return new Point2D.Double(\n            prevX * (1 - factor) + coords[0] * factor,\n            prevY * (1 - factor) + coords[1] * factor);\n      }\n      pos += segLen;\n      prevX = coords[0];\n      prevY = coords[1];\n    }\n    throw new InternalError(""We should never get here"");\n"
1780,joinSegments,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,1001,1009,5,/**\n   * Joins two segments into one if the given Point2D.Double hits a node\n   * of the bezier path.\n   * @return the index of the joined segment or -1 if no segment was joined.\n   */,9,"  public int joinSegments(Point2D.Double join, double tolerance) {\n    for (int i = 0; i < size(); i++) {\n      Node p = get(i);\n      if (Geom.length(p.x[0], p.y[0], join.x, join.y) < tolerance) {\n        remove(i);\n        return i;\n      }\n    }\n    return -1;\n"
1781,outlineContains,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,400,401,7,"/**\n   * Returns true, if the outline of this bezier path contains the specified\n   * point.\n   *\n   * @param p The point to be tested.\n   * @param tolerance The tolerance for the test.\n   */",2,"  public boolean outlineContains(Point2D.Double p, double tolerance) {\n    return Shapes.outlineContains(this, p, tolerance);\n"
1782,getCenter,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,692,701,3,/**\n   * Returns the point at the center of the bezier path.\n   */,9,"  public Point2D.Double getCenter() {\n    double sx = 0;\n    double sy = 0;\n    for (Node p : this) {\n      sx += p.x[0];\n      sy += p.y[0];\n    }\n    int n = size();\n    return new Point2D.Double(sx / n, sy / n);\n"
1783,splitSegment,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,1016,1037,4,/**\n   * Splits the segment at the given Point2D.Double if a segment was hit.\n   * @return the index of the segment or -1 if no segment was hit.\n   */,22,"  public int splitSegment(Point2D.Double split, double tolerance) {\n    int i = findSegment(split, tolerance);\n    int nextI = (i + 1) % size();\n    if (i != -1) {\n      if ((get(i).mask & C2_MASK) == C2_MASK\n          && (get(nextI).mask & C1_MASK) == 0) {\n        // quadto\n        add(i + 1, new Node(C2_MASK, split, split, split));\n      } else if ((get(i).mask & C2_MASK) == 0\n          && (get(nextI).mask & C1_MASK) == C1_MASK) {\n        // quadto\n        add(i + 1, new Node(C1_MASK, split, split, split));\n      } else if ((get(i).mask & C2_MASK) == C2_MASK\n          && (get(nextI).mask & C1_MASK) == C1_MASK) {\n        // cubicto\n        add(i + 1, new Node(C1_MASK | C2_MASK, split, split, split));\n      } else {\n        // lineto\n        add(i + 1, new Node(split));\n      }\n    }\n    return i + 1;\n"
1785,addAll,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,267,269,7,/**\n   * Convenience method for adding multiple control points with a single\n   * coordinate C0.\n   */\n --------------\n/** Control point y coordinates. */\n --------------,3,"  public void addAll(Collection<Point2D.Double> points) {\n    for (Point2D.Double c0 : points) {\n      add(new Node(0, c0, c0, c0));\n"
1786,invalidatePath,BezierPath,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPath.java,295,298,3,/**\n   * This must be called after the BezierPath has been changed.\n   */,4,  public void invalidatePath() {\n    generalPath = null;\n    bounds = null;\n    outer = -1;\n
1787,mousePressed,TextAreaEditingTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaEditingTool.java,81,85,4,"/**\n   * Creates a new figure at the mouse location.\n   * If editing is in progress, this finishes editing.\n   */",5,"  @Override\n  public void mousePressed(MouseEvent e) {\n    if (typingTarget != null) {\n      beginEdit(typingTarget);\n      updateCursor(getView(), e.getPoint());\n"
1788,TextAreaEditingTool,TextAreaEditingTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextAreaEditingTool.java,67,68,1,/** Creates a new instance. */,2,  public TextAreaEditingTool(TextHolderFigure typingTarget) {\n    this.typingTarget = typingTarget;\n
1789,mousePressed,TextEditingTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextEditingTool.java,70,74,3,/**\n   * If the pressed figure is a TextHolderFigure it can be edited.\n   */,5,"  @Override\n  public void mousePressed(MouseEvent e) {\n    if (typingTarget != null) {\n      beginEdit(typingTarget);\n      updateCursor(getView(), e.getPoint());\n"
1790,TextEditingTool,TextEditingTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/TextEditingTool.java,57,58,1,/** Creates a new instance. */,2,  public TextEditingTool(TextHolderFigure typingTarget) {\n    this.typingTarget = typingTarget;\n
1791,reparameterize,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,559,568,10,"/**\n   * Given set of points and their parameterization, try to find\n   * a better parameterization.\n   *\n   * @param d  Array of digitized points.\n   * @param first Indice of first point of region in d.\n   * @param last Indice of last point of region in d.\n   * @param u Current parameter values.\n   * @param bezCurve Current fitted curve.\n   */",9,"  private static double[] reparameterize(ArrayList<Point2D.Double> d, int first, int last, double[] u, Point2D.Double[] bezCurve) {\n    int nPts = last - first + 1;\n    int i;\n    double[] uPrime; /*  New parameter values  */\n    uPrime = new double[nPts];\n    for (i = first; i <= last; i++) {\n      uPrime[i - first] = newtonRaphsonRootFind(bezCurve, d.get(i), u[i - first]);\n    }\n    return (uPrime);\n"
1792,fitBezierPath,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,65,66,9,"/**\n   * Fits a bezier path to the specified list of digitized points.\n   * <p>\n   * This is a convenience method for calling fitCubicSegments(List<Point2D.Double>, double);\n   * \n   * @param digitizedPoints digited points.\n   * @param error the maximal allowed error between the bezier path and the\n   * digitized points. \n   */",2,"  public static BezierPath fitBezierPath(Point2D.Double[] digitizedPoints, double error) {\n    return fitBezierPath(Arrays.asList(digitizedPoints), error);\n"
1793,fitBezierPath,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,146,151,9,"/**\n   * Fits a bezier path to the specified list of digitized points.\n   * <p>\n   * This is a convenience method for calling fitCubicSegments(List<Point2D.Double>, double);\n   * \n   * @param digitizedPoints digited points.\n   * @param error the maximal allowed error between the bezier path and the\n   * digitized points. \n   */",6,"  public static BezierPath fitBezierPath(BezierPath digitizedPoints, double error) {\n    ArrayList<Point2D.Double> d = new ArrayList<Point2D.Double>(digitizedPoints.size());\n    for (BezierPath.Node n : digitizedPoints) {\n      d.add(new Point2D.Double(n.x[0], n.y[0]));\n    }\n    return fitBezierPath(d, error);\n"
1794,v2Length,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,762,763,3,/**\n   * Returns length of input vector.\n   */,2,  private static double v2Length(Point2D.Double a) {\n    return Math.sqrt(v2SquaredLength(a));\n
1795,reduceNoise,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,332,350,15,"/**\n   * Reduces noise from the digitized points, by applying an approximation\n   * of a gaussian filter to the data.\n   * <p>\n   * The filter does the following for each point P, with weight 0.5:\n   * <p>\n   * x[i] = 0.5*x[i] + 0.25*x[i-1] + 0.25*x[i+1];\n   * y[i] = 0.5*y[i] + 0.25*y[i-1] + 0.25*y[i+1];\n   * \n   * \n   * \n   * @param digitizedPoints Digitized points\n   * @param weight Weight of the current point\n   * @return Digitized points with reduced noise.\n   */",19,"  public static ArrayList<Point2D.Double> reduceNoise(java.util.List<Point2D.Double> digitizedPoints, double weight) {\n    java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();\n    if (digitizedPoints.size() > 0) {\n      Point2D.Double prev = digitizedPoints.get(0);\n      cleaned.add(prev);\n      double pnWeight = (1d - weight) / 2d; // weight of previous and next\n      for (int i = 1, n = digitizedPoints.size() - 1; i < n; i++) {\n        Point2D.Double cur = digitizedPoints.get(i);\n        Point2D.Double next = digitizedPoints.get(i + 1);\n        cleaned.add(new Point2D.Double(\n            cur.x * weight + pnWeight * prev.x + pnWeight * next.x,\n            cur.y * weight + pnWeight * prev.y + pnWeight * next.y));\n        prev = cur;\n      }\n      if (digitizedPoints.size() > 1) {\n        cleaned.add(digitizedPoints.get(digitizedPoints.size() - 1));\n      }\n    }\n    return cleaned;\n"
1796,chordLengthParameterize,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,530,546,8,/**\n   * Assign parameter values to digitized points\n   * using relative distances between points.\n   *\n   * @param d Digitized points.\n   * @param first Indice of first point of region in d.\n   * @param last Indice of last point of region in d.\n   */,13,"  private static double[] chordLengthParameterize(ArrayList<Point2D.Double> d, int first, int last) {\n    int i;\n    double[] u;  /*  Parameterization    */\n    u = new double[last - first + 1];\n    u[0] = 0.0;\n    for (i = first + 1; i <= last; i++) {\n      u[i - first] = u[i - first - 1] +\n          v2DistanceBetween2Points(d.get(i), d.get(i - 1));\n    }\n    for (i = first + 1; i <= last; i++) {\n      u[i - first] = u[i - first] / u[last - first];\n    }\n    return (u);\n"
1797,fitCubic,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,367,451,14,/**\n   * Fit one or multiple subsequent cubic bezier curves to a (sub)set of \n   * digitized points. The digitized points represent a smooth curve without\n   * corners.\n   *\n   * @param d  Array of digitized points. Must not contain subsequent \n   * coincident points.\n   * @param first Indice of first point in d.\n   * @param last Indice of last point in d.\n   * @param tHat1 Unit tangent vectors at start point.\n   * @param tHat2 Unit tanget vector at end point.\n   * @param errorSquared User-defined errorSquared squared.\n   * @param bezierPath Path to which the bezier curve segments are added.\n   */,75,"  private static void fitCubic(ArrayList<Point2D.Double> d, int first, int last,\n      Point2D.Double tHat1, Point2D.Double tHat2,\n      double errorSquared, BezierPath bezierPath) {\n    Point2D.Double[] bezCurve; /*Control points of fitted Bezier curve*/\n    double[] u;    /*  Parameter values for point  */\n    double maxError;  /*  Maximum fitting errorSquared   */\n    int[] splitPoint = new int[1]; /*  Point to split point set at.\n    This is an array of size one, because we need it as an input/output parameter.\n     */\n    int nPts;    /*  Number of points in subset  */\n    double iterationError; /* Error below which you try iterating  */\n    int maxIterations = 4; /*  Max times to try iterating  */\n    Point2D.Double tHatCenter = new Point2D.Double(); /* Unit tangent vector at splitPoint */\n    int i;\n    // clone unit tangent vectors, so that we can alter their coordinates\n    // without affecting the input values.\n    tHat1 = (Point2D.Double) tHat1.clone();\n    tHat2 = (Point2D.Double) tHat2.clone();\n    iterationError = errorSquared * errorSquared;\n    nPts = last - first + 1;\n    /*  Use heuristic if region only has two points in it */\n    if (nPts == 2) {\n      double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;\n      bezCurve = new Point2D.Double[4];\n      for (i = 0; i < bezCurve.length; i++) {\n        bezCurve[i] = new Point2D.Double();\n      }\n      bezCurve[0] = d.get(first);\n      bezCurve[3] = d.get(last);\n      v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);\n      v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);\n      bezierPath.curveTo(\n          bezCurve[1].x, bezCurve[1].y,\n          bezCurve[2].x, bezCurve[2].y,\n          bezCurve[3].x, bezCurve[3].y);\n      return;\n    }\n    /*  Parameterize points, and attempt to fit curve */\n    u = chordLengthParameterize(d, first, last);\n    bezCurve = generateBezier(d, first, last, u, tHat1, tHat2);\n    /*  Find max deviation of points to fitted curve */\n    maxError = computeMaxError(d, first, last, bezCurve, u, splitPoint);\n    if (maxError < errorSquared) {\n      addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);\n      return;\n    }\n\n    /*  If errorSquared not too large, try some reparameterization  */\n    /*  and iteration */\n    if (maxError < iterationError) {\n      double[] uPrime;  /*  Improved parameter values */\n      for (i = 0; i < maxIterations; i++) {\n        uPrime = reparameterize(d, first, last, u, bezCurve);\n        bezCurve = generateBezier(d, first, last, uPrime, tHat1, tHat2);\n        maxError = computeMaxError(d, first, last, bezCurve, uPrime, splitPoint);\n        if (maxError < errorSquared) {\n          addCurveTo(bezCurve, bezierPath, errorSquared, first == 0 && last == d.size() - 1);\n          return;\n        }\n        u = uPrime;\n      }\n    }\n    /* Fitting failed -- split at max errorSquared point and fit recursively */\n    tHatCenter = computeCenterTangent(d, splitPoint[0]);\n    if (first < splitPoint[0]) {\n      fitCubic(d, first, splitPoint[0], tHat1, tHatCenter, errorSquared, bezierPath);\n    } else {\n      bezierPath.lineTo(d.get(splitPoint[0]).x, d.get(splitPoint[0]).y);\n     //   System.err.println(""Can\'t split any further "" + first + "".."" + splitPoint[0]);\n    }\n    v2Negate(tHatCenter);\n    if (splitPoint[0] < last) {\n      fitCubic(d, splitPoint[0], last, tHatCenter, tHat2, errorSquared, bezierPath);\n    } else {\n      bezierPath.lineTo(d.get(last).x, d.get(last).y);\n"
1798,computeCenterTangent,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,510,519,6,"/**\n   * Approximate unit tangents at ""center"" of digitized curve.\n   *\n   * @param d Digitized points.\n   * @param center Index to ""center"" end of region.\n   */",9,"  private static Point2D.Double computeCenterTangent(ArrayList<Point2D.Double> d, int center) {\n    Point2D.Double V1 = new Point2D.Double(), V2 = new Point2D.Double(),\n        tHatCenter = new Point2D.Double();\n    V1 = v2SubII(d.get(center - 1), d.get(center));\n    V2 = v2SubII(d.get(center), d.get(center + 1));\n    tHatCenter.x = (V1.x + V2.x) / 2.0;\n    tHatCenter.y = (V1.y + V2.y) / 2.0;\n    tHatCenter = v2Normalize(tHatCenter);\n    return tHatCenter;\n"
1799,v2SubII,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,830,834,7,/**\n   * Subtract Vector a from Vector b.\n   * \n   * @param a Vector a - the value is not changed by this method\n   * @param b Vector b - the value is not changed by this method\n   * @return Vector a subtracted by Vector v.\n   */,5,"  private static Point2D.Double v2SubII(Point2D.Double a, Point2D.Double b) {\n    Point2D.Double c = new Point2D.Double();\n    c.x = a.x - b.x;\n    c.y = a.y - b.y;\n    return (c);\n"
1800,v2Normalize,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,813,820,3,/**\n   * Normalizes the input vector and returns it.\n   */,7,  private static Point2D.Double v2Normalize(Point2D.Double v) {\n    double len = v2Length(v);\n    if (len != 0.0) {\n      v.x /= len;\n      v.y /= len;\n    }\n    return v;\n
1801,bezierII,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,686,706,7,/**\n   * Evaluate a Bezier curve at a particular parameter value.\n   *\n   * @param degree  The degree of the bezier curve.\n   * @param V  Array of control points.\n   * @param t  Parametric value to find point for.\n   */,18,"  private static Point2D.Double bezierII(int degree, Point2D.Double[] V, double t) {\n    int i, j;\n    Point2D.Double q; /* Point on curve at parameter t  */\n    Point2D.Double[] vTemp; /* Local copy of control points    */\n    /* Copy array  */\n    vTemp = new Point2D.Double[degree + 1];\n    for (i = 0; i <= degree; i++) {\n      vTemp[i] = (Point2D.Double) V[i].clone();\n    }\n    /* Triangle computation  */\n    for (i = 1; i <= degree; i++) {\n      for (j = 0; j <= degree - i; j++) {\n        vTemp[j].x = (1.0 - t) * vTemp[j].x + t * vTemp[j + 1].x;\n        vTemp[j].y = (1.0 - t) * vTemp[j].y + t * vTemp[j + 1].y;\n      }\n    }\n    q = vTemp[0];\n    return q;\n"
1802,v2DistanceBetween2Points,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,719,720,3,/**\n   * Return the distance between two points\n   */,2,"  private static double v2DistanceBetween2Points(Point2D.Double a, Point2D.Double b) {\n    return Math.sqrt(v2SquaredDistanceBetween2Points(a, b));\n"
1804,v2Scale,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,737,744,5,/**\n   * Scales the input vector to the new length and returns it.\n   * <p>\n   * This method alters the value of the input point!\n   */,7,"  private static Point2D.Double v2Scale(Point2D.Double v, double newlen) {\n    double len = v2Length(v);\n    if (len != 0.0) {\n      v.x *= newlen / len;\n      v.y *= newlen / len;\n    }\n    return v;\n"
1805,findCorners,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,264,314,9,"/**\n   * Finds corners in the provided point list, and returns their indices.\n   * \n   * @param digitizedPoints List of digitized points.\n   * @param minAngle Minimal angle for corner points\n   * @param minDistance Minimal distance between a point and adjacent points\n   * for corner detection\n   * @return list of corner indices.\n   */",45,"  public static ArrayList<Integer> findCorners(java.util.List<Point2D.Double> digitizedPoints, double minAngle, double minDistance) {\n    ArrayList<Integer> cornerIndices = new ArrayList<Integer>();\n    double squaredDistance = minDistance * minDistance;\n    int previousCorner = -1;\n    double previousCornerAngle = 0;\n    for (int i = 1, n = digitizedPoints.size(); i < n - 1; i++) {\n      Point2D.Double p = digitizedPoints.get(i);\n      // search for a preceding point for corner detection\n      Point2D.Double prev = null;\n      boolean intersectsPreviousCorner = false;\n      for (int j = i - 1; j >= 0; j--) {\n        if (j == previousCorner || v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {\n          prev = digitizedPoints.get(j);\n          intersectsPreviousCorner = j < previousCorner;\n          break;\n        }\n      }\n      if (prev == null) {\n        continue;\n      }\n      // search for a succeeding point for corner detection\n      Point2D.Double next = null;\n      for (int j = i + 1; j < n; j++) {\n        if (v2SquaredDistanceBetween2Points(digitizedPoints.get(j), p) >= squaredDistance) {\n          next = digitizedPoints.get(j);\n          break;\n        }\n      }\n      if (next == null) {\n        continue;\n      }\n      double aPrev = Math.atan2(prev.y - p.y, prev.x - p.x);\n      double aNext = Math.atan2(next.y - p.y, next.x - p.x);\n      double angle = Math.abs(aPrev - aNext);\n      if (angle < Math.PI - minAngle || angle > Math.PI + minAngle) {\n        if (intersectsPreviousCorner) {\n          cornerIndices.set(cornerIndices.size() - 1, i);\n        } else {\n          cornerIndices.add(i);\n        }\n        previousCorner = i;\n        previousCornerAngle = angle;\n      }\n    }\n    return cornerIndices;\n"
1806,v2SquaredDistanceBetween2Points,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,726,729,3,/**\n   * Return the distance between two points\n   */,4,"  private static double v2SquaredDistanceBetween2Points(Point2D.Double a, Point2D.Double b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return (dx * dx) + (dy * dy);\n"
1807,computeRightTangent,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,497,501,6,"/**\n   * Approximate unit tangents at ""right"" endpoint of digitized curve.\n   *\n   * @param d Digitized points.\n   * @param end Index to ""right"" end of region.\n   */",5,"  private static Point2D.Double computeRightTangent(ArrayList<Point2D.Double> d, int end) {\n    Point2D.Double tHat2 = new Point2D.Double();\n    tHat2 = v2SubII(d.get(end - 1), d.get(end));\n    tHat2 = v2Normalize(tHat2);\n    return tHat2;\n"
1808,v2Negate,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,797,800,3,/**\n   * Negates the input vector and returns it.\n   */,4,  private static Point2D.Double v2Negate(Point2D.Double v) {\n    v.x = -v.x;\n    v.y = -v.y;\n    return v;\n
1809,addCurveTo,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,462,474,6,/**\n   * Adds the curve to the bezier path.\n   * \n   * @param bezCurve\n   * @param bezierPath\n   */,12,"  private static void addCurveTo(Point2D.Double[] bezCurve, BezierPath bezierPath, double errorSquared, boolean connectsCorners) {\n    BezierPath.Node lastNode = bezierPath.get(bezierPath.size() - 1);\n    double error = Math.sqrt(errorSquared);\n    if (connectsCorners && Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[1].x, bezCurve[1].y, error) &&\n        Geom.lineContainsPoint(lastNode.x[0], lastNode.y[0], bezCurve[3].x, bezCurve[3].y, bezCurve[2].x, bezCurve[2].y, error)) {\n      bezierPath.lineTo(\n          bezCurve[3].x, bezCurve[3].y);\n    } else {\n      bezierPath.curveTo(\n          bezCurve[1].x, bezCurve[1].y,\n          bezCurve[2].x, bezCurve[2].y,\n          bezCurve[3].x, bezCurve[3].y);\n"
1810,splitAtCorners,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,238,252,13,"/**\n   * Splits the digitized points into multiple segments at each corner point.\n   * <p>\n   * Corner points are both contained as the last point of a segment and\n   * the first point of a subsequent segment.\n   * \n   * @param digitizedPoints Digitized points \n   * @param maxAngle maximal angle in radians between the current point and its\n   * predecessor and successor up to which the point does not break the\n   * digitized list into segments. Recommended value 44 = 44 * 180d / Math.PI\n   * @return Segments of digitized points, each segment having less than maximal\n   * angle between points.\n   */",13,"  public static ArrayList<ArrayList<Point2D.Double>> splitAtCorners(java.util.List<Point2D.Double> digitizedPoints, double maxAngle, double minDistance) {\n    ArrayList<Integer> cornerIndices = findCorners(digitizedPoints, maxAngle, minDistance);\n    ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>(cornerIndices.size() + 1);\n    if (cornerIndices.size() == 0) {\n      segments.add(new ArrayList<Point2D.Double>(digitizedPoints));\n    } else {\n      segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(0, cornerIndices.get(0) + 1)));\n      for (int i = 1; i < cornerIndices.size(); i++) {\n        segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(i - 1), cornerIndices.get(i) + 1)));\n      }\n      segments.add(new ArrayList<Point2D.Double>(digitizedPoints.subList(cornerIndices.get(cornerIndices.size() - 1), digitizedPoints.size())));\n    }\n    return segments;\n"
1811,v2Dot,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,806,807,3,/**\n   * Return the dot product of vectors a and b.\n   */,2,"  private static double v2Dot(Point2D.Double a, Point2D.Double b) {\n    return (a.x * b.x) + (a.y * b.y);\n"
1812,computeLeftTangent,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,484,488,6,"/**\n   * Approximate unit tangents at ""left"" endpoint of digitized curve.\n   *\n   * @param d Digitized points.\n   * @param end Index to ""left"" end of region.\n   */",5,"  private static Point2D.Double computeLeftTangent(ArrayList<Point2D.Double> d, int end) {\n    Point2D.Double tHat1 = new Point2D.Double();\n    tHat1 = v2SubII(d.get(end + 1), d.get(end));\n    tHat1 = v2Normalize(tHat1);\n    return tHat1;\n"
1813,v2AddII,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,787,791,3,/**\n   * Return vector sum = a+b.\n   */,5,"  private static Point2D.Double v2AddII(Point2D.Double a, Point2D.Double b) {\n    Point2D.Double c = new Point2D.Double();\n    c.x = a.x + b.x;\n    c.y = a.y + b.y;\n    return c;\n"
1814,generateBezier,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,660,676,11,/**\n   * Use least-squares method to find Bezier control points for region.\n   *\n   * @param d  Array of digitized points.\n   * @param first Indice of first point in d.\n   * @param last Indice of last point in d.\n   * @param uPrime Parameter values for region .\n   * @param tHat1 Unit tangent vectors at start point.\n   * @param tHat2 Unit tanget vector at end point.\n   * @return A cubic bezier curve consisting of 4 control points.\n   */,14,"  private static Point2D.Double[] generateBezier(ArrayList<Point2D.Double> d, int first, int last, double[] uPrime, Point2D.Double tHat1, Point2D.Double tHat2) {\n    Point2D.Double[] bezCurve;\n    bezCurve = new Point2D.Double[4];\n    for (int i = 0; i < bezCurve.length; i++) {\n      bezCurve[i] = new Point2D.Double();\n    }\n\n    /*  Use the Wu/Barsky heuristic*/\n    double dist = v2DistanceBetween2Points(d.get(last), d.get(first)) / 3.0;\n    bezCurve[0] = d.get(first);\n    bezCurve[3] = d.get(last);\n    v2Add(bezCurve[0], v2Scale(tHat1, dist), bezCurve[1]);\n    v2Add(bezCurve[3], v2Scale(tHat2, dist), bezCurve[2]);\n    return (bezCurve);\n"
1815,removeCoincidentPoints,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,210,222,13,"/**\n   * Removes sequences of coincident points.\n   * <p>\n   * The purpose of this method, is to clean up a list of digitized points\n   * for later processing using method {@link #splitAtCorners}.\n   * <p>\n   * Use this method only, if you know that the digitized points contain no\n   * quantization errors - which is never the case, unless you want to debug\n   * the curve fitting algorithm of this class.\n   * \n   * @param digitizedPoints Digitized points\n   * @return Digitized points without subsequent duplicates.\n   */",13,  private static ArrayList<Point2D.Double> removeCoincidentPoints(java.util.List<Point2D.Double> digitizedPoints) {\n    java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();\n    if (digitizedPoints.size() > 0) {\n      Point2D.Double prev = digitizedPoints.get(0);\n      cleaned.add(prev);\n      for (Point2D.Double p : digitizedPoints) {\n        if (!prev.equals(p)) {\n          cleaned.add(p);\n          prev = p;\n        }\n      }\n    }\n    return cleaned;\n
1816,v2SquaredLength,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,769,770,3,/**\n   * Returns squared length of input vector.\n   */,2,  private static double v2SquaredLength(Point2D.Double a) {\n    return (a.x * a.x) + (a.y * a.y);\n
1817,fitBezierPath,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,76,134,7,/**\n   * Fits a bezier path to the specified list of digitized points.\n   * \n   * @param digitizedPoints digited points.\n   * @param error the maximal allowed error between the bezier path and the\n   * digitized points. \n   */,55,"  public static BezierPath fitBezierPath(java.util.List<Point2D.Double> digitizedPoints, double error) {\n    // Split into segments at corners\n    ArrayList<ArrayList<Point2D.Double>> segments = new ArrayList<ArrayList<Point2D.Double>>();\n    segments = splitAtCorners(digitizedPoints, 77 / 180d * Math.PI, error * error);\n    \n    // Clean up the data in the segments\n    for (int i = 0, n = segments.size(); i < n; i++) {\n      ArrayList<Point2D.Double> seg = segments.get(i);\n      seg = removeClosePoints(seg, error * 2);\n      seg = reduceNoise(seg, 0.8);\n      segments.set(i, seg);\n    }\n\n    // Create fitted bezier path\n    BezierPath fittedPath = new BezierPath();\n\n    // Quickly deal with empty dataset\n    boolean isEmpty = false;\n    for (ArrayList<Point2D.Double> seg : segments) {\n      if (seg.isEmpty()) {\n        isEmpty = false;\n        break;\n      }\n    }\n    if (!isEmpty) {\n      // Process each segment of digitized points\n      double errorSquared = error * error;\n      for (ArrayList<Point2D.Double> seg : segments) {\n        switch (seg.size()) {\n          case 0:\n            break;\n          case 1:\n            fittedPath.add(new BezierPath.Node(seg.get(0)));\n            break;\n          case 2:\n            if (fittedPath.isEmpty()) {\n              fittedPath.add(new BezierPath.Node(seg.get(0)));\n            }\n            fittedPath.lineTo(seg.get(1).x, seg.get(1).y);\n            break;\n          default:\n            if (fittedPath.isEmpty()) {\n              fittedPath.add(new BezierPath.Node(seg.get(0)));\n            }\n            /*  Unit tangent vectors at endpoints */\n            Point2D.Double tHat1 = new Point2D.Double();\n            Point2D.Double tHat2 = new Point2D.Double();\n            tHat1 = computeLeftTangent(seg, 0);\n            tHat2 = computeRightTangent(seg, seg.size() - 1);\n            fitCubic(seg, 0, seg.size() - 1, tHat1, tHat2, errorSquared, fittedPath);\n            break;\n        }\n      }\n    }\n    return fittedPath;\n"
1818,v2ScaleIII,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,752,756,5,/**\n   * Scales the input vector by the specified factor and returns it.\n   * <p>\n   * This method alters the value of the input point!\n   */,5,"  private static Point2D.Double v2ScaleIII(Point2D.Double v, double s) {\n    Point2D.Double result = new Point2D.Double();\n    result.x = v.x * s;\n    result.y = v.y * s;\n    return result;\n"
1819,computeMaxError,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,628,646,12,"/**\n   * Find the maximum squared distance of digitized points\n   * to fitted curve.\n   *\n   * @param d Digitized points.\n   * @param first Indice of first point of region in d.\n   * @param last Indice of last point of region in d.\n   * @param bezCurve Fitted Bezier curve\n   * @param u Parameterization of points*\n   * @param splitPoint Point of maximum error (input/output parameter, must be\n   * an array of 1)\n   */",18,"  private static double computeMaxError(ArrayList<Point2D.Double> d, int first, int last, Point2D.Double[] bezCurve, double[] u, int[] splitPoint) {\n    int i;\n    double maxDist;    /*  Maximum error */\n    double dist;    /*  Current error */\n    Point2D.Double P = new Point2D.Double(); /*  Point on curve */\n    Point2D.Double v = new Point2D.Double(); /*  Vector from point to curve */\n    splitPoint[0] = (last - first + 1) / 2;\n    maxDist = 0.0;\n    for (i = first + 1; i < last; i++) {\n      P = bezierII(3, bezCurve, u[i - first]);\n      v = v2SubII(P, d.get(i));\n      dist = v2SquaredLength(v);\n      if (dist >= maxDist) {\n        maxDist = dist;\n        splitPoint[0] = i;\n      }\n    }\n    return (maxDist);\n"
1820,removeClosePoints,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,173,193,19,"/**\n   * Removes points which are closer together than the specified minimal \n   * distance.\n   * <p>\n   * The minimal distance should be chosen dependent on the size and resolution of the\n   * display device, and on the sampling rate. A good value for mouse input\n   * on a display with 100% Zoom factor is 2.\n   * <p>\n   * The purpose of this method, is to remove points, which add no additional\n   * information about the shape of the curve from the list of digitized points.\n   * <p>\n   * The cleaned up set of digitized points gives better results, when used\n   * as input for method {@link #splitAtCorners}.\n   * \n   * @param digitizedPoints Digitized points\n   * @param minDistance minimal distance between two points. If minDistance is\n   * 0, this method only removes sequences of coincident points. \n   * @return Digitized points with a minimal distance.\n   */",20,"  public static ArrayList<Point2D.Double> removeClosePoints(java.util.List<Point2D.Double> digitizedPoints, double minDistance) {\n    if (minDistance == 0) {\n      return removeCoincidentPoints(digitizedPoints);\n    } else {\n      double squaredDistance = minDistance * minDistance;\n      java.util.ArrayList<Point2D.Double> cleaned = new ArrayList<Point2D.Double>();\n      if (digitizedPoints.size() > 0) {\n        Point2D.Double prev = digitizedPoints.get(0);\n        cleaned.add(prev);\n        for (Point2D.Double p : digitizedPoints) {\n          if (v2SquaredDistanceBetween2Points(prev, p) > squaredDistance) {\n            cleaned.add(p);\n            prev = p;\n          }\n        }\n        if (!prev.equals(digitizedPoints.get(digitizedPoints.size() - 1))) {\n          cleaned.set(cleaned.size() - 1, digitizedPoints.get(digitizedPoints.size() - 1));\n        }\n      }\n      return cleaned;\n"
1821,v2Add,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,778,781,5,/**\n   * Return vector sum c = a+b.\n   * <p>\n   * This method alters the value of c.\n   */,4,"  private static Point2D.Double v2Add(Point2D.Double a, Point2D.Double b, Point2D.Double c) {\n    c.x = a.x + b.x;\n    c.y = a.y + b.y;\n    return c;\n"
1822,newtonRaphsonRootFind,Bezier,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/Bezier.java,578,613,7,/**\n   * Use Newton-Raphson iteration to find better root.\n   *\n   * @param Q  Current fitted bezier curve.\n   * @param P  Digitized point.\n   * @param u  Parameter value vor P.\n   */,30,"  private static double newtonRaphsonRootFind(Point2D.Double[] Q, Point2D.Double P, double u) {\n    double numerator, denominator;\n    Point2D.Double[] Q1 = new Point2D.Double[3], Q2 = new Point2D.Double[2];  /*  Q' and Q''      */\n    Point2D.Double Q_u = new Point2D.Double(), Q1_u = new Point2D.Double(), Q2_u = new Point2D.Double(); /*u evaluated at Q, Q', & Q''  */\n    double uPrime;    /*  Improved u  */\n    int i;\n    /* Compute Q(u)  */\n    Q_u = bezierII(3, Q, u);\n    /* Generate control vertices for Q'  */\n    for (i = 0; i <= 2; i++) {\n      Q1[i] = new Point2D.Double(\n          (Q[i + 1].x - Q[i].x) * 3.0,\n          (Q[i + 1].y - Q[i].y) * 3.0);\n    }\n    /* Generate control vertices for Q'' */\n    for (i = 0; i <= 1; i++) {\n      Q2[i] = new Point2D.Double(\n          (Q1[i + 1].x - Q1[i].x) * 2.0,\n          (Q1[i + 1].y - Q1[i].y) * 2.0);\n    }\n    /* Compute Q'(u) and Q''(u)  */\n    Q1_u = bezierII(2, Q1, u);\n    Q2_u = bezierII(1, Q2, u);\n    /* Compute f(u)/f'(u) */\n    numerator = (Q_u.x - P.x) * (Q1_u.x) + (Q_u.y - P.y) * (Q1_u.y);\n    denominator = (Q1_u.x) * (Q1_u.x) + (Q1_u.y) * (Q1_u.y) +\n        (Q_u.x - P.x) * (Q2_u.x) + (Q_u.y - P.y) * (Q2_u.y);\n    /* u = u - f(u)/f'(u) */\n    uPrime = u - (numerator / denominator);\n    return (uPrime);\n"
1823,isDone,BezierPathIterator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java,80,81,4,/**\n   * Tests if there are more points to read.\n   * @return true if there are more points to read\n   */,2,  public boolean isDone() {\n    return (index >= path.size() + (path.isClosed() ? 2 : 0));\n
1824,getWindingRule,BezierPathIterator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java,72,73,6,/**\n   * Return the winding rule for determining the interior of the\n   * path.\n   * @see PathIterator#WIND_EVEN_ODD\n   * @see PathIterator#WIND_NON_ZERO\n   */,2,  public int getWindingRule() {\n    return path.getWindingRule();\n
1825,currentSegment,BezierPathIterator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java,113,210,18,"/**\n   * Returns the coordinates and type of the current path segment in\n   * the iteration.\n   * The return value is the path segment type:\n   * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.\n   * A float array of length 6 must be passed in and may be used to\n   * store the coordinates of the point(s).\n   * Each point is stored as a pair of float x,y coordinates.\n   * SEG_MOVETO and SEG_LINETO types will return one point,\n   * SEG_QUADTO will return two points,\n   * SEG_CUBICTO will return 3 points\n   * and SEG_CLOSE will not return any points.\n   * @see PathIterator#SEG_MOVETO\n   * @see PathIterator#SEG_LINETO\n   * @see PathIterator#SEG_QUADTO\n   * @see PathIterator#SEG_CUBICTO\n   * @see PathIterator#SEG_CLOSE\n   */",98,"  public int currentSegment(float[] coords) {\n    int numCoords = 0;\n    int type = 0;\n    if (index == path.size()) {\n      // We only get here for closed paths\n      if (path.size() > 1) {\n        BezierPath.Node previous = path.get(path.size() - 1);\n        BezierPath.Node current = path.get(0);\n        \n        if ((previous.mask & BezierPath.C2_MASK) == 0) {\n          if ((current.mask & BezierPath.C1_MASK) == 0) {\n            numCoords = 1;\n            type = SEG_LINETO;\n            coords[0] = (float) current.x[0];\n            coords[1] = (float) current.y[0];\n          } else {\n            numCoords = 2;\n            type = SEG_QUADTO;\n            coords[0] = (float) current.x[1];\n            coords[1] = (float) current.y[1];\n            coords[2] = (float) current.x[0];\n            coords[3] = (float) current.y[0];\n          }\n        } else {\n          if ((current.mask & BezierPath.C1_MASK) == 0) {\n            numCoords = 2;\n            type = SEG_QUADTO;\n            coords[0] = (float) previous.x[2];\n            coords[1] = (float) previous.y[2];\n            coords[2] = (float) current.x[0];\n            coords[3] = (float) current.y[0];\n          } else {\n            numCoords = 3;\n            type = SEG_CUBICTO;\n            coords[0] = (float) previous.x[2];\n            coords[1] = (float) previous.y[2];\n            coords[2] = (float) current.x[1];\n            coords[3] = (float) current.y[1];\n            coords[4] = (float) current.x[0];\n            coords[5] = (float) current.y[0];\n          }\n        }\n      }\n    } else if (index > path.size()) {\n      // We only get here for closed paths\n      return SEG_CLOSE;\n    } else if (index == 0) {\n      BezierPath.Node current = path.get(index);\n      coords[0] = (float) current.x[0];\n      coords[1] = (float) current.y[0];\n      numCoords = 1;\n      type = SEG_MOVETO;\n      \n    } else if (index < path.size()) {\n      BezierPath.Node current = path.get(index);\n      BezierPath.Node previous = path.get(index - 1);\n      \n      if ((previous.mask & BezierPath.C2_MASK) == 0) {\n        if ((current.mask & BezierPath.C1_MASK) == 0) {\n          numCoords = 1;\n          type = SEG_LINETO;\n          coords[0] = (float) current.x[0];\n          coords[1] = (float) current.y[0];\n          \n        } else {\n          numCoords = 2;\n          type = SEG_QUADTO;\n          coords[0] = (float) current.x[1];\n          coords[1] = (float) current.y[1];\n          coords[2] = (float) current.x[0];\n          coords[3] = (float) current.y[0];\n        }\n      } else {\n        if ((current.mask & BezierPath.C1_MASK) == 0) {\n          numCoords = 2;\n          type = SEG_QUADTO;\n          coords[0] = (float) previous.x[2];\n          coords[1] = (float) previous.y[2];\n          coords[2] = (float) current.x[0];\n          coords[3] = (float) current.y[0];\n        } else {\n          numCoords = 3;\n          type = SEG_CUBICTO;\n          coords[0] = (float) previous.x[2];\n          coords[1] = (float) previous.y[2];\n          coords[2] = (float) current.x[1];\n          coords[3] = (float) current.y[1];\n          coords[4] = (float) current.x[0];\n          coords[5] = (float) current.y[0];\n        }\n      }\n    }\n    \n    \n    if (affine != null) {\n      affine.transform(coords, 0, coords, 0, numCoords);\n    }\n    return type;\n"
1826,next,BezierPathIterator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java,89,91,5,/**\n   * Moves the iterator to the next segment of the path forwards\n   * along the primary direction of traversal as long as there are\n   * more points in that direction.\n   */,3,  public void next() {\n    if (! isDone()) {\n      index++;\n
1827,BezierPathIterator,BezierPathIterator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java,61,63,5,/**\n   * Constructs an iterator given a BezierPath and an optional\n   * AffineTransform.\n   * @see BezierPath#getPathIterator\n   */,3,"  public BezierPathIterator(BezierPath path, AffineTransform at) {\n    this.path = path;\n    this.affine = at;\n"
1828,currentSegment,BezierPathIterator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java,231,330,18,"/**\n   * Returns the coordinates and type of the current path segment in\n   * the iteration.\n   * The return value is the path segment type:\n   * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.\n   * A double array of length 6 must be passed in and may be used to\n   * store the coordinates of the point(s).\n   * Each point is stored as a pair of double x,y coordinates.\n   * SEG_MOVETO and SEG_LINETO types will return one point,\n   * SEG_QUADTO will return two points,\n   * SEG_CUBICTO will return 3 points\n   * and SEG_CLOSE will not return any points.\n   * @see PathIterator#SEG_MOVETO\n   * @see PathIterator#SEG_LINETO\n   * @see PathIterator#SEG_QUADTO\n   * @see PathIterator#SEG_CUBICTO\n   * @see PathIterator#SEG_CLOSE\n   */",100,"  public int currentSegment(double[] coords) {\n    int numCoords = 0;\n    int type = 0;\n    if (index == path.size()) {\n      // We only get here for closed paths\n      if (path.size() > 1) {\n        BezierPath.Node previous = path.get(path.size() - 1);\n        BezierPath.Node current = path.get(0);\n        \n        if ((previous.mask & BezierPath.C2_MASK) == 0) {\n          if ((current.mask & BezierPath.C1_MASK) == 0) {\n            numCoords = 1;\n            type = SEG_LINETO;\n            coords[0] = current.x[0];\n            coords[1] = current.y[0];\n          } else {\n            numCoords = 2;\n            type = SEG_QUADTO;\n            coords[0] = current.x[1];\n            coords[1] = current.y[1];\n            coords[2] = current.x[0];\n            coords[3] = current.y[0];\n          }\n        } else {\n          if ((current.mask & BezierPath.C1_MASK) == 0) {\n            numCoords = 2;\n            type = SEG_QUADTO;\n            coords[0] = previous.x[2];\n            coords[1] = previous.y[2];\n            coords[2] = current.x[0];\n            coords[3] = current.y[0];\n          } else {\n            numCoords = 3;\n            type = SEG_CUBICTO;\n            coords[0] = previous.x[2];\n            coords[1] = previous.y[2];\n            coords[2] = current.x[1];\n            coords[3] = current.y[1];\n            coords[4] = current.x[0];\n            coords[5] = current.y[0];\n          }\n        }\n      }\n    } else if (index > path.size()) {\n      // We only get here for closed paths\n      return SEG_CLOSE;\n    } else if (index == 0) {\n      BezierPath.Node current = path.get(index);\n      coords[0] = current.x[0];\n      coords[1] = current.y[0];\n      numCoords = 1;\n      type = SEG_MOVETO;\n      \n    } else if (index < path.size()) {\n      BezierPath.Node current = path.get(index);\n      BezierPath.Node previous = path.get(index - 1);\n      \n      if ((previous.mask & BezierPath.C2_MASK) == 0) {\n        if ((current.mask & BezierPath.C1_MASK) == 0) {\n          numCoords = 1;\n          type = SEG_LINETO;\n          coords[0] = current.x[0];\n          coords[1] = current.y[0];\n          \n        } else {\n          numCoords = 2;\n          type = SEG_QUADTO;\n          coords[0] = current.x[1];\n          coords[1] = current.y[1];\n          coords[2] = current.x[0];\n          coords[3] = current.y[0];\n        }\n      } else {\n        if ((current.mask & BezierPath.C1_MASK) == 0) {\n          numCoords = 2;\n          type = SEG_QUADTO;\n          coords[0] = previous.x[2];\n          coords[1] = previous.y[2];\n          coords[2] = current.x[0];\n          coords[3] = current.y[0];\n        } else {\n          numCoords = 3;\n          type = SEG_CUBICTO;\n          coords[0] = previous.x[2];\n          coords[1] = previous.y[2];\n          coords[2] = current.x[1];\n          coords[3] = current.y[1];\n          coords[4] = current.x[0];\n          coords[5] = current.y[0];\n        }\n      }\n    }\n    \n    \n    if (affine != null) {\n      affine.transform(coords, 0, coords, 0, numCoords);\n    } else {\n      System.arraycopy(coords, 0, coords, 0, numCoords);\n    }\n    return type;\n"
1829,BezierPathIterator,BezierPathIterator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/BezierPathIterator.java,52,53,4,/**\n   * Constructs an iterator given a BezierPath.\n   * @see BezierPath#getPathIterator\n   */,2,"  public BezierPathIterator(BezierPath path) {\n    this(path, null);\n"
1830,getConvexHullPolygon,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,40,45,6,/**\n   * Computes the convex hull from a set of points.\n   *\n   * @param points\n   * @return convex hull of the points as a polygon object.\n   */,6,"  public static Polygon getConvexHullPolygon(List<Point> points) {\n    Polygon convexHull = new Polygon();\n    for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {\n      convexHull.addPoint(p.x, p.y);\n    }\n    return convexHull;\n"
1831,getConvexHullPath2D,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,54,59,6,/**\n   * Computes the convex hull from a set of points.\n   *\n   * @param points\n   * @return convex hull of the points as a Polygon2D object.\n   */,6,  public static Polygon2D.Double getConvexHullPath2D(List<Point2D.Double> points) {\n    Polygon2D.Double convexHull = new Polygon2D.Double();\n    for (Point p : getConvexHull(points.toArray(new Point[points.size()]))) {\n      convexHull.add(p);\n    }\n    return convexHull;\n
1832,getConvexHull2D,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,114,115,6,/**\n   * Computes the convex hull from a set of points.\n   *\n   * @param points\n   * @return convex hull of the points\n   */,2,  public static List<Point2D.Double> getConvexHull2D(List<Point2D.Double> points) {\n    return Arrays.asList(getConvexHull2D(points.toArray(new Point2D.Double[points.size()])));\n
1833,getConvexHull,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,124,169,6,/**\n   * Computes the convex hull from a set of points.\n   *\n   * @param points\n   * @return convex hull of the points\n   */,40,"  public static Point[] getConvexHull(Point[] points) {\n    // Quickly return if no work is needed\n    if (points.length < 3) {\n      return points.clone();\n    }\n    // Sort points from left to right O(n log n)\n    Point[] sorted = points.clone();\n    Arrays.sort(sorted, new Comparator<Point>() {\n      public int compare(Point o1, Point o2) {\n        int v = o1.x - o2.x;\n        return (v == 0) ? o1.y - o2.y : v;\n      }\n    });\n    Point[] hull = new Point[sorted.length + 2];\n    // Process upper part of convex hull O(n)\n    int upper = 0; // Number of points in upper part of convex hull\n    hull[upper++] = sorted[0];\n    hull[upper++] = sorted[1];\n    for (int i = 2; i < sorted.length; i++) {\n      hull[upper++] = sorted[i];\n      while (upper > 2 && !isRightTurn(hull[upper - 3], hull[upper - 2], hull[upper - 1])) {\n        hull[upper - 2] = hull[upper - 1];\n        upper--;\n      }\n    }\n    // Process lower part of convex hull O(n)\n    int lower = upper; // (lower - number + 1) = number of points in the lower part of the convex hull\n    hull[lower++] = sorted[sorted.length - 2];\n    for (int i = sorted.length - 3; i >= 0; i--) {\n      hull[lower++] = sorted[i];\n      while (lower - upper > 1 && !isRightTurn(hull[lower - 3], hull[lower - 2], hull[lower - 1])) {\n        hull[lower - 2] = hull[lower - 1];\n        lower--;\n      }\n    }\n    lower -= 1;\n    // Reduce array\n    Point[] convexHull = new Point[lower];\n    System.arraycopy(hull, 0, convexHull, 0, lower);\n    return convexHull;\n"
1834,getConvexHull2D,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,195,242,6,/**\n   * Computes the convex hull from a set of points.\n   *\n   * @param points\n   * @return convex hull of the points\n   */,43,"  public static Point2D.Double[] getConvexHull2D(Point2D.Double[] points) {\n    // Quickly return if no work is needed\n    if (points.length < 3) {\n      return points.clone();\n    }\n    // Sort points from left to right O(n log n)\n    Point2D.Double[] sorted = points.clone();\n    Arrays.sort(sorted, new Comparator<Point2D.Double>() {\n      public int compare(Point2D.Double o1, Point2D.Double o2) {\n        double v = o1.x - o2.x;\n        if (v == 0) {\n          v = o1.y - o2.y;\n        }\n        return (v > 0) ? 1 : ((v < 0) ? -1 : 0);\n      }\n    });\n    Point2D.Double[] hull = new Point2D.Double[sorted.length + 2];\n    // Process upper part of convex hull O(n)\n    int upper = 0; // Number of points in upper part of convex hull\n    hull[upper++] = sorted[0];\n    hull[upper++] = sorted[1];\n    for (int i = 2; i < sorted.length; i++) {\n      hull[upper++] = sorted[i];\n      while (upper > 2 && !isRightTurn2D(hull[upper - 3], hull[upper - 2], hull[upper - 1])) {\n        hull[upper - 2] = hull[upper - 1];\n        upper--;\n      }\n    }\n    // Process lower part of convex hull O(n)\n    int lower = upper; // (lower - number + 1) = number of points in the lower part of the convex hull\n    hull[lower++] = sorted[sorted.length - 2];\n    for (int i = sorted.length - 3; i >= 0; i--) {\n      hull[lower++] = sorted[i];\n      while (lower - upper > 1 && !isRightTurn2D(hull[lower - 3], hull[lower - 2], hull[lower - 1])) {\n        hull[lower - 2] = hull[lower - 1];\n        lower--;\n      }\n    }\n    lower -= 1;\n    // Reduce array\n    Point2D.Double[] convexHull = new Point2D.Double[lower];\n    System.arraycopy(hull, 0, convexHull, 0, lower);\n    return convexHull;\n"
1835,getConvexHull,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,104,105,6,/**\n   * Computes the convex hull from a set of points.\n   *\n   * @param points\n   * @return convex hull of the points\n   */,2,  public static List<Point> getConvexHull(List<Point> points) {\n    return Arrays.asList(getConvexHull(points.toArray(new Point[points.size()])));\n
1836,isRightTurn2D,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,253,260,8,"/**\n   * Returns true, if the three given points make a right turn.\n   *\n   * @param p1 first point\n   * @param p2 second point\n   * @param p3 third point\n   * @return true if right turn.\n   */",8,"  public static boolean isRightTurn2D(Point.Double p1, Point.Double p2, Point.Double p3) {\n    if (p1.equals(p2)||p2.equals(p3)) {\n      // no right turn if points are at same location\n      return false;\n    }\n    \n    double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);\n    return val > 0;\n"
1837,isRightTurn,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,180,186,8,"/**\n   * Returns true, if the three given points make a right turn.\n   * \n   * @param p1 first point\n   * @param p2 second point\n   * @param p3 third point\n   * @return true if right turn.\n   */",7,"  public static boolean isRightTurn(Point p1, Point p2, Point p3) {\n    if (p1.equals(p2)||p2.equals(p3)) {\n      // no right turn if points are at same location\n      return false;\n    }\n    double val = (p2.x * p3.y + p1.x * p2.y + p3.x * p1.y) - (p2.x * p1.y + p3.x * p2.y + p1.x * p3.y);\n    return val > 0;\n"
1838,getConvexHullPath2D,ConvexHull,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/geom/ConvexHull.java,68,95,6,/**\n   * Computes the convex hull from a shape.\n   *\n   * @param shape an arbitray shape\n   * @return convex hull of the points as a Polygon2D object.\n   */,27,"  public static Polygon2D.Double getConvexHullPath2D(Shape shape) {\n    List<Point2D.Double> points = new LinkedList<Point2D.Double>();\n    double[] coords = new double[6];\n    for (PathIterator i = shape.getPathIterator(null); !i.isDone(); i.next()) {\n      switch (i.currentSegment(coords)) {\n        case PathIterator.SEG_CLOSE:\n          break;\n        case PathIterator.SEG_MOVETO:\n        case PathIterator.SEG_LINETO:\n          points.add(new Point2D.Double(coords[0], coords[1]));\n          break;\n        case PathIterator.SEG_QUADTO:\n          points.add(new Point2D.Double(coords[0], coords[1]));\n          points.add(new Point2D.Double(coords[2], coords[3]));\n          break;\n        case PathIterator.SEG_CUBICTO:\n          points.add(new Point2D.Double(coords[0], coords[1]));\n          points.add(new Point2D.Double(coords[2], coords[3]));\n          points.add(new Point2D.Double(coords[4], coords[5]));\n          break;\n      }\n    }\n    Polygon2D.Double convexHull = new Polygon2D.Double();\n    for (Point2D.Double p : getConvexHull2D(points.toArray(new Point2D.Double[points.size()]))) {\n      convexHull.add(p);\n    }\n    return convexHull;\n"
1839,setDragTracker,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,364,365,4,"/**\n   * Method to set a {@code DragTracker}. If you specify null, the\n   * {@code SelectionTool} uses the {@code DefaultDragTracker}.\n   */",2,  public void setDragTracker(DragTracker newValue) {\n    dragTracker = newValue;\n
1840,setHandleTracker,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,348,349,4,"/**\n   * Method to set a {@code HandleTracker}. If you specify null, the\n   * {@code SelectionTool} uses the {@code DefaultHandleTracker}.\n   */",2,  public void setHandleTracker(HandleTracker newValue) {\n    handleTracker = newValue;\n
1841,setSelectAreaTracker,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,356,357,4,"/**\n   * Method to set a {@code SelectAreaTracker}. If you specify null, the\n   * {@code SelectionTool} uses the {@code DefaultSelectAreaTracker}.\n   */",2,  public void setSelectAreaTracker(SelectAreaTracker newValue) {\n    selectAreaTracker = newValue;\n
1842,setSelectBehindEnabled,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,142,145,6,/**\n   * Sets the selectBehindEnabled property.\n   * This is a bound property.\n   *\n   * @param newValue The new value.\n   */,4,"  public void setSelectBehindEnabled(boolean newValue) {\n    boolean oldValue = isSelectBehindEnabled;\n    isSelectBehindEnabled = newValue;\n    firePropertyChange(SELECT_BEHIND_ENABLED_PROPERTY, oldValue, newValue);\n"
1843,getHandleTracker,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,313,318,4,/**\n   * Method to get a {@code HandleTracker} which handles user interaction\n   * for the specified handle.\n   */,6,"  protected HandleTracker getHandleTracker(Handle handle) {\n    if (handleTracker == null) {\n      handleTracker = new DefaultHandleTracker();\n    }\n    handleTracker.setHandles(handle, getView().getCompatibleHandles(handle));\n    return handleTracker;\n"
1844,getDragTracker,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,325,330,4,/**\n   * Method to get a {@code DragTracker} which handles user interaction\n   * for dragging the specified figure.\n   */,6,  protected DragTracker getDragTracker(Figure f) {\n    if (dragTracker == null) {\n      dragTracker = new DefaultDragTracker();\n    }\n    dragTracker.setDraggedFigure(f);\n    return dragTracker;\n
1845,SelectionTool,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,130,133,1,/** Creates a new instance. */,4,  public SelectionTool() {\n    tracker = getSelectAreaTracker();\n    trackerHandler = new TrackerHandler();\n    tracker.addToolListener(trackerHandler);\n
1846,isSelectBehindEnabled,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,154,155,6,/**\n   * Returns the value of the selectBehindEnabled property.\n   * This is a bound property.\n   *\n   * @return The property value.\n   */,2,  public boolean isSelectBehindEnabled() {\n    return isSelectBehindEnabled;\n
1847,getSelectAreaTracker,SelectionTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/tool/SelectionTool.java,337,341,4,/**\n   * Method to get a {@code SelectAreaTracker} which handles user interaction\n   * for selecting an area on the drawing.\n   */,5,  protected SelectAreaTracker getSelectAreaTracker() {\n    if (selectAreaTracker == null) {\n      selectAreaTracker = new DefaultSelectAreaTracker();\n    }\n    return selectAreaTracker;\n
1861,main,DefaultDOMStorableSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/DefaultDOMStorableSample.java,62,89,1,/** DOM Storable objects must have a non-argument constructor. */,22,"  public static void main(String[] args) {\n    try {\n      // Set up the DefaultDOMFactory\n      DefaultDOMFactory factory = new DefaultDOMFactory();\n      factory.addStorableClass(""MyElementName"", MyObject.class);\n      // Create a DOMStorable object\n      MyObject obj = new MyObject(""Hello World"");\n      System.out.println(""The name of the original object is:"" + obj.getName());\n      // Write the object into a DOM, and then serialize the DOM into a String\n      NanoXMLDOMOutput out = new NanoXMLDOMOutput(factory);\n      out.writeObject(obj);\n      StringWriter writer = new StringWriter();\n      out.save(writer);\n      String serializedString = writer.toString();\n      System.out.println(""\\nThe serialized representation of the object is:\\n"" + serializedString);\n      // Deserialize a DOM from a String, and then read the object from the DOM\n      StringReader reader = new StringReader(serializedString);\n      NanoXMLDOMInput in = new NanoXMLDOMInput(factory, reader);\n      MyObject obj2 = (MyObject) in.readObject();\n      System.out.println(""\\nThe name of the restored object is:"" + obj2.getName());\n    } catch (IOException ex) {\n      Logger.getLogger(DefaultDOMStorableSample.class.getName()).log(Level.SEVERE, null, ex);\n"
1862,main,MovableChildFiguresSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/MovableChildFiguresSample.java,73,102,3,/**\n     * Return default handles from the presentation figure.\n     */,27,"  public static void main(String[] args) {\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        // Create a simple drawing consisting of three\n        // text areas and an elbow connection.\n        LabeledEllipseFigure ta = new LabeledEllipseFigure();\n        ta.setBounds(new Point2D.Double(10, 10), new Point2D.Double(100, 100));\n        LabeledEllipseFigure tb = new LabeledEllipseFigure();\n        tb.setBounds(new Point2D.Double(220, 120), new Point2D.Double(310, 210));\n        LabeledEllipseFigure tc = new LabeledEllipseFigure();\n        tc.setBounds(new Point2D.Double(220, 10), new Point2D.Double(310, 100));\n        Drawing drawing = new DefaultDrawing();\n        drawing.add(ta);\n        drawing.add(tb);\n        drawing.add(tc);\n        // Create a frame with a drawing view and a drawing editor\n        JFrame f = new JFrame(""My Drawing"");\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setSize(400, 300);\n        DrawingView view = new DefaultDrawingView();\n        view.setDrawing(drawing);\n        f.add(view.getComponent());\n        f.add(new JLabel(""Press space bar to toggle handles.""), BorderLayout.SOUTH);\n        DrawingEditor editor = new DefaultDrawingEditor();\n        editor.add(view);\n        editor.setTool(new DelegationSelectionTool());\n        f.setVisible(true);\n"
1863,createDrawing,MultiEditorSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/MultiEditorSample.java,103,109,6,"/**\n   * Creates a drawing with input and output formats, so that drawing figures\n   * can be copied and pasted between drawing views.\n   * \n   * @return a drawing\n   */",7,  private static Drawing createDrawing() {\n    // Create a default drawing with\n    // input/output formats for basic clipboard support.\n    DefaultDrawing drawing = new DefaultDrawing();\n    drawing.addInputFormat(new SerializationInputOutputFormat());\n    drawing.addOutputFormat(new SerializationInputOutputFormat());\n    return drawing;\n
1864,createDrawing,DnDMultiEditorSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/DnDMultiEditorSample.java,110,117,6,"/**\n   * Creates a drawing with input and output formats, so that drawing figures\n   * can be copied and pasted between drawing views.\n   * \n   * @return a drawing\n   */",8,  private static Drawing createDrawing() {\n    // Create a default drawing with\n    // input/output formats for basic clipboard support.\n    DefaultDrawing drawing = new DefaultDrawing();\n    drawing.addInputFormat(new SerializationInputOutputFormat());\n    drawing.addOutputFormat(new SerializationInputOutputFormat());\n    drawing.addOutputFormat(new ImageOutputFormat());\n    return drawing;\n
1865,read,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,172,207,3,/**\n   * Reads the view from the specified uri.\n   */,33,"  public void read(URI f, URIChooser fc) throws IOException {\n    try {\n      final Drawing drawing = createDrawing();\n      boolean success = false;\n        for (InputFormat sfi : drawing.getInputFormats()) {\n            try {\n              sfi.read(new File(f), drawing, true);\n              success = true;\n              break;\n            } catch (Exception e) {\n            // try with the next input format\n            }\n          }\n      if (!success) {\n        ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n        throw new IOException(labels.getFormatted(""file.open.unsupportedFileFormat.message"", URIUtil.getName(f)));\n      }\n      SwingUtilities.invokeAndWait(new Runnable() {\n        public void run() {\n          view.getDrawing().removeUndoableEditListener(undo);\n          view.setDrawing(drawing);\n          view.getDrawing().addUndoableEditListener(undo);\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InterruptedException e) {\n      InternalError error = new InternalError();\n      e.initCause(e);\n      throw error;\n    } catch (InvocationTargetException e) {\n      InternalError error = new InternalError();\n      error.initCause(e);\n      throw error;\n"
1866,write,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,163,166,3,/**\n   * Writes the view to the specified uri.\n   */,4,"  public void write(URI f, URIChooser fc) throws IOException {\n    Drawing drawing = view.getDrawing();\n    OutputFormat outputFormat = drawing.getOutputFormats().get(0);\n    outputFormat.write(new File(f), drawing);\n"
1868,getEditor,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,228,229,3,/**\n   * Gets the drawing editor of the view.\n   */,2,  public DrawingEditor getEditor() {\n    return editor;\n
1869,setEditor,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,215,221,3,/**\n   * Sets a drawing editor for the view.\n   */,7,  public void setEditor(DrawingEditor newValue) {\n    if (editor != null) {\n      editor.remove(view);\n    }\n    editor = newValue;\n    if (editor != null) {\n      editor.add(view);\n
1870,initComponents,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,264,275,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,8,"  private void initComponents() {\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n"
1871,init,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,79,114,3,/**\n   * Initializes the view.\n   */,36,"  public void init() {\n    super.init();\n    \n    initComponents();\n    \n    JPanel zoomButtonPanel = new JPanel(new BorderLayout());\n    scrollPane.setLayout(new PlacardScrollPaneLayout());\n    scrollPane.setBorder(new EmptyBorder(0,0,0,0));\n    \n    setEditor(new DefaultDrawingEditor());\n    undo = new UndoRedoManager();\n    view.setDrawing(createDrawing());\n    view.getDrawing().addUndoableEditListener(undo);\n    initActions();\n    undo.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        setHasUnsavedChanges(undo.hasSignificantEdits());\n      }\n    });\n    \n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    \n    JPanel placardPanel = new JPanel(new BorderLayout());\n    javax.swing.AbstractButton pButton;\n    pButton = ButtonFactory.createZoomButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"",""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"",new Insets(0,0,0,0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    placardPanel.add(pButton, BorderLayout.WEST);\n    pButton = ButtonFactory.createToggleGridButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"",""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"",new Insets(0,0,0,0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    labels.configureToolBarButton(pButton, ""view.toggleGrid.placard"");\n    placardPanel.add(pButton, BorderLayout.EAST);\n    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);\n"
1872,initActions,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,151,153,3,/**\n   * Initializes view specific actions.\n   */,3,"  private void initActions() {\n    getActionMap().put(UndoAction.ID, undo.getUndoAction());\n    getActionMap().put(RedoAction.ID, undo.getRedoAction());\n"
1873,createPageable,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,142,143,3,/**\n   * Creates a Pageable object for printing the view.\n   */,2,  public Pageable createPageable() {\n    return new DrawingPageable(view.getDrawing());\n
1874,clear,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,235,249,3,/**\n   * Clears the view.\n   */,15,  public void clear() {\n    final Drawing newDrawing = createDrawing();\n    try {\n      SwingUtilities.invokeAndWait(new Runnable() {\n        public void run() {\n          view.getDrawing().removeUndoableEditListener(undo);\n          view.setDrawing(newDrawing);\n          view.getDrawing().addUndoableEditListener(undo);\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InvocationTargetException ex) {\n      ex.printStackTrace();\n    } catch (InterruptedException ex) {\n      ex.printStackTrace();\n
1875,createDrawing,DrawView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawView.java,120,135,3,/**\n   * Creates a new Drawing for this view.\n   */,16,"  protected Drawing createDrawing() {\n    Drawing drawing = new QuadTreeDrawing();\n    DOMStorableInputOutputFormat ioFormat =\n        new DOMStorableInputOutputFormat(new DrawFigureFactory());\n    \n    drawing.addInputFormat(ioFormat);\n    ImageFigure prototype = new ImageFigure();\n    drawing.addInputFormat(new ImageInputFormat(prototype));\n    drawing.addInputFormat(new TextInputFormat(new TextFigure()));\n    TextAreaFigure taf = new TextAreaFigure();\n    taf.setBounds(new Point2D.Double(10,10), new Point2D.Double(60,40));\n    drawing.addInputFormat(new TextInputFormat(taf));\n    \n    drawing.addOutputFormat(ioFormat);\n    drawing.addOutputFormat(new ImageOutputFormat());\n    return drawing;\n"
1876,main,Main,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/Main.java,28,49,1,/** Creates a new instance. */,21,"  public static void main(String[] args) {\n    ResourceBundleUtil.setVerbose(true);\n    Application app;\n    String os = System.getProperty(""os.name"").toLowerCase();\n    if (os.startsWith(""mac"")) {\n      app = new OSXApplication();\n    } else if (os.startsWith(""win"")) {\n      //app = new DefaultMDIApplication();\n      app = new SDIApplication();\n    } else {\n      app = new SDIApplication();\n    }\n    \n    DrawApplicationModel model = new DrawApplicationModel();\n    model.setName(""JHotDraw Draw"");\n    model.setVersion(Main.class.getPackage().getImplementationVersion());\n    model.setCopyright(""Copyright 2006-2009 (c) by the authors of JHotDraw and all its contributors.\\n"" +\n        ""This software is licensed under LGPL or Creative Commons 3.0 Attribution."");\n    model.setViewClassName(""org.jhotdraw.samples.draw.DrawView"");\n    app.setModel(model);\n    app.launch(args);\n"
1877,AnimationSample,AnimationSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/AnimationSample.java,33,56,1,/** Creates new form AnimationSample */,22,"  public AnimationSample() {\n    initComponents();\n    DefaultDrawingView view = new DefaultDrawingView();\n    view.setDrawingDoubleBuffered(false);\n    add(view);\n    setSize(400, 400);\n    Drawing d = new DefaultDrawing();\n    d.set(CANVAS_FILL_COLOR, new Color(0x76a9d2));\n    final EllipseFigure ellipse = new EllipseFigure(160, 160, 80, 80);\n    ellipse.set(STROKE_WIDTH, 7d);\n    d.add(ellipse);\n    view.setDrawing(d);\n    Timer t = new Timer(10, new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        double alpha = 2d * Math.PI * (System.currentTimeMillis() % 1000) / 1000d;\n        ellipse.willChange();\n        ellipse.setBounds(new Rectangle2D.Double(160 + Math.sin(alpha) * 100, 160 + Math.cos(alpha) * 100, 80, 80));\n        ellipse.changed();\n      }\n    });\n    t.setRepeats(true);\n    t.start();\n"
1878,initComponents,AnimationSample,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/AnimationSample.java,64,70,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,5,"  @SuppressWarnings(""unchecked"")\n  // <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents\n  private void initComponents() {\n    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n    pack();\n"
1879,FontChooserMain,FontChooserMain,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/font/FontChooserMain.java,29,31,1,/** Creates new form FontChooserMain */,3,  public FontChooserMain() {\n    initComponents();\n    add(new JFontChooser());\n
1880,initComponents,FontChooserMain,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/font/FontChooserMain.java,56,60,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,4,"  @SuppressWarnings(""unchecked"")\n  // <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents\n  private void initComponents() {\n    setLayout(new java.awt.BorderLayout());\n"
1881,getEventSetDescriptors,DrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java,116,117,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1882,getPropertyDescriptors,DrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java,105,106,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1883,getDefaultPropertyIndex,DrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java,139,140,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1886,getBeanDescriptor,DrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java,89,90,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1888,getDefaultEventIndex,DrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java,150,151,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1889,getMethodDescriptors,DrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanelBeanInfo.java,127,128,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1891,initComponents,DrawLiveConnectApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawLiveConnectApplet.java,206,228,5,/** This method is called from within the init() method to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,16,"  private void initComponents() {//GEN-BEGIN:initComponents\n    toolButtonGroup = new javax.swing.ButtonGroup();\n    drawingPanel = new org.jhotdraw.samples.draw.DrawingPanel();\n    jToolBar1 = new javax.swing.JToolBar();\n    loadButton = new javax.swing.JButton();\n    saveButton = new javax.swing.JButton();\n    FormListener formListener = new FormListener();\n    getContentPane().add(drawingPanel, java.awt.BorderLayout.CENTER);\n    jToolBar1.setFloatable(false);\n    loadButton.setText(""Laden"");\n    loadButton.addActionListener(formListener);\n    jToolBar1.add(loadButton);\n    saveButton.setText(""Speichern"");\n    saveButton.addActionListener(formListener);\n    jToolBar1.add(saveButton);\n    getContentPane().add(jToolBar1, java.awt.BorderLayout.SOUTH);\n"
1893,init,DrawLiveConnectApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawLiveConnectApplet.java,41,136,1,/** Initializes the applet DrawApplet */,86,"  public void init() {\n    // Set look and feel\n    // -----------------\n    try {\n      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Throwable e) {\n      // Do nothing.\n      // If we can\'t set the desired look and feel, UIManager does\n      // automaticaly the right thing for us.\n    }\n    // Display copyright info while we are loading the data\n    // ----------------------------------------------------\n    Container c = getContentPane();\n    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));\n    String[] lines = getAppletInfo().split(""\\n"");//Strings.split(getAppletInfo(), \'\\n\');\n    for (int i = 0; i < lines.length; i++) {\n      c.add(new JLabel(lines[i]));\n    }\n    // We load the data using a worker thread\n    // --------------------------------------\n    new Worker<Drawing>() {\n      protected Drawing construct() throws IOException {\n        Drawing result;\n        if (getParameter(""data"") != null && getParameter(""data"").length() > 0) {\n          NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), new StringReader(getParameter(""data"")));\n          result = (Drawing) domi.readObject(0);\n        } else if (getParameter(""datafile"") != null) {\n          InputStream in = null;\n          try {\n            URL url = new URL(getDocumentBase(), getParameter(""datafile""));\n            in = url.openConnection().getInputStream();\n            NanoXMLDOMInput domi = new NanoXMLDOMInput(new DrawFigureFactory(), in);\n            result = (Drawing) domi.readObject(0);\n          } finally {\n            if (in != null) {\n              in.close();\n            }\n          }\n        } else {\n          result = null;\n        }\n        return result;\n      }\n      protected void done(Drawing result) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        initComponents();\n        if (result != null) {\n          setDrawing(result);\n        }\n      }\n      @Override\n      protected void failed(Throwable result) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        initComponents();\n        getDrawing().add(new TextFigure(result.toString()));\n        result.printStackTrace();\n      }\n      protected void finished() {\n        Container c = getContentPane();\n        boolean isLiveConnect;\n        try {\n          Class.forName(""netscape.javascript.JSObject"");\n          isLiveConnect = true;\n        } catch (Throwable t) {\n          isLiveConnect = false;\n        }\n        loadButton.setEnabled(isLiveConnect && getParameter(""dataread"") != null);\n        saveButton.setEnabled(isLiveConnect && getParameter(""datawrite"") != null);\n        if (isLiveConnect) {\n          String methodName = getParameter(""dataread"");\n          if (methodName.indexOf(\'(\') > 0) {\n            methodName = methodName.substring(0, methodName.indexOf(\'(\') - 1);\n          }\n          JSObject win = JSObject.getWindow(DrawLiveConnectApplet.this);\n          Object data = win.call(methodName, new Object[0]);\n          if (data instanceof String) {\n            setData((String) data);\n          }\n        }\n        c.validate();\n      }\n    }.start();\n"
1894,initComponents,BezierDemo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/BezierDemo.java,286,417,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,119,"  @SuppressWarnings(""unchecked"")\n  // <editor-fold defaultstate=""collapsed"" desc=""Generated Code"">//GEN-BEGIN:initComponents\n  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    jPanel1 = new javax.swing.JPanel();\n    toleranceLabel = new javax.swing.JLabel();\n    zoomSlider = new javax.swing.JSlider();\n    showDigitizedCheck = new javax.swing.JCheckBox();\n    showPreprocessedCheck = new javax.swing.JCheckBox();\n    showPolylineCheck = new javax.swing.JCheckBox();\n    showBezierCheck = new javax.swing.JCheckBox();\n    showControlsCheck = new javax.swing.JCheckBox();\n    eraseButton = new javax.swing.JButton();\n    dumpButton = new javax.swing.JButton();\n    setLayout(new java.awt.BorderLayout());\n    jPanel1.setBorder(javax.swing.BorderFactory.createEmptyBorder(12, 20, 20, 20));\n    jPanel1.setLayout(new java.awt.GridBagLayout());\n    toleranceLabel.setText(""Zoom:"");\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(toleranceLabel, gridBagConstraints);\n    zoomSlider.setMaximum(800);\n    zoomSlider.setMinimum(100);\n    zoomSlider.addChangeListener(new javax.swing.event.ChangeListener() {\n      public void stateChanged(javax.swing.event.ChangeEvent evt) {\n        zoomChanged(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 1;\n    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.weightx = 1.0;\n    jPanel1.add(zoomSlider, gridBagConstraints);\n    showDigitizedCheck.setText(""Show Source Points"");\n    showDigitizedCheck.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        checkboxPerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridwidth = 2;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(showDigitizedCheck, gridBagConstraints);\n    showPreprocessedCheck.setText(""Show Preprocessed Points"");\n    showPreprocessedCheck.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        checkboxPerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridwidth = 2;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(showPreprocessedCheck, gridBagConstraints);\n    showPolylineCheck.setSelected(true);\n    showPolylineCheck.setText(""Show Polyline"");\n    showPolylineCheck.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        checkboxPerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 2;\n    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    gridBagConstraints.insets = new java.awt.Insets(0, 20, 0, 0);\n    jPanel1.add(showPolylineCheck, gridBagConstraints);\n    showBezierCheck.setSelected(true);\n    showBezierCheck.setText(""Show Bezier Path"");\n    showBezierCheck.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        checkboxPerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 2;\n    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    gridBagConstraints.insets = new java.awt.Insets(0, 20, 0, 0);\n    jPanel1.add(showBezierCheck, gridBagConstraints);\n    showControlsCheck.setText(""Show Bezier Controls"");\n    showControlsCheck.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        checkboxPerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridwidth = 2;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(showControlsCheck, gridBagConstraints);\n    eraseButton.setText(""Erase"");\n    eraseButton.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        eraseButtonActionPerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 2;\n    gridBagConstraints.gridy = 4;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n    gridBagConstraints.weightx = 1.0;\n    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);\n    jPanel1.add(eraseButton, gridBagConstraints);\n    dumpButton.setText(""Dump"");\n    dumpButton.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        dumpButtonActionPerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 3;\n    gridBagConstraints.gridy = 4;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;\n    gridBagConstraints.insets = new java.awt.Insets(6, 0, 0, 0);\n    jPanel1.add(dumpButton, gridBagConstraints);\n    add(jPanel1, java.awt.BorderLayout.NORTH);\n"
1897,BezierDemo,BezierDemo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/mini/BezierDemo.java,233,249,1,/** Creates new form BezierDemo */,16,"  public BezierDemo() {\n    initComponents();\n    canvas = new Canvas();\n    canvas.setOpaque(true);\n    canvas.setBackground(Color.WHITE);\n    canvas.addMouseListener(handler);\n    canvas.addMouseMotionListener(handler);\n    add(canvas, BorderLayout.CENTER);\n    Point2D.Double[] d = { //  Digitized points \n    };   \n    BezierPath digi = new BezierPath();\n    digi.addAll(Arrays.asList(d));\n    Example ex = new Example();\n    examples.add(ex);\n    ex.digitized = digi;\n    ex.error = 2d;\n"
1900,initComponents,DrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanel.java,157,191,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,27,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    toolButtonGroup = new javax.swing.ButtonGroup();\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    jPanel1 = new javax.swing.JPanel();\n    creationToolbar = new javax.swing.JToolBar();\n    attributesToolbar = new javax.swing.JToolBar();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n    jPanel1.setLayout(new java.awt.GridBagLayout());\n    creationToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 0;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(creationToolbar, gridBagConstraints);\n    attributesToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(attributesToolbar, gridBagConstraints);\n    add(jPanel1, java.awt.BorderLayout.SOUTH);\n"
1901,DrawingPanel,DrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/draw/DrawingPanel.java,64,129,1,/** Creates new instance. */,62,"  public DrawingPanel() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    initComponents();\n    undoManager = new UndoRedoManager();\n    editor = new DefaultDrawingEditor();\n    editor.add(view);\n    addCreationButtonsTo(creationToolbar, editor);\n    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);\n    JPopupButton pb = new JPopupButton();\n    pb.setItemFont(UIManager.getFont(""MenuItem.font""));\n    labels.configureToolBarButton(pb, ""actions"");\n    pb.add(new DuplicateAction());\n    pb.addSeparator();\n    pb.add(new GroupAction(editor));\n    pb.add(new UngroupAction(editor));\n    pb.addSeparator();\n    pb.add(new BringToFrontAction(editor));\n    pb.add(new SendToBackAction(editor));\n    pb.addSeparator();\n    pb.add(new CutAction());\n    pb.add(new CopyAction());\n    pb.add(new PasteAction());\n    pb.add(new SelectAllAction());\n    pb.add(new SelectSameAction(editor));\n    pb.addSeparator();\n    pb.add(undoManager.getUndoAction());\n    pb.add(undoManager.getRedoAction());\n    // FIXME - We need a toggle grid action!\n    // pb.addSeparator();\n    // pb.add(new ToggleGridAction(editor));\n    JMenu m = new JMenu(labels.getString(""view.zoomFactor.text""));\n    JRadioButtonMenuItem rbmi;\n    ButtonGroup group = new ButtonGroup();\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));\n    rbmi.setSelected(true);\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));\n    group.add(rbmi);\n    pb.add(m);\n    pb.setFocusable(false);\n    creationToolbar.addSeparator();\n    creationToolbar.add(pb);\n\n    DefaultDrawing drawing = new DefaultDrawing();\n    view.setDrawing(drawing);\n    drawing.addUndoableEditListener(undoManager);\n"
1903,initComponents,MessagePanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/MessagePanel.java,77,106,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,27,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    iconLabel = new javax.swing.JLabel();\n    messageLabel = new javax.swing.JLabel();\n    closeButton = new javax.swing.JButton();\n    setBackground(new java.awt.Color(255, 255, 255));\n    setBorder(javax.swing.BorderFactory.createEmptyBorder(10, 10, 10, 10));\n    setLayout(new java.awt.GridBagLayout());\n    add(iconLabel, new java.awt.GridBagConstraints());\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    gridBagConstraints.weightx = 1.0;\n    gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);\n    add(messageLabel, gridBagConstraints);\n    closeButton.setText(labels.getString(""messagePanel.close.text"")); // NOI18N\n    closeButton.setActionCommand(""close"");\n    closeButton.addActionListener(new java.awt.event.ActionListener() {\n      public void actionPerformed(java.awt.event.ActionEvent evt) {\n        closePerformed(evt);\n      }\n    });\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 1;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHEAST;\n    gridBagConstraints.insets = new java.awt.Insets(10, 10, 0, 0);\n    add(closeButton, gridBagConstraints);\n"
1904,MessagePanel,MessagePanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/MessagePanel.java,38,39,1,/** Creates new instance. */,2,"  public MessagePanel() {\n    this(null, null);\n"
1906,getPropertyDescriptors,SummaryToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1907,getDefaultEventIndex,SummaryToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1908,getEventSetDescriptors,SummaryToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1909,getDefaultPropertyIndex,SummaryToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1913,getMethodDescriptors,SummaryToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1914,getBeanDescriptor,SummaryToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1915,initComponents,SummaryToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBar.java,71,85,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,11,"  private void initComponents() {\n    summaryLabel = new javax.swing.JLabel();\n    summaryField = new javax.swing.JTextField();\n    setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));\n    setFloatable(false);\n    setOpaque(false);\n    summaryLabel.setFont(new java.awt.Font(""Dialog"", 0, 11));\n    summaryLabel.setText(labels.getString(""summary"")); // NOI18N\n    add(summaryLabel);\n    summaryField.setFont(new java.awt.Font(""DialogInput"", 0, 11));\n    add(summaryField);\n"
1916,SummaryToolBar,SummaryToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/SummaryToolBar.java,46,58,1,/** Creates new instance. */,13,"  public SummaryToolBar() {\n    labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    initComponents();\n    \n    GridBagLayout layout = new GridBagLayout();\n    setLayout(layout);\n    \n    GridBagConstraints gbc;\n    gbc = new GridBagConstraints();\n    gbc.insets = new Insets(0,10,0,0);\n    gbc.weightx = 1d;\n    gbc.fill = GridBagConstraints.HORIZONTAL;\n    layout.setConstraints(summaryField, gbc);\n"
1917,getBeanDescriptor,ToolsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1920,getPropertyDescriptors,ToolsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1921,getDefaultPropertyIndex,ToolsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1922,getEventSetDescriptors,ToolsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1923,getMethodDescriptors,ToolsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1924,getDefaultEventIndex,ToolsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1926,ProgressIndicator,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,31,32,1,/** Creates new instance. */,2,"  public ProgressIndicator() {\n    this(null, null);\n"
1927,getMinimum,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,95,96,6,/**\n   * Returns the minimum value -- the lower end of the progress value.\n   *\n   * @return an int representing the minimum value\n   * @see #setMinimum\n   */,2,  public int getMinimum() {\n    return progressModel.getMinimum();\n
1928,setMaximum,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,136,137,6,/**\n   * Specifies the maximum value.\n   *\n   * @param m  an int specifying the maximum value\n   * @see #getMaximum\n   */,2,  public void setMaximum(int m) {\n    progressModel.setMaximum(m);\n
1929,getMaximum,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,125,126,6,/**\n   * Returns the maximum value -- the higher end of the progress value.\n   *\n   * @return an int representing the maximum value\n   * @see #setMaximum\n   */,2,  public int getMaximum() {\n    return progressModel.getMaximum();\n
1930,setMinimum,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,106,107,6,/**\n   * Specifies the minimum value.\n   *\n   * @param m  an int specifying the minimum value\n   * @see #getMinimum\n   */,2,  public void setMinimum(int m) {\n    progressModel.setMinimum(m);\n
1931,ProgressIndicator,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,41,54,1,/** Creates new instance. */,14,"  public ProgressIndicator(\n      String message,\n      String note,\n      int min,\n      int max,\n      boolean indeterminate) {\n    initComponents();\n    \n    messageLabel.setFont(messageLabel.getFont().deriveFont(Font.BOLD));\n    progressModel = new DefaultBoundedRangeModel(0, 0, min, max);\n    progressBar.setModel(progressModel);\n    setMessage(message);\n    setNote(note);\n    setIndeterminate(indeterminate);\n"
1932,initComponents,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,154,178,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,21,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    messageLabel = new javax.swing.JLabel();\n    noteLabel = new javax.swing.JLabel();\n    progressBar = new javax.swing.JProgressBar();\n    setBackground(new java.awt.Color(255, 255, 255));\n    setLayout(new java.awt.GridBagLayout());\n    messageLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    add(messageLabel, gridBagConstraints);\n    noteLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);\n    add(noteLabel, gridBagConstraints);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);\n    add(progressBar, gridBagConstraints);\n"
1933,setProgress,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,115,116,5,"/**\n   * Indicate the progress of the operation being monitored.\n   * @param nv an int specifying the current value, between the\n   *    maximum and minimum specified for this component\n   */",2,  public void setProgress(int nv) {\n    progressModel.setValue(nv);\n
1934,ProgressIndicator,ProgressIndicator,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ProgressIndicator.java,35,38,1,/** Creates new instance. */,4,"  public ProgressIndicator(\n      String message,\n      String note) {\n    this(message, note, 0, 100, true);\n"
1936,getDefaultEventIndex,StrokeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
1939,getMethodDescriptors,StrokeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
1940,getDefaultPropertyIndex,StrokeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
1941,getPropertyDescriptors,StrokeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
1942,getEventSetDescriptors,StrokeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
1943,getBeanDescriptor,StrokeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
1945,ODGRectRadiusHandle,ODGRectRadiusHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectRadiusHandle.java,40,41,1,/** Creates a new instance. */,2,  public ODGRectRadiusHandle(Figure owner) {\n    super(owner);\n
1946,draw,ODGRectRadiusHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectRadiusHandle.java,47,48,3,/**\n   * Draws this handle.\n   */,2,"  public void draw(Graphics2D g) {\n    drawDiamond(g, Color.yellow, Color.black);\n"
1947,StrokeToolBar,StrokeToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/StrokeToolBar.java,45,48,1,/** Creates new instance. */,4,"  public StrokeToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(""stroke.toolbar""));\n    setDisclosureStateCount(3);\n"
1948,ToolsToolBar,ToolsToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ToolsToolBar.java,45,47,1,/** Creates new instance. */,3,"  public ToolsToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(""tools.toolbar""));\n"
1949,getInsets,TextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java,338,341,3,/**\n   * Returns the insets used to draw text.\n   */,4,"  public Insets2D.Double getInsets() {\n    double sw = Math.ceil(get(STROKE_WIDTH) / 2);\n    Insets2D.Double insets = new Insets2D.Double(4, 4, 4, 4);\n    return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);\n"
1950,drawParagraph,TextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java,151,280,16,"/**\n   * Draws or measures a paragraph of text at the specified y location and\n   * the bounds of the paragraph.\n   *\n   * @param g Graphics object. This parameter is null, if we want to\n   *  measure the size of the paragraph.\n   * @param styledText the text of the paragraph.\n   * @param verticalPos the top bound of the paragraph\n   * @param maxVerticalPos the bottom bound of the paragraph\n   * @param leftMargin the left bound of the paragraph\n   * @param rightMargin the right bound of the paragraph\n   * @param tabStops an array with tab stops\n   * @param tabCount the number of entries in tabStops which contain actual\n   *    values\n   * @return Returns the actual bounds of the paragraph.\n   */",109,"  private Rectangle2D.Double drawParagraph(Graphics2D g, AttributedCharacterIterator styledText,\n      float verticalPos, float maxVerticalPos, float leftMargin, float rightMargin, float[] tabStops, int tabCount) {\n    // This method is based on the code sample given\n    // in the class comment of java.awt.font.LineBreakMeasurer, \n    // assume styledText is an AttributedCharacterIterator, and the number\n    // of tabs in styledText is tabCount\n    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);\n    int[] tabLocations = new int[tabCount + 1];\n    int i = 0;\n    for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {\n      if (c == '\\t') {\n        tabLocations[i++] = styledText.getIndex();\n      }\n    }\n    tabLocations[tabCount] = styledText.getEndIndex() - 1;\n    // Now tabLocations has an entry for every tab's offset in\n    // the text.  For convenience, the last entry is tabLocations\n    // is the offset of the last character in the text.\n    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());\n    int currentTab = 0;\n    while (measurer.getPosition() < styledText.getEndIndex() &&\n        verticalPos <= maxVerticalPos) {\n      // Lay out and draw each line.  All segments on a line\n      // must be computed before any drawing can occur, since\n      // we must know the largest ascent on the line.\n      // TextLayouts are computed and stored in a List;\n      // their horizontal positions are stored in a parallel\n      // List.\n      // lineContainsText is true after first segment is drawn\n      boolean lineContainsText = false;\n      boolean lineComplete = false;\n      float maxAscent = 0, maxDescent = 0;\n      float horizontalPos = leftMargin;\n      LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();\n      LinkedList<Float> penPositions = new LinkedList<Float>();\n      int first = layouts.size();\n      while (!lineComplete && verticalPos <= maxVerticalPos) {\n        float wrappingWidth = rightMargin - horizontalPos;\n        TextLayout layout = null;\n        layout =\n            measurer.nextLayout(wrappingWidth,\n            tabLocations[currentTab] + 1,\n            lineContainsText);\n        // layout can be null if lineContainsText is true\n        if (layout != null) {\n          layouts.add(layout);\n          penPositions.add(horizontalPos);\n          horizontalPos += layout.getAdvance();\n          maxAscent = Math.max(maxAscent, layout.getAscent());\n          maxDescent = Math.max(maxDescent,\n              layout.getDescent() + layout.getLeading());\n        } else {\n          lineComplete = true;\n        }\n        lineContainsText = true;\n        if (measurer.getPosition() == tabLocations[currentTab] + 1) {\n          currentTab++;\n        }\n        if (measurer.getPosition() == styledText.getEndIndex()) {\n          lineComplete = true;\n        } else if (tabStops.length == 0 || horizontalPos >= tabStops[tabStops.length - 1]) {\n          lineComplete = true;\n        }\n        if (!lineComplete) {\n          // move to next tab stop\n          int j;\n          for (j = 0; horizontalPos >= tabStops[j]; j++) {\n          }\n          horizontalPos = tabStops[j];\n        }\n      }\n      // If there is only one layout element on the line, and we are\n      // drawing, then honor alignemnt\n      if (first == layouts.size() - 1 && g != null) {\n        switch (get(TEXT_ALIGNMENT)) {\n          case TRAILING:\n            penPositions.set(first, rightMargin - layouts.get(first).getVisibleAdvance() - 1);\n            break;\n          case CENTER:\n            penPositions.set(first, (rightMargin - 1 - leftMargin - layouts.get(first).getVisibleAdvance()) / 2 + leftMargin);\n            break;\n          case BLOCK:\n            // not supported\n            break;\n          case LEADING:\n          default:\n            break;\n        }\n      }\n\n      verticalPos += maxAscent;\n      Iterator<TextLayout> layoutEnum = layouts.iterator();\n      Iterator<Float> positionEnum = penPositions.iterator();\n      // now iterate through layouts and draw them\n      while (layoutEnum.hasNext()) {\n        TextLayout nextLayout = layoutEnum.next();\n        float nextPosition = positionEnum.next();\n        if (g != null) {\n          nextLayout.draw(g, nextPosition, verticalPos);\n        }\n        Rectangle2D layoutBounds = nextLayout.getBounds();\n        paragraphBounds.add(new Rectangle2D.Double(layoutBounds.getX() + nextPosition,\n            layoutBounds.getY() + verticalPos,\n            layoutBounds.getWidth(),\n            layoutBounds.getHeight()));\n      }\n      verticalPos += maxDescent;\n    }\n    return paragraphBounds;\n"
1951,TextAreaFigure,TextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java,74,76,1,/** Creates a new instance. */,3,"  public TextAreaFigure() {\n    this(ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"").\n        getString(""TextFigure.defaultText""));\n"
1952,getText,TextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java,331,332,3,/**\n   * Gets the text shown by the text figure.\n   */,2,  public String getText() {\n    return (String) get(TEXT);\n
1953,setText,TextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java,355,356,3,/**\n   * Sets the text shown by the text figure.\n   */,2,"  public void setText(String newText) {\n    set(TEXT, newText);\n"
1954,getTool,TextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java,396,401,4,"/**\n   * Returns a specialized tool for the given coordinate.\n   * <p>Returns null, if no specialized tool is available.\n   */",6,  public Tool getTool(Point2D.Double p) {\n    if (isEditable() && contains(p)) {\n      TextAreaEditingTool tool = new TextAreaEditingTool(this);\n      return tool;\n    }\n    return null;\n
1961,getPreferredTextSize,TextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextAreaFigure.java,474,508,10,"/**\n   * Returns the preferred text size of the TextAreaFigure.\n   * <p>\n   * If you want to use this method to determine the bounds of the TextAreaFigure,\n   * you need to add the insets of the TextAreaFigure to the size.\n   * \n   * @param maxWidth the maximal width to use. Specify Double.MAX_VALUE\n   * if you want the width to be unlimited.\n   * @return width and height needed to lay out the text.\n   */",33,"  public Dimension2DDouble getPreferredTextSize(double maxWidth) {\n    Rectangle2D.Double textRect = new Rectangle2D.Double();\n    if (getText() != null) {\n      Font font = getFont();\n      boolean isUnderlined = get(FONT_UNDERLINE);\n      float leftMargin = 0;\n      float rightMargin = (float) maxWidth - 1;\n      float verticalPos = 0;\n      float maxVerticalPos = Float.MAX_VALUE;\n      if (leftMargin < rightMargin) {\n        float tabWidth = (float) (getTabSize() * font.getStringBounds(""m"", getFontRenderContext()).getWidth());\n        float[] tabStops = new float[(int) (textRect.width / tabWidth)];\n        for (int i = 0; i < tabStops.length; i++) {\n          tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));\n        }\n        String[] paragraphs = getText().split(""\\n"");//Strings.split(getText(), \'\\n\');\n        for (int i = 0; i < paragraphs.length; i++) {\n          if (paragraphs[i].length() == 0) {\n            paragraphs[i] = "" "";\n          }\n          AttributedString as = new AttributedString(paragraphs[i]);\n          as.addAttribute(TextAttribute.FONT, font);\n          if (isUnderlined) {\n            as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);\n          }\n          int tabCount = paragraphs[i].split(""\\t"").length - 1;\n          Rectangle2D.Double paragraphBounds = drawParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);\n          verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);\n          textRect.add(paragraphBounds);\n        }\n      }\n    }\n    return new Dimension2DDouble(-Math.min(textRect.x, 0) + textRect.width, -Math.min(textRect.y, 0) + textRect.height);\n"
1962,readCustomShapeElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,445,461,7,"/** A <draw:custom-shape> represents a shape that is capable of rendering\n   * complex figures. It is offering font work and extrusion functiona-\n   * lity. A custom shape may have a geometry that influences its shape.\n   * This geometry may be visualized in office application user\n   * interfaces, for instance by displaying interaction handles, that\n   * provide a simple way to modify the geometry.\n   */",14,"  private ODGFigure readCustomShapeElement(IXMLElement elem)\n      throws IOException {\n    String styleName = elem.getAttribute(""style-name"", DRAWING_NAMESPACE, null);\n    Map<AttributeKey, Object> a = styles.getAttributes(styleName, ""graphic"");\n    Rectangle2D.Double figureBounds = new Rectangle2D.Double(\n        toLength(elem.getAttribute(""x"", SVG_NAMESPACE, ""0""), 1),\n        toLength(elem.getAttribute(""y"", SVG_NAMESPACE, ""0""), 1),\n        toLength(elem.getAttribute(""width"", SVG_NAMESPACE, ""0""), 1),\n        toLength(elem.getAttribute(""height"", SVG_NAMESPACE, ""0""), 1));\n    ODGFigure figure = null;\n    for (IXMLElement child : elem.getChildrenNamed(""enhanced-geometry"", DRAWING_NAMESPACE)) {\n      figure = readEnhancedGeometryElement(child, a, figureBounds);\n    }\n    return figure;\n"
1963,createPolylineFigure,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,579,591,3,/**\n   * Creates a Polyline figure.\n   */,13,"  private ODGFigure createPolylineFigure(\n      Point2D.Double[] points,\n      Map<AttributeKey, Object> a)\n      throws IOException {\n    ODGPathFigure figure = new ODGPathFigure();\n    ODGBezierFigure bezier = new ODGBezierFigure();\n    for (Point2D.Double p : points) {\n      bezier.addNode(new BezierPath.Node(p.x, p.y));\n    }\n    figure.removeAllChildren();\n    figure.add(bezier);\n    figure.setAttributes(a);\n    return figure;\n"
1964,toLength,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,892,922,4,/**\n   * Returns a value as a length.\n   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength\n   */,29,"  private double toLength(String str, double percentFactor) throws IOException {\n    double scaleFactor = 1d;\n    if (str == null || str.length() == 0) {\n      return 0d;\n    }\n    if (str.endsWith(""%"")) {\n      str = str.substring(0, str.length() - 1);\n      scaleFactor = percentFactor;\n    } else if (str.endsWith(""px"")) {\n      str = str.substring(0, str.length() - 2);\n    } else if (str.endsWith(""pt"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 1.25;\n    } else if (str.endsWith(""pc"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 15;\n    } else if (str.endsWith(""mm"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 3.543307;\n    } else if (str.endsWith(""cm"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 35.43307;\n    } else if (str.endsWith(""in"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 90;\n    } else {\n      scaleFactor = 1d;\n    }\n    return Double.parseDouble(str) * scaleFactor;\n"
1965,readAllBytes,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,100,107,3,/**\n   * Reads all bytes from the InputStreams until EOF is reached.\n   */,8,"  private byte[] readAllBytes(InputStream in) throws IOException {\n    ByteArrayOutputStream tmp = new ByteArrayOutputStream();\n    byte[] buf = new byte[512];\n    for (int len; -1 != (len = in.read(buf));) {\n      tmp.write(buf, 0, len);\n    }\n    tmp.close();\n    return tmp.toByteArray();\n"
1966,createPolygonFigure,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,597,610,3,/**\n   * Creates a Polygon figure.\n   */,14,"  private ODGFigure createPolygonFigure(\n      Point2D.Double[] points,\n      Map<AttributeKey, Object> a)\n      throws IOException {\n    ODGPathFigure figure = new ODGPathFigure();\n    ODGBezierFigure bezier = new ODGBezierFigure();\n    for (Point2D.Double p : points) {\n      bezier.addNode(new BezierPath.Node(p.x, p.y));\n    }\n    bezier.setClosed(true);\n    figure.removeAllChildren();\n    figure.add(bezier);\n    figure.setAttributes(a);\n    return figure;\n"
1967,readPolygonElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,784,801,20,"/**\n   * The &lt;draw:polygon&gt; element represents a polygon. A polygon is a\n   * closed put of straight lines.\n   * Some implementations may ignore the size attribute, and instead determine\n   * the size of a shape exclusively from the shape data (i.e., polygon vertices).\n   * <p>\n   * The attributes that may be associated with the &lt;draw:polygon&gt; element\n   * are:\n   *  Position, Size, View box, Style, Layer, Z-Index, ID, Caption ID and\n   * Transformation  see section 9.2.15\n   *  Text anchor, table background, draw end position  see section 9.2.16\n   *  Points  see section 9.2.3\n   * The elements that may be contained in the &lt;draw:polygon&gt; element are:\n   *  Title (short accessible name)  see section 9.2.20.\n   *  Long description (in support of accessibility)  see section 9.2.20.\n   *  Event listeners  see section 9.2.21.\n   *  Glue points  see section 9.2.19.\n   *  Text  see section 9.2.17.\n   *\n   */",15,"  private ODGFigure readPolygonElement(IXMLElement elem)\n      throws IOException {\n    AffineTransform viewBoxTransform = readViewBoxTransform(elem);\n    String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute(""points"", DRAWING_NAMESPACE, null));\n    Point2D.Double[] points = new Point2D.Double[coords.length / 2];\n    for (int i = 0; i < coords.length; i += 2) {\n      Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));\n      points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);\n    }\n    String styleName = elem.getAttribute(""style-name"", DRAWING_NAMESPACE, null);\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    a.putAll(styles.getAttributes(styleName, ""graphic""));\n    readCommonDrawingShapeAttributes(elem, a);\n    ODGFigure f = createPolygonFigure(points, a);\n    return f;\n"
1968,sort,QuadTreeCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java,87,95,3,/**\n   * Implementation note: Sorting can not be done for orphaned children.\n   */,9,  public java.util.List<Figure> sort(Collection<Figure> c) {\n    ensureSorted();\n    ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());\n    for (Figure f : children) {\n      if (c.contains(f)) {\n        sorted.add(f);\n      }\n    }\n    return sorted;\n
1969,QuadTreeCompositeFigure,QuadTreeCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java,46,47,1,/** Creates a new instance. */,2,  public QuadTreeCompositeFigure() {\n    figureHandler = createFigureHandler();\n
1970,getFiguresFrontToBack,QuadTreeCompositeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeCompositeFigure.java,131,133,4,/**\n   * Returns an iterator to iterate in\n   * Z-order front to back over the children.\n   */,3,  public java.util.List<Figure> getFiguresFrontToBack() {\n    ensureSorted();\n    return new ReversedList<Figure>(children);\n
1971,toEnhancedPath,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,968,1199,23,"/**\n   * Returns a value as a EnhancedPath array.\n   *\n   * The draw:enhanced-path attribute specifies a path similar to the svg:d attribute of the\n   * <svg:path> element. Instructions such as moveto, lineto, arcto and other instructions\n   * together with its parameter are describing the geometry of a shape which can be filled and or\n   * stroked. Relative commands are not supported.\n   * The syntax of draw:enhanced-path attribute is as follows:\n   *  Instructions are expressed as one character (e.g., a moveto is expressed as an M).\n   *  A prefix notation is being used, that means that each command is followed by its parameter.\n   *  Superfluous white space and separators such as commas can be eliminated. (e.g., M 10 10\n   * L 20 20 L 30 20 can also be written: M10 10L20 20L30 20\n   *  If the command is repeated multiple times, only the first command is required. (e.g., M 10 10\n   * L 20 20 L 30 20 can also be expressed as followed M 10 10 L 20 20 30 20\n   *  Floats can be used, therefore the only allowable decimal point is a dot (.)\n   * The above mentioned rules are the same as specified for the <svg:path> element.\n   * A parameter can also have one of the following enhancements:\n   *  A ? is used to mark the beginning of a formula name. The result of the element\'s\n   * draw:formula attribute is used as parameter value in this case.\n   *  If $ is preceding a integer value, the value is indexing a draw:modifiers attribute. The\n   * corresponding modifier value is used as parameter value then.\n   *\n   */",216,"  private EnhancedPath toEnhancedPath(String str) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGInputFormat toEnhancedPath "" + str);\n    }\n    EnhancedPath path = null;\n    Object x, y;\n    Object x1, y1, x2, y2, x3, y3;\n    StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));\n    tt.resetSyntax();\n    tt.parseNumbers();\n    tt.parseExponents();\n    tt.parsePlusAsNumber();\n    tt.whitespaceChars(0, \' \');\n    tt.whitespaceChars(\',\', \',\');\n\n    char nextCommand = \'M\';\n    char command = \'M\';\n    Commands:\n    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {\n      if (tt.ttype > 0) {\n        command = (char) tt.ttype;\n      } else {\n        command = nextCommand;\n        tt.pushBack();\n      }\n      nextCommand = command;\n      switch (command) {\n        case \'M\':\n          // moveto (x y)+\n          // Start a new sub-path at the given (x,y)\n          // coordinate. If a moveto is followed by multiple\n          // pairs of coordinates, they are treated as lineto.\n          if (path == null) {\n            path = new EnhancedPath();\n          }\n          // path.setFilled(isFilled);\n          //path.setStroked(isStroked);\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.moveTo(x, y);\n          nextCommand = \'L\';\n          break;\n        case \'L\':\n          // lineto (x y)+\n          // Draws a line from the current point to (x, y). If\n          // multiple coordinate pairs are following, they\n          // are all interpreted as lineto.\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.lineTo(x, y);\n          break;\n        case \'C\':\n          // curveto (x1 y1 x2 y2 x y)+\n          // Draws a cubic Bezier curve from the current\n          // point to (x,y) using (x1,y1) as the control point\n          // at the beginning of the curve and (x2,y2) as\n          // the control point at the end of the curve.\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x2 = nextEnhancedCoordinate(tt, str);\n          y2 = nextEnhancedCoordinate(tt, str);\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.curveTo(x1, y1, x2, y2, x, y);\n          break;\n        case \'Z\':\n          // closepath\n          // Close the current sub-path by drawing a\n          // straight line from the current point to current\n          // sub-path\'s initial point.\n          path.close();\n          break;\n        case \'N\':\n          // endpath\n          // Ends the current put of sub-paths. The sub-\n          // paths will be filled by using the even-odd\n          // filling rule. Other following subpaths will be\n          // filled independently.\n          break;\n        case \'F\':\n          // nofill\n          // Specifies that the current put of sub-paths\n          // won\'t be filled.\n          break;\n        case \'S\':\n          // nostroke\n          // Specifies that the current put of sub-paths\n          // won\'t be stroked.\n          break;\n        case \'T\':\n          // angle-ellipseto (x y w h t0 t1) +\n          // Draws a segment of an ellipse. The ellipse is specified\n          // by the center(x, y), the size(w, h) and the start-angle\n          // t0 and end-angle t1.\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x2 = nextEnhancedCoordinate(tt, str);\n          y2 = nextEnhancedCoordinate(tt, str);\n          path.ellipseTo(x, y, x1, y1, x2, y2);\n          break;\n        case \'U\':\n          // angle-ellipse (x y w h t0 t1) +\n          // The same as the T command, except that a implied moveto\n          // to the starting point is done.\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x2 = nextEnhancedCoordinate(tt, str);\n          y2 = nextEnhancedCoordinate(tt, str);\n          path.moveTo(x1, y1);\n          path.ellipseTo(x, y, x1, y1, x2, y2);\n          break;\n        case \'A\':\n          // arcto (x1 y1 x2 y2 x3 y3 x y) +\n          // (x1, y1) and (x2, y2) is defining the bounding\n          // box of a ellipse. A line is then drawn from the\n          // current point to the start angle of the arc that is\n          // specified by the radial vector of point (x3, y3)\n          // and then counter clockwise to the end-angle\n          // that is specified by point (x4, y4).\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x2 = nextEnhancedCoordinate(tt, str);\n          y2 = nextEnhancedCoordinate(tt, str);\n          x3 = nextEnhancedCoordinate(tt, str);\n          y3 = nextEnhancedCoordinate(tt, str);\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.arcTo(x1, y1, x2, y2, x3, y3, x, y);\n          break;\n        case \'B\':\n          // arc (x1 y1 x2 y2 x3 y3 x y) +\n          // The same as the A command, except that a\n          // implied moveto to the starting point is done.\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x2 = nextEnhancedCoordinate(tt, str);\n          y2 = nextEnhancedCoordinate(tt, str);\n          x3 = nextEnhancedCoordinate(tt, str);\n          y3 = nextEnhancedCoordinate(tt, str);\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.moveTo(x1, y1);\n          path.arcTo(x1, y1, x2, y2, x3, y3, x, y);\n          break;\n        case \'W\':\n          // clockwisearcto (x1 y1 x2 y2 x3 y3 x y) +\n          // The same as the A command except, that the arc is drawn\n          // clockwise.\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x2 = nextEnhancedCoordinate(tt, str);\n          y2 = nextEnhancedCoordinate(tt, str);\n          x3 = nextEnhancedCoordinate(tt, str);\n          y3 = nextEnhancedCoordinate(tt, str);\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);\n          break;\n        case \'V\':\n          // clockwisearc (x1 y1 x2 y2 x3 y3 x y)+\n          // The same as the A command, except that a implied moveto\n          // to the starting point is done and the arc is drawn\n          // clockwise.\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x2 = nextEnhancedCoordinate(tt, str);\n          y2 = nextEnhancedCoordinate(tt, str);\n          x3 = nextEnhancedCoordinate(tt, str);\n          y3 = nextEnhancedCoordinate(tt, str);\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.moveTo(x1, y1);\n          path.clockwiseArcTo(x1, y1, x2, y2, x3, y3, x, y);\n          break;\n        case \'X\':\n          // elliptical-quadrantx (x y) +\n          // Draws a quarter ellipse, whose initial segment is\n          // tangential to the x-axis, is drawn from the\n          // current point to (x, y).\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.quadrantXTo(x, y);\n          break;\n        case \'Y\':\n          // elliptical-quadranty (x y) +\n          // Draws a quarter ellipse, whose initial segment is\n          // tangential to the y-axis, is drawn from the\n          // current point to(x, y).\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.quadrantYTo(x, y);\n          break;\n        case \'Q\':\n          // quadratic-curveto(x1 y1 x y)+\n          // Draws a quadratic Bezier curve from the current point\n          // to(x, y) using(x1, y1) as the control point. (x, y)\n          // becomes the new current point at the end of the command.\n          x1 = nextEnhancedCoordinate(tt, str);\n          y1 = nextEnhancedCoordinate(tt, str);\n          x = nextEnhancedCoordinate(tt, str);\n          y = nextEnhancedCoordinate(tt, str);\n          path.quadTo(x1, y1, x, y);\n          break;\n        default:\n          if (DEBUG) {\n            System.out.println(""ODGInputFormat.toEnhancedPath aborting after illegal path command: "" + command + "" found in path "" + str);\n          }\n          break Commands;\n        //throw new IOException(""Illegal command: ""+command);\n      }\n    }\n    return path;\n"
1972,createLineFigure,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,566,573,3,/**\n   * Creates a Line figure.\n   */,8,"  private ODGFigure createLineFigure(\n      Point2D.Double p1, Point2D.Double p2,\n      Map<AttributeKey, Object> a)\n      throws IOException {\n    ODGPathFigure figure = new ODGPathFigure();\n    figure.setBounds(p1, p2);\n    figure.setAttributes(a);\n    return figure;\n"
1973,readPolylineElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,822,839,18,"/**\n   * The &lt;draw:polyline&gt; element represents a polyline drawing shape.\n   * Some implementations may ignore the size attribute, and instead determine the size of a shape\n   * exclusively from the shape data (i.e., polygon vertices).\n   * <p>\n   * The attributes that may be associated with the &lt;draw:polyline&gt;\n   * element are:\n   *  Position, Size, View box, Style, Layer, Z-Index, ID, Caption ID and Transformation  see\n   * section 9.2.15\n   *  Text anchor, table background, draw end position  see section 9.2.16\n   *  Points\n   * The elements that may be contained in the &lt;draw:polyline&gt; element are:\n   *  Title (short accessible name)  see section 9.2.20.\n   *  Long description (in support of accessibility)  see section 9.2.20.\n   *  Event listeners  see section 9.2.21.\n   *  Glue points  see section 9.2.19.\n   *  Text  see section 9.2.17.\n   */",15,"  private ODGFigure readPolylineElement(IXMLElement elem)\n      throws IOException {\n    AffineTransform viewBoxTransform = readViewBoxTransform(elem);\n    String[] coords = toWSOrCommaSeparatedArray(elem.getAttribute(""points"", DRAWING_NAMESPACE, null));\n    Point2D.Double[] points = new Point2D.Double[coords.length / 2];\n    for (int i = 0; i < coords.length; i += 2) {\n      Point2D.Double p = new Point2D.Double(toNumber(coords[i]), toNumber(coords[i + 1]));\n      points[i / 2] = (Point2D.Double) viewBoxTransform.transform(p, p);\n    }\n    String styleName = elem.getAttribute(""style-name"", DRAWING_NAMESPACE, null);\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    a.putAll(styles.getAttributes(styleName, ""graphic""));\n    readCommonDrawingShapeAttributes(elem, a);\n    ODGFigure f = createPolylineFigure(points, a);\n    return f;\n"
1974,readLineElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,729,743,18,"/**\n   * The &lt;draw:line&gt; element represents a line.\n   * <p>\n   * The attributes that may be associated with the &lt;draw:line&gt; element\n   * are:\n   *  Style, Layer, Z-Index, ID, Caption ID and Transformation  see section\n   * 9.2.15.\n   *  Text anchor, table background, draw end position see section 9.2.16.\n   *  Start point\n   *  End point\n   * <p>\n   * The elements that may be contained in the &lt;draw:line&gt; element are:\n   *  Title (short accessible name)  see section 9.2.20.\n   *  Long description (in support of accessibility)  see section 9.2.20.\n   *  Event listeners  see section 9.2.21.\n   *  Glue points  see section 9.2.19.\n   *  Text  see section 9.2.17.\n   */",12,"  private ODGFigure readLineElement(IXMLElement elem)\n      throws IOException {\n    Point2D.Double p1 = new Point2D.Double(\n        toLength(elem.getAttribute(""x1"", SVG_NAMESPACE, ""0""), 1),\n        toLength(elem.getAttribute(""y1"", SVG_NAMESPACE, ""0""), 1));\n    Point2D.Double p2 = new Point2D.Double(\n        toLength(elem.getAttribute(""x2"", SVG_NAMESPACE, ""0""), 1),\n        toLength(elem.getAttribute(""y2"", SVG_NAMESPACE, ""0""), 1));\n    String styleName = elem.getAttribute(""style-name"", DRAWING_NAMESPACE, null);\n    Map<AttributeKey, Object> a = styles.getAttributes(styleName, ""graphic"");\n    ODGFigure f = createLineFigure(p1, p2, a);\n    return f;\n"
1975,toNumber,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,884,885,4,/**\n   * Returns a value as a number.\n   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeNumber\n   */,2,"  private double toNumber(String str) throws IOException {\n    return toLength(str, 100);\n"
1976,createPathFigure,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,616,628,3,/**\n   * Creates a Path figure.\n   */,13,"  private ODGFigure createPathFigure(\n      BezierPath[] paths,\n      Map<AttributeKey, Object> a)\n      throws IOException {\n    ODGPathFigure figure = new ODGPathFigure();\n    figure.removeAllChildren();\n    for (BezierPath p : paths) {\n      ODGBezierFigure bezier = new ODGBezierFigure();\n      bezier.setBezierPath(p);\n      figure.add(bezier);\n    }\n    figure.setAttributes(a);\n    return figure;\n"
1977,createGroupFigure,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,684,687,3,/**\n   * Creates a ODGGroupFigure.\n   */,4,  private CompositeFigure createGroupFigure()\n      throws IOException {\n    ODGGroupFigure figure = new ODGGroupFigure();\n    return figure;\n
1978,readDrawingElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,226,273,3,"/**\n   * Reads an ODG ""office:drawing"" element.\n   */",44,"  private void readDrawingElement(IXMLElement elem)\n      throws IOException {\n    /*\n    2.3.2Drawing Documents\n    The content of drawing document consists of a sequence of draw pages.\n    <define name=""office-body-content"" combine=""choice"">\n    <element name=""office:drawing"">\n    <ref name=""office-drawing-attlist""/>\n    <ref name=""office-drawing-content-prelude""/>\n    <ref name=""office-drawing-content-main""/>\n    <ref name=""office-drawing-content-epilogue""/>\n    </element>\n    </define>\n    <define name=""office-drawing-attlist"">\n    <empty/>\n    </define>\n    Drawing Document Content Model\n    The drawing document prelude may contain text declarations only. To allow office applications to\n    implement functionality that usually is available in spreadsheets for drawing documents, it may\n    also contain elements that implement enhanced table features. See also section 2.3.4.\n    <define name=""office-drawing-content-prelude"">\n    <ref name=""text-decls""/>\n    <ref name=""table-decls""/>\n    </define>\n    The main document content contains a sequence of draw pages.\n    <define name=""office-drawing-content-main"">\n    <zeroOrMore>\n    <ref name=""draw-page""/>\n    </zeroOrMore>\n    </define>\n    There are no drawing documents specific epilogue elements, but the epilogue may contain\n    elements that implement enhanced table features. See also section 2.3.4.\n    <define name=""office-drawing-content-epilogue"">\n    <ref name=""table-functions""/>\n    </define>\n     */\n    for (IXMLElement node : elem.getChildren()) {\n      if (node instanceof IXMLElement) {\n        IXMLElement child = (IXMLElement) node;\n        if (child.getNamespace() == null ||\n            child.getNamespace().equals(DRAWING_NAMESPACE)) {\n          String name = child.getName();\n          if (name.equals(""page"")) {\n            readPageElement(child);\n"
1979,createEnhancedGeometryEllipseFigure,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,542,548,3,/**\n   * Creates a Ellipse figure.\n   */,7,"  private ODGFigure createEnhancedGeometryEllipseFigure(\n      Rectangle2D.Double bounds, Map<AttributeKey, Object> a)\n      throws IOException {\n    ODGEllipseFigure figure = new ODGEllipseFigure();\n    figure.setBounds(bounds);\n    figure.setAttributes(a);\n    return figure;\n"
1981,createEnhancedGeometryRectangleFigure,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,554,560,3,/**\n   * Creates a Rect figure.\n   */,7,"  private ODGFigure createEnhancedGeometryRectangleFigure(\n      Rectangle2D.Double bounds, Map<AttributeKey, Object> a)\n      throws IOException {\n    ODGRectFigure figure = new ODGRectFigure();\n    figure.setBounds(bounds);\n    figure.setAttributes(a);\n    return figure;\n"
1982,readPageElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,283,340,3,"/**\n   * Reads an ODG ""draw:page"" element.\n   */",58,"  private void readPageElement(IXMLElement elem)\n      throws IOException {\n    /* 9.1.4Drawing Pages\n     *\n    The element <draw:page> is a container for content in a drawing or presentation document.\n    Drawing pages are used for the following:\n     Forms (see section 11.1)\n     Drawings (see section 9.2)\n     Frames (see section 9.3)\n     Presentation Animations (see section 9.7)\n     Presentation Notes (see section 9.1.5)\n     *\n    A master page must be assigned to each drawing page.\n     *\n    <define name=""draw-page"">\n    <element name=""draw:page"">\n    <ref name=""common-presentation-header-footer-attlist""/>\n    <ref name=""draw-page-attlist""/>\n    <optional>\n    <ref name=""office-forms""/>\n    </optional>\n    <zeroOrMore>\n    <ref name=""shape""/>\n    </zeroOrMore>\n    <optional>\n    <choice>\n    <ref name=""presentation-animations""/>\n    <ref name=""animation-element""/>\n    </choice>\n    </optional>\n    <optional>\n    <ref name=""presentation-notes""/>\n    </optional>\n    </element>\n    </define>\n     *\n    The attributes that may be associated with the <draw:page> element are:\n     Page name\n     Page style\n     Master page\n     Presentation page layout\n     Header declaration\n     Footer declaration\n     Date and time declaration\n     ID\n     *\n    The elements that my be included in the <draw:page> element are:\n     Forms\n     Shapes\n     Animations\n     Presentation notes\n     */\n    for (IXMLElement node : elem.getChildren()) {\n      if (node instanceof IXMLElement) {\n        IXMLElement child = (IXMLElement) node;\n        ODGFigure figure = readElement(child);\n        if (figure != null) {\n          figures.add(figure);\n"
1983,getFigureDrawingArea,TextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java,131,148,3,/**\n   * Gets the drawing area without taking the decorator into account.\n   */,18,"  protected Rectangle2D.Double getFigureDrawingArea() {\n    if (getText() == null) {\n      return getBounds();\n    } else {\n      TextLayout layout = getTextLayout();\n      Rectangle2D.Double r = new Rectangle2D.Double(\n          origin.x, origin.y, layout.getAdvance(), layout.getAscent());\n      Rectangle2D lBounds = layout.getBounds();\n      if (!lBounds.isEmpty() && !Double.isNaN(lBounds.getX())) {\n        r.add(new Rectangle2D.Double(\n            lBounds.getX() + origin.x,\n            (lBounds.getY() + origin.y + layout.getAscent()),\n            lBounds.getWidth(),\n            lBounds.getHeight()));\n      }\n      // grow by two pixels to take antialiasing into account\n      Geom.grow(r, 2d, 2d);\n      return r;\n"
1984,setText,TextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java,175,176,5,"/**\n   * Sets the text shown by the text figure.\n   * This is a convenience method for calling willChange,\n   * AttribuTEXT.basicSet, changed.\n   */",2,"  public void setText(String newText) {\n    set(TEXT, newText);\n"
1985,readElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,349,425,3,/**\n   * Reads an ODG element.\n   */,77,"  private ODGFigure readElement(IXMLElement elem)\n      throws IOException {\n    /*\n    Drawing Shapes\n    This section describes drawing shapes that might occur within all kind of applications.\n    <define name=""shape"">\n    <choice>\n    <ref name=""draw-rect""/>\n    <ref name=""draw-line""/>\n    <ref name=""draw-polyline""/>\n    <ref name=""draw-polygon""/>\n    <ref name=""draw-regular-polygon""/>\n    <ref name=""draw-path""/>\n    <ref name=""draw-circle""/>\n    <ref name=""draw-ellipse""/>\n    <ref name=""draw-g""/>\n    <ref name=""draw-page-thumbnail""/>\n    <ref name=""draw-frame""/>\n    <ref name=""draw-measure""/>\n    <ref name=""draw-caption""/>\n    <ref name=""draw-connector""/>\n    <ref name=""draw-control""/>\n    <ref name=""dr3d-scene""/>\n    <ref name=""draw-custom-shape""/>\n    </choice>\n    </define>\n     */\n    ODGFigure f = null;\n    if (elem.getNamespace() == null ||\n        elem.getNamespace().equals(DRAWING_NAMESPACE)) {\n      String name = elem.getName();\n      if (name.equals(""caption"")) {\n        f = readCaptionElement(elem);\n      } else if (name.equals(""circle"")) {\n        f = readCircleElement(elem);\n      } else if (name.equals(""connector"")) {\n        f = readCircleElement(elem);\n      } else if (name.equals(""custom-shape"")) {\n        f = readCustomShapeElement(elem);\n      } else if (name.equals(""ellipse"")) {\n        f = readEllipseElement(elem);\n      } else if (name.equals(""frame"")) {\n        f = readFrameElement(elem);\n      } else if (name.equals(""g"")) {\n        f = readGElement(elem);\n      } else if (name.equals(""line"")) {\n        f = readLineElement(elem);\n      } else if (name.equals(""measure"")) {\n        f = readMeasureElement(elem);\n      } else if (name.equals(""path"")) {\n        f = readPathElement(elem);\n      } else if (name.equals(""polygon"")) {\n        f = readPolygonElement(elem);\n      } else if (name.equals(""polyline"")) {\n        f = readPolylineElement(elem);\n      } else if (name.equals(""rect"")) {\n        f = readRectElement(elem);\n      } else if (name.equals(""regularPolygon"")) {\n        f = readRegularPolygonElement(elem);\n      } else {\n        if (DEBUG) {\n          System.out.println(""ODGInputFormat.readElement("" + elem + "") not implemented."");\n        }\n      }\n    }\n    if (f != null) {\n      if (f.isEmpty()) {\n        if (DEBUG) {\n          System.out.println(""ODGInputFormat.readElement():null - discarded empty figure "" + f);\n        }\n        return null;\n      }\n      if (DEBUG) {\n        System.out.println(""ODGInputFormat.readElement():"" + f + ""."");\n      }\n    }\n    return f;\n"
1988,TextFigure,TextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java,53,55,1,/** Creates a new instance. */,3,"  public TextFigure() {\n    this(ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"").\n        getString(""TextFigure.defaultText""));\n"
1989,getTabSize,TextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java,187,188,3,/**\n   * Gets the number of characters used to expand tabs.\n   */,2,  public int getTabSize() {\n    return 8;\n
1990,getTool,TextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java,251,257,4,"/**\n   * Returns a specialized tool for the given coordinate.\n   * <p>Returns null, if no specialized tool is available.\n   */",7,  @Override\n  public Tool getTool(Point2D.Double p) {\n    if (isEditable() && contains(p)) {\n      TextEditingTool t = new TextEditingTool(this);\n      return t;\n    }\n    return null;\n
1991,getText,TextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TextFigure.java,166,167,3,/**\n   * Gets the text shown by the text figure.\n   */,2,  public String getText() {\n    return get(TEXT);\n
1993,contains,RectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RectangleFigure.java,70,74,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,5,"  public boolean contains(Point2D.Double p) {\n    Rectangle2D.Double r = (Rectangle2D.Double) rectangle.clone();\n    double grow = AttributeKeys.getPerpendicularHitGrowth(this) + 1d;\n    Geom.grow(r, grow, grow);\n    return r.contains(p);\n"
1995,RectangleFigure,RectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RectangleFigure.java,32,33,1,/** Creates a new instance. */,2,"  public RectangleFigure() {\n    this(0, 0, 0, 0);\n"
1997,LineFigure,LineFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LineFigure.java,35,38,1,/** Creates a new instance. */,4,"  public LineFigure() {\n    addNode(new BezierPath.Node(new Point2D.Double(0,0)));\n    addNode(new BezierPath.Node(new Point2D.Double(0,0)));\n    setConnectable(false);\n"
1998,toPath,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,1424,1863,7,/**\n   * Returns a value as a BezierPath array.\n   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF\n   *\n   * Also supports elliptical arc commands \'a\' and \'A\' as specified in\n   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n   */,409,"  private BezierPath[] toPath(String str) throws IOException {\n    LinkedList<BezierPath> paths = new LinkedList<BezierPath>();\n    BezierPath path = null;\n    Point2D.Double p = new Point2D.Double();\n    Point2D.Double c1 = new Point2D.Double();\n    Point2D.Double c2 = new Point2D.Double();\n    StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));\n    tt.resetSyntax();\n    tt.parseNumbers();\n    tt.parseExponents();\n    tt.parsePlusAsNumber();\n    tt.whitespaceChars(0, \' \');\n    tt.whitespaceChars(\',\', \',\');\n\n    char nextCommand = \'M\';\n    char command = \'M\';\n    Commands:\n    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {\n      if (tt.ttype > 0) {\n        command = (char) tt.ttype;\n      } else {\n        command = nextCommand;\n        tt.pushBack();\n      }\n      BezierPath.Node node;\n      switch (command) {\n        case \'M\':\n          // absolute-moveto x y\n          if (path != null) {\n            paths.add(path);\n          }\n          path = new BezierPath();\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'M\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'M\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.moveTo(p.x, p.y);\n          nextCommand = \'L\';\n          break;\n        case \'m\':\n          // relative-moveto dx dy\n          if (path != null) {\n            paths.add(path);\n          }\n          path = new BezierPath();\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'m\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'m\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.moveTo(p.x, p.y);\n          nextCommand = \'l\';\n          break;\n        case \'Z\':\n        case \'z\':\n          // close path\n          p.x = path.get(0).x[0];\n          p.y = path.get(0).y[0];\n          // If the last point and the first point are the same, we\n          // can merge them\n          if (path.size() > 1) {\n            BezierPath.Node first = path.get(0);\n            BezierPath.Node last = path.get(path.size() - 1);\n            if (first.x[0] == last.x[0] &&\n                first.y[0] == last.y[0]) {\n              if ((last.mask & BezierPath.C1_MASK) != 0) {\n                first.mask |= BezierPath.C1_MASK;\n                first.x[1] = last.x[1];\n                first.y[1] = last.y[1];\n              }\n              path.remove(path.size() - 1);\n            }\n          }\n          path.setClosed(true);\n          break;\n        case \'L\':\n          // absolute-lineto x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'L\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'L\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'L\';\n          break;\n        case \'l\':\n          // relative-lineto dx dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'l\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'l\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'l\';\n          break;\n        case \'H\':\n          // absolute-horizontal-lineto x\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'H\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'H\';\n          break;\n        case \'h\':\n          // relative-horizontal-lineto dx\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'h\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'h\';\n          break;\n        case \'V\':\n          // absolute-vertical-lineto y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'V\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'V\';\n          break;\n        case \'v\':\n          // relative-vertical-lineto dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'v\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'v\';\n          break;\n        case \'C\':\n          // absolute-curveto x1 y1 x2 y2 x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x1 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y1 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x2 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y2 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'C\';\n          break;\n        case \'c\':\n          // relative-curveto dx1 dy1 dx2 dy2 dx dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx1 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy1 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx2 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy2 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'c\';\n          break;\n        case \'S\':\n          // absolute-shorthand-curveto x2 y2 x y\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x2 coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y2 coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'S\';\n          break;\n        case \'s\':\n          // relative-shorthand-curveto dx2 dy2 dx dy\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx2 coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy2 coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'s\';\n          break;\n        case \'Q\':\n          // absolute-quadto x1 y1 x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x1 coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y1 coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'Q\';\n          break;\n        case \'q\':\n          // relative-quadto dx1 dy1 dx dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx1 coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy1 coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'q\';\n          break;\n        case \'T\':\n          // absolute-shorthand-quadto x y\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'T\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'T\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'T\';\n          break;\n        case \'t\':\n          // relative-shorthand-quadto dx dy\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'t\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'t\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'s\';\n          break;\n\n        case \'A\': {\n          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""rx coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          // If rX or rY have negative signs, these are dropped;\n          // the absolute value is used instead.\n          double rx = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""ry coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double ry = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x-axis-rotation missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double xAxisRotation = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""large-arc-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean largeArcFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""sweep-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean sweepFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);\n          nextCommand = \'A\';\n          break;\n        }\n        case \'a\': {\n          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""rx coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          // If rX or rY have negative signs, these are dropped;\n          // the absolute value is used instead.\n          double rx = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""ry coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double ry = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x-axis-rotation missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double xAxisRotation = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""large-arc-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean largeArcFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""sweep-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean sweepFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);\n          nextCommand = \'a\';\n          break;\n        }\n        default:\n          if (DEBUG) {\n            System.out.println(""SVGInputFormat.toPath aborting after illegal path command: "" + command + "" found in path "" + str);\n          }\n          break Commands;\n        //throw new IOException(""Illegal command: ""+command);\n      }\n    }\n    if (path != null) {\n      paths.add(path);\n    }\n    return paths.toArray(new BezierPath[paths.size()]);\n"
1999,setArc,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,126,128,1,/** Convenience method for setting both the arc width and the arc height. */,3,"  public void setArc(double width, double height) {\n    setArcWidth(width);\n    setArcHeight(height);\n"
2000,contains,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,134,143,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,10,  public boolean contains(Point2D.Double p) {\n    RoundRectangle2D.Double r = (RoundRectangle2D.Double) roundrect.clone();\n    double grow = AttributeKeys.getPerpendicularHitGrowth(this);\n    r.x -= grow;\n    r.y -= grow;\n    r.width += grow * 2;\n    r.height += grow * 2;\n    r.arcwidth += grow * 2;\n    r.archeight += grow * 2;\n    return r.contains(p);\n
2001,setArcHeight,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,119,122,1,/** Sets the arc height. */,4,"  public void setArcHeight(double newValue) {\n    double oldValue = roundrect.archeight;\n    roundrect.archeight = newValue;\n    firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);\n"
2002,setArcWidth,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,113,116,1,/** Sets the arc width. */,4,"  public void setArcWidth(double newValue) {\n    double oldValue = roundrect.arcwidth;\n    roundrect.arcwidth = newValue;\n    firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);\n"
2004,RoundRectangleFigure,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,50,51,1,/** Creates a new instance. */,2,"  public RoundRectangleFigure() {\n    this(0, 0, 0, 0);\n"
2005,readFiguresFromDocumentContent,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,154,220,4,/**\n   * Reads figures from the content.xml file of an ODG open document drawing\n   * document.\n   */,61,"  @SuppressWarnings(""unchecked"")\n  public void readFiguresFromDocumentContent(InputStream in, Drawing drawing, boolean replace) throws IOException {\n    this.figures = new LinkedList<Figure>();\n    IXMLParser parser;\n    try {\n      parser = XMLParserFactory.createDefaultXMLParser();\n    } catch (Exception ex) {\n      InternalError e = new InternalError(""Unable to instantiate NanoXML Parser"");\n      e.initCause(ex);\n      throw e;\n    }\n    IXMLReader reader = new StdXMLReader(in);\n    parser.setReader(reader);\n    try {\n      document = (IXMLElement) parser.parse();\n    } catch (XMLException ex) {\n      IOException e = new IOException(ex.getMessage());\n      e.initCause(ex);\n      throw e;\n    }\n    if (styles == null) {\n      styles = new ODGStylesReader();\n    }\n    styles.read(document);\n\n    // Search for the first \'office:drawing\' element in the XML document\n    // in preorder sequence\n    IXMLElement drawingElem = document;\n    Stack<Iterator> stack = new Stack<Iterator>();\n    LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();\n    ll.add(document);\n    stack.push(ll.iterator());\n    while (!stack.empty() && stack.peek().hasNext()) {\n      Iterator<IXMLElement> iter = stack.peek();\n      IXMLElement node = iter.next();\n      Iterator<IXMLElement> children = node.getChildren().iterator();\n      if (!iter.hasNext()) {\n        stack.pop();\n      }\n      if (children.hasNext()) {\n        stack.push(children);\n      }\n      if (node.getName() != null &&\n          node.getName().equals(""drawing"") &&\n          (node.getNamespace() == null ||\n          node.getNamespace().equals(OFFICE_NAMESPACE))) {\n        drawingElem = node;\n        break;\n      }\n    }\n    if (drawingElem.getName() == null ||\n        !drawingElem.getName().equals(""drawing"") ||\n        (drawingElem.getNamespace() != null &&\n        !drawingElem.getNamespace().equals(OFFICE_NAMESPACE))) {\n      throw new IOException(""\'office:drawing\' element expected: "" + drawingElem.getName());\n    }\n    readDrawingElement(drawingElem);\n    if (replace) {\n      drawing.removeAllChildren();\n    }\n    drawing.addAll(figures);\n"
2006,transform,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,157,162,4,/**\n   * Transforms the figure.\n   * @param tx The transformation.\n   */,6,"  public void transform(AffineTransform tx) {\n    Point2D.Double anchor = getStartPoint();\n    Point2D.Double lead = getEndPoint();\n    setBounds(\n        (Point2D.Double) tx.transform(anchor, anchor),\n        (Point2D.Double) tx.transform(lead, lead));\n"
2007,getArcWidth,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,103,104,1,/** Gets the arc width. */,2,  public double getArcWidth() {\n    return roundrect.arcwidth;\n
2008,readFrameElement,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,674,678,43,"/**\n   * Reads a &lt;draw:frame&gt; element from the specified\n   * XML element.\n   * <p>\n   * A frame is a rectangular container where that contains enhanced content\n   * like text boxes, images or objects. Frames are very similar to regular\n   * drawing shapes, but support some features that are not available for\n   * regular drawing shapes, like contours, image maps and hyperlinks. In\n   * particular, a frame allows to have multiple renditions of an object. That\n   * is, a frame may for instance contain an object as well as an image. In\n   * this case, the application may choose the content that it supports best.\n   * If the application supports the object type contained in the frame, it\n   * probably will render the object. If it does not support the object, it\n   * will render the image.\n   * <p>\n   * In general, an application must not render more than one of the content\n   * elements contained in a frame. The order of content elements dictates\n   * the document author\'s preference for rendering, with the first child\n   * being the most preferred. This means that applications should render the\n   * first child element that it supports. A frame must contain at least one\n   * content element. The inclusion of multiple content elements is optional.\n   * Application may preserve the content elements they don\'t render, but\n   * don\'t have to.\n   * <p>\n   * Within text documents, frames are also used to position content outside\n   * the default text flow of a document.\n   * <p>\n   * Frames can contain:\n   *  Text boxes\n   *  Objects represented either in the OpenDocument format or in a object\n   *    specific binary format\n   *  Images\n   *  Applets\n   *  Plug-ins\n   *  Floating frames\n   * <p>\n   * Like the formatting properties of drawing shapes, frame formatting\n   * properties are stored in styles belonging to the graphic family. The way\n   * a frame is contained in a document also is the same as for drawing shapes.\n   *\n   *\n   * @param elem A &lt;frame&gt; element.\n   */",5,"  private ODGFigure readFrameElement(IXMLElement elem) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGInputFormat.readFrameElement("" + elem + "") not implemented."");\n    }\n    return null;\n"
2010,toWSOrCommaSeparatedArray,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,871,876,5,/**\n   * Returns a value as a String array.\n   * The values are separated by whitespace or by commas with optional white\n   * space.\n   */,6,"  public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {\n    String[] result = str.split(""(\\\\s*,\\\\s*|\\\\s+)"");\n    if (result.length == 1 && result[0].equals("""")) {\n      return new String[0];\n    } else {\n      return result;\n"
2014,getArcHeight,RoundRectangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/RoundRectangleFigure.java,108,109,1,/** Gets the arc height. */,2,  public double getArcHeight() {\n    return roundrect.archeight;\n
2015,toTransform,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,1300,1414,18,"/** Converts an ODG draw:transform attribute value into an AffineTransform.\n   * <p>\n   * The draw:transform attribute specifies a list of transformations that can be applied to a\n   * drawing shape.\n   * The value of this attribute is a list of transform definitions, which are applied to the drawing shape\n   * in the order in which they are listed. The transform definitions in the list must be separated by a\n   * white space and/or a comma. The types of transform definitions available include:\n   *  matrix(<a> <b> <c> <d> <e> <f>), which specifies a transformation in the form of a\n   * transformation matrix of six values. matrix(a,b,c,d,e,f) is the equivalent of applying the\n   * transformation matrix [a b c d e f].\n   *  translate(<tx> [<ty>]), which specifies a translation by tx and ty.\n   *  scale(<sx> [<sy>]), which specifies a scale operation by sx and sy. If <sy> is not\n   * provided, it is assumed to be equal to <sx>.\n   *  rotate(<rotate-angle>), which specifies a rotation by <rotate-angle> about the\n   * origin of the shapes coordinate system.\n   *  skewX(<skew-angle>), which specifies a skew transformation along the X axis.\n   *  skewY(<skew-angle>), which specifies a skew transformation along the Y axis.\n   */",105,"  public static AffineTransform toTransform(String str) throws IOException {\n    AffineTransform t = new AffineTransform();\n    AffineTransform t2 = new AffineTransform();\n    if (str != null) {\n      StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));\n      tt.resetSyntax();\n      tt.wordChars(\'a\', \'z\');\n      tt.wordChars(\'A\', \'Z\');\n      tt.wordChars(128 + 32, 255);\n      tt.whitespaceChars(0, \' \');\n      tt.whitespaceChars(\',\', \',\');\n      tt.parseNumbers();\n      tt.parseExponents();\n      while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {\n        if (tt.ttype != StreamPosTokenizer.TT_WORD) {\n          throw new IOException(""Illegal transform "" + str);\n        }\n        String type = tt.sval;\n        if (tt.nextToken() != \'(\') {\n          throw new IOException(""\'(\' not found in transform "" + str);\n        }\n        if (type.equals(""matrix"")) {\n          double[] m = new double[6];\n          for (int i = 0; i < 6; i++) {\n            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n              throw new IOException(""Matrix value "" + i + "" not found in transform "" + str + "" token:"" + tt.ttype + "" "" + tt.sval);\n            }\n            m[i] = tt.nval;\n          }\n          t.preConcatenate(new AffineTransform(m));\n        } else if (type.equals(""translate"")) {\n          double tx, ty;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""X-translation value not found in transform "" + str);\n          }\n          tx = tt.nval;\n          if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {\n            tx *= toUnitFactor(tt.sval);\n          } else {\n            tt.pushBack();\n          }\n          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {\n            ty = tt.nval;\n            if (tt.nextToken() == StreamPosTokenizer.TT_WORD) {\n              ty *= toUnitFactor(tt.sval);\n            } else {\n              tt.pushBack();\n            }\n          } else {\n            tt.pushBack();\n            ty = 0;\n          }\n          t2.setToIdentity();\n          t2.translate(tx, ty);\n          t.preConcatenate(t2);\n        } else if (type.equals(""scale"")) {\n          double sx, sy;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""X-scale value not found in transform "" + str);\n          }\n          sx = tt.nval;\n          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {\n            sy = tt.nval;\n          } else {\n            tt.pushBack();\n            sy = sx;\n          }\n          t2.setToIdentity();\n          t2.scale(sx, sy);\n          t.preConcatenate(t2);\n        } else if (type.equals(""rotate"")) {\n          double angle, cx, cy;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""Angle value not found in transform "" + str);\n          }\n          angle = tt.nval;\n          t2.setToIdentity();\n          t2.rotate(-angle);\n          t.preConcatenate(t2);\n\n        } else if (type.equals(""skewX"")) {\n          double angle;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""Skew angle not found in transform "" + str);\n          }\n          angle = tt.nval;\n          t.preConcatenate(new AffineTransform(\n              1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));\n        } else if (type.equals(""skewY"")) {\n          double angle;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""Skew angle not found in transform "" + str);\n          }\n          angle = tt.nval;\n          t.preConcatenate(new AffineTransform(\n              1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));\n        } else {\n          throw new IOException(""Unknown transform "" + type + "" in "" + str);\n        }\n        if (tt.nextToken() != \')\') {\n          throw new IOException(""\')\' not found in transform "" + str);\n        }\n      }\n    }\n    return t;\n"
2016,nextEnhancedCoordinate,ODGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGInputFormat.java,1207,1234,5,"/**\n   * Retrieves an enhanced coordinate from the specified tokenizer.\n   * An enhanced coordinate can be a double, or a \'?\' followed by a\n   * formula name, or a \'$\' followed by an index to a modifier.\n   */",28,"  private Object nextEnhancedCoordinate(StreamPosTokenizer tt, String str) throws IOException {\n    switch (tt.nextToken()) {\n      case \'?\': {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\'?\');\n        int ch = tt.nextChar();\n        for (; ch >= \'a\' && ch <= \'z\' || ch >= \'A\' && ch <= \'Z\' || ch >= \'0\' && ch <= \'9\';\n            ch = tt.nextChar()) {\n          buf.append((char) ch);\n        }\n        tt.pushCharBack(ch);\n        return buf.toString();\n      }\n      case \'$\': {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\'$\');\n        int ch = tt.nextChar();\n        for (; ch >= \'0\' && ch <= \'9\';\n            ch = tt.nextChar()) {\n          buf.append((char) ch);\n        }\n        tt.pushCharBack(ch);\n        return buf.toString();\n      }\n      case StreamPosTokenizer.TT_NUMBER:\n        return tt.nval;\n      default:\n        throw new IOException(""coordinate missing at position"" + tt.getStartPosition() + "" in "" + str);\n"
2017,handleMouseClick,LineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java,405,435,3,/**\n   * Handles a mouse click.\n   */,29,"  @Override\n  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {\n    if (getLiner() == null &&\n        evt.getClickCount() == 2) {\n      willChange();\n      final int index = splitSegment(p, (float) (5f / view.getScaleFactor()));\n      if (index != -1) {\n        final BezierPath.Node newNode = getNode(index);\n        fireUndoableEditHappened(new AbstractUndoableEdit() {\n          @Override\n          public void redo() throws CannotRedoException {\n            super.redo();\n            willChange();\n            addNode(index, newNode);\n            changed();\n          }\n          @Override\n          public void undo() throws CannotUndoException {\n            super.undo();\n            willChange();\n            removeNode(index);\n            changed();\n          }\n        });\n        changed();\n        return true;\n      }\n    }\n    return false;\n"
2019,addNotify,LineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java,277,283,6,"/**\n   * This method is invoked, when the Figure is being removed from a Drawing.\n   * This method invokes handleConnect, if the Figure is connected.\n   *\n   * @see #handleConnect\n   */",6,"  @Override\n  public void addNotify(Drawing drawing) {\n    super.addNotify(drawing);\n    if (getStartConnector() != null && getEndConnector() != null) {\n      handleConnect(getStartConnector(), getEndConnector());\n      updateConnection();\n"
2021,transform,LineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java,101,104,4,/**\n   * Ensures that a connection is updated if the connection\n   * was moved.\n   */,4,  @Override\n  public void transform(AffineTransform tx) {\n    super.transform(tx);\n    updateConnection(); // make sure that we are still connected\n
2022,createHandles,LineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java,114,132,5,/**\n   * Gets the handles of the figure. It returns the normal\n   * PolylineHandles but adds ChangeConnectionHandles at the\n   * start and end.\n   */,19,"  @Override\n  public Collection<Handle> createHandles(int detailLevel) {\n    ArrayList<Handle> handles = new ArrayList<Handle>(getNodeCount());\n    switch (detailLevel) {\n      case -1: // Mouse hover handles\n        handles.add(new BezierOutlineHandle(this, true));\n        break;\n      case 0:\n        handles.add(new BezierOutlineHandle(this));\n        if (getLiner() == null) {\n          for (int i = 1, n = getNodeCount() - 1; i < n; i++) {\n            handles.add(new BezierNodeHandle(this, i));\n          }\n        }\n        handles.add(new ConnectionStartHandle(this));\n        handles.add(new ConnectionEndHandle(this));\n        break;\n    }\n    return handles;\n"
2024,removeNotify,LineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java,293,306,9,"/**\n   * This method is invoked, when the Figure is being removed from a Drawing.\n   * This method invokes handleDisconnect, if the Figure is connected.\n   *\n   * @see #handleDisconnect\n   */\n --------------\n// SHAPE AND BOUNDS\n --------------",14,"  @Override\n  public void removeNotify(Drawing drawing) {\n    if (getStartConnector() != null && getEndConnector() != null) {\n      handleDisconnect(getStartConnector(), getEndConnector());\n    }\n    // Note: we do not set the connectors to null here, because we\n    // need them when we are added back to a drawing again. For example,\n    // when an undo is performed, after the LineConnection has been\n    // deleted.\n    /*\n    setStartConnector(null);\n    setEndConnector(null);\n     */\n    super.removeNotify(drawing);\n"
2027,setConnectable,LineConnectionFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/LineConnectionFigure.java,140,142,4,/**\n   * \n   * ConnectionFigures cannot be connected and always sets connectable to false.\n   */,3,  @Override\n  public void setConnectable(boolean newValue) {\n    super.setConnectable(false);\n
2028,transform,ODGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java,176,204,4,/**\n   * Transforms the figure.\n   * @param tx The transformation.\n   */,29,"  public void transform(AffineTransform tx) {\n    invalidateTransformedShape();\n    if (get(TRANSFORM) != null ||\n        //        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {\n        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {\n      if (get(TRANSFORM) == null) {\n        set(TRANSFORM, (AffineTransform) tx.clone());\n      } else {\n        AffineTransform t = TRANSFORM.getClone(this);\n        t.preConcatenate(tx);\n        set(TRANSFORM, t);\n      }\n    } else {\n      Point2D.Double anchor = getStartPoint();\n      Point2D.Double lead = getEndPoint();\n      setBounds(\n          (Point2D.Double) tx.transform(anchor, anchor),\n          (Point2D.Double) tx.transform(lead, lead));\n      if (get(FILL_GRADIENT) != null &&\n          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = FILL_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(FILL_GRADIENT, g);\n      }\n      if (get(STROKE_GRADIENT) != null &&\n          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = STROKE_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(STROKE_GRADIENT, g);\n"
2029,ODGRectFigure,ODGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java,48,49,1,/** Creates a new instance. */,2,"  public ODGRectFigure() {\n    this(0, 0, 0, 0);\n"
2030,contains,ODGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGRectFigure.java,132,133,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,2,  public boolean contains(Point2D.Double p) {\n    return getHitShape().contains(p);\n
2036,sort,QuadTreeDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java,74,82,3,/**\n   * Implementation note: Sorting can not be done for orphaned children.\n   */,9,  public java.util.List<Figure> sort(Collection<? extends Figure> c) {\n    ensureSorted();\n    ArrayList<Figure> sorted = new ArrayList<Figure>(c.size());\n    for (Figure f : children) {\n      if (c.contains(f)) {\n        sorted.add(f);\n      }\n    }\n    return sorted;\n
2037,ensureSorted,QuadTreeDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java,268,271,3,/**\n   * Ensures that the children are sorted in z-order sequence.\n   */,4,"  private void ensureSorted() {\n    if (needsSorting) {\n      Collections.sort(children, FigureLayerComparator.INSTANCE);\n      needsSorting = false;\n"
2040,getFiguresFrontToBack,QuadTreeDrawing,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/QuadTreeDrawing.java,118,120,4,/**\n   * Returns an iterator to iterate in\n   * Z-order front to back over the children.\n   */,3,  public java.util.List<Figure> getFiguresFrontToBack() {\n    ensureSorted();\n    return new ReversedList<Figure>(children);\n
2041,ODGPathFigure,ODGPathFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/figures/ODGPathFigure.java,57,59,1,/** Creates a new instance. */,3,  public ODGPathFigure() {\n    add(new ODGBezierFigure());\n    ODGAttributeKeys.setDefaults(this);\n
2044,AlignAction,AlignAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AlignAction.java,36,37,1,/** Creates a new instance. */,2,  public AlignAction(DrawingEditor editor) {\n    super(editor);\n
2058,AbstractDrawingViewAction,AbstractDrawingViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java,79,80,3,/**\n   * Creates a view action which acts on the current view of the editor.\n   */,2,  public AbstractDrawingViewAction(DrawingEditor editor) {\n    setEditor(editor);\n
2059,dispose,AbstractDrawingViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java,139,140,3,"/** Frees all resources held by this object, so that it can be garbage\n   * collected.\n   */",2,  public void dispose() {\n    setEditor(null);\n
2060,setUpdateEnabledState,AbstractDrawingViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java,152,165,9,"/** By default, the enabled state of this action is updated to reflect\n   * the enabled state of the active {@code DrawingView}.\n   * Since this is not always necessary, and since many listening actions\n   * may considerably slow down the drawing editor, you can switch this\n   * behavior off here.\n   *\n   * @param newValue Specify false to prevent automatic updating of the\n   * enabled state.\n   */",14,"  public void setUpdateEnabledState(boolean newValue) {\n    // Note: eventHandler != null yields true, if we are currently updating\n    // the enabled state.\n    if (eventHandler != null != newValue) {\n      if (newValue) {\n        eventHandler = new EventHandler();\n        registerEventHandler();\n      } else {\n        unregisterEventHandler();\n        eventHandler = null;\n      }\n    }\n    if (newValue) {\n      updateEnabledState();\n"
2062,unregisterEventHandler,AbstractDrawingViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java,179,188,3,/** Unregisters the event handler from the drawing editor and the\n   * active drawing view.\n   */,10,  private void unregisterEventHandler() {\n    if (editor != null) {\n      editor.removePropertyChangeListener(eventHandler);\n    }\n    if (activeView != null) {\n      activeView.removePropertyChangeListener(eventHandler);\n      activeView = null;\n    }\n    if (specificView != null) {\n      specificView.removePropertyChangeListener(eventHandler);\n
2063,AbstractDrawingViewAction,AbstractDrawingViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java,86,88,3,/**\n   * Creates a view action which acts on the specified view.\n   */,3,  public AbstractDrawingViewAction(DrawingView view) {\n    this.specificView = view;\n    registerEventHandler();\n
2064,isUpdatEnabledState,AbstractDrawingViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java,172,173,3,"/** Returns true, if this action automatically updates its enabled\n   * state to reflect the enabled state of the active {@code DrawingView}.\n   */",2,  public boolean isUpdatEnabledState() {\n    return eventHandler != null;\n
2065,updateEnabledState,AbstractDrawingViewAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingViewAction.java,122,126,4,"/** Updates the enabled state of this action to reflect the enabled state\n   * of the active {@code DrawingView}. If no drawing view is active, this\n   * action is disabled.\n   */",5,  public void updateEnabledState() {\n    if (getView() != null) {\n      setEnabled(getView().isEnabled());\n    } else {\n      setEnabled(false);\n
2066,AttributeToggler,AttributeToggler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeToggler.java,45,46,1,/** Creates a new instance. */,2,"  public AttributeToggler(DrawingEditor editor, AttributeKey<T> key, T value1, T value2) {\n    this(editor, key, value1, value2, null);\n"
2068,TriangleFigure,TriangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java,50,51,1,/** Creates a new instance. */,2,"  public TriangleFigure() {\n    this(0, 0, 0, 0);\n"
2069,contains,TriangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java,183,194,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,12,"  public boolean contains(Point2D.Double p) {\n    Shape triangle = getBezierPath();\n    \n    double grow = AttributeKeys.getPerpendicularHitGrowth(this);\n    if (grow != 0d) {\n      GrowStroke gs = new GrowStroke((float) grow,\n          (float) (AttributeKeys.getStrokeTotalWidth(this) *\n          get(STROKE_MITER_LIMIT))\n          );\n      triangle =gs.createStrokedShape(triangle);\n    }\n    return triangle.contains(p);\n"
2070,findCompatibleConnector,TriangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java,81,82,7,/**\n   * Returns a compatible connector.\n   * By default a {@link org.jhotdraw.draw.connector.ChopTriangleConnector} is returned.\n   */\n --------------\n// SHAPE AND BOUNDS\n --------------,2,"  public Connector findCompatibleConnector(Connector c, boolean isStartConnector) {\n    return new ChopTriangleConnector(this);\n"
2071,findConnector,TriangleFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/TriangleFigure.java,74,75,4,/**\n   * Returns the Figures connector for the specified location.\n   * By default a {@link org.jhotdraw.draw.connector.ChopTriangleConnector} is returned.\n   */,2,"  public Connector findConnector(Point2D.Double p, ConnectionFigure prototype) {\n    return new ChopTriangleConnector(this);\n"
2072,ApplyAttributesAction,ApplyAttributesAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ApplyAttributesAction.java,36,39,1,/** Creates a new instance. */,4,"  public ApplyAttributesAction(DrawingEditor editor) {\n    super(editor);\n    labels.configureAction(this, ""edit.applyAttributes"");\n    setEnabled(true);\n"
2073,AttributeAction,AttributeAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java,41,42,1,/** Creates a new instance. */,2,"  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, Icon icon) {\n    this(editor, key, value, null, icon);\n"
2074,AttributeAction,AttributeAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java,36,37,1,/** Creates a new instance. */,2,"  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value) {\n    this(editor, key, value, null, null);\n"
2075,AttributeAction,AttributeAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AttributeAction.java,46,47,1,/** Creates a new instance. */,2,"  public AttributeAction(DrawingEditor editor, AttributeKey key, Object value, String name) {\n    this(editor, key, value, name, null);\n"
2076,updateEnabledState,AbstractSelectedAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java,99,104,4,"/** Updates the enabled state of this action to reflect the enabled state\n   * of the active {@code DrawingView}. If no drawing view is active, this\n   * action is disabled.\n   */",6,  protected void updateEnabledState() {\n    if (getView() != null) {\n      setEnabled(getView().isEnabled() &&\n          getView().getSelectionCount() > 0);\n    } else {\n      setEnabled(false);\n
2077,setUpdateEnabledState,AbstractSelectedAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java,148,161,9,"/** By default, the enabled state of this action is updated to reflect\n   * the enabled state of the active {@code DrawingView}.\n   * Since this is not always necessary, and since many listening actions\n   * may considerably slow down the drawing editor, you can switch this\n   * behavior off here.\n   *\n   * @param newValue Specify false to prevent automatic updating of the\n   * enabled state.\n   */",14,"  public void setUpdateEnabledState(boolean newValue) {\n    // Note: eventHandler != null yields true, if we are currently updating\n    // the enabled state.\n    if (eventHandler != null != newValue) {\n      if (newValue) {\n        eventHandler = new EventHandler();\n        registerEventHandler();\n      } else {\n        unregisterEventHandler();\n        eventHandler = null;\n      }\n    }\n    if (newValue) {\n      updateEnabledState();\n"
2078,isUpdatEnabledState,AbstractSelectedAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java,168,169,3,"/** Returns true, if this action automatically updates its enabled\n   * state to reflect the enabled state of the active {@code DrawingView}.\n   */",2,  public boolean isUpdatEnabledState() {\n    return eventHandler != null;\n
2079,AbstractSelectedAction,AbstractSelectedAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java,90,92,3,/** Creates an action which acts on the selected figures on the current view\n   * of the specified editor.\n   */,3,  public AbstractSelectedAction(DrawingEditor editor) {\n    setEditor(editor);\n    updateEnabledState();\n
2080,unregisterEventHandler,AbstractSelectedAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractSelectedAction.java,175,182,3,/** Unregisters the event handler from the drawing editor and the\n   * active drawing view.\n   */,8,  private void unregisterEventHandler() {\n    if (editor != null) {\n      editor.removePropertyChangeListener(eventHandler);\n    }\n    if (activeView != null) {\n      activeView.removeFigureSelectionListener(eventHandler);\n      activeView.removePropertyChangeListener(eventHandler);\n      activeView = null;\n
2081,unregisterEventHandler,AbstractDrawingEditorAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java,131,133,3,/** Unregisters the event handler from the drawing editor and the\n   * active drawing view.\n   */,3,  private void unregisterEventHandler() {\n    if (editor != null) {\n      editor.removePropertyChangeListener(eventHandler);\n
2082,AbstractDrawingEditorAction,AbstractDrawingEditorAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java,56,57,1,/** Creates a new instance. */,2,  public AbstractDrawingEditorAction(DrawingEditor editor) {\n    setEditor(editor);\n
2083,fireUndoableEditHappened,AbstractDrawingEditorAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java,91,92,4,"/** Updates the enabled state of this action to reflect the enabled state\n   * of the active {@code DrawingView}. If no drawing view is active, this\n   * action is disabled.\n   */",2,  protected void fireUndoableEditHappened(UndoableEdit edit) {\n    getDrawing().fireUndoableEditHappened(edit);\n
2084,setUpdateEnabledState,AbstractDrawingEditorAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java,104,117,9,"/** By default, the enabled state of this action is updated to reflect\n   * the enabled state of the active {@code DrawingView}.\n   * Since this is not always necessary, and since many listening actions\n   * may considerably slow down the drawing editor, you can switch this\n   * behavior off here.\n   *\n   * @param newValue Specify false to prevent automatic updating of the\n   * enabled state.\n   */",14,"  public void setUpdateEnabledState(boolean newValue) {\n    // Note: eventHandler != null yields true, if we are currently updating\n    // the enabled state.\n    if (eventHandler != null != newValue) {\n      if (newValue) {\n        eventHandler = new EventHandler();\n        registerEventHandler();\n      } else {\n        unregisterEventHandler();\n        eventHandler = null;\n      }\n    }\n    if (newValue) {\n      updateEnabledState();\n"
2085,isUpdatEnabledState,AbstractDrawingEditorAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/AbstractDrawingEditorAction.java,124,125,3,"/** Returns true, if this action automatically updates its enabled\n   * state to reflect the enabled state of the active {@code DrawingView}.\n   */",2,  public boolean isUpdatEnabledState() {\n    return eventHandler != null;\n
2088,getEventSetDescriptors,AlignToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2089,getBeanDescriptor,AlignToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2090,getMethodDescriptors,AlignToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2091,getPropertyDescriptors,AlignToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2093,getDefaultPropertyIndex,AlignToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2094,getDefaultEventIndex,AlignToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2095,getID,AbstractToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBar.java,54,55,7,"/** This should be an abstract method, but the NetBeans GUI builder\n   * doesn\'t support abstract beans.\n   * @return The ID used to retrieve labels and store user preferences.\n   */\n --------------\n// prefs is null, because we are not permitted to read preferences\n --------------",2,"  protected String getID() {\n    return """";\n"
2096,AbstractToolBar,AbstractToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBar.java,41,45,1,/** Creates new form. */,5,  public AbstractToolBar() {\n    initComponents();\n    try {\n      prefs = PreferencesUtil.userNodeForPackage(getClass());\n    } catch (SecurityException e) {\n
2099,getDefaultPropertyIndex,CanvasToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2100,getDefaultEventIndex,CanvasToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2103,getPropertyDescriptors,CanvasToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2104,getEventSetDescriptors,CanvasToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2106,getMethodDescriptors,CanvasToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2107,getBeanDescriptor,CanvasToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2108,SVGImageFigure,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,70,71,1,/** Creates a new instance. */,2,"  public SVGImageFigure() {\n    this(0, 0, 0, 0);\n"
2109,AlignToolBar,AlignToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBar.java,37,39,1,/** Creates new instance. */,3,"  public AlignToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n"
2111,initComponents,AlignToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AlignToolBar.java,144,146,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,2,  private void initComponents() {\n    setOpaque(false);\n
2114,transform,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,199,215,4,/**\n   * Transforms the figure.\n   * @param tx The transformation.\n   */,17,"  public void transform(AffineTransform tx) {\n    invalidateTransformedShape();\n    if (get(TRANSFORM) != null ||\n        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {\n      if (get(TRANSFORM) == null) {\n        set(TRANSFORM, (AffineTransform) tx.clone());\n      } else {\n        AffineTransform t = TRANSFORM.getClone(this);\n        t.preConcatenate(tx);\n        set(TRANSFORM, t);\n      }\n    } else {\n      Point2D.Double anchor = getStartPoint();\n      Point2D.Double lead = getEndPoint();\n      setBounds(\n          (Point2D.Double) tx.transform(anchor, anchor),\n          (Point2D.Double) tx.transform(lead, lead));\n"
2115,contains,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,159,160,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,2,  public boolean contains(Point2D.Double p) {\n    return getHitShape().contains(p);\n
2117,getBufferedImage,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,389,402,4,"/**\n   * Gets the buffered image. If necessary, this method creates the buffered\n   * image from the image data.\n   */",14,"  public BufferedImage getBufferedImage() {\n    if (bufferedImage == null && imageData != null) {\n      //System.out.println(""recreateing bufferedImage"");\n      try {\n        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));\n      } catch (Throwable e) {\n        e.printStackTrace();\n        // If we can\'t create a buffered image from the image data,\n        // there is no use to keep the image data and try again, so\n        // we drop the image data.\n        imageData = null;\n      }\n    }\n    return bufferedImage;\n"
2118,setImage,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,356,360,11,"/**\n   * Sets the image.\n   *\n   * @param imageData The image data. If this is null, a buffered image must\n   * be provided.\n   * @param bufferedImage An image constructed from the imageData. If this\n   * is null, imageData must be provided.\n   */\n --------------\n// COMPOSITE FIGURES\n --------------",5,"  public void setImage(byte[] imageData, BufferedImage bufferedImage) {\n    willChange();\n    this.imageData = imageData;\n    this.bufferedImage = bufferedImage;\n    changed();\n"
2119,getImageData,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,409,424,4,"/**\n   * Gets the image data. If necessary, this method creates the image\n   * data from the buffered image.\n   */",16,"  public byte[] getImageData() {\n    if (bufferedImage != null && imageData == null) {\n      try {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        ImageIO.write(bufferedImage, ""PNG"", bout);\n        bout.close();\n        imageData = bout.toByteArray();\n      } catch (IOException e) {\n        e.printStackTrace();\n        // If we can\'t create image data from the buffered image,\n        // there is no use to keep the buffered image and try again, so\n        // we drop the buffered image.\n        bufferedImage = null;\n      }\n    }\n    return imageData;\n"
2122,setImageData,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,367,371,4,/**\n   * Sets the image data.\n   * This clears the buffered image.\n   */,5,  public void setImageData(byte[] imageData) {\n    willChange();\n    this.imageData = imageData;\n    this.bufferedImage = null;\n    changed();\n
2125,getMethodDescriptors,AbstractToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2126,setBufferedImage,SVGImageFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGImageFigure.java,378,382,4,/**\n   * Sets the buffered image.\n   * This clears the image data.\n   */,5,  public void setBufferedImage(BufferedImage image) {\n    willChange();\n    this.imageData = null;\n    this.bufferedImage = image;\n    changed();\n
2127,getBeanDescriptor,AbstractToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2128,getPropertyDescriptors,AbstractToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2129,getDefaultEventIndex,AbstractToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2130,getEventSetDescriptors,AbstractToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2131,getDefaultPropertyIndex,AbstractToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/AbstractToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2132,SVGEllipseFigure,SVGEllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java,49,50,1,/** Creates a new instance. */,2,"  public SVGEllipseFigure() {\n    this(0, 0, 0, 0);\n"
2134,contains,SVGEllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java,112,113,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,2,  public boolean contains(Point2D.Double p) {\n    return getHitShape().contains(p);\n
2137,transform,SVGEllipseFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGEllipseFigure.java,153,182,5,/**\n   * Transforms the figure.\n   *\n   * @param tx the transformation.\n   */,30,"  public void transform(AffineTransform tx) {\n    if (get(TRANSFORM) != null ||\n        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {\n      if (get(TRANSFORM) == null) {\n        TRANSFORM.setClone(this, tx);\n      } else {\n        AffineTransform t = TRANSFORM.getClone(this);\n        t.preConcatenate(tx);\n        set(TRANSFORM,  t);\n      }\n    } else {\n      Point2D.Double anchor = getStartPoint();\n      Point2D.Double lead = getEndPoint();\n      setBounds(\n          (Point2D.Double) tx.transform(anchor, anchor),\n          (Point2D.Double) tx.transform(lead, lead));\n      if (get(FILL_GRADIENT) != null &&\n          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = FILL_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(FILL_GRADIENT,  g);\n      }\n      if (get(STROKE_GRADIENT) != null &&\n          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = STROKE_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(STROKE_GRADIENT,  g);\n      }\n    }\n    invalidate();\n"
2139,CanvasToolBar,CanvasToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/CanvasToolBar.java,41,44,1,/** Creates new instance. */,4,"  public CanvasToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n    setDisclosureStateCount(3);\n"
2140,getDefaultPropertyIndex,ArrangeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2141,getPropertyDescriptors,ArrangeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2142,getDefaultEventIndex,ArrangeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2143,getMethodDescriptors,ArrangeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2146,getBeanDescriptor,ArrangeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2148,contains,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,200,201,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,2,  public boolean contains(Point2D.Double p) {\n    return getHitShape().contains(p);\n
2149,getEventSetDescriptors,ArrangeToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBarBeanInfo.java,117,118,8,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */\n,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2150,getArcWidth,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,141,142,1,/** Gets the arc width. */,2,  public double getArcWidth() {\n    return roundrect.arcwidth;\n
2151,setArcHeight,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,158,161,1,/** Sets the arc height. */,4,"  public void setArcHeight(double newValue) {\n    double oldValue = roundrect.archeight;\n    roundrect.archeight = newValue;\n    firePropertyChange(ARC_HEIGHT_PROPERTY, oldValue, newValue);\n"
2152,SVGRectFigure,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,68,69,1,/** Creates a new instance. */,2,"  public SVGRectFigure() {\n    this(0, 0, 0, 0);\n"
2153,transform,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,250,278,4,/**\n   * Transforms the figure.\n   * @param tx The transformation.\n   */,29,"  public void transform(AffineTransform tx) {\n    invalidateTransformedShape();\n    if (get(TRANSFORM) != null ||\n        //        (tx.getType() & (AffineTransform.TYPE_TRANSLATION | AffineTransform.TYPE_MASK_SCALE)) != tx.getType()) {\n        (tx.getType() & (AffineTransform.TYPE_TRANSLATION)) != tx.getType()) {\n      if (get(TRANSFORM) == null) {\n        set(TRANSFORM,  (AffineTransform) tx.clone());\n      } else {\n        AffineTransform t = TRANSFORM.getClone(this);\n        t.preConcatenate(tx);\n        set(TRANSFORM,  t);\n      }\n    } else {\n      Point2D.Double anchor = getStartPoint();\n      Point2D.Double lead = getEndPoint();\n      setBounds(\n          (Point2D.Double) tx.transform(anchor, anchor),\n          (Point2D.Double) tx.transform(lead, lead));\n      if (get(FILL_GRADIENT) != null &&\n          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = FILL_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(FILL_GRADIENT,  g);\n      }\n      if (get(STROKE_GRADIENT) != null &&\n          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = STROKE_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(STROKE_GRADIENT,  g);\n"
2154,getArcHeight,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,146,147,1,/** Gets the arc height. */,2,  public double getArcHeight() {\n    return roundrect.archeight;\n
2155,getMethodDescriptors,ActionsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2156,setArc,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,165,167,1,/** Convenience method for setting both the arc width and the arc height. */,3,"  public void setArc(double width, double height) {\n    setArcWidth(width);\n    setArcHeight(height);\n"
2157,getBeanDescriptor,ActionsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2159,getDefaultPropertyIndex,ActionsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2163,getPropertyDescriptors,ActionsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2165,getEventSetDescriptors,ActionsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2166,setArcWidth,SVGRectFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectFigure.java,152,155,1,/** Sets the arc width. */,4,"  public void setArcWidth(double newValue) {\n    double oldValue = roundrect.arcwidth;\n    roundrect.arcwidth = newValue;\n    firePropertyChange(ARC_WIDTH_PROPERTY, oldValue, newValue);\n"
2167,getDefaultEventIndex,ActionsToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2169,ArrangeToolBar,ArrangeToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBar.java,37,39,1,/** Creates new instance. */,3,"  public ArrangeToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n"
2170,initComponents,ArrangeToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ArrangeToolBar.java,117,119,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,2,  private void initComponents() {\n    setOpaque(false);\n
2172,ActionsToolBar,ActionsToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ActionsToolBar.java,50,52,1,/** Creates new instance. */,3,"  public ActionsToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n"
2173,getTool,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,505,510,4,"/**\n   * Returns a specialized tool for the given coordinate.\n   * <p>Returns null, if no specialized tool is available.\n   */",6,  public Tool getTool(Point2D.Double p) {\n    if (isEditable() && contains(p)) {\n      TextAreaEditingTool tool = new TextAreaEditingTool(this);\n      return tool;\n    }\n    return null;\n
2174,appendParagraph,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,191,304,17,"/**\n   * Appends a paragraph of text at the specified y location and returns\n   * the bounds of the paragraph.\n   * \n   *\n   * @param shape Shape to which to add the glyphs of the paragraph. This \n   * parameter is null, if we only want to measure the size of the paragraph.\n   * @param styledText the text of the paragraph.\n   * @param verticalPos the top bound of the paragraph\n   * @param maxVerticalPos the bottom bound of the paragraph\n   * @param leftMargin the left bound of the paragraph\n   * @param rightMargin the right bound of the paragraph\n   * @param tabStops an array with tab stops\n   * @param tabCount the number of entries in tabStops which contain actual\n   *    values\n   * @return Returns the actual bounds of the paragraph.\n   */",95,"  private Rectangle2D.Double appendParagraph(Path2D.Double shape,\n      AttributedCharacterIterator styledText,\n      float verticalPos, float maxVerticalPos,\n      float leftMargin, float rightMargin,\n      float[] tabStops, int tabCount) {\n    // assume styledText is an AttributedCharacterIterator, and the number\n    // of tabs in styledText is tabCount\n    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);\n    int[] tabLocations = new int[tabCount + 1];\n    int i = 0;\n    for (char c = styledText.first(); c != styledText.DONE; c = styledText.next()) {\n      if (c == '\\t') {\n        tabLocations[i++] = styledText.getIndex();\n      }\n    }\n    tabLocations[tabCount] = styledText.getEndIndex() - 1;\n    // Now tabLocations has an entry for every tab's offset in\n    // the text.  For convenience, the last entry is tabLocations\n    // is the offset of the last character in the text.\n    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());\n    int currentTab = 0;\n    while (measurer.getPosition() < styledText.getEndIndex()) {\n      // Lay out and draw each line.  All segments on a line\n      // must be computed before any drawing can occur, since\n      // we must know the largest ascent on the line.\n      // TextLayouts are computed and stored in a List;\n      // their horizontal positions are stored in a parallel\n      // List.\n      // lineContainsText is true after first segment is drawn\n      boolean lineContainsText = false;\n      boolean lineComplete = false;\n      float maxAscent = 0, maxDescent = 0;\n      float horizontalPos = leftMargin;\n      LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();\n      LinkedList<Float> penPositions = new LinkedList<Float>();\n      while (!lineComplete) {\n        float wrappingWidth = rightMargin - horizontalPos;\n        TextLayout layout = null;\n        layout =\n            measurer.nextLayout(wrappingWidth,\n            tabLocations[currentTab] + 1,\n            lineContainsText);\n        // layout can be null if lineContainsText is true\n        if (layout != null) {\n          layouts.add(layout);\n          penPositions.add(horizontalPos);\n          horizontalPos += layout.getAdvance();\n          maxAscent = Math.max(maxAscent, layout.getAscent());\n          maxDescent = Math.max(maxDescent,\n              layout.getDescent() + layout.getLeading());\n        } else {\n          lineComplete = true;\n        }\n        lineContainsText = true;\n        if (measurer.getPosition() == tabLocations[currentTab] + 1) {\n          currentTab++;\n        }\n        if (measurer.getPosition() == styledText.getEndIndex()) {\n          lineComplete = true;\n        } else if (tabStops.length == 0 || horizontalPos >= tabStops[tabStops.length - 1]) {\n          lineComplete = true;\n        }\n        if (!lineComplete) {\n          // move to next tab stop\n          int j;\n          for (j = 0; horizontalPos >= tabStops[j]; j++) {\n          }\n          horizontalPos = tabStops[j];\n        }\n      }\n      verticalPos += maxAscent;\n      if (verticalPos > maxVerticalPos) {\n        break;\n      }\n      Iterator<TextLayout> layoutEnum = layouts.iterator();\n      Iterator<Float> positionEnum = penPositions.iterator();\n      // now iterate through layouts and draw them\n      while (layoutEnum.hasNext()) {\n        TextLayout nextLayout = layoutEnum.next();\n        float nextPosition = positionEnum.next();\n        AffineTransform tx = new AffineTransform();\n        tx.translate(nextPosition, verticalPos);\n        if (shape != null) {\n          Shape outline = nextLayout.getOutline(tx);\n          shape.append(outline, false);\n        }\n        Rectangle2D layoutBounds = nextLayout.getBounds();\n        paragraphBounds.add(new Rectangle2D.Double(layoutBounds.getX() + nextPosition,\n            layoutBounds.getY() + verticalPos,\n            layoutBounds.getWidth(),\n            layoutBounds.getHeight()));\n      }\n      verticalPos += maxDescent;\n    }\n    return paragraphBounds;\n"
2176,contains,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,109,119,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,10,"  public boolean contains(Point2D.Double p) {\n    if (get(TRANSFORM) != null) {\n      try {\n        p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());\n      } catch (NoninvertibleTransformException ex) {\n        ex.printStackTrace();\n      }\n    }\n    Rectangle2D r = getTextShape().getBounds2D();\n    return r.isEmpty() ? getBounds().contains(p) : r.contains(p);\n"
2180,transform,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,320,351,5,/**\n   * Transforms the figure.\n   *\n   * @param tx the transformation.\n   */,32,"  public void transform(AffineTransform tx) {\n    if (get(TRANSFORM) != null ||\n        (tx.getType() &\n        (AffineTransform.TYPE_TRANSLATION /*| AffineTransform.TYPE_MASK_SCALE*/)) !=\n        tx.getType()) {\n      if (get(TRANSFORM) == null) {\n        set(TRANSFORM,  (AffineTransform) tx.clone());\n      } else {\n        AffineTransform t = TRANSFORM.getClone(this);\n        t.preConcatenate(tx);\n        set(TRANSFORM,  t);\n      }\n    } else {\n      Point2D.Double anchor = getStartPoint();\n      Point2D.Double lead = getEndPoint();\n      setBounds(\n          (Point2D.Double) tx.transform(anchor, anchor),\n          (Point2D.Double) tx.transform(lead, lead));\n      if (get(FILL_GRADIENT) != null &&\n          !get(FILL_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = FILL_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(FILL_GRADIENT,  g);\n      }\n      if (get(STROKE_GRADIENT) != null &&\n          !get(STROKE_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = STROKE_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(STROKE_GRADIENT,  g);\n      }\n    }\n    invalidate();\n"
2181,SVGTextAreaFigure,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,60,61,1,/** Creates a new instance. */,2,"  public SVGTextAreaFigure() {\n    this(""Text"");\n"
2182,getPreferredTextSize,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,550,586,10,"/**\n   * Returns the preferred text size of the TextAreaFigure.\n   * <p>\n   * If you want to use this method to determine the bounds of the TextAreaFigure,\n   * you need to add the insets of the TextAreaFigure to the size.\n   * \n   * @param maxWidth the maximal width to use. Specify Double.MAX_VALUE\n   * if you want the width to be unlimited.\n   * @return width and height needed to lay out the text.\n   */",35,"  public Dimension2DDouble getPreferredTextSize(double maxWidth) {\n    Rectangle2D.Double textRect = new Rectangle2D.Double();\n    if (getText() != null) {\n      Font font = getFont();\n      boolean isUnderlined = get(FONT_UNDERLINE);\n      float leftMargin = 0;\n      float rightMargin = (float) maxWidth - 1;\n      float verticalPos = 0;\n      float maxVerticalPos = Float.MAX_VALUE;\n      if (leftMargin < rightMargin) {\n        float tabWidth = (float) (getTabSize() * font.getStringBounds(""m"", getFontRenderContext()).getWidth());\n        float[] tabStops = new float[(int) (textRect.width / tabWidth)];\n        for (int i = 0; i < tabStops.length; i++) {\n          tabStops[i] = (float) (textRect.x + (int) (tabWidth * (i + 1)));\n        }\n        if (getText() != null) {\n          String[] paragraphs = getText().split(""\\n"");//Strings.split(getText(), \'\\n\');\n          for (int i = 0; i < paragraphs.length; i++) {\n            if (paragraphs[i].length() == 0) {\n              paragraphs[i] = "" "";\n            }\n            AttributedString as = new AttributedString(paragraphs[i]);\n            as.addAttribute(TextAttribute.FONT, font);\n            if (isUnderlined) {\n              as.addAttribute(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_LOW_ONE_PIXEL);\n            }\n            int tabCount = paragraphs[i].split(""\\t"").length - 1;\n            Rectangle2D.Double paragraphBounds = appendParagraph(null, as.getIterator(), verticalPos, maxVerticalPos, leftMargin, rightMargin, tabStops, tabCount);\n            verticalPos = (float) (paragraphBounds.y + paragraphBounds.height);\n            textRect.add(paragraphBounds);\n          }\n        }\n      }\n    }\n    return new Dimension2DDouble(Math.abs(textRect.x) + textRect.width, Math.abs(textRect.y) + textRect.height);\n"
2183,getInsets,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,404,407,3,/**\n   * Returns the insets used to draw text.\n   */,4,"  public Insets2D.Double getInsets() {\n    double sw = (get(STROKE_COLOR) == null) ? 0 : Math.ceil(get(STROKE_WIDTH) / 2);\n    Insets2D.Double insets = new Insets2D.Double(0, 0, 0, 0);\n    return new Insets2D.Double(insets.top + sw, insets.left + sw, insets.bottom + sw, insets.right + sw);\n"
2184,setText,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,397,398,3,/**\n   * Sets the text shown by the text figure.\n   */,2,"  public void setText(String newText) {\n    set(TEXT, newText);\n"
2185,isEmpty,SVGTextAreaFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextAreaFigure.java,520,521,3,/**\n   * Gets the text shown by the text figure.\n   */,2,  public boolean isEmpty() {\n    return getText() == null || getText().length() == 0;\n
2187,SVGPathOutlineHandle,SVGPathOutlineHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathOutlineHandle.java,38,39,1,/** Creates a new instance. */,2,"  public SVGPathOutlineHandle(SVGPathFigure owner) {\n    this(owner, false);\n"
2188,SVGPathFigure,SVGPathFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathFigure.java,57,59,1,/** Creates a new instance. */,3,  public SVGPathFigure() {\n    add(new SVGBezierFigure());\n    SVGAttributeKeys.setDefaults(this);\n
2189,handleMouseClick,SVGPathFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGPathFigure.java,455,468,3,/**\n   * Handles a mouse click.\n   */,14,"  @Override\n  public boolean handleMouseClick(Point2D.Double p, MouseEvent evt, DrawingView view) {\n    if (evt.getClickCount() == 2 && view.getHandleDetailLevel() % 2 == 0) {\n      for (Figure child : getChildren()) {\n        SVGBezierFigure bf = (SVGBezierFigure) child;\n        int index = bf.findSegment(p, 5f / view.getScaleFactor());\n        if (index != -1) {\n          bf.handleMouseClick(p, evt, view);\n          evt.consume();\n          return true;\n        }\n      }\n    }\n    return false;\n"
2192,draw,SVGRectRadiusHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectRadiusHandle.java,49,58,3,/**\n   * Draws this handle.\n   */,10,"  @Override\n  public void draw(Graphics2D g) {\n    if (getEditor().getTool().supportsHandleInteraction()) {\n      drawDiamond(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR));\n    } else {\n      drawDiamond(g,\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_FILL_COLOR_DISABLED),\n          (Color) getEditor().getHandleAttribute(HandleAttributeKeys.ATTRIBUTE_HANDLE_STROKE_COLOR_DISABLED));\n"
2193,SVGRectRadiusHandle,SVGRectRadiusHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGRectRadiusHandle.java,42,43,1,/** Creates a new instance. */,2,  public SVGRectRadiusHandle(Figure owner) {\n    super(owner);\n
2195,contains,SVGTextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java,170,178,3,/**\n   * Checks if a Point2D.Double is inside the figure.\n   */,9,"  public boolean contains(Point2D.Double p) {\n    if (get(TRANSFORM) != null) {\n      try {\n        p = (Point2D.Double) get(TRANSFORM).inverseTransform(p, new Point2D.Double());\n      } catch (NoninvertibleTransformException ex) {\n        ex.printStackTrace();\n      }\n    }\n    return getTextShape().getBounds2D().contains(p);\n"
2197,SVGTextFigure,SVGTextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java,71,72,1,/** Creates a new instance. */,2,"  public SVGTextFigure() {\n    this(""Text"");\n"
2199,setText,SVGTextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java,309,310,3,/**\n   * Sets the text shown by the text figure.\n   */,2,"  public void setText(String newText) {\n    set(TEXT, newText);\n"
2200,getTool,SVGTextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java,415,421,7,"/**\n   * Returns a specialized tool for the given coordinate.\n   * <p>Returns null, if no specialized tool is available.\n   */\n --------------\n// EDITING\n --------------",7,  @Override\n  public Tool getTool(Point2D.Double p) {\n    if (isEditable() && contains(p)) {\n      TextEditingTool tool = new TextEditingTool(this);\n      return tool;\n    }\n    return null;\n
2202,getText,SVGTextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java,291,292,3,/**\n   * Gets the text shown by the text figure.\n   */,2,  public String getText() {\n    return (String) get(TEXT);\n
2203,transform,SVGTextFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGTextFigure.java,233,260,5,/**\n   * Transforms the figure.\n   *\n   * @param tx the transformation.\n   */,28,"  public void transform(AffineTransform tx) {\n    if (get(TRANSFORM) != null ||\n        tx.getType() != (tx.getType() & AffineTransform.TYPE_TRANSLATION)) {\n      if (get(TRANSFORM) == null) {\n        set(TRANSFORM,  (AffineTransform) tx.clone());\n      } else {\n        AffineTransform t = TRANSFORM.getClone(this);\n        t.preConcatenate(tx);\n        set(TRANSFORM,  t);\n      }\n    } else {\n      for (int i=0; i < coordinates.length; i++) {\n        tx.transform(coordinates[i], coordinates[i]);\n      }\n      if (get(FILL_GRADIENT) != null &&\n          ! get(FILL_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = FILL_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(FILL_GRADIENT,  g);\n      }\n      if (get(STROKE_GRADIENT) != null &&\n          ! get(STROKE_GRADIENT).isRelativeToFigureBounds()) {\n        Gradient g = STROKE_GRADIENT.getClone(this);\n        g.transform(tx);\n        set(STROKE_GRADIENT,  g);\n      }\n    }\n    invalidate();\n"
2205,SVGGroupFigure,SVGGroupFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGGroupFigure.java,40,41,1,/** Creates a new instance. */,2,  public SVGGroupFigure() {\n    SVGAttributeKeys.setDefaults(this);\n
2206,EditGridPanel,EditGridPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java,36,70,1,/** Creates new instance. */,33,"  public EditGridPanel() {\n    labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    initComponents();\n    widthField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 1000, 1));\n    heightField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 1000, 1));\n    thetaField.setFormatterFactory(JavaNumberFormatter.createFormatterFactory(0, 180, 1));\n    constrainer = new GridConstrainer(10, 10);\n    \n    widthField.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (evt.getPropertyName().equals(""value"")) {\n          if (evt.getNewValue() != null) {\n            constrainer.setWidth((Double) evt.getNewValue());\n          }\n        }\n      }\n    });\n    \n    heightField.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (evt.getPropertyName().equals(""value"")) {\n          if (evt.getNewValue() != null) {\n            constrainer.setHeight((Double) evt.getNewValue());\n          }\n        }\n      }\n    });\n    \n    thetaField.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        if (evt.getPropertyName().equals(""value"")) {\n          if (evt.getNewValue() != null) {\n            constrainer.setTheta((Double) evt.getNewValue() * Math.PI / 180d);\n"
2207,getConstrainer,EditGridPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java,95,96,5,/**\n   * Returns the GridConstrainer currently being edited by this panel.\n   * \n   * @return The GridConstrainer.\n   */,2,  public GridConstrainer getConstrainer() {\n    return constrainer;\n
2208,initComponents,EditGridPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java,105,158,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,46,"  private void initComponents() {\n    widthLabel = new javax.swing.JLabel();\n    heightLabel = new javax.swing.JLabel();\n    widthField = new org.jhotdraw.gui.JLifeFormattedTextField();\n    heightField = new org.jhotdraw.gui.JLifeFormattedTextField();\n    thetaLabel = new javax.swing.JLabel();\n    thetaField = new org.jhotdraw.gui.JLifeFormattedTextField();\n    widthLabel.setText(labels.getString(""view.grid.width.text"")); // NOI18N\n    heightLabel.setText(labels.getString(""view.grid.height.text"")); // NOI18N\n    widthField.setColumns(5);\n    heightField.setColumns(5);\n    thetaLabel.setText(labels.getString(""view.grid.theta.text"")); // NOI18N\n    thetaField.setColumns(5);\n    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n    this.setLayout(layout);\n    layout.setHorizontalGroup(\n      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n      .addGroup(layout.createSequentialGroup()\n        .addContainerGap()\n        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n          .addComponent(heightLabel, javax.swing.GroupLayout.Alignment.TRAILING)\n          .addComponent(widthLabel, javax.swing.GroupLayout.Alignment.TRAILING)\n          .addComponent(thetaLabel, javax.swing.GroupLayout.Alignment.TRAILING))\n        .addGap(4, 4, 4)\n        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n          .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n          .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n          .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n        .addContainerGap(67, Short.MAX_VALUE))\n    );\n    layout.setVerticalGroup(\n      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n      .addGroup(layout.createSequentialGroup()\n        .addContainerGap()\n        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n          .addComponent(widthLabel)\n          .addComponent(widthField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n          .addComponent(heightLabel)\n          .addComponent(heightField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n          .addComponent(thetaLabel)\n          .addComponent(thetaField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n"
2209,setConstrainer,EditGridPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditGridPanel.java,83,87,5,/**\n   * Sets the GridConstrainer to be edited by this panel.\n   * \n   * @param newValue The GridConstrainer.\n   */,5,  public void setConstrainer(GridConstrainer newValue) {\n    constrainer = newValue;\n    widthField.setValue(constrainer.getWidth());\n    heightField.setValue(constrainer.getHeight());\n    thetaField.setValue(constrainer.getTheta() * 180d / Math.PI);\n
2210,IncreaseHandleDetailLevelAction,IncreaseHandleDetailLevelAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/IncreaseHandleDetailLevelAction.java,28,30,1,/** Creates a new instance. */,3,"  public IncreaseHandleDetailLevelAction(DrawingEditor editor) {\n    super(editor);\n    labels.configureAction(this, ID);\n"
2211,EditorColorChooserAction,EditorColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java,42,43,1,/** Creates a new instance. */,2,"  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, Icon icon) {\n    this(editor, key, null, icon);\n"
2212,EditorColorChooserAction,EditorColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java,37,38,1,/** Creates a new instance. */,2,"  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key) {\n    this(editor, key, null, null);\n"
2213,EditorColorChooserAction,EditorColorChooserAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/EditorColorChooserAction.java,47,48,1,/** Creates a new instance. */,2,"  public EditorColorChooserAction(DrawingEditor editor, AttributeKey<Color> key, String name) {\n    this(editor, key, name, null);\n"
2214,GroupAction,GroupAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/GroupAction.java,39,40,1,/** Creates a new instance. */,2,"  public GroupAction(DrawingEditor editor) {\n    this(editor, new GroupFigure(), true);\n"
2215,FontChooserHandler,FontChooserHandler,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/FontChooserHandler.java,41,49,1,/** Creates a new instance. */,8,"  public FontChooserHandler(DrawingEditor editor, AttributeKey<Font> key, JFontChooser fontChooser, JPopupMenu popupMenu) {\n    super(editor);\n    this.key = key;\n    this.fontChooser = fontChooser;\n    this.popupMenu = popupMenu;\n    fontChooser.addActionListener(this);\n    fontChooser.addPropertyChangeListener(this);\n    updateEnabledState();\n"
2216,getBorderInsets,ImageBevelBorder,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java,112,113,4,/**\n   * Returns the insets of the border.\n   * @param c the component for which this border insets value applies\n   */,2,  public Insets getBorderInsets(Component c) {\n    return (Insets) borderInsets.clone();\n
2217,paintBorder,ImageBevelBorder,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java,127,246,10,/**\n   * Paints the bevel image for the specified component with the\n   * specified position and size.\n   * @param c the component for which this border is being painted\n   * @param gr the paint graphics\n   * @param x the x position of the painted border\n   * @param y the y position of the painted border\n   * @param width the width of the painted border\n   * @param height the height of the painted border\n   */,120,"  public void paintBorder(Component c, Graphics gr, int x, int y, int width, int height) {\n    if (image == null) return;\n    \n    // Cast Graphics to Graphics2D\n    Graphics2D g = (Graphics2D) gr;\n    \n    // Set some variables for easy access of insets and image size\n    int top = imageInsets.top;\n    int left = imageInsets.left;\n    int bottom = imageInsets.bottom;\n    int right = imageInsets.right;\n    int imgWidth = image.getWidth();\n    int imgHeight = image.getHeight();\n    \n    \n    // Optimisation: Draw image directly if it fits into the component\n    if (fillContentArea) {\n      if (width == imgWidth && height == imgHeight) {\n        g.drawImage(image, x, y, c);\n        return;\n      }\n    }\n    \n    // Optimisation: Remove insets, if image width or image height fits\n    if (width == imgWidth) {\n      left = imgWidth;\n      right = 0;\n    }\n    if (height == imgHeight) {\n      top = imgHeight;\n      bottom = 0;\n    }\n    \n    // Adjust insets if component is too small\n    if (width < left + right) {\n      left = Math.min(left, width / 2); //Math.max(0, left + (width - left - right) / 2);\n      right = width - left;\n    }\n    if (height < top + bottom) {\n      top = Math.min(top, height / 2); //Math.max(0, top + (height - top - bottom) / 2);\n      bottom = height - top;\n    }\n    \n    // Draw the Leads\n    if (top > 0 && left > 0) {\n      g.drawImage(\n      image,\n      x, y, x + left, y + top,\n      0, 0, left, top,\n      c\n      );\n    }\n    if (top > 0 && right > 0) {\n      //g.fillRect(x+width-right, y, x+width, y+top);\n      g.drawImage(\n      image,\n      x + width - right, y, x + width, y + top,\n      imgWidth - right, 0, imgWidth, top,\n      c\n      );\n    }\n    if (bottom > 0 && left > 0) {\n      g.drawImage(\n      image,\n      x, y + height - bottom, x + left, y + height,\n      0, imgHeight - bottom, left, imgHeight,\n      c\n      );\n    }\n    if (bottom > 0 && right > 0) {\n      g.drawImage(\n      image,\n      x + width - right, y + height - bottom, x + width, y + height,\n      imgWidth - right, imgHeight - bottom, imgWidth, imgHeight,\n      c\n      );\n    }\n    \n    // Draw the edges\n    BufferedImage subImg = null;\n    TexturePaint paint;\n    \n    // North\n    if (top > 0 && left + right < width) {\n      subImg = image.getSubimage(left, 0, imgWidth - right - left, top);\n      paint = new TexturePaint(subImg, new Rectangle(x+left, y, imgWidth - left - right, top));\n      g.setPaint(paint);\n      g.fillRect(x+left, y, width - left - right, top);\n    }\n    // South\n    if (bottom > 0 && left + right < width) {\n      subImg = image.getSubimage(left, imgHeight - bottom, imgWidth - right - left, bottom);\n      paint = new TexturePaint(subImg, new Rectangle(x+left, y + height - bottom, imgWidth - left - right, bottom));\n      g.setPaint(paint);\n      g.fillRect(x+left, y + height - bottom, width - left - right, bottom);\n    }\n    // West\n    if (left > 0 && top + bottom < height) {\n      subImg = image.getSubimage(0, top, left, imgHeight - top - bottom);\n      paint = new TexturePaint(subImg, new Rectangle(x, y+top, left, imgHeight - top - bottom));\n      g.setPaint(paint);\n      g.fillRect(x, y+top, left, height - top - bottom);\n    }\n    // East\n    if (right > 0 && top + bottom < height) {\n      subImg = image.getSubimage(imgWidth - right, top, right, imgHeight - top - bottom);\n      paint = new TexturePaint(subImg, new Rectangle(x+width-right, y + top, right, imgHeight - top - bottom));\n      g.setPaint(paint);\n      g.fillRect(x+width-right, y + top, right, height - top - bottom);\n    }\n    \n    // Fill the center\n    if (fillContentArea) {\n      g.setColor(Color.yellow);\n      if (left + right < width\n      && top + bottom < height) {\n        subImg = image.getSubimage(left, top, imgWidth - right - left, imgHeight - top - bottom);\n        paint = new TexturePaint(subImg, new Rectangle(x + left, y + top, imgWidth - right - left, imgHeight - top - bottom));\n        g.setPaint(paint);\n        g.fillRect(x+left, y + top, width - right - left, height - top - bottom);\n"
2218,ImageBevelBorder,ImageBevelBorder,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java,73,74,4,/**\n   * Creates a new instance with the given image and insets.\n   * The image has different insets than the border.\n   */,2,"  public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets) {\n    this(img, imageInsets, borderInsets, true);\n"
2219,ImageBevelBorder,ImageBevelBorder,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java,80,97,4,/**\n   * Creates a new instance with the given image and insets.\n   * The image has different insets than the border.\n   */,18,"  public ImageBevelBorder(Image img, Insets imageInsets, Insets borderInsets, boolean fillContentArea) {\n    if (img instanceof BufferedImage) {\n      this.image = (BufferedImage) img;\n    } else {\n      Frame f = new Frame();\n      f.pack();\n      MediaTracker t = new MediaTracker(f);\n      t.addImage(img, 0);\n      try { t.waitForAll(); } catch (InterruptedException e) {}\n      image = new BufferedImage(img.getWidth(f), img.getHeight(f), BufferedImage.TYPE_INT_ARGB);\n      Graphics2D imgGraphics = image.createGraphics();\n      imgGraphics.drawImage(img, 0, 0, f);\n      imgGraphics.dispose();\n      f.dispose();\n    }\n    this.imageInsets = imageInsets;\n    this.borderInsets = borderInsets;\n    this.fillContentArea = fillContentArea;\n"
2220,ImageBevelBorder,ImageBevelBorder,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java,65,66,4,/**\n   * Creates a new instance with the given image and insets.\n   * The image has the same insets as the border.\n   */,2,"  public ImageBevelBorder(Image img, Insets borderInsets) {\n    this(img, borderInsets, borderInsets, true);\n"
2221,isBorderOpaque,ImageBevelBorder,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/draw/action/ImageBevelBorder.java,104,105,4,/**\n   * Returns true if the border is opaque.\n   * This implementation always returns false.\n   */,2,  public boolean isBorderOpaque() {\n    return false;\n
2222,getRedoAction,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,200,201,3,/**\n   * Gets the redo action for use as a Redo menu item.\n   */,2,  public Action getRedoAction() {\n    return redoAction;\n
2223,UndoRedoManager,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,128,131,6,/** Creates new UndoRedoManager */\n --------------\n/**\n   * Redo Action for use in a menu bar.\n   */\n --------------,4,  public UndoRedoManager() {\n    getLabels();\n    undoAction = new UndoAction();\n    redoAction = new RedoAction();\n
2224,updateActions,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,209,232,4,/**\n   * Updates the properties of the UndoAction\n   * and of the RedoAction.\n   */,24,"  private void updateActions() {\n    String label;\n    if (DEBUG) System.out.println(""UndoRedoManager@""+hashCode()+"".updateActions ""+\n        editToBeUndone()\n        +"" canUndo=""+canUndo()+"" canRedo=""+canRedo());\n    if (canUndo()) {\n      undoAction.setEnabled(true);\n      label = getUndoPresentationName();\n    } else {\n      undoAction.setEnabled(false);\n      label = labels.getString(""edit.undo.text"");\n    }\n    undoAction.putValue(Action.NAME, label);\n    undoAction.putValue(Action.SHORT_DESCRIPTION, label);\n    \n    if (canRedo()) {\n      redoAction.setEnabled(true);\n      label = getRedoPresentationName();\n    } else {\n      redoAction.setEnabled(false);\n      label = labels.getString(""edit.redo.text"");\n    }\n    redoAction.putValue(Action.NAME, label);\n    redoAction.putValue(Action.SHORT_DESCRIPTION, label);\n"
2225,discardAllEdits,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,141,144,8,/**\n   * Discards all edits.\n   */\n --------------\n/**\n     * Invoked when an action occurs.\n     */\n --------------,4,  public void discardAllEdits() {\n    super.discardAllEdits();\n    updateActions();\n    setHasSignificantEdits(false);\n
2226,addEdit,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,177,188,16,"/**\n   * If inProgress, inserts anEdit at indexOfNextAdd, and removes\n   * any old edits that were at indexOfNextAdd or later. The die\n   * method is called on each edit that is removed is sent, in the\n   * reverse of the order the edits were added. Updates\n   * indexOfNextAdd.\n   *\n   * <p>If not inProgress, acts as a CompoundEdit</p>\n   *\n   * <p>Regardless of inProgress, if undoOrRedoInProgress,\n   * calls die on each edit that is sent.</p>\n   *\n   *\n   * @see CompoundEdit#end\n   * @see CompoundEdit#addEdit\n   */",12,"  public boolean addEdit(UndoableEdit anEdit) {\n    if (DEBUG) System.out.println(""UndoRedoManager@""+hashCode()+"".add ""+anEdit);\n    if (undoOrRedoInProgress) {\n      anEdit.die();\n      return true;\n    }\n    boolean success = super.addEdit(anEdit);\n    updateActions();\n    if (success && anEdit.isSignificant() && editToBeUndone() == anEdit) {\n      setHasSignificantEdits(true);\n    }\n    return success;\n"
2227,undo,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,240,247,5,"/**\n   * Undoes the last edit event.\n   * The UndoRedoManager ignores all incoming UndoableEdit events,\n   * while undo is in progress.\n   */",8,  public void undo()\n  throws CannotUndoException {\n    undoOrRedoInProgress = true;\n    try {\n      super.undo();\n    } finally {\n      undoOrRedoInProgress = false;\n      updateActions();\n
2228,hasSignificantEdits,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,157,158,4,/**\n   * Returns true if at least one significant UndoableEdit\n   * has been added since the last call to discardAllEdits.\n   */,2,  public boolean hasSignificantEdits() {\n    return hasSignificantEdits;\n
2229,getUndoAction,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,193,194,3,/**\n   * Gets the undo action for use as an Undo menu item.\n   */,2,  public Action getUndoAction() {\n    return undoAction;\n
2230,redo,UndoRedoManager,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/UndoRedoManager.java,256,263,5,"/**\n   * Redoes the last undone edit event.\n   * The UndoRedoManager ignores all incoming UndoableEdit events,\n   * while redo is in progress.\n   */",8,  public void redo()\n  throws CannotUndoException {\n    undoOrRedoInProgress = true;\n    try {\n      super.redo();\n    } finally {\n      undoOrRedoInProgress = false;\n      updateActions();\n
2231,CompositeEdit,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,66,67,7,/**\n   * Creates a new {@code CompositeEdit} which uses the specified significance.\n   * <p>\n   * The presentation name is used from CompoundEdit#getPresentationName().\n   *\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */,2,  public CompositeEdit(boolean isSignificant) {\n    this.isSignificant = isSignificant;\n
2232,addEdit,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,134,141,12,"/**\n   * If this edit is inProgress, accepts anEdit and returns\n   * true.\n   *\n   * <p>The last edit added to this CompositeEdit is given a\n   * chance to addEdit(anEdit). If it refuses (returns false), anEdit is\n   * given a chance to replaceEdit the last edit. If anEdit returns\n   * false here, it is added to edits.</p>\n   *\n   * <p>If the CompositeEdit is added to itself, then method end()\n   * is called, and true is returned.</p>\n   */",8,  public boolean addEdit(UndoableEdit anEdit) {\n    if (anEdit == this) {\n        end();\n      return true;\n    } else if (isInProgress() && (anEdit instanceof CompositeEdit)) {\n      return true;\n    } else {\n      return super.addEdit(anEdit);\n
2233,CompositeEdit,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,77,79,8,"/**\n   * Creates a new {@code CompositeEdit} which uses the specified\n   * presentation name.\n   * <p>\n   * If the presentation name is null, then CompoundEdit.getPresentatioName\n   * is used.\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */",3,  public CompositeEdit(String presentationName) {\n    this.presentationName = presentationName;\n    isSignificant = true;\n
2234,CompositeEdit,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,89,91,8,"/**\n   * Creates a new {@code CompositeEdit} which uses the given presentation name\n   * and significance.\n   * <p>\n   * If the presentation name is null, then CompoundEdit.getPresentatioName\n   * is used.\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */",3,"  public CompositeEdit(String presentationName, boolean isSignificant) {\n    this.presentationName = presentationName;\n    this.isSignificant = isSignificant;\n"
2235,getRedoPresentationName,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,118,119,6,"/**\n   * Returns the redo presentation name.\n   * If the presentation name is null, then CompoundEdit.getRedoPresentationName\n   * is returned.\n   * @see javax.swing.undo.CompoundEdit#getRedoPresentationName()\n   */",2,"  public String getRedoPresentationName() {\n    return ((presentationName != null) ? UndoRedoManager.getLabels().getString(""edit.redo.text"")+"" ""+presentationName : super.getRedoPresentationName());\n"
2236,getPresentationName,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,100,101,6,"/**\n   * Returns the presentation name.\n   * If the presentation name is null, then CompoundEdit.getPresentatioName\n   * is returned.\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */",2,  public String getPresentationName() {\n    return (presentationName != null) ? presentationName : super.getPresentationName();\n
2237,getUndoPresentationName,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,109,110,6,"/**\n   * Returns the undo presentation name.\n   * If the presentation name is null, then CompoundEdit.getUndoPresentationName\n   * is returned.\n   * @see javax.swing.undo.CompoundEdit#getUndoPresentationName()\n   */",2,"  public String getUndoPresentationName() {\n    return ((presentationName != null) ? UndoRedoManager.getLabels().getString(""edit.undo.text"")+"" ""+presentationName : super.getUndoPresentationName());\n"
2238,CompositeEdit,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,56,57,6,/**\n   * Creates a new {@code CompositeEdit} which uses CompoundEdit#getPresentationName()\n   * and is significant..\n   *\n   * @see javax.swing.undo.CompoundEdit#getPresentationName()\n   */,2,  public CompositeEdit() {\n    isSignificant = true;\n
2239,isSignificant,CompositeEdit,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/undo/CompositeEdit.java,150,151,5,"/**\n   * Returns false if this edit is insignificant - for example one\n   * that maintains the user's selection, but does not change\n   * any model state.\n   */",2,  public boolean isSignificant() {\n    return (isSignificant) ? super.isSignificant() : false;\n
2240,invokeGetter,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,188,198,8,"/**\n   * Invokes the specified getter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param defaultValue This value is returned, if the method does not exist.\n   * @return  The value returned by the getter method or the default value.\n   */",11,"  public static int invokeGetter(Object obj, String methodName, int defaultValue) {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);\n      Object result = method.invoke(obj, new Object[0]);\n      return ((Integer) result).intValue();\n    } catch (NoSuchMethodException e) {\n      return defaultValue;\n    } catch (IllegalAccessException e) {\n      return defaultValue;\n    } catch (InvocationTargetException e) {\n      return defaultValue;\n"
2241,invoke,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,327,336,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,10,"  public static Object invoke(Object obj, String methodName, float newValue)\n  throws NoSuchMethodException {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Float.TYPE} );\n      return method.invoke(obj, new Object[] { new Float(newValue)});\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2242,invoke,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,291,300,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,10,"  public static Object invoke(Object obj, String methodName, boolean newValue)\n  throws NoSuchMethodException {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Boolean.TYPE} );\n       return method.invoke(obj, new Object[] { new Boolean(newValue)});\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2243,invoke,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,309,318,6,/**\n   * Invokes the specified method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,10,"  public static Object invoke(Object obj, String methodName, int newValue)\n  throws NoSuchMethodException {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[] { Integer.TYPE} );\n      return method.invoke(obj, new Object[] { new Integer(newValue)});\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2244,invokeIfExists,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,409,412,6,/**\n   * Invokes the specified method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,4,"  public static void invokeIfExists(Object obj, String methodName, boolean newValue) {\n    try {\n       invoke(obj, methodName, newValue);\n    } catch (NoSuchMethodException e) {\n"
2245,invokeIfExists,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,396,399,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,4,"  public static void invokeIfExists(Object obj, String methodName, float newValue) {\n    try {\n      invoke(obj, methodName, newValue);\n    } catch (NoSuchMethodException e) {\n"
2246,invokeIfExists,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,383,386,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,4,"  public static void invokeIfExists(Object obj, String methodName) {\n    try {\n       invoke(obj, methodName);\n    } catch (NoSuchMethodException e) {\n"
2247,invoke,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,363,374,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,12,"  public static Object invoke(Object obj, String methodName, Class[] clazz, Object... newValue)\n  throws NoSuchMethodException {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  clazz );\n      return method.invoke(obj, newValue);\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      InternalError error = new InternalError(e.getMessage());\n      error.initCause((e.getCause() != null) ? e.getCause() : e);\n      throw error;\n"
2248,invokeStatic,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,169,176,11,/**\n   * Invokes the specified parameterless method if it exists.\n   *\n   * @param clazz The class on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param types The parameter types.\n   * @param values The parameter values.\n   * @param defaultValue The default value.\n   * @return The return value of the method or the default value if the method\n   * does not exist or is not accessible.\n   */,8,"  public static Object invokeStatic(String clazz, String methodName,\n  Class[] types, Object[] values, Object defaultValue) {\n    try {\n      return invokeStatic(Class.forName(clazz), methodName, types, values);\n    } catch (ClassNotFoundException e) {\n      return defaultValue;\n    } catch (NoSuchMethodException e) {\n      return defaultValue;\n"
2249,invokeGetter,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,251,261,8,"/**\n   * Invokes the specified getter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param defaultValue This value is returned, if the method does not exist.\n   * @return The value returned by the getter method or the default value.\n   */",11,"  public static Object invokeGetter(Object obj, String methodName, Object defaultValue) {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);\n      Object result = method.invoke(obj, new Object[0]);\n      return result;\n    } catch (NoSuchMethodException e) {\n      return defaultValue;\n    } catch (IllegalAccessException e) {\n      return defaultValue;\n    } catch (InvocationTargetException e) {\n      return defaultValue;\n"
2250,invokeStaticGetter,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,272,282,8,"/**\n   * Invokes the specified getter method if it exists.\n   *\n   * @param clazz The object on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param defaultValue This value is returned, if the method does not exist.\n   * @return The value returned by the getter method or the default value.\n   */",11,"  public static boolean invokeStaticGetter(Class clazz, String methodName, boolean defaultValue) {\n    try {\n      Method method =  clazz.getMethod(methodName,  new Class[0]);\n      Object result = method.invoke(null, new Object[0]);\n      return ((Boolean) result).booleanValue();\n    } catch (NoSuchMethodException e) {\n      return defaultValue;\n    } catch (IllegalAccessException e) {\n      return defaultValue;\n    } catch (InvocationTargetException e) {\n      return defaultValue;\n"
2251,invoke,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,65,75,9,/**\n   * Invokes the specified accessible method with a string parameter if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param stringParameter The String parameter\n   * @return The return value of the method or METHOD_NOT_FOUND.\n   * @return NoSuchMethodException if the method does not exist or is not accessible.\n   */,11,"  public static Object invoke(Object obj, String methodName, String stringParameter)\n  throws NoSuchMethodException {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[] { String.class });\n      Object result = method.invoke(obj, new Object[] { stringParameter });\n      return result;\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2252,invoke,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,43,53,9,/**\n   * Invokes the specified accessible parameterless method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   * @return The return value of the method.\n   * @return NoSuchMethodException if the method does not exist or is not\n   * accessible.\n   */,11,"  public static Object invoke(Object obj, String methodName)\n  throws NoSuchMethodException {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);\n      Object result = method.invoke(obj, new Object[0]);\n      return result;\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2253,invokeGetter,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,209,219,8,"/**\n   * Invokes the specified getter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param defaultValue This value is returned, if the method does not exist.\n   * @return  The value returned by the getter method or the default value.\n   */",11,"  public static long invokeGetter(Object obj, String methodName, long defaultValue) {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);\n      Object result = method.invoke(obj, new Object[0]);\n      return ((Long) result).longValue();\n    } catch (NoSuchMethodException e) {\n      return defaultValue;\n    } catch (IllegalAccessException e) {\n      return defaultValue;\n    } catch (InvocationTargetException e) {\n      return defaultValue;\n"
2254,invokeStatic,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,126,136,10,/**\n   * Invokes the specified parameterless method if it exists.\n   *\n   * @param clazz The class on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param types The parameter types.\n   * @param values The parameter values.\n   * @return The return value of the method.\n   * @return NoSuchMethodException if the method does not exist or is not accessible.\n   */,11,"  public static Object invokeStatic(Class clazz, String methodName, Class[] types, Object[] values)\n  throws NoSuchMethodException {\n    try {\n      Method method =  clazz.getMethod(methodName,  types);\n      Object result = method.invoke(null, values);\n      return result;\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2256,invokeIfExists,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,422,425,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,4,"  public static void invokeIfExists(Object obj, String methodName, Class clazz, Object newValue) {\n    try {\n       invoke(obj, methodName, clazz, newValue);\n    } catch (NoSuchMethodException e) {\n"
2257,invokeStatic,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,108,113,8,/**\n   * Invokes the specified accessible parameterless method if it exists.\n   *\n   * @param clazz The class on which to invoke the method.\n   * @param methodName The name of the method.\n   * @return The return value of the method.\n   * @return NoSuchMethodException if the method does not exist or is not accessible.\n   */,6,"  public static Object invokeStatic(String clazz, String methodName)\n  throws NoSuchMethodException {\n    try {\n      return invokeStatic(Class.forName(clazz), methodName);\n    } catch (ClassNotFoundException e) {\n      throw new NoSuchMethodException(""class ""+clazz+"" not found"");\n"
2258,invokeIfExistsWithEnum,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,436,448,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,13,"  public static void invokeIfExistsWithEnum(Object obj, String methodName, String enumClassName, String enumValueName) {\n    try {\n      Class enumClass = Class.forName(enumClassName);\n      Object enumValue = invokeStatic(""java.lang.Enum"", ""valueOf"", new Class[] {Class.class, String.class},\n          new Object[] {enumClass, enumValueName}\n      );\n      invoke(obj, methodName, enumClass, enumValue);\n    } catch (ClassNotFoundException e) {\n      // ignore\n      e.printStackTrace();\n    } catch (NoSuchMethodException e) {\n      // ignore\n      e.printStackTrace();\n"
2259,invoke,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,345,354,6,/**\n   * Invokes the specified setter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   */,10,"  public static Object invoke(Object obj, String methodName, Class clazz, Object newValue)\n  throws NoSuchMethodException {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[] { clazz } );\n      return method.invoke(obj, new Object[] { newValue});\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2260,invokeGetter,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,230,240,8,"/**\n   * Invokes the specified getter method if it exists.\n   *\n   * @param obj The object on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param defaultValue This value is returned, if the method does not exist.\n   * @return The value returned by the getter method or the default value.\n   */",11,"  public static boolean invokeGetter(Object obj, String methodName, boolean defaultValue) {\n    try {\n      Method method =  obj.getClass().getMethod(methodName,  new Class[0]);\n      Object result = method.invoke(obj, new Object[0]);\n      return ((Boolean) result).booleanValue();\n    } catch (NoSuchMethodException e) {\n      return defaultValue;\n    } catch (IllegalAccessException e) {\n      return defaultValue;\n    } catch (InvocationTargetException e) {\n      return defaultValue;\n"
2261,invokeStatic,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,149,155,10,/**\n   * Invokes the specified parameterless method if it exists.\n   *\n   * @param clazz The class on which to invoke the method.\n   * @param methodName The name of the method.\n   * @param types The parameter types.\n   * @param values The parameter values.\n   * @return The return value of the method.\n   * @return NoSuchMethodException if the method does not exist or is not accessible.\n   */,7,"  public static Object invokeStatic(String clazz, String methodName,\n  Class[] types, Object[] values)\n  throws NoSuchMethodException {\n    try {\n      return invokeStatic(Class.forName(clazz), methodName, types, values);\n    } catch (ClassNotFoundException e) {\n      throw new NoSuchMethodException(""class ""+clazz+"" not found"");\n"
2262,invokeStatic,Methods,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Methods.java,87,97,8,/**\n   * Invokes the specified accessible parameterless method if it exists.\n   *\n   * @param clazz The class on which to invoke the method.\n   * @param methodName The name of the method.\n   * @return The return value of the method or METHOD_NOT_FOUND.\n   * @return NoSuchMethodException if the method does not exist or is not accessible.\n   */,11,"  public static Object invokeStatic(Class clazz, String methodName)\n  throws NoSuchMethodException {\n    try {\n      Method method =  clazz.getMethod(methodName,  new Class[0]);\n      Object result = method.invoke(null, new Object[0]);\n      return result;\n    } catch (IllegalAccessException e) {\n      throw new NoSuchMethodException(methodName+"" is not accessible"");\n    } catch (InvocationTargetException e) {\n      // The method is not supposed to throw exceptions\n      throw new InternalError(e.getMessage());\n"
2264,split,Images,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Images.java,171,189,3,/**\n   * Splits an image into count subimages.\n   */,18,"  public static BufferedImage[] split(Image image, int count, boolean isHorizontal) {\n    BufferedImage src = Images.toBufferedImage(image);\n    if (count == 1) {\n      return new BufferedImage[]{src};\n    }\n    BufferedImage[] parts = new BufferedImage[count];\n    for (int i = 0; i < count; i++) {\n      if (isHorizontal) {\n        parts[i] = src.getSubimage(\n            src.getWidth() / count * i, 0,\n            src.getWidth() / count, src.getHeight());\n      } else {\n        parts[i] = src.getSubimage(\n            0, src.getHeight() / count * i,\n            src.getWidth(), src.getHeight() / count);\n      }\n    }\n    return parts;\n"
2265,toBufferedImage,Images,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Images.java,55,70,7,"/**\n   * Converts an Image to BufferedImage. If the Image is already a\n   * BufferedImage, the same image is returned.\n   * \n   * @param rImg An Image.\n   * @return A BufferedImage.\n   */",16,"  public static BufferedImage toBufferedImage(RenderedImage rImg) {\n    BufferedImage image;\n    if (rImg instanceof BufferedImage) {\n      image = (BufferedImage) rImg;\n    } else {\n      Raster r = rImg.getData();\n      WritableRaster wr = WritableRaster.createWritableRaster(\n          r.getSampleModel(), null);\n      rImg.copyData(wr);\n      image = new BufferedImage(\n          rImg.getColorModel(),\n          wr,\n          rImg.getColorModel().isAlphaPremultiplied(),\n          null);\n    }\n    return image;\n"
2266,hasAlpha,Images,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/Images.java,148,165,6,/**\n   * This method returns true if the specified image has transparent pixels\n   *\n   * Code taken from the Java Developers Almanac 1.4\n   * http://javaalmanac.com/egs/java.awt.image/HasAlpha.html\n   */,16,"  public static boolean hasAlpha(Image image) {\n    // If buffered image, the color model is readily available\n    if (image instanceof BufferedImage) {\n      BufferedImage bimage = (BufferedImage) image;\n      return bimage.getColorModel().hasAlpha();\n    }\n    // Use a pixel grabber to retrieve the image's color model;\n    // grabbing a single pixel is usually sufficient\n    PixelGrabber pg = new PixelGrabber(image, 0, 0, 1, 1, false);\n    try {\n      pg.grabPixels();\n    } catch (InterruptedException e) {\n    }\n    // Get the image's color model\n    ColorModel cm = pg.getColorModel();\n    return cm.hasAlpha();\n"
2270,ResourceBundleUtil,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,108,111,4,/**\n   * Creates a new ResouceBundleUtil which wraps\n   * the provided resource bundle.\n   */,4,"  public ResourceBundleUtil(String baseName, Locale locale) {\n    this.locale = locale;\n    this.baseName = baseName;\n    this.resource = ResourceBundle.getBundle(baseName, locale);\n"
2271,getMnemonic,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,309,311,8,/**\n   * Get a Mnemonic from the ResourceBundle.\n   * <br>Convenience method.\n   *\n   * @param key The key of the property.\n   * @return The first char of the value of the property.\n   *      Returns '\\0' if the property is missing.\n   */,3,  public char getMnemonic(String key) {\n    String s = getStringRecursive(key);\n    return (s == null || s.length() == 0) ? '\\0' : s.charAt(0);\n
2272,getString,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,130,141,8,/**\n   * Get a String from the ResourceBundle.\n   * <br>Convenience method to save casting.\n   *\n   * @param key The key of the property.\n   * @return The value of the property. Returns the key\n   *      if the property is missing.\n   */,12,"  public String getString(String key) {\n    try {\n      String value = getStringRecursive(key);\n      // System.out.println(""ResourceBundleUtil ""+baseName+"" get(""+key+""):""+value);\n      return value;\n    } catch (MissingResourceException e) {\n      // System.out.println(""ResourceBundleUtil ""+baseName+"" get(""+key+""):***MISSING***"");\n      if (isVerbose) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""] \\"""" + key + ""\\"" not found."");\n        //e.printStackTrace();\n      }\n      return key;\n"
2273,getAcceleratorProperty,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,402,415,8,"/**\n   * Gets a KeyStroke for a JavaBeans ""accelerator"" property from the ResourceBundle.\n   * <BR>Convenience method.\n   *\n   * @param key The key of the property. This method adds "".accelerator"" to the key.\n   * @return <code>javax.swing.KeyStroke.getKeyStroke(value)</code>.\n   *      Returns null if the property is missing.\n   */",14,"  public KeyStroke getAcceleratorProperty(String key) {\n    KeyStroke ks = null;\n    try {\n      String s;\n      s = getStringRecursive(key + "".accelerator"");\n      ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);\n    } catch (MissingResourceException e) {\n      if (isVerbose) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""] \\"""" + key + "".accelerator\\"" not found."");\n        //e.printStackTrace();\n      }\n    } catch (NoSuchElementException e) {\n    }\n    return ks;\n"
2274,removePropertyNameModifier,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,533,534,3,/**\n   * Removes a property name modifier.\n   */,2,  public static void removePropertyNameModifier(String name) {\n    propertyNameModifiers.remove(name);\n
2275,getMnemonicProperty,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,322,333,8,"/**\n   * Gets a char for a JavaBeans ""mnemonic"" property from the ResourceBundle.\n   * <br>Convenience method.\n   *\n   * @param key The key of the property. This method appends "".mnemonic"" to the key.\n   * @return The first char of the value of the property.\n   *      Returns \'\\0\' if the property is missing.\n   */",12,"  public char getMnemonicProperty(String key) {\n    String s;\n    try {\n      s = getStringRecursive(key + "".mnemonic"");\n    } catch (MissingResourceException e) {\n      if (isVerbose) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""] \\"""" + key + "".mnemonic\\"" not found."");\n        //e.printStackTrace();\n      }\n      s = null;\n    }\n    return (s == null || s.length() == 0) ? \'\\0\' : s.charAt(0);\n"
2276,putPropertyNameModifier,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,526,527,6,/**\n   * Puts a property name modifier along with a fallback chain.\n   *\n   * @param name The name of the modifier.\n   * @param fallbackChain The fallback chain of the modifier.\n   */,2,"  public static void putPropertyNameModifier(String name, String... fallbackChain) {\n    propertyNameModifiers.put(name, fallbackChain);\n"
2277,getIconProperty,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,279,297,8,"/**\n   * Get an image icon from the ResourceBundle.\n   * <br>Convenience method .\n   *\n   * @param key The key of the property. This method appends "".icon"" to the key.\n   * @return The value of the property. Returns null\n   *      if the property is missing.\n   */",17,"  public ImageIcon getIconProperty(String key, Class baseClass) {\n    try {\n      String rsrcName = getStringRecursive(key + "".icon"");\n      if (rsrcName.equals("""")) {\n        return null;\n      }\n      URL url = baseClass.getResource(rsrcName);\n      if (isVerbose && url == null) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""].getIconProperty \\"""" + key + "".icon\\"" resource:"" + rsrcName + "" not found."");\n      }\n      return (url == null) ? null : new ImageIcon(url);\n    } catch (MissingResourceException e) {\n      if (isVerbose) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""].getIconProperty \\"""" + key + "".icon\\"" not found."");\n        //e.printStackTrace();\n      }\n      return null;\n"
2278,format,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,246,248,6,/**\n   * Returns a formatted string using java.util.Formatter().\n   * @param key\n   * @param arguments\n   * @return formatted String\n   */,3,"  public String format(String key, Object... arguments) {\n    //return String.format(resource.getLocale(), getString(key), arguments);\n    return new Formatter(resource.getLocale()).format(getString(key), arguments).toString();\n"
2279,getBundle,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,423,425,5,/**\n   * Get the appropriate ResourceBundle subclass.\n   *\n   * @see java.util.ResourceBundle\n   */,3,"  public static ResourceBundleUtil getBundle(String baseName)\n      throws MissingResourceException {\n    return getBundle(baseName, LocaleUtil.getDefault());\n"
2280,getBundle,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,500,504,5,/**\n   * Get the appropriate ResourceBundle subclass.\n   *\n   * @see java.util.ResourceBundle\n   */,5,"  public static ResourceBundleUtil getBundle(String baseName, Locale locale)\n      throws MissingResourceException {\n    ResourceBundleUtil r;\n    r = new ResourceBundleUtil(baseName, locale);\n    return r;\n"
2281,getWrappedBundle,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,118,119,4,/**\n   * Returns the wrapped resource bundle.\n   * @return The wrapped resource bundle.\n   */,2,  public ResourceBundle getWrappedBundle() {\n    return resource;\n
2282,getToolTipTextProperty,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,343,352,7,"/**\n   * Get a String for a JavaBeans ""toolTipText"" property from the ResourceBundle.\n   * <br>Convenience method.\n   *\n   * @param key The key of the property. This method appends "".toolTipText"" to the key.\n   * @return The ToolTip. Returns null if no tooltip is defined.\n   */",10,"  public String getToolTipTextProperty(String key) {\n    try {\n      String value = getStringRecursive(key + "".toolTipText"");\n      return value;\n    } catch (MissingResourceException e) {\n      if (isVerbose) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""] \\"""" + key + "".toolTipText\\"" not found."");\n        //e.printStackTrace();\n      }\n      return null;\n"
2283,getTextProperty,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,363,372,7,"/**\n   * Get a String for a JavaBeans ""text"" property from the ResourceBundle.\n   * <br>Convenience method.\n   *\n   * @param key The key of the property. This method appends "".text"" to the key.\n   * @return The ToolTip. Returns null if no tooltip is defined.\n   */",10,"  public String getTextProperty(String key) {\n    try {\n      String value = getStringRecursive(key + "".text"");\n      return value;\n    } catch (MissingResourceException e) {\n      if (isVerbose) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""] \\"""" + key + "".text\\"" not found."");\n        //e.printStackTrace();\n      }\n      return null;\n"
2284,initComponents,ODGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanel.java,190,223,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,26,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    toolButtonGroup = new javax.swing.ButtonGroup();\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    jPanel1 = new javax.swing.JPanel();\n    creationToolbar = new javax.swing.JToolBar();\n    attributesToolbar = new javax.swing.JToolBar();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n    jPanel1.setLayout(new java.awt.GridBagLayout());\n    creationToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 0;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(creationToolbar, gridBagConstraints);\n    attributesToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(attributesToolbar, gridBagConstraints);\n    add(jPanel1, java.awt.BorderLayout.SOUTH);\n"
2285,getStringRecursive,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,151,203,6,/**\n   * Recursive part of the getString method.\n   *\n   * @param key\n   * @throws java.util.MissingResourceException\n   */,47,"  private String getStringRecursive(String key) throws MissingResourceException {\n    String value = resource.getString(key);\n    // Substitute placeholders in the value\n    for (int p1 = value.indexOf(""${""); p1 != -1; p1 = value.indexOf(""${"")) {\n      int p2 = value.indexOf(\'}\', p1 + 2);\n      if (p2 == -1) {\n        break;\n      }\n      String placeholderKey = value.substring(p1 + 2, p2);\n      String placeholderFormat;\n      int p3 = placeholderKey.indexOf(\',\');\n      if (p3 != -1) {\n        placeholderFormat = placeholderKey.substring(p3 + 1);\n        placeholderKey = placeholderKey.substring(0, p3);\n      } else {\n        placeholderFormat = ""string"";\n      }\n      ArrayList<String> fallbackKeys = new ArrayList<String>();\n      generateFallbackKeys(placeholderKey, fallbackKeys);\n      String placeholderValue = null;\n      for (String fk : fallbackKeys) {\n        try {\n          placeholderValue = getStringRecursive(fk);\n          break;\n        } catch (MissingResourceException e) {\n        }\n      }\n      if (placeholderValue == null) {\n        throw new MissingResourceException(""\\""""+key+""\\"" not found in ""+baseName, baseName, key);\n      }\n      // Do post-processing depending on placeholder format \n      if (placeholderFormat.equals(""accelerator"")) {\n        // Localize the keywords shift, control, ctrl, meta, alt, altGraph\n        StringBuilder b = new StringBuilder();\n        for (String s : placeholderValue.split("" "")) {\n          if (acceleratorKeys.contains(s)) {\n            b.append(getString(""accelerator."" + s));\n          } else {\n            b.append(s);\n          }\n        }\n        placeholderValue = b.toString();\n      }\n      // Insert placeholder value into value\n      value = value.substring(0, p1) + placeholderValue + value.substring(p2 + 1);\n    }\n    return value;\n"
2286,getKeyStroke,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,384,391,8,/**\n   * Get a KeyStroke from the ResourceBundle.\n   * <BR>Convenience method.\n   *\n   * @param key The key of the property.\n   * @return <code>javax.swing.KeyStroke.getKeyStroke(value)</code>.\n   *      Returns null if the property is missing.\n   */,8,  public KeyStroke getKeyStroke(String key) {\n    KeyStroke ks = null;\n    try {\n      String s = getStringRecursive(key);\n      ks = (s == null) ? (KeyStroke) null : KeyStroke.getKeyStroke(s);\n    } catch (NoSuchElementException e) {\n    }\n    return ks;\n
2287,readObject,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,538,542,1,/** Read object from ObjectInputStream and re-establish ResourceBundle. */,5,"  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // our ""pseudo-constructor""\n    in.defaultReadObject();\n    // re-establish the ""resource"" variable\n    this.resource = ResourceBundle.getBundle(baseName, locale);\n"
2288,generateFallbackKeys,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,210,225,4,/**\n   * Generates fallback keys by processing all property name modifiers\n   * in the key.\n   */,16,"  private void generateFallbackKeys(String key, ArrayList<String> fallbackKeys) {\n    int p1 = key.indexOf(""[$"");\n    if (p1 == -1) {\n      fallbackKeys.add(key);\n    } else {\n      int p2 = key.indexOf(\']\', p1 + 2);\n      if (p2 == -1) {\n        return;\n      }\n      String modifierKey = key.substring(p1 + 2, p2);\n      String[] modifierValues = propertyNameModifiers.get(modifierKey);\n      if (modifierValues == null) {\n        modifierValues = new String[]{""default""};\n      }\n      for (String mv : modifierValues) {\n        generateFallbackKeys(key.substring(0, p1) + mv + key.substring(p2 + 1), fallbackKeys);\n"
2289,ODGDrawingPanel,ODGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanel.java,51,116,1,/** Creates new instance. */,66,"  public ODGDrawingPanel() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    initComponents();\n    undoManager = new UndoRedoManager();\n    editor = new DefaultDrawingEditor();\n    editor.add(view);\n    \n    addCreationButtonsTo(creationToolbar, editor);\n    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);\n    \n    JPopupButton pb = new JPopupButton();\n    pb.setItemFont(UIManager.getFont(""MenuItem.font""));\n    labels.configureToolBarButton(pb, ""actions"");\n    pb.add(new DuplicateAction());\n    pb.addSeparator();\n    pb.add(new GroupAction(editor));\n    pb.add(new UngroupAction(editor));\n    pb.addSeparator();\n    pb.add(new BringToFrontAction(editor));\n    pb.add(new SendToBackAction(editor));\n    pb.addSeparator();\n    pb.add(new CutAction());\n    pb.add(new CopyAction());\n    pb.add(new PasteAction());\n    pb.add(new SelectAllAction());\n    pb.add(new SelectSameAction(editor));\n    pb.addSeparator();\n    pb.add(undoManager.getUndoAction());\n    pb.add(undoManager.getRedoAction());\n     // FIXME - We need a toggle grid action\n     // pb.addSeparator();\n     // pb.add(new ToggleGridAction(editor));\n    \n    JMenu m = new JMenu(labels.getString(""view.zoomFactor.text""));\n    JRadioButtonMenuItem rbmi;\n    ButtonGroup group = new ButtonGroup();\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));\n    rbmi.setSelected(true);\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));\n    group.add(rbmi);\n    pb.add(m);\n    pb.setFocusable(false);\n    creationToolbar.addSeparator();\n    creationToolbar.add(pb);\n    \n    \n    DefaultDrawing drawing = new DefaultDrawing();\n    view.setDrawing(drawing);\n    drawing.addUndoableEditListener(undoManager);\n"
2290,getInteger,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,259,267,8,/**\n   * Get an Integer from the ResourceBundle.\n   * <br>Convenience method to save casting.\n   *\n   * @param key The key of the property.\n   * @return The value of the property. Returns -1\n   *      if the property is missing.\n   */,9,"  public Integer getInteger(String key) {\n    try {\n      return Integer.valueOf(getStringRecursive(key));\n    } catch (MissingResourceException e) {\n      if (isVerbose) {\n        System.err.println(""Warning ResourceBundleUtil["" + baseName + ""] \\"""" + key + ""\\"" not found."");\n        //e.printStackTrace();\n      }\n      return new Integer(-1);\n"
2291,getFormatted,ResourceBundleUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/ResourceBundleUtil.java,236,237,6,/**\n   * Returns a formatted string using javax.text.MessageFormat.\n   * @param key\n   * @param arguments\n   * @return formatted String\n   */,2,"  public String getFormatted(String key, Object... arguments) {\n    return MessageFormat.format(getString(key), arguments);\n"
2293,createToolBars,ODGApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java,175,200,3,/**\n   * Creates toolbars for the application.\n   */,24,"  public java.util.List<JToolBar> createToolBars(Application a, View pr) {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    ODGView p = (ODGView) pr;\n    DrawingEditor editor;\n    if (p == null) {\n      editor = getSharedEditor();\n    } else {\n      editor = p.getEditor();\n    }\n    LinkedList<JToolBar> list = new LinkedList<JToolBar>();\n    JToolBar tb;\n    tb = new JToolBar();\n    addCreationButtonsTo(tb, editor);\n    tb.setName(labels.getString(""window.drawToolBar.title""));\n    list.add(tb);\n    tb = new JToolBar();\n    addAttributesButtonsTo(tb, editor);\n    tb.setName(labels.getString(""window.attributesToolBar.title""));\n    list.add(tb);\n    tb = new JToolBar();\n    ButtonFactory.addAlignmentButtonsTo(tb, editor);\n    tb.setName(labels.getString(""window.alignmentToolBar.title""));\n    list.add(tb);\n    return list;\n"
2294,addAttributesButtonsTo,ODGApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java,130,144,3,/**\n   * Creates toolbar buttons and adds them to the specified JToolBar\n   */,13,"  private void addAttributesButtonsTo(JToolBar bar, DrawingEditor editor) {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    JButton b;\n    b = bar.add(new PickAttributesAction(editor));\n    b.setFocusable(false);\n    b = bar.add(new ApplyAttributesAction(editor));\n    b.setFocusable(false);\n    bar.addSeparator();\n    addColorButtonsTo(bar, editor);\n    bar.addSeparator();\n    addStrokeButtonsTo(bar, editor);\n    bar.addSeparator();\n    ButtonFactory.addFontButtonsTo(bar, editor);\n"
2295,ODGApplicationModel,ODGApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGApplicationModel.java,64,65,1,/** Creates a new instance. */,2,  public ODGApplicationModel() {\n    setViewClass(ODGView.class);\n
2296,NodeFigure,NodeFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/figures/NodeFigure.java,47,54,1,/** Creates a new instance. */,8,"  public NodeFigure() {\n    RectangleFigure rf = new RectangleFigure();\n    setDecorator(rf);\n    createConnectors();\n    set(DECORATOR_INSETS, new Insets2D.Double(6, 10, 6, 10));\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.net.Labels"");\n    setText(labels.getString(""nodeDefaultName""));\n    setAttributeEnabled(DECORATOR_INSETS, false);\n"
2300,userNodeForPackage,PreferencesUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java,245,259,5,"/** Gets the user node for the package of the class if\n   * permitted, gets a proxy otherwise.\n   *\n   * @return user node or a proxy.\n   */",14,"  public static Preferences userNodeForPackage(Class<?> c) {\n    if (userNodes != null) {\n      if (!userNodes.containsKey(c.getPackage())) {\n        userNodes.put(c.getPackage(), new PreferencesUtil(false));\n      }\n      return userNodes.get(c.getPackage());\n    }\n    try {\n      return Preferences.userNodeForPackage(c);\n    } catch (Throwable t) {\n      if (userNodes == null) {\n        userNodes = new HashMap<Package, Preferences>();\n      }\n      return userNodeForPackage(c);\n"
2305,systemNodeForPackage,PreferencesUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java,221,236,5,"/** Gets the system node for the package of the class if\n   * permitted, gets a proxy otherwise.\n   *\n   * @return system node or a proxy.\n   */",15,"  public static Preferences systemNodeForPackage(Class<?> c) {\n    if (systemNodes != null) {\n      if (!systemNodes.containsKey(c.getPackage())) {\n        systemNodes.put(c.getPackage(), new PreferencesUtil(false));\n      }\n      return systemNodes.get(c.getPackage());\n    }\n\n    try {\n      return Preferences.systemNodeForPackage(c);\n    } catch (Throwable t) {\n      if (systemNodes == null) {\n        systemNodes = new HashMap<Package, Preferences>();\n      }\n      return systemNodeForPackage(c);\n"
2306,installToolBarPrefsHandler,PreferencesUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java,482,483,9,"/**\n   * Installs a toolbar preferences handler.\n   * On first run, sets the toolbar to BorderLayout.TOP.\n   * On subsequent runs, set the toolbar to the last BorderLayout location.\n   *\n   * @param prefs Preferences for storing/retrieving preferences values.\n   * @param name Base name of the preference.\n   * @param toolbar The JToolBar for which to track preferences.\n   */",2,"  public static void installToolBarPrefsHandler(final Preferences prefs, final String name, JToolBar toolbar) {\n    new ToolBarPrefsHandler(toolbar, name, prefs);\n"
2307,installPalettePrefsHandler,PreferencesUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java,367,368,11,"/**\n   * Installs a palette preferences handler.\n   * On first run, sets the palette to its preferred location at the top left\n   * corner of the screen.\n   * On subsequent runs, sets the palette the last location where\n   * the user had placed it before.\n   *\n   * @param prefs Preferences for storing/retrieving preferences values.\n   * @param name Base name of the preference.\n   * @param window The window for which to track preferences.\n   */",2,"  public static void installPalettePrefsHandler(final Preferences prefs, final String name, Window window) {\n    installPalettePrefsHandler(prefs, name, window, 0);\n"
2308,installInternalFramePrefsHandler,PreferencesUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java,432,467,11,"/**\n   * Installs an intenal frame preferences handler.\n   * On first run, sets the frame to its preferred size at the top left\n   * corner of the desktop pane.\n   * On subsequent runs, sets the frame the last size and location where\n   * the user had placed it before.\n   *\n   * @param prefs Preferences for storing/retrieving preferences values.\n   * @param name Base name of the preference.\n   * @param window The window for which to track preferences.\n   */",29,"  public static void installInternalFramePrefsHandler(final Preferences prefs, final String name, JInternalFrame window, JDesktopPane desktop) {\n    Rectangle screenBounds = desktop.getBounds();\n    screenBounds.setLocation(0, 0);\n    Insets screenInsets = desktop.getInsets();\n    screenBounds.x += screenInsets.left;\n    screenBounds.y += screenInsets.top;\n    screenBounds.width -= screenInsets.left + screenInsets.right;\n    screenBounds.height -= screenInsets.top + screenInsets.bottom;\n    Dimension preferredSize = window.getPreferredSize();\n    Dimension minSize = window.getMinimumSize();\n    Rectangle bounds = new Rectangle(\n        prefs.getInt(name + "".x"", 0),\n        prefs.getInt(name + "".y"", 0),\n        Math.max(minSize.width, prefs.getInt(name + "".width"", preferredSize.width)),\n        Math.max(minSize.height, prefs.getInt(name + "".height"", preferredSize.height)));\n    if (!screenBounds.contains(bounds)) {\n      bounds.x = screenBounds.x + (screenBounds.width - bounds.width) / 2;\n      bounds.y = screenBounds.y + (screenBounds.height - bounds.height) / 2;\n      Rectangle.intersect(screenBounds, bounds, bounds);\n    }\n    window.setBounds(bounds);\n    window.addComponentListener(new ComponentAdapter() {\n      public void componentMoved(ComponentEvent evt) {\n        prefs.putInt(name + "".x"", evt.getComponent().getX());\n        prefs.putInt(name + "".y"", evt.getComponent().getY());\n      }\n      public void componentResized(ComponentEvent evt) {\n        prefs.putInt(name + "".width"", evt.getComponent().getWidth());\n        prefs.putInt(name + "".height"", evt.getComponent().getHeight());\n"
2311,installFramePrefsHandler,PreferencesUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java,285,286,14,"/**\n   * Installs a frame preferences handler.\n   * On first run, sets the window to its preferred size at the top left\n   * corner of the screen.\n   * On subsequent runs, sets the window the last size and location where\n   * the user had placed it before.\n   * <p>\n   * If no preferences are stored yet for this window, a default size\n   * of 400 x 300 pixels is used.\n   *\n   * @param prefs Preferences for storing/retrieving preferences values.\n   * @param name Base name of the preference.\n   * @param window The window for which to track preferences.\n   */",2,"  public static void installFramePrefsHandler(final Preferences prefs, final String name, Window window) {\n    installFramePrefsHandler(prefs, name, window, new Dimension(400, 300));\n"
2312,clear,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,239,253,3,/**\n   * Clears the view.\n   */,15,  public void clear() {\n    final Drawing newDrawing = createDrawing();\n    try {\n      SwingUtilities.invokeAndWait(new Runnable() {\n        public void run() {\n          view.getDrawing().removeUndoableEditListener(undo);\n          view.setDrawing(newDrawing);\n          view.getDrawing().addUndoableEditListener(undo);\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InvocationTargetException ex) {\n      ex.printStackTrace();\n    } catch (InterruptedException ex) {\n      ex.printStackTrace();\n
2313,initActions,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,173,175,3,/**\n   * Initializes view specific actions.\n   */,3,"  private void initActions() {\n    getActionMap().put(UndoAction.ID, undo.getUndoAction());\n    getActionMap().put(RedoAction.ID, undo.getRedoAction());\n"
2314,installFramePrefsHandler,PreferencesUtil,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/util/prefs/PreferencesUtil.java,302,350,13,"/**\n   * Installs a frame preferences handler.\n   * On first run, sets the window to its preferred size at the top left\n   * corner of the screen.\n   * On subsequent runs, sets the window the last size and location where\n   * the user had placed it before.\n   *\n   * @param prefs Preferences for storing/retrieving preferences values.\n   * @param name Base name of the preference.\n   * @param window The window for which to track preferences.\n   * @param defaultSize This size is used when no prefences are stored yet for this window.\n   *\n   */",44,"  public static void installFramePrefsHandler(final Preferences prefs, final String name, Window window, Dimension defaultSize) {\n    GraphicsConfiguration conf = window.getGraphicsConfiguration();\n    Rectangle screenBounds = conf.getBounds();\n    Insets screenInsets = window.getToolkit().getScreenInsets(conf);\n    screenBounds.x += screenInsets.left;\n    screenBounds.y += screenInsets.top;\n    screenBounds.width -= screenInsets.left + screenInsets.right;\n    screenBounds.height -= screenInsets.top + screenInsets.bottom;\n    window.pack();\n    Dimension preferredSize = window.getPreferredSize();\n    boolean resizable = true;\n    if (window instanceof Frame) {\n      resizable = ((Frame) window).isResizable();\n    } else if (window instanceof Dialog) {\n      resizable = ((Dialog) window).isResizable();\n    }\n    Rectangle bounds;\n    if (resizable) {\n      bounds = new Rectangle(\n          prefs.getInt(name + "".x"", 0),\n          prefs.getInt(name + "".y"", 0),\n          Math.max(defaultSize.width, prefs.getInt(name + "".width"", preferredSize.width)),\n          Math.max(defaultSize.height, prefs.getInt(name + "".height"", preferredSize.height)));\n    } else {\n      bounds = new Rectangle(\n          prefs.getInt(name + "".x"", 0),\n          prefs.getInt(name + "".y"", 0),\n          window.getWidth(), window.getHeight());\n    }\n    if (!screenBounds.contains(bounds)) {\n      bounds.x = screenBounds.x + (screenBounds.width - bounds.width) / 2;\n      bounds.y = screenBounds.y + (screenBounds.height - bounds.height) / 2;\n      Rectangle.intersect(screenBounds, bounds, bounds);\n    }\n    window.setBounds(bounds);\n    window.addComponentListener(\n        new ComponentAdapter() {\n          public void componentMoved(ComponentEvent evt) {\n            prefs.putInt(name + "".x"", evt.getComponent().getX());\n            prefs.putInt(name + "".y"", evt.getComponent().getY());\n          }\n          public void componentResized(ComponentEvent evt) {\n            prefs.putInt(name + "".width"", evt.getComponent().getWidth());\n            prefs.putInt(name + "".height"", evt.getComponent().getHeight());\n"
2315,read,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,194,212,3,/**\n   * Reads the view from the specified uri.\n   */,19,"  public void read(URI f, URIChooser chooser) throws IOException {\n    try {\n      final Drawing drawing = createDrawing();\n      InputFormat inputFormat = drawing.getInputFormats().get(0);\n      inputFormat.read(new File(f), drawing, true);\n      SwingUtilities.invokeAndWait(new Runnable() { public void run() {\n        view.getDrawing().removeUndoableEditListener(undo);\n        view.setDrawing(drawing);\n        view.getDrawing().addUndoableEditListener(undo);\n        undo.discardAllEdits();\n      }});\n    } catch (InterruptedException e) {\n      InternalError error = new InternalError();\n      e.initCause(e);\n      throw error;\n    } catch (InvocationTargetException e) {\n      InternalError error = new InternalError();\n      e.initCause(e);\n      throw error;\n"
2316,write,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,185,188,3,/**\n   * Writes the view to the specified uri.\n   */,4,"  public void write(URI f, URIChooser chooser) throws IOException {\n      Drawing drawing = view.getDrawing();\n      OutputFormat outputFormat = drawing.getOutputFormats().get(0);\n      outputFormat.write(new File(f), drawing);\n"
2317,NetView,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,71,114,3,/**\n   * Creates a new view.\n   */,44,"  public NetView() {\n    initComponents();\n    \n    JPanel zoomButtonPanel = new JPanel(new BorderLayout());\n    scrollPane.setLayout(new PlacardScrollPaneLayout());\n    scrollPane.setBorder(new EmptyBorder(0,0,0,0));\n    \n    setEditor(new DefaultDrawingEditor());\n    undo = new UndoRedoManager();\n    view.setDrawing(createDrawing());\n    view.getDrawing().addUndoableEditListener(undo);\n    initActions();\n    undo.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        setHasUnsavedChanges(undo.hasSignificantEdits());\n      }\n    });\n    \n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    \n    JPanel placardPanel = new JPanel(new BorderLayout());\n    javax.swing.AbstractButton pButton;\n    pButton = ButtonFactory.createZoomButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"",""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"",new Insets(0,0,0,0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    placardPanel.add(pButton, BorderLayout.WEST);\n    toggleGridButton = pButton = ButtonFactory.createToggleGridButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"",""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"",new Insets(0,0,0,0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    labels.configureToolBarButton(pButton, ""view.toggleGrid.placard"");\n    placardPanel.add(pButton, BorderLayout.EAST);\n    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);\n    \n    toggleGridButton.setSelected(preferences.getBoolean(""view.gridVisible"", false));\n    view.setScaleFactor(preferences.getDouble(""view.scaleFactor"", 1d));\n    \n    view.addPropertyChangeListener(new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        String name = evt.getPropertyName();\n        if (name.equals(""scaleFactor"")) {\n          preferences.putDouble(""view.scaleFactor"", (Double) evt.getNewValue());\n          firePropertyChange(""scaleFactor"", evt.getOldValue(), evt.getNewValue());\n"
2318,createPageable,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,145,146,3,/**\n   * Creates a Pageable object for printing the view.\n   */,2,  public Pageable createPageable() {\n    return new DrawingPageable(view.getDrawing());\n
2319,initComponents,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,268,279,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,8,"  private void initComponents() {\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n"
2320,setDrawingEditor,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,219,225,3,/**\n   * Sets a drawing editor for the view.\n   */,7,  public void setDrawingEditor(DrawingEditor newValue) {\n    if (editor != null) {\n      editor.remove(view);\n    }\n    editor = newValue;\n    if (editor != null) {\n      editor.add(view);\n
2321,createDrawing,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,132,140,3,/**\n   * Creates a new Drawing for this view.\n   */,9,  protected Drawing createDrawing() {\n    DefaultDrawing drawing = new DefaultDrawing();\n    DOMStorableInputOutputFormat ioFormat =\n        new DOMStorableInputOutputFormat(new NetFactory());\n    drawing.addInputFormat(ioFormat);\n    drawing.addInputFormat(new TextInputFormat(new NodeFigure()));\n    drawing.addOutputFormat(ioFormat);\n    drawing.addOutputFormat(new ImageOutputFormat());\n    return drawing;\n
2322,getDrawingEditor,NetView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/net/NetView.java,232,233,3,/**\n   * Gets the drawing editor of the view.\n   */,2,  public DrawingEditor getDrawingEditor() {\n    return editor;\n
2324,getDefaultPropertyIndex,FontToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2325,getMethodDescriptors,FontToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2326,getPropertyDescriptors,FontToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2327,getBeanDescriptor,FontToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2329,getEventSetDescriptors,FontToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2332,getDefaultEventIndex,FontToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2333,getMethodDescriptors,ODGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java,121,122,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2334,getPropertyDescriptors,ODGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java,99,100,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2340,getBeanDescriptor,ODGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java,83,84,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2343,getDefaultEventIndex,ODGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java,144,145,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2344,getDefaultPropertyIndex,ODGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java,133,134,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2345,getEventSetDescriptors,ODGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGDrawingPanelBeanInfo.java,110,111,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2346,getStrokePaint,ODGAttributeKeys,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java,119,132,5,"/**\n   * Gets the stroke paint for the specified figure based on the attributes\n   * STROKE_GRADIENT, STROKE_OPACITY, STROKE_PAINT and the bounds of the figure.\n   * Returns null if the figure is not filled.\n   */",14,"  public static Paint getStrokePaint(Figure f) {\n    double opacity = f.get(STROKE_OPACITY);\n    if (f.get(STROKE_GRADIENT) != null) {\n      return f.get(STROKE_GRADIENT).getPaint(f, opacity);\n    }\n    Color color = f.get(STROKE_COLOR);\n    if (color != null) {\n      if (opacity != 1) {\n        color = new Color(\n            (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,\n            true);\n      }\n    }\n    return color;\n"
2347,getFillPaint,ODGAttributeKeys,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java,99,112,5,"/**\n   * Gets the fill paint for the specified figure based on the attributes\n   * FILL_GRADIENT, FILL_OPACITY, FILL_PAINT and the bounds of the figure.\n   * Returns null if the figure is not filled.\n   */",14,"  public static Paint getFillPaint(Figure f) {\n    double opacity = f.get(FILL_OPACITY);\n    if (f.get(FILL_GRADIENT) != null) {\n      return f.get(FILL_GRADIENT).getPaint(f, opacity);\n    }\n    Color color = f.get(FILL_COLOR);\n    if (color != null) {\n      if (opacity != 1) {\n        color = new Color(\n            (color.getRGB() & 0xffffff) | (int) (opacity * 255) << 24,\n            true);\n      }\n    }\n    return color;\n"
2348,setDefaults,ODGAttributeKeys,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/ODGAttributeKeys.java,143,157,1,/** Sets ODG default values. */,15,"  public static void setDefaults(Figure f) {\n    // Fill properties\n    f.set(FILL_COLOR, Color.black);\n    f.set(WINDING_RULE, WindingRule.NON_ZERO);\n    \n    // Stroke properties\n    f.set(STROKE_COLOR, null);\n    f.set(STROKE_WIDTH, 1d);\n    f.set(STROKE_CAP, BasicStroke.CAP_BUTT);\n    f.set(STROKE_JOIN, BasicStroke.JOIN_MITER);\n    f.set(STROKE_MITER_LIMIT, 4d);\n    f.set(IS_STROKE_MITER_LIMIT_FACTOR, false);\n    f.set(STROKE_DASHES, null);\n    f.set(STROKE_DASH_PHASE, 0d);\n    f.set(IS_STROKE_DASH_FACTOR, false);\n"
2351,getDefaultEventIndex,FigureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java,156,158,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",3,  @Override\n  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2352,getDefaultPropertyIndex,FigureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java,144,146,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",3,  @Override\n  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2355,getPropertyDescriptors,FigureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java,107,109,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",3,  @Override\n  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2356,getEventSetDescriptors,FigureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java,119,121,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,3,  @Override\n  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2357,getMethodDescriptors,FigureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java,131,133,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,3,  @Override\n  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2358,getBeanDescriptor,FigureToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBarBeanInfo.java,90,92,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,3,  @Override\n  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2359,LinkToolBar,LinkToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBar.java,44,47,1,/** Creates new instance. */,4,"  public LinkToolBar() {\n    labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n    setDisclosureStateCount(3);\n"
2360,getMethodDescriptors,FillToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2361,getBeanDescriptor,FillToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2363,getPropertyDescriptors,FillToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2364,getEventSetDescriptors,FillToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2366,getDefaultEventIndex,FillToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2368,getDefaultPropertyIndex,FillToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2369,getDefaultPropertyIndex,LinkToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java,144,146,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",3,  @Override\n  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2371,getPropertyDescriptors,LinkToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java,107,109,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",3,  @Override\n  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2373,getBeanDescriptor,LinkToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java,90,92,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,3,  @Override\n  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2375,getMethodDescriptors,LinkToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java,131,133,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,3,  @Override\n  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2376,getDefaultEventIndex,LinkToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java,156,158,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",3,  @Override\n  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2377,getEventSetDescriptors,LinkToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/LinkToolBarBeanInfo.java,119,121,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,3,  @Override\n  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2378,FontToolBar,FontToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FontToolBar.java,51,55,1,/** Creates new instance. */,5,"  public FontToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(""font.toolbar""));\n    JFontChooser.loadAllFonts();\n    setDisclosureStateCount(3);\n"
2379,FillToolBar,FillToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FillToolBar.java,45,48,1,/** Creates new instance. */,4,"  public FillToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n    setDisclosureStateCount(3);\n"
2380,FigureToolBar,FigureToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/FigureToolBar.java,43,46,1,/** Creates new instance. */,4,"  public FigureToolBar() {\n    labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n    setDisclosureStateCount(3);\n"
2381,save,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,89,96,3,/**\n   * Writes the contents of the DOMOutput into the specified writer.\n   */,8,"  public void save(Writer out) throws IOException {\n    if (doctype != null) {\n      out.write(""<!DOCTYPE "");\n      out.write(doctype);\n      out.write("">\\n"");\n    }\n    XMLWriter writer = new XMLWriter(out);\n    writer.write((XMLElement) document.getChildren().get(0));\n"
2383,save,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,81,84,3,/**\n   * Writes the contents of the DOMOutput into the specified output stream.\n   */,4,"  public void save(OutputStream out) throws IOException {\n    Writer w = new OutputStreamWriter(out, ""UTF8"");\n    save(w);\n    w.flush();\n"
2384,NanoXMLDOMOutput,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,69,75,1,/** Creates a new instance. */,7,"  public NanoXMLDOMOutput(DOMFactory factory) {\n    this.factory = factory;\n    objectids = new HashMap<Object,String>();\n    document = new XMLElement();//new HashMap(), false, false);\n    current = document;\n    stack = new Stack<XMLElement>();\n    stack.push(current);\n"
2385,addAttribute,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,158,160,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,3,"  public void addAttribute(String name, String value) {\n    if (value != null) {\n      current.setAttribute(name, value);\n"
2386,addAttribute,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,187,191,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,5,"  public void addAttribute(String name, double value) {\n    // Remove the awkard .0 at the end of each number\n    String str = Double.toString(value);\n    if (str.endsWith("".0"")) str = str.substring(0, str.length() - 2);\n    current.setAttribute(name, str);\n"
2387,closeElement,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,134,135,6,/**\n   * Closes the current element of the DOM Document.\n   * The parent of the current element becomes the current element.\n   * @exception IllegalArgumentException if the provided tagName does\n   * not match the tag name of the element.\n   */,2,  public void closeElement() {\n    current = (XMLElement) stack.pop();\n
2388,addText,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,147,152,7,/**\n   * Adds a text to current element of the DOM Document.\n   * Note: Multiple consecutives texts will be merged.\n   */\n --------------\n// NanoXML does not support comments\n --------------,6,  public void addText(String text) {\n    String old = current.getContent();\n    if (old == null) {\n      current.setContent(text);\n    } else {\n      current.setContent(old+text);\n
2389,openElement,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,121,126,9,/**\n   * Puts a new element into the DOM Document.\n   * The new element is added as a child to the current element in the DOM\n   * document. Then it becomes the current element.\n   * The element must be closed using closeElement.\n   */\n --------------\n//((XMLElement) document.getChildren().get(0)).print(out);\n --------------,6,"  public void openElement(String tagName) {\n    XMLElement newElement = new XMLElement();//new HashMap(), false, false);\n    newElement.setName(tagName);\n    current.addChild(newElement);\n    stack.push(current);\n    current = newElement;\n"
2390,addAttribute,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,166,167,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,2,"  public void addAttribute(String name, int value) {\n    current.setAttribute(name, Integer.toString(value));\n"
2391,print,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,101,110,3,/**\n   * Prints the contents of the DOMOutput into the specified print writer.\n   */,10,"  public void print(PrintWriter out) {\n    XMLWriter writer = new XMLWriter(out);\n    \n    try {\n      // writer.write(document);\n      writer.write((XMLElement) document.getChildren().get(0), true);\n    } catch (IOException e) {\n      InternalError error = new InternalError();\n      error.initCause(e);\n      throw error;\n"
2392,addAttribute,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,178,182,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,5,"  public void addAttribute(String name, float value) {\n    // Remove the awkard .0 at the end of each number\n    String str = Float.toString(value);\n    if (str.endsWith("".0"")) str = str.substring(0, str.length() - 2);\n    current.setAttribute(name, str);\n"
2393,addAttribute,NanoXMLDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMOutput.java,172,173,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,2,"  public void addAttribute(String name, boolean value) {\n    current.setAttribute(name, new Boolean(value).toString());\n"
2411,addEnumClass,DefaultDOMFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java,56,58,3,/**\n   * Adds an Enum class to the DOMFactory.\n   */,3,"  public void addEnumClass(String name, Class c) {\n    enumClassToNameMap.put(c, name);\n    nameToEnumClassMap.put(name, c);\n"
2412,addEnum,DefaultDOMFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java,63,72,3,/**\n   * Adds an Enum value to the DOMFactory.\n   */,10,"  public void addEnum(String value, Enum e) {\n    enumToValueMap.put(e, value);\n    Set<Enum> enums;\n    if (valueToEnumMap.containsKey(value)) {\n      enums = valueToEnumMap.get(value);\n    } else {\n      enums = new HashSet<Enum>();\n      valueToEnumMap.put(value, enums);\n    }\n    enums.add(e);\n"
2413,addStorableClass,DefaultDOMFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java,41,43,3,/**\n   * Adds a DOMStorable class to the DOMFactory.\n   */,3,"  public void addStorableClass(String name, Class c) {\n    nameToPrototypeMap.put(name, c);\n    classToNameMap.put(c, name);\n"
2414,addStorable,DefaultDOMFactory,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/DefaultDOMFactory.java,48,50,3,/**\n   * Adds a DOMStorable prototype to the DOMFactory.\n   */,3,"  public void addStorable(String name, DOMStorable prototype) {\n    nameToPrototypeMap.put(name, prototype);\n    classToNameMap.put(prototype.getClass(), name);\n"
2415,getElementCount,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,197,207,4,/**\n   * Returns the number of child elements with the specified tag name\n   * of the current element.\n   */,11,  public int getElementCount(String tagName) {\n    int count = 0;\n    NodeList list = current.getChildNodes();\n    for (int i=0; i < list.getLength(); i++) {\n      Node node = list.item(i);\n      if ((node instanceof Element)\n      && ((Element) node).getTagName().equals(tagName)) {\n        count++;\n      }\n    }\n    return count;\n
2416,readObject,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,283,284,3,/**\n   * Reads an object from the current element.\n   */,2,  public Object readObject() throws IOException {\n    return readObject(0);\n
2417,getAttribute,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,173,175,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public boolean getAttribute(String name, boolean defaultValue) {\n    String value = ((Element) current).getAttribute(name);\n    return (value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();\n"
2418,getElementCount,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,182,191,3,/**\n   * Returns the number of child elements of the current element.\n   */,10,  public int getElementCount() {\n    int count = 0;\n    NodeList list = current.getChildNodes();\n    for (int i=0; i < list.getLength(); i++) {\n      Node node = list.item(i);\n      if ((node instanceof Element)) {\n        count++;\n      }\n    }\n    return count;\n
2419,openElement,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,231,243,3,/**\n   * Opens the last element with the specified name and makes it the current node.\n   */,13,"  public void openElement(String tagName) {\n    int count = 0;\n    NodeList list = current.getChildNodes();\n    int len = list.getLength();\n    for (int i=0; i < len; i++) {\n      Node node = list.item(i);\n      if ((node instanceof Element)\n      && ((Element) node).getTagName().equals(tagName)) {\n        current = node;\n        return;\n      }\n    }\n    throw new IllegalArgumentException(""element not found:""+tagName);\n"
2420,getBuilder,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,64,79,4,/**\n   * Lazily create the document builder and keep a reference to it for\n   * performance improvement.\n   */,16,"  protected static DocumentBuilder getBuilder() throws IOException {\n    if (documentBuilder == null) {\n      DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n      factory.setNamespaceAware(true);\n      factory.setValidating(false);\n      factory.setXIncludeAware(false);\n      try {\n        factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        documentBuilder = factory.newDocumentBuilder();\n      } catch (Exception ex) {\n        InternalError error = new InternalError(""Unable to create DocumentBuilder"");\n        error.initCause(ex);\n        throw error;\n      }\n    }\n    return documentBuilder;\n"
2421,openElement,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,213,222,3,/**\n   * Opens the element with the specified index and makes it the current node.\n   */,10,  public void openElement(int index) {\n    int count = 0;\n    NodeList list = current.getChildNodes();\n    int len = list.getLength();\n    for (int i=0; i < len; i++) {\n      Node node = list.item(i);\n      if ((node instanceof Element)) {\n        if (count++ == index) {\n          current = node;\n          return;\n
2422,getText,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,127,133,3,/**\n   * Gets the text of the current element of the DOM Document.\n   */,7,"  public String getText(String defaultValue) {\n    if (current.getChildNodes().getLength() == 0) return defaultValue;\n    \n    StringBuilder buf = new StringBuilder();\n    getText(current, buf);\n    \n    return buf.toString();\n"
2423,getAttribute,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,166,168,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public double getAttribute(String name, double defaultValue) {\n    String value = ((Element) current).getAttribute(name);\n    return (value.length() == 0) ? defaultValue : Double.parseDouble(value);\n"
2424,getInheritedAttribute,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,146,154,4,/**\n   * Gets an attribute of the current element of the DOM Document and of\n   * all parent DOM elements.\n   */,9,  public java.util.List<String> getInheritedAttribute(String name) {\n    LinkedList<String> values = new LinkedList<String>();\n    Node node = current;\n    while (node != null) {\n      String value = (String) ((Element) node).getAttribute(name);\n      values.addFirst(value);\n      node = node.getParentNode();\n    }\n    return values;\n
2425,readObject,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,289,353,3,/**\n   * Reads an object from the current element.\n   */,65,"  public Object readObject(int index) throws IOException {\n    openElement(index);\n    Object o;\n    \n    String tagName = getTagName();\n    if (tagName.equals(""null"")) {\n      o =  null;\n    } else if (tagName.equals(""string"")) {\n      o = getText();\n    } else if (tagName.equals(""int"")) {\n      o = Integer.decode(getText());\n    } else if (tagName.equals(""long"")) {\n      o = Long.decode(getText());\n    } else if (tagName.equals(""float"")) {\n      o = new Float(Float.parseFloat(getText()));\n    } else if (tagName.equals(""double"")) {\n      o = new Double(Double.parseDouble(getText()));\n    } else if (tagName.equals(""boolean"")) {\n      o = Boolean.valueOf(getText());\n    } else if (tagName.equals(""color"")) {\n      o = new Color(getAttribute(""rgba"",0xff));\n    } else if (tagName.equals(""intArray"")) {\n      int[] a = new int[getElementCount()];\n      for (int i=0; i < a.length; i++) {\n        a[i] = ((Integer) readObject(i)).intValue();\n      }\n      o = a;\n    } else if (tagName.equals(""floatArray"")) {\n      float[] a = new float[getElementCount()];\n      for (int i=0; i < a.length; i++) {\n        a[i] = ((Float) readObject(i)).floatValue();\n      }\n      o = a;\n    } else if (tagName.equals(""doubleArray"")) {\n      double[] a = new double[getElementCount()];\n      for (int i=0; i < a.length; i++) {\n        a[i] = ((Double) readObject(i)).doubleValue();\n      }\n      o = a;\n    } else if (tagName.equals(""font"")) {\n      o = new Font(getAttribute(""name"", ""Dialog""), getAttribute(""style"", 0), getAttribute(""size"", 0));\n    } else if (tagName.equals(""enum"")) {\n      o = factory.createEnum(getAttribute(""type"",(String)null), getText());\n    } else {\n      String ref = getAttribute(""ref"", null);\n      String id = getAttribute(""id"", ref);\n      \n      // Keep track of objects which have an ID\n      if (id == null) {\n        o = factory.create(getTagName());\n      } else if (idobjects.containsKey(id)) {\n        o = idobjects.get(id);\n      } else {\n        o = factory.create(getTagName());\n        idobjects.put(id, o);\n      }\n      if (ref == null) {\n        if (o instanceof DOMStorable) {\n          ((DOMStorable) o).read(this);\n        }\n      }\n    }\n    \n    closeElement();\n    return o;\n"
2426,getText,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,121,122,3,/**\n   * Gets the text of the current element of the DOM Document.\n   */,2,  public String getText() {\n    return getText(null);\n
2427,getTagName,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,108,109,3,/**\n   * Returns the tag name of the current element.\n   */,2,  public String getTagName() {\n    return ((Element) current).getTagName();\n
2428,closeElement,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,272,277,6,/**\n   * Closes the current element of the DOM Document.\n   * The parent of the current element becomes the current element.\n   * @exception IllegalArgumentException if the provided tagName does\n   * not match the tag name of the element.\n   */,6,"  public void closeElement() {\n    /*\n    if (! ((Element) current).getTagName().equals(tagName)) {\n      throw new IllegalArgumentException(""Attempt to close wrong element:""+tagName +""!=""+((Element) current).getTagName());\n    }*/\n    current = current.getParentNode();\n"
2429,openElement,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,249,263,4,/**\n   * Opens the element with the specified name and index and makes it the\n   * current node.\n   */,15,"  public void openElement(String tagName, int index) {\n    int count = 0;\n    NodeList list = current.getChildNodes();\n    int len = list.getLength();\n    for (int i=0; i < len; i++) {\n      Node node = list.item(i);\n      if ((node instanceof Element)\n      && ((Element) node).getTagName().equals(tagName)) {\n        if (count++ == index) {\n          current = node;\n          return;\n        }\n      }\n    }\n    throw new IllegalArgumentException(""no such child ""+tagName+""[""+index+""]"");\n"
2430,getAttribute,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,159,161,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public int getAttribute(String name, int defaultValue) {\n    String value = ((Element) current).getAttribute(name);\n    return (value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();\n"
2431,getAttribute,JavaxDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMInput.java,114,116,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public String getAttribute(String name, String defaultValue) {\n    String value = ((Element) current).getAttribute(name);\n    return (value.length() == 0) ? defaultValue : value;\n"
2432,JavaxDOMOutput,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,68,69,1,/** Creates a new instance. */,2,  public JavaxDOMOutput(DOMFactory factory) throws IOException {\n    this.factory = factory;\n
2433,addAttribute,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,178,179,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,2,"  public void addAttribute(String name, boolean value) {\n    ((Element) current).setAttribute(name, Boolean.toString(value));\n"
2434,addText,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,158,159,4,/**\n   * Adds a text to current element of the DOM Document.\n   * Note: Multiple consecutives texts will be merged.\n   */,2,  public void addText(String text) {\n    current.appendChild(document.createTextNode(text));\n
2435,addComment,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,151,152,3,/**\n   * Adds a comment to the current element of the DOM Document.\n   */,2,  public void addComment(String comment) {\n    current.appendChild(document.createComment(comment));\n
2436,save,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,107,120,3,/**\n   * Writes the contents of the DOMOutput into the specified output stream.\n   */,14,"  public void save(Writer out) throws IOException {\n    reset();\n    try {\n      if (doctype != null) {\n        out.write(""<!DOCTYPE "");\n        out.write(doctype);\n        out.write("">\\n"");\n      }\n      Transformer t = TransformerFactory.newInstance().newTransformer();\n      t.transform(new DOMSource(document), new StreamResult(out));\n    } catch (TransformerException e) {\n      IOException error = new IOException(e.getMessage());\n      error.initCause(e);\n      throw error;\n"
2437,addAttribute,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,193,197,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,5,"  public void addAttribute(String name, double value) {\n    // Remove the awkard .0 at the end of each number\n    String str = Double.toString(value);\n    if (str.endsWith("".0"")) str = str.substring(0, str.length() - 2);\n    ((Element) current).setAttribute(name, str);\n"
2438,closeElement,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,141,146,6,/**\n   * Closes the current element of the DOM Document.\n   * The parent of the current element becomes the current element.\n   * @exception IllegalArgumentException if the provided tagName does\n   * not match the tag name of the element.\n   */,6,"  public void closeElement() {\n    /*\n    if (! ((Element) current).getName().equals(tagName)) {\n      throw new IllegalArgumentException(""Attempt to close wrong element:""+tagName +""!=""+((Element) current).getName());\n    }*/\n    current = current.getParentNode();\n"
2439,addAttribute,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,164,166,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,3,"  public void addAttribute(String name, String value) {\n    if (value != null) {\n      ((Element) current).setAttribute(name, value);\n"
2440,openElement,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,130,133,6,/**\n   * Puts a new element into the DOM Document.\n   * The new element is added as a child to the current element in the DOM\n   * document. Then it becomes the current element.\n   * The element must be closed using closeElement.\n   */,4,  public void openElement(String tagName) {\n    Element newElement = document.createElement(tagName);\n    current.appendChild(newElement);\n    current = newElement;\n
2441,addAttribute,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,172,173,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,2,"  public void addAttribute(String name, int value) {\n    ((Element) current).setAttribute(name, Integer.toString(value));\n"
2442,save,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,86,101,3,/**\n   * Writes the contents of the DOMOutput into the specified output stream.\n   */,16,"  public void save(OutputStream out) throws IOException {\n    reset();\n    try {\n      if (doctype != null) {\n        OutputStreamWriter w = new OutputStreamWriter(out, ""UTF8"");\n        w.write(""<!DOCTYPE "");\n        w.write(doctype);\n        w.write("">\\n"");\n        w.flush();\n      }\n      Transformer t = TransformerFactory.newInstance().newTransformer();\n      t.transform(new DOMSource(document), new StreamResult(out));\n    } catch (TransformerException e) {\n      IOException error = new IOException(e.getMessage());\n      error.initCause(e);\n      throw error;\n"
2443,addAttribute,JavaxDOMOutput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/JavaxDOMOutput.java,184,188,3,/**\n   * Adds an attribute to current element of the DOM Document.\n   */,5,"  public void addAttribute(String name, float value) {\n    // Remove the awkard .0 at the end of each number\n    String str = Float.toString(value);\n    if (str.endsWith("".0"")) str = str.substring(0, str.length() - 2);\n    ((Element) current).setAttribute(name, str);\n"
2463,getText,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,114,115,3,/**\n   * Gets the text of the current element of the DOM Document.\n   */,2,  public String getText() {\n    return getText(null);\n
2464,getInheritedAttribute,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,101,109,4,/**\n   * Gets an attribute of the current element of the DOM Document and of\n   * all parent DOM elements.\n   */,9,  public java.util.List<String> getInheritedAttribute(String name) {\n    LinkedList<String> values = new LinkedList<String>();\n    for (XMLElement node: stack) {\n      String value = (String) node.getAttribute(name);\n      values.add(value);\n    }\n    String value = (String) current.getAttribute(name);\n    values.add(value);\n    return values;\n
2465,getAttribute,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,141,143,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public boolean getAttribute(String name, boolean defaultValue) {\n    String value = (String) current.getAttribute(name);\n    return (value == null || value.length() == 0) ? defaultValue : Boolean.valueOf(value).booleanValue();\n"
2466,openElement,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,197,210,4,/**\n   * Opens the element with the specified name and index and makes it the\n   * current node.\n   */,14,"  public void openElement(String tagName, int index) throws IOException {\n    int count = 0;\n    ArrayList list = current.getChildren();\n    for (int i=0; i < list.size(); i++) {\n      XMLElement node = (XMLElement) list.get(i);\n      if (node.getName().equals(tagName)) {\n        if (count++ == index) {\n          stack.push(current);\n          current = node;\n          return;\n        }\n      }\n    }\n    throw new IOException(""no such element:""+tagName+"" at index:""+index);\n"
2467,getAttribute,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,127,129,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public int getAttribute(String name, int defaultValue) {\n    String value = (String) current.getAttribute(name);\n    return (value == null || value.length() == 0) ? defaultValue : (int) Long.decode(value).intValue();\n"
2468,openElement,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,181,191,3,/**\n   * Opens the last element with the specified name and makes it the current node.\n   */,11,"  public void openElement(String tagName) throws IOException {\n    ArrayList list = current.getChildren();\n    for (int i=0; i < list.size(); i++) {\n      XMLElement node = (XMLElement) list.get(i);\n      if (node.getName().equals(tagName)) {\n        stack.push(current);\n        current = node;\n        return;\n      }\n    }\n    throw new IOException(""no such element:""+tagName);\n"
2469,getTagName,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,87,88,3,/**\n   * Returns the tag name of the current element.\n   */,2,  public String getTagName() {\n    return current.getName();\n
2470,getAttribute,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,93,95,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public String getAttribute(String name, String defaultValue) {\n    String value = (String) current.getAttribute(name);\n    return (value == null || value.length() == 0) ? defaultValue : value;\n"
2471,getElementCount,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,157,166,4,/**\n   * Returns the number of child elements with the specified tag name\n   * of the current element.\n   */,10,  public int getElementCount(String tagName) {\n    int count = 0;\n    ArrayList list = current.getChildren();\n    for (int i=0; i < list.size(); i++) {\n      XMLElement node = (XMLElement) list.get(i);\n      if (node.getName().equals(tagName)) {\n        count++;\n      }\n    }\n    return count;\n
2472,openElement,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,172,175,3,/**\n   * Opens the element with the specified index and makes it the current node.\n   */,4,  public void openElement(int index) {\n    stack.push(current);\n    ArrayList list = current.getChildren();\n    current = (XMLElement) list.get(index);\n
2473,getText,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,120,122,3,/**\n   * Gets the text of the current element of the DOM Document.\n   */,3,  public String getText(String defaultValue) {\n    String value = current.getContent();\n    return (value == null) ? defaultValue : value;\n
2474,readObject,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,232,297,3,/**\n   * Reads an object from the current element.\n   */,66,"  public Object readObject(int index) throws IOException {\n    openElement(index);\n    Object o;\n    \n    String tagName = getTagName();\n    if (tagName.equals(""null"")) {\n      o =  null;\n    } else if (tagName.equals(""string"")) {\n      o = getText();\n    } else if (tagName.equals(""int"")) {\n      o = Integer.decode(getText());\n    } else if (tagName.equals(""long"")) {\n      o = Long.decode(getText());\n    } else if (tagName.equals(""float"")) {\n      o = new Float(Float.parseFloat(getText()));\n    } else if (tagName.equals(""double"")) {\n      o = new Double(Double.parseDouble(getText()));\n    } else if (tagName.equals(""boolean"")) {\n      o = Boolean.valueOf(getText());\n    } else if (tagName.equals(""color"")) {\n      o = new Color(getAttribute(""rgba"",0xff));\n    } else if (tagName.equals(""intArray"")) {\n      int[] a = new int[getElementCount()];\n      for (int i=0; i < a.length; i++) {\n        a[i] = ((Integer) readObject(i)).intValue();\n      }\n      o = a;\n    } else if (tagName.equals(""floatArray"")) {\n      float[] a = new float[getElementCount()];\n      for (int i=0; i < a.length; i++) {\n        a[i] = ((Float) readObject(i)).floatValue();\n      }\n      o = a;\n    } else if (tagName.equals(""doubleArray"")) {\n      double[] a = new double[getElementCount()];\n      for (int i=0; i < a.length; i++) {\n        a[i] = ((Double) readObject(i)).doubleValue();\n      }\n      o = a;\n    } else if (tagName.equals(""font"")) {\n      o = new Font(getAttribute(""name"", ""Dialog""), getAttribute(""style"", 0), getAttribute(""size"", 0));\n    } else if (tagName.equals(""enum"")) {\n      o = factory.createEnum(getAttribute(""type"",(String)null), getText());\n    } else {\n      String ref = getAttribute(""ref"", null);\n      String id = getAttribute(""id"", ref);\n      \n      // Keep track of objects which have an ID\n      if (id == null) {\n        o = factory.create(getTagName());\n      } else if (idobjects.containsKey(id)) {\n        o = idobjects.get(id);\n      } else {\n        o = factory.create(getTagName());\n        idobjects.put(id, o);\n      }\n      \n      if (ref == null) {\n        if (o instanceof DOMStorable) {\n          ((DOMStorable) o).read(this);\n        }\n      }\n    }\n    \n    closeElement();\n    return o;\n"
2475,closeElement,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,219,220,6,/**\n   * Closes the current element of the DOM Document.\n   * The parent of the current element becomes the current element.\n   * @exception IllegalArgumentException if the provided tagName does\n   * not match the tag name of the element.\n   */,2,  public void closeElement() {\n    current = (XMLElement) stack.pop();\n
2476,getElementCount,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,150,151,3,/**\n   * Returns the number of child elements of the current element.\n   */,2,  public int getElementCount() {\n    return current.getChildrenCount();\n
2477,getAttribute,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,134,136,3,/**\n   * Gets an attribute of the current element of the DOM Document.\n   */,3,"  public double getAttribute(String name, double defaultValue) {\n    String value = (String) current.getAttribute(name);\n    return (value == null || value.length() == 0) ? defaultValue : Double.parseDouble(value);\n"
2478,readObject,NanoXMLDOMInput,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/NanoXMLDOMInput.java,226,227,3,/**\n   * Reads an object from the current element.\n   */,2,  public Object readObject() throws IOException {\n    return readObject(0);\n
2479,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,356,360,9,"/**\n   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments\n   * @param raw_cookies request cookies\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameters\n   * @see #setCookies\n   */",5,"  public InputStream post(String raw_cookies, Map parameters) throws IOException {\n  setCookies(raw_cookies);\n  postCookies();\n  setParameters(parameters);\n  return doPost();\n"
2480,setParameter,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,215,228,7,/**\n   * adds a file parameter to the request\n   * @param name parameter name\n   * @param filename the name of the file\n   * @param is input stream to read the contents of the file from\n   * @throws IOException\n   */,14,"  public void setParameter(String name, String filename, InputStream is) throws IOException {\n  boundary();\n  writeName(name);\n  write(""; filename=\\"""");\n  write(filename);\n  write(\'""\');\n  newline();\n  write(""Content-Type: "");\n  String type = URLConnection.guessContentTypeFromName(filename);\n  if (type == null) type = ""application/octet-stream"";\n  writeln(type);\n  newline();\n  pipe(is, _os);\n  newline();\n"
2481,ClientHttpRequest,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,80,85,6,/**\n   * Creates a new multipart POST HTTP request on a freshly opened URLConnection\n   *\n   * @param connection an already open URL connection\n   * @throws IOException\n   */,6,"  public ClientHttpRequest(URLConnection connection) throws IOException {\n  this._connection = connection;\n  connection.setDoOutput(true);\n  connection.setDoInput(true);\n  connection.setRequestProperty(""Content-Type"",\n                  ""multipart/form-data; boundary="" + boundary);\n"
2482,PertPanel,PertPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertPanel.java,51,116,1,/** Creates new instance. */,66,"  public PertPanel() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    initComponents();\n    undoManager = new UndoRedoManager();\n    editor = new DefaultDrawingEditor();\n    editor.add(view);\n    \n    addCreationButtonsTo(creationToolbar, editor);\n    ButtonFactory.addAttributesButtonsTo(attributesToolbar, editor);\n    \n    JPopupButton pb = new JPopupButton();\n    pb.setItemFont(UIManager.getFont(""MenuItem.font""));\n    labels.configureToolBarButton(pb, ""actions"");\n    pb.add(new DuplicateAction());\n    pb.addSeparator();\n    pb.add(new GroupAction(editor));\n    pb.add(new UngroupAction(editor));\n    pb.addSeparator();\n    pb.add(new BringToFrontAction(editor));\n    pb.add(new SendToBackAction(editor));\n    pb.addSeparator();\n    pb.add(new CutAction());\n    pb.add(new CopyAction());\n    pb.add(new PasteAction());\n    pb.add(new SelectAllAction());\n    pb.add(new SelectSameAction(editor));\n    pb.addSeparator();\n    pb.add(undoManager.getUndoAction());\n    pb.add(undoManager.getRedoAction());\n     // FIXME - We need a toggle grid action\n     // pb.addSeparator();\n     // pb.add(new ToggleGridAction(editor));\n    \n    JMenu m = new JMenu(labels.getString(""view.zoomFactor.text""));\n    JRadioButtonMenuItem rbmi;\n    ButtonGroup group = new ButtonGroup();\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.1, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 0.75, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.0, null)));\n    rbmi.setSelected(true);\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.25, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 1.5, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 2, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 3, null)));\n    group.add(rbmi);\n    m.add(rbmi = new JRadioButtonMenuItem(new ZoomAction(editor, 4, null)));\n    group.add(rbmi);\n    pb.add(m);\n    pb.setFocusable(false);\n    creationToolbar.addSeparator();\n    creationToolbar.add(pb);\n    \n    \n    DefaultDrawing drawing = new DefaultDrawing();\n    view.setDrawing(drawing);\n    drawing.addUndoableEditListener(undoManager);\n"
2483,setParameters,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,274,277,5,"/**\n   * adds parameters to the request\n   * @param parameters array of parameter names and values (parameters[2*i] is a name, parameters[2*i + 1] is a value); if a value is a file, the file is uploaded, otherwise it is stringified and sent in the request\n   * @throws IOException\n   */",4,"  public void setParameters(Object[] parameters) throws IOException {\n  if (parameters != null) {\n    for (int i = 0; i < parameters.length - 1; i += 2) {\n    setParameter(parameters[i].toString(), parameters[i + 1]);\n"
2484,setCookies,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,150,152,5,"/**\n   * adds cookies to the request\n   * @param cookies the cookie ""name-to-value"" map\n   * @throws IOException\n   */",3,"  public void setCookies(Map<String,String> cookies) throws IOException {\n  if (cookies == null) return;\n  this._cookies.putAll(cookies);\n"
2485,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,387,390,8,"/**\n   * post the POST request to the server, with the specified parameter\n   * @param name parameter name\n   * @param value parameter value\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameter\n   */",4,"  public InputStream post(String name, Object value) throws IOException {\n  postCookies();\n  setParameter(name, value);\n  return doPost();\n"
2487,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,444,450,14,"/**\n   * post the POST request to the server, with the specified parameters\n   * @param name1 first parameter name\n   * @param value1 first parameter value\n   * @param name2 second parameter name\n   * @param value2 second parameter value\n   * @param name3 third parameter name\n   * @param value3 third parameter value\n   * @param name4 fourth parameter name\n   * @param value4 fourth parameter value\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameter\n   */",7,"  public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3, String name4, Object value4) throws IOException {\n  postCookies();\n  setParameter(name1, value1);\n  setParameter(name2, value2);\n  setParameter(name3, value3);\n  setParameter(name4, value4);\n  return doPost();\n"
2488,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,484,485,9,"/**\n   * posts a new request to specified URL, with cookies and parameters that are passed in the argument\n   * @param cookies request cookies\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setCookies\n   * @see #setParameters\n   */",2,"  public static InputStream post(URL url, Map<String,String> cookies, Map parameters) throws IOException {\n  return new ClientHttpRequest(url).post(cookies, parameters);\n"
2489,initComponents,PertPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertPanel.java,141,175,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,27,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    toolButtonGroup = new javax.swing.ButtonGroup();\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    jPanel1 = new javax.swing.JPanel();\n    creationToolbar = new javax.swing.JToolBar();\n    attributesToolbar = new javax.swing.JToolBar();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n    jPanel1.setLayout(new java.awt.GridBagLayout());\n    creationToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 0;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(creationToolbar, gridBagConstraints);\n    attributesToolbar.setFloatable(false);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.gridx = 0;\n    gridBagConstraints.gridy = 1;\n    gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;\n    gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;\n    jPanel1.add(attributesToolbar, gridBagConstraints);\n    add(jPanel1, java.awt.BorderLayout.SOUTH);\n"
2490,setParameters,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,260,264,5,"/**\n   * adds parameters to the request\n   * @param parameters ""name-to-value"" map of parameters; if a value is a file, the file is uploaded, otherwise it is stringified and sent in the request\n   * @throws IOException\n   */",5,"  public void setParameters(Map parameters) throws IOException {\n  if (parameters != null) {\n    for (Iterator i = parameters.entrySet().iterator(); i.hasNext();) {\n    Map.Entry entry = (Map.Entry)i.next();\n    setParameter(entry.getKey().toString(), entry.getValue());\n"
2491,setParameter,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,237,238,6,/**\n   * adds a file parameter to the request\n   * @param name parameter name\n   * @param file the file to upload\n   * @throws IOException\n   */,2,"  public void setParameter(String name, File file) throws IOException {\n  setParameter(name, file.getPath(), new FileInputStream(file));\n"
2492,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,460,461,7,"/**\n   * posts a new request to specified URL, with parameters that are passed in the argument\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameters\n   */",2,"  public static InputStream post(URL url, Map parameters) throws IOException {\n  return new ClientHttpRequest(url).post(parameters);\n"
2493,ClientHttpRequest,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,104,105,6,/**\n   * Creates a new multipart POST HTTP request for a specified URL string\n   *\n   * @param urlString the string representation of the URL to send request to\n   * @throws IOException\n   */,2,  public ClientHttpRequest(String urlString) throws IOException {\n  this(new URL(urlString));\n
2494,setCookie,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,141,142,6,/**\n   * adds a cookie to the requst\n   * @param name cookie name\n   * @param value cookie value\n   * @throws IOException\n   */,2,"  public void setCookie(String name, String value) throws IOException {\n    _cookies.put(name, value);\n"
2495,main,Main,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/Main.java,30,50,1,/** Creates a new instance. */,21,"  public static void main(String[] args) {\n    Application app;\n    String os = System.getProperty(""os.name"").toLowerCase();\n    if (os.startsWith(""mac"")) {\n      app = new OSXApplication();\n    } else if (os.startsWith(""win"")) {\n      //  app = new DefaultMDIApplication();\n      app = new SDIApplication();\n    } else {\n      app = new SDIApplication();\n    }\n    \n    \n    DefaultApplicationModel model = new PertApplicationModel();\n    model.setName(""JHotDraw Pert"");\n    model.setVersion(Main.class.getPackage().getImplementationVersion());\n    model.setCopyright(""Copyright 2006-2010 (c) by the authors of JHotDraw and all its contributors.\\n"" +\n        ""This software is licensed under LGPL and Creative Commons 3.0 Attribution."");\n    model.setViewClassName(""org.jhotdraw.samples.pert.PertView"");\n    app.setModel(model);\n    app.launch(args);\n"
2497,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,403,407,10,"/**\n   * post the POST request to the server, with the specified parameters\n   * @param name1 first parameter name\n   * @param value1 first parameter value\n   * @param name2 second parameter name\n   * @param value2 second parameter value\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameter\n   */",5,"  public InputStream post(String name1, Object value1, String name2, Object value2) throws IOException {\n  postCookies();\n  setParameter(name1, value1);\n  setParameter(name2, value2);\n  return doPost();\n"
2498,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,312,315,7,"/**\n   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with parameters that are passed in the argument\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameters\n   */",4,  public InputStream post(Map parameters) throws IOException {\n  postCookies();\n  setParameters(parameters);\n  return doPost();\n
2499,setParameter,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,247,251,6,"/**\n   * adds a parameter to the request; if the parameter is a File, the file is uploaded, otherwise the string value of the parameter is passed in the request\n   * @param name parameter name\n   * @param object parameter value, a File or anything else that can be stringified\n   * @throws IOException\n   */",5,"  public void setParameter(String name, Object object) throws IOException {\n  if (object instanceof File) {\n    setParameter(name, (File) object);\n  } else {\n    setParameter(name, object.toString());\n"
2500,doPost,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,287,292,5,"/**\n   * posts the requests to the server, with all the cookies and parameters that were added\n   * @return input stream with the server response\n   * @throws IOException\n   */",5,"  private InputStream doPost() throws IOException {\n  boundary();\n  writeln(""--"");\n  _os.close();\n  return _connection.getInputStream();\n"
2501,setCookies,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,130,132,5,/**\n   * adds a cookie to the requst\n   * @param rawCookies A string with raw cookie data.\n   * @throws IOException\n   */,3,"  public void setCookies(String rawCookies) throws IOException {\n  this._rawCookies = (rawCookies == null) ? """" : rawCookies;\n  _cookies.clear();\n"
2502,DependencyFigure,DependencyFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java,32,41,1,/** Creates a new instance. */,10,"  public DependencyFigure() {\n    set(STROKE_COLOR, new Color(0x000099));\n    set(STROKE_WIDTH, 1d);\n    set(END_DECORATION, new ArrowTip());\n    \n    setAttributeEnabled(END_DECORATION, false);\n    setAttributeEnabled(START_DECORATION, false);\n    setAttributeEnabled(STROKE_DASHES, false);\n    setAttributeEnabled(FONT_ITALIC, false);\n    setAttributeEnabled(FONT_UNDERLINE, false);\n"
2503,setParameter,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,180,190,6,/**\n   * adds a string parameter to the request\n   * @param name parameter name\n   * @param value parameter value\n   * @throws IOException\n   */,11,"  public void setParameter(String name, String value) throws IOException {\n    if (name == null) {\n      throw new InvalidParameterException(""setParameter(""+name+"",""+value+"") name must not be null"");\n    }\n    if (value == null) {\n      throw new InvalidParameterException(""setParameter(""+name+"",""+value+"") value must not be null"");\n    }\n  boundary();\n  writeName(name);\n  newline(); newline();\n  writeln(value);\n"
2504,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,372,376,9,"/**\n   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments\n   * @param cookies request cookies\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameters\n   * @see #setCookies\n   */",5,"  public InputStream post(String[] cookies, Object[] parameters) throws IOException {\n  setCookies(cookies);\n  postCookies();\n  setParameters(parameters);\n  return doPost();\n"
2505,canConnect,DependencyFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java,48,64,4,/**\n   * Checks if two figures can be connected. Implement this method\n   * to constrain the allowed connections between figures.\n   */,17,"   @Override public boolean canConnect(Connector start, Connector end) {\n    if ((start.getOwner() instanceof TaskFigure)\n    && (end.getOwner() instanceof TaskFigure)) {\n      \n      TaskFigure sf = (TaskFigure) start.getOwner();\n      TaskFigure ef = (TaskFigure) end.getOwner();\n      \n      // Disallow multiple connections to same dependent\n      if (ef.getPredecessors().contains(sf)) {\n        return false;\n      }\n      \n      // Disallow cyclic connections\n      return ! sf.isDependentOf(ef);\n    }\n    \n    return false;\n"
2506,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,300,302,5,"/**\n   * posts the requests to the server, with all the cookies and parameters that were added\n   * @return input stream with the server response\n   * @throws IOException\n   */",3,  public InputStream post() throws IOException {\n      postCookies();\n    return doPost();\n
2507,setCookies,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,160,163,5,"/**\n   * adds cookies to the request\n   * @param cookies array of cookie names and values (cookies[2*i] is a name, cookies[2*i + 1] is a value)\n   * @throws IOException\n   */",4,"  public void setCookies(String[] cookies) throws IOException {\n  if (cookies == null) return;\n  for (int i = 0; i < cookies.length - 1; i+=2) {\n    setCookie(cookies[i], cookies[i+1]);\n"
2508,handleDisconnect,DependencyFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/DependencyFigure.java,75,80,4,/**\n   * Handles the disconnection of a connection.\n   * Override this method to handle this event.\n   */,6,"  @Override protected void handleDisconnect(Connector start, Connector end) {\n    TaskFigure sf = (TaskFigure) start.getOwner();\n    TaskFigure ef = (TaskFigure) end.getOwner();\n    \n    sf.removeDependency(this);\n    ef.removeDependency(this);\n"
2509,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,340,344,9,"/**\n   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with cookies and parameters that are passed in the arguments\n   * @param cookies request cookies\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameters\n   * @see #setCookies\n   */",5,"  public InputStream post(Map<String,String> cookies, Map parameters) throws IOException {\n  setCookies(cookies);\n  postCookies();\n  setParameters(parameters);\n  return doPost();\n"
2510,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,422,427,12,"/**\n   * post the POST request to the server, with the specified parameters\n   * @param name1 first parameter name\n   * @param value1 first parameter value\n   * @param name2 second parameter name\n   * @param value2 second parameter value\n   * @param name3 third parameter name\n   * @param value3 third parameter value\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameter\n   */",6,"  public InputStream post(String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {\n  postCookies();\n  setParameter(name1, value1);\n  setParameter(name2, value2);\n  setParameter(name3, value3);\n  return doPost();\n"
2511,ClientHttpRequest,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,94,95,6,/**\n   * Creates a new multipart POST HTTP request for a specified URL\n   *\n   * @param url the URL to send request to\n   * @throws IOException\n   */,2,  public ClientHttpRequest(URL url) throws IOException {\n  this(url.openConnection());\n
2512,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,498,499,10,"/**\n   * posts a new request to specified URL, with cookies and parameters that are passed in the argument\n   * @param url post URL\n   * @param cookies request cookies\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setCookies\n   * @see #setParameters\n   */",2,"  public static InputStream post(URL url, String[] cookies, Object[] parameters) throws IOException {\n  return new ClientHttpRequest(url).post(cookies, parameters);\n"
2513,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,471,472,7,"/**\n   * posts a new request to specified URL, with parameters that are passed in the argument\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameters\n   */",2,"  public static InputStream post(URL url, Object[] parameters) throws IOException {\n  return new ClientHttpRequest(url).post(parameters);\n"
2514,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,541,542,12,"/**\n   * post the POST request to specified URL, with the specified parameters\n   * @param name1 first parameter name\n   * @param value1 first parameter value\n   * @param name2 second parameter name\n   * @param value2 second parameter value\n   * @param name3 third parameter name\n   * @param value3 third parameter value\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameter\n   */",2,"  public static InputStream post(URL url, String name1, Object value1, String name2, Object value2, String name3, Object value3) throws IOException {\n  return new ClientHttpRequest(url).post(name1, value1, name2, value2, name3, value3);\n"
2515,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,325,328,7,"/**\n   * posts the requests to the server, with all the cookies and parameters that were added before (if any), and with parameters that are passed in the argument\n   * @param parameters request parameters\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameters\n   */",4,  public InputStream post(Object[] parameters) throws IOException {\n  postCookies();\n  setParameters(parameters);\n  return doPost();\n
2516,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,511,512,9,"/**\n   * post the POST request specified URL, with the specified parameter\n   * @param url post URL\n   * @param name1 parameter name\n   * @param value1 parameter value\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameter\n   */",2,"  public static InputStream post(URL url, String name1, Object value1) throws IOException {\n  return new ClientHttpRequest(url).post(name1, value1);\n"
2517,post,ClientHttpRequest,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ClientHttpRequest.java,525,526,10,"/**\n   * post the POST request to specified URL, with the specified parameters\n   * @param name1 first parameter name\n   * @param value1 first parameter value\n   * @param name2 second parameter name\n   * @param value2 second parameter value\n   * @return input stream with the server response\n   * @throws IOException\n   * @see #setParameter\n   */",2,"  public static InputStream post(URL url, String name1, Object value1, String name2, Object value2) throws IOException {\n  return new ClientHttpRequest(url).post(name1, value1, name2, value2);\n"
2518,getParameter,PertApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java,51,55,4,/**\n   * We override getParameter() to make it work even if we have no Applet\n   * context.\n   */,5,  public String getParameter(String name) {\n    try {\n      return super.getParameter(name);\n    } catch (NullPointerException e) {\n      return null;\n
2519,init,PertApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java,66,153,3,/**\n   * Initializes the applet PertApplet\n   */,79,"  public void init() {\n    // Set look and feel\n    // -----------------\n    try {\n      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Throwable e) {\n      // Do nothing.\n      // If we can\'t set the desired look and feel, UIManager does\n      // automaticaly the right thing for us.\n    }\n    // Set our own popup factory, because the one that comes with Mac OS X\n    // creates translucent popups which is not useful for color selection\n    // using pop menus.\n    try {\n      PopupFactory.setSharedInstance(new PopupFactory());\n    } catch (Throwable e) {\n      // If we can\'t set the popup factory, we have to use what is there.\n    }\n\n    // Display copyright info while we are loading the data\n    // ----------------------------------------------------\n    Container c = getContentPane();\n    c.setLayout(new BoxLayout(c, BoxLayout.Y_AXIS));\n    String[] labels = getAppletInfo().split(""\\n"");//Strings.split(getAppletInfo(), \'\\n\');\n    for (int i = 0; i < labels.length; i++) {\n      c.add(new JLabel((labels[i].length() == 0) ? "" "" : labels[i]));\n    }\n    // We load the data using a worker thread\n    // --------------------------------------\n    new Worker<Drawing>() {\n      public Drawing construct() throws IOException {\n        Drawing result;\n        System.out.println(""getParameter.datafile:"" + getParameter(""datafile""));\n        if (getParameter(""data"") != null) {\n          NanoXMLDOMInput domi = new NanoXMLDOMInput(new PertFactory(), new StringReader(getParameter(""data"")));\n          result = (Drawing) domi.readObject(0);\n        } else if (getParameter(""datafile"") != null) {\n          URL url = new URL(getDocumentBase(), getParameter(""datafile""));\n          InputStream in = url.openConnection().getInputStream();\n          try {\n            NanoXMLDOMInput domi = new NanoXMLDOMInput(new PertFactory(), in);\n            result = (Drawing) domi.readObject(0);\n          } finally {\n            in.close();\n          }\n        } else {\n          result = null;\n        }\n        return result;\n      }\n      @Override\n      protected void done(Drawing result) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        c.add(drawingPanel = new PertPanel());\n        initComponents();\n        if (result != null) {\n          setDrawing(result);\n        }\n      }\n      @Override\n      protected void failed(Throwable value) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        c.add(drawingPanel = new PertPanel());\n        value.printStackTrace();\n        initComponents();\n        getDrawing().add(new TextFigure(value.toString()));\n        value.printStackTrace();\n      }\n      @Override\n      protected void finished() {\n        Container c = getContentPane();\n        initDrawing(getDrawing());\n        c.validate();\n      }\n    }.start();\n"
2520,initDrawing,PertApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java,167,179,3,/**\n   * Configure Drawing object to support copy and paste.\n   */,10,  private void initDrawing(Drawing d) {\n    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();\n    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();\n    DOMStorableInputOutputFormat ioFormat = new DOMStorableInputOutputFormat(\n        new PertFactory());\n    inputFormats.add(ioFormat);\n    outputFormats.add(ioFormat);\n    outputFormats.add(new ImageOutputFormat());\n    d.setInputFormats(inputFormats);\n    d.setOutputFormats(outputFormats);\n
2522,initComponents,PertApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplet.java,243,244,5,/** This method is called from within the init() method to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,2,  private void initComponents() {\n    toolButtonGroup = new javax.swing.ButtonGroup();\n
2523,TaskFigure,TaskFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java,84,136,1,/** Creates a new instance. */,41,"  public TaskFigure() {\n    super(new RectangleFigure());\n    setLayouter(new VerticalLayouter());\n    RectangleFigure nameCompartmentPF = new RectangleFigure();\n    nameCompartmentPF.set(STROKE_COLOR, null);\n    nameCompartmentPF.setAttributeEnabled(STROKE_COLOR, false);\n    nameCompartmentPF.set(FILL_COLOR, null);\n    nameCompartmentPF.setAttributeEnabled(FILL_COLOR, false);\n    ListFigure nameCompartment = new ListFigure(nameCompartmentPF);\n    ListFigure attributeCompartment = new ListFigure();\n    SeparatorLineFigure separator1 = new SeparatorLineFigure();\n    applyAttributes(getPresentationFigure());\n    add(nameCompartment);\n    add(separator1);\n    add(attributeCompartment);\n    Insets2D.Double insets = new Insets2D.Double(4, 8, 4, 8);\n    nameCompartment.set(LAYOUT_INSETS, insets);\n    attributeCompartment.set(LAYOUT_INSETS, insets);\n    TextFigure nameFigure;\n    nameCompartment.add(nameFigure = new TextFigure());\n    nameFigure.set(FONT_BOLD, true);\n    nameFigure.setAttributeEnabled(FONT_BOLD, false);\n    TextFigure durationFigure;\n    attributeCompartment.add(durationFigure = new TextFigure());\n    durationFigure.set(FONT_BOLD, true);\n    durationFigure.setText(""0"");\n    durationFigure.setAttributeEnabled(FONT_BOLD, false);\n    TextFigure startTimeFigure;\n    attributeCompartment.add(startTimeFigure = new TextFigure());\n    startTimeFigure.setEditable(false);\n    startTimeFigure.setText(""0"");\n    startTimeFigure.setAttributeEnabled(FONT_BOLD, false);\n    applyAttributes(this);\n    setAttributeEnabled(STROKE_DASHES, false);\n    ResourceBundleUtil labels =\n        ResourceBundleUtil.getBundle(""org.jhotdraw.samples.pert.Labels"");\n    setName(labels.getString(""pert.task.defaultName""));\n    setDuration(0);\n    dependencies = new HashSet<DependencyFigure>();\n    nameFigure.addFigureListener(new NameAdapter(this));\n    durationFigure.addFigureListener(new DurationAdapter(this));\n"
2524,writeRectAttributes,ImageMapOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java,268,299,6,"/**\n   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,\n   * <code>nohref</code> Attribute for the specified figure and rectangle.\n   *\n   * @return Returns true, if the rect is inside of the image bounds.\n   */",29,"  private boolean writeRectAttributes(IXMLElement elem, SVGFigure f, Rectangle2D.Double rect) {\n    AffineTransform t = TRANSFORM.getClone(f);\n    if (t == null) {\n      t = drawingTransform;\n    } else {\n      t.preConcatenate(drawingTransform);\n    }\n    if ((t.getType() &\n        (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==\n        t.getType()) {\n      Point2D.Double start = new Point2D.Double(rect.x, rect.y);\n      Point2D.Double end = new Point2D.Double(rect.x + rect.width, rect.y + rect.height);\n      t.transform(start, start);\n      t.transform(end, end);\n      Rectangle r = new Rectangle(\n          (int) Math.min(start.x, end.x),\n          (int) Math.min(start.y, end.y),\n          (int) Math.abs(start.x - end.x),\n          (int) Math.abs(start.y - end.y));\n      elem.setAttribute(""shape"", ""rect"");\n      elem.setAttribute(""coords"",\n          r.x + "","" +\n          r.y + "","" +\n          (r.x + r.width) + "","" +\n          (r.y + r.height));\n      writeHrefAttribute(elem, f);\n      return bounds.intersects(r);\n    } else {\n      return writePolyAttributes(elem, f, (Shape) rect);\n"
2525,getSuccessors,TaskFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java,307,315,4,/**\n   * Returns dependent PertTasks which are directly connected via a\n   * PertDependency to this TaskFigure.\n   */,8,  public List<TaskFigure> getSuccessors() {\n    LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();\n    for (DependencyFigure c : getDependencies()) {\n      if (c.getStartFigure() == this) {\n        list.add((TaskFigure) c.getEndFigure());\n      }\n    }\n    return list;\n
2527,getPredecessors,TaskFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/figures/TaskFigure.java,322,330,4,/**\n   * Returns predecessor PertTasks which are directly connected via a\n   * PertDependency to this TaskFigure.\n   */,8,  public List<TaskFigure> getPredecessors() {\n    LinkedList<TaskFigure> list = new LinkedList<TaskFigure>();\n    for (DependencyFigure c : getDependencies()) {\n      if (c.getEndFigure() == this) {\n        list.add((TaskFigure) c.getStartFigure());\n      }\n    }\n    return list;\n
2528,writePolyAttributes,ImageMapOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java,324,369,6,"/**\n   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,\n   * <code>nohref</code> Attribute for the specified figure and shape.\n   *\n   * @return Returns true, if the polygon is inside of the image bounds.\n   */",45,"  private boolean writePolyAttributes(IXMLElement elem, SVGFigure f, Shape shape) {\n    AffineTransform t = TRANSFORM.getClone(f);\n    if (t == null) {\n      t = drawingTransform;\n    } else {\n      t.preConcatenate(drawingTransform);\n    }\n    StringBuilder buf = new StringBuilder();\n    float[] coords = new float[6];\n    Path2D.Double path = new Path2D.Double();\n    for (PathIterator i = shape.getPathIterator(t, 1.5f);\n        !i.isDone(); i.next()) {\n      switch (i.currentSegment(coords)) {\n        case PathIterator.SEG_MOVETO:\n          if (buf.length() != 0) {\n            throw new IllegalArgumentException(""Illegal shape "" + shape);\n          }\n          if (buf.length() != 0) {\n            buf.append(\',\');\n          }\n          buf.append((int) coords[0]);\n          buf.append(\',\');\n          buf.append((int) coords[1]);\n          path.moveTo(coords[0], coords[1]);\n          break;\n        case PathIterator.SEG_LINETO:\n          if (buf.length() != 0) {\n            buf.append(\',\');\n          }\n          buf.append((int) coords[0]);\n          buf.append(\',\');\n          buf.append((int) coords[1]);\n          path.lineTo(coords[0], coords[1]);\n          break;\n        case PathIterator.SEG_CLOSE:\n          path.closePath();\n          break;\n        default:\n          throw new InternalError(""Illegal segment type "" + i.currentSegment(coords));\n      }\n    }\n    elem.setAttribute(""shape"", ""poly"");\n    elem.setAttribute(""coords"", buf.toString());\n    writeHrefAttribute(elem, f);\n    return path.intersects(new Rectangle2D.Float(bounds.x, bounds.y, bounds.width, bounds.height));\n"
2529,write,ImageMapOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java,108,143,7,"/**\n   * Writes the figures to the specified output stream.\n   * This method applies the specified drawingTransform to the drawing, and draws\n   * it on an image of the specified getChildCount.\n   * \n   * All other write methods delegate their work to here.\n   */",30,"  public void write(OutputStream out, java.util.List<Figure> figures,\n      AffineTransform drawingTransform, Dimension imageSize) throws IOException {\n    this.drawingTransform = (drawingTransform == null) ? new AffineTransform() : drawingTransform;\n    this.bounds = (imageSize == null) ? new Rectangle(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE) : new Rectangle(0, 0, imageSize.width, imageSize.height);\n    XMLElement document = new XMLElement(""map"");\n    // Note: Image map elements need to be written from front to back\n    for (Figure f : new ReversedList<Figure>(figures)) {\n      writeElement(document, f);\n    }\n    // Strip AREA elements with ""nohref"" attributes from the end of the\n    // map\n    if (!isIncludeNohref) {\n      for (int i = document.getChildrenCount() - 1; i >= 0; i--) {\n        XMLElement child = (XMLElement) document.getChildAtIndex(i);\n        if (child.hasAttribute(""nohref"")) {\n          document.removeChildAtIndex(i);\n        }\n      }\n    }\n\n    // Write XML content\n    PrintWriter writer = new PrintWriter(\n        new OutputStreamWriter(out, ""UTF-8""));\n    //new XMLWriter(writer).write(document);\n    for (Object o : document.getChildren()) {\n      XMLElement child = (XMLElement) o;\n      new XMLWriter(writer).write(child);\n    }\n    // Flush writer\n    writer.flush();\n"
2530,write,ImageMapOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java,96,98,5,"/**\n   * Writes the drawing to the specified output stream.\n   * This method applies the specified drawingTransform to the drawing, and draws\n   * it on an image of the specified getChildCount.\n   */",3,"  public void write(OutputStream out, Drawing drawing,\n      AffineTransform drawingTransform, Dimension imageSize) throws IOException {\n    write(out, drawing.getChildren(), drawingTransform, imageSize);\n"
2531,writeCircleAttributes,ImageMapOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java,228,258,6,"/**\n   * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,\n   * <code>nohref</code> Attribute for the specified figure and ellipse.\n   *\n   * @return Returns true, if the circle is inside of the image bounds.\n   */",28,"  private boolean writeCircleAttributes(IXMLElement elem, SVGFigure f, Ellipse2D.Double ellipse) {\n    AffineTransform t = TRANSFORM.getClone(f);\n    if (t == null) {\n      t = drawingTransform;\n    } else {\n      t.preConcatenate(drawingTransform);\n    }\n    if ((t.getType() &\n        (AffineTransform.TYPE_UNIFORM_SCALE | AffineTransform.TYPE_TRANSLATION)) ==\n        t.getType() &&\n        ellipse.width == ellipse.height) {\n      Point2D.Double start = new Point2D.Double(ellipse.x, ellipse.y);\n      Point2D.Double end = new Point2D.Double(ellipse.x + ellipse.width, ellipse.y + ellipse.height);\n      t.transform(start, start);\n      t.transform(end, end);\n      ellipse.x = Math.min(start.x, end.x);\n      ellipse.y = Math.min(start.y, end.y);\n      ellipse.width = Math.abs(start.x - end.x);\n      ellipse.height = Math.abs(start.y - end.y);\n      elem.setAttribute(""shape"", ""circle"");\n      elem.setAttribute(""coords"",\n          (int) (ellipse.x + ellipse.width / 2d) + "","" +\n          (int) (ellipse.y + ellipse.height / 2d) + "","" +\n          (int) (ellipse.width / 2d));\n      writeHrefAttribute(elem, f);\n      return bounds.intersects(ellipse.getBounds());\n    } else {\n      return writePolyAttributes(elem, f, (Shape) ellipse);\n"
2532,write,ImageMapOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/ImageMapOutputFormat.java,149,168,3,/**\n   * All other write methods delegate their work to here.\n   */,17,"  public void write(OutputStream out, java.util.List<Figure> figures) throws IOException {\n    Rectangle2D.Double drawingRect = null;\n    for (Figure f : figures) {\n      if (drawingRect == null) {\n        drawingRect = f.getBounds();\n      } else {\n        drawingRect.add(f.getBounds());\n      }\n    }\n    AffineTransform drawingTransform = new AffineTransform();\n    drawingTransform.translate(\n        -Math.min(0, drawingRect.x),\n        -Math.min(0, drawingRect.y));\n    write(out, figures, drawingTransform,\n        new Dimension(\n        (int) (Math.abs(drawingRect.x) + drawingRect.width),\n        (int) (Math.abs(drawingRect.y) + drawingRect.height)));\n"
2534,getDefaultPropertyIndex,ViewToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java,140,141,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2535,getPropertyDescriptors,ViewToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java,106,107,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2536,getMethodDescriptors,ViewToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java,128,129,7,/**\n   * Gets the bean's <code>MethodDescriptor</code>s.\n   *\n   * @return  An array of MethodDescriptors describing the methods\n   * implemented by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public MethodDescriptor[] getMethodDescriptors() {\n    return getMdescriptor();\n
2537,getBeanDescriptor,ViewToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java,90,91,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2538,readMasterPageElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,562,564,11,"/**\n   * Reads a &lt;style:master-page&gt; element from the specified\n   * XML element.\n   * <p>\n   *\n   * @param elem A &lt;page-layout&gt; element.\n   * @param styles Style attributes to be filled in by this method.\n   */\n --------------\n//if (DEBUG) System.out.println(""ODGStylesReader unsupported <""+elem.getName()+""> element."");\n --------------",3,"  private void readMasterPageElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> element."");\n"
2540,getEventSetDescriptors,ViewToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java,117,118,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2543,readStylesElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,441,442,9,/**\n   * Reads a &lt;styles&gt; element from the specified\n   * XML element.\n   * <p>\n   * The styles element contains common styles.\n   *\n   *\n   * @param elem A &lt;styles&gt; element.\n   */,2,"  private void readStylesElement(IXMLElement elem) throws IOException {\n    readStylesChildren(elem, commonStyles);\n"
2544,getDefaultEventIndex,ViewToolBarBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBarBeanInfo.java,151,152,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2545,readMasterStylesElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,534,535,9,/**\n   * Reads a &lt;master-styles&gt; element from the specified\n   * XML element.\n   * <p>\n   * The master-styles element contains master styles.\n   *\n   *\n   * @param elem A &lt;master-styles&gt; element.\n   */,2,"  private void readMasterStylesElement(IXMLElement elem) throws IOException {\n    readStylesChildren(elem, masterStyles);\n"
2546,read,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,165,174,8,/**\n   * Reads a &lt;document-styles&gt; element from the specified\n   * XML element.\n   *\n   *\n   * @param root A &lt;document&gt; element or a\n   * &lt;document-styles&gt; element.\n   */,10,"  public void read(IXMLElement root) throws IOException {\n    String name = root.getName();\n    String ns = root.getNamespace();\n    if (name.equals(""document-content"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n      readDocumentContentElement(root);\n    } else if (name.equals(""document-styles"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n      readDocumentStylesElement(root);\n    } else {\n      if (DEBUG) {\n        System.out.println(""ODGStylesReader unsupported root element "" + root);\n"
2547,readGraphicPropertiesElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,316,368,7,/**\n   * Reads a &lt;style:graphic-properties&gt; element from the specified\n   * XML element.\n   * <p>\n   *\n   * @param elem A &lt;style:graphic-properties&gt; element.\n   */,50,"  private void readGraphicPropertiesElement(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {\n    // The attribute draw:stroke specifies the style of the stroke on the current object. The value\n    // none means that no stroke is drawn, and the value solid means that a solid stroke is drawn. If\n    // the value is dash, the stroke referenced by the draw:stroke-dash property is drawn.\n    if (elem.hasAttribute(""stroke"", DRAWING_NAMESPACE)) {\n      STROKE_STYLE.put(a, (StrokeStyle) elem.getAttribute(""stroke"", DRAWING_NAMESPACE, STROKE_STYLES, null));\n    }\n    // The attribute svg:stroke-width specifies the width of the stroke on\n    // the current object.\n    if (elem.hasAttribute(""stroke-width"", SVG_NAMESPACE)) {\n      STROKE_WIDTH.put(a, toLength(elem.getAttribute(""stroke-width"", SVG_NAMESPACE, null)));\n    }\n    // The attribute svg:stroke-color specifies the color of the stroke on\n    // the current object.\n    if (elem.hasAttribute(""stroke-color"", SVG_NAMESPACE)) {\n      STROKE_COLOR.put(a, toColor(elem.getAttribute(""stroke-color"", SVG_NAMESPACE, null)));\n    }\n    // FIXME read draw:marker-start-width, draw:marker-start-center, draw:marker-end-width,\n    // draw:marker-end-centre\n    // The attribute draw:fill specifies the fill style for a graphic\n    // object. Graphic objects that are not closed, such as a path without a\n    // closepath at the end, will not be filled. The fill operation does not\n    // automatically close all open subpaths by connecting the last point of\n    // the subpath with the first point of the subpath before painting the\n    // fill. The attribute has the following values:\n    //   none:   the drawing object is not filled.\n    //   solid:  the drawing object is filled with color specified by the\n    //        draw:fill-color attribute.\n    //   bitmap:   the drawing object is filled with the bitmap specified\n    //        by the draw:fill-image-name attribute.\n    //   gradient: the drawing object is filled with the gradient specified\n    //        by the draw:fill-gradient-name attribute.\n    //   hatch:  the drawing object is filled with the hatch specified by\n    //        the draw:fill-hatch-name attribute.\n    if (elem.hasAttribute(""fill"", DRAWING_NAMESPACE)) {\n      FILL_STYLE.put(a, (FillStyle) elem.getAttribute(""fill"", DRAWING_NAMESPACE, FILL_STYLES, null));\n    }\n    // The attribute draw:fill-color specifies the color of the fill for a\n    // graphic object. It is used only if the draw:fill attribute has the\n    // value solid.\n    if (elem.hasAttribute(""fill-color"", DRAWING_NAMESPACE)) {\n      FILL_COLOR.put(a, toColor(elem.getAttribute(""fill-color"", DRAWING_NAMESPACE, null)));\n    }\n    // FIXME read fo:padding-top, fo:padding-bottom, fo:padding-left,\n    // fo:padding-right\n    // FIXME read draw:shadow, draw:shadow-offset-x, draw:shadow-offset-y,\n    // draw:shadow-color\n    for (IXMLElement child : elem.getChildren()) {\n      String ns = child.getNamespace();\n      String name = child.getName();\n"
2548,readListStyleElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,519,521,8,/**\n   * Reads a &lt;text:list-style&gt; element from the specified\n   * XML element.\n   * <p>\n   *\n   * @param elem A &lt;list-style&gt; element.\n   * @param styles Style attributes to be filled in by this method.\n   */,3,"  private void readListStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> element."");\n"
2549,read,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,112,117,8,/**\n   * Reads a &lt;document-styles&gt; element from the specified\n   * XML file.\n   *\n   *\n   * @param file A XML file with a &lt;document&gt; root element\n   * or with a &lt;document-styles&gt; root element.\n   */,6,  public void read(File file) throws IOException {\n    BufferedInputStream in = new BufferedInputStream(new FileInputStream(file));\n    try {\n      read(in);\n    } finally {\n      in.close();\n
2551,readLayerSetElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,505,507,8,/**\n   * Reads a &lt;draw:layer-put&gt; element from the specified\n   * XML element.\n   * <p>\n   *\n   * @param elem A &lt;layer-put&gt; element.\n   * @param styles Style attributes to be filled in by this method.\n   */,3,"  private void readLayerSetElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> element."");\n"
2552,ODGStylesReader,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,76,77,1,/** Creates a new instance. */,2,  public ODGStylesReader() {\n    reset();\n
2553,readDrawingPagePropertiesElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,303,305,7,/**\n   * Reads a &lt;style:drawing-page-properties&gt; element from the specified\n   * XML element.\n   * <p>\n   *\n   * @param elem A &lt;style:drawing-page-properties&gt; element.\n   */,3,"  private void readDrawingPagePropertiesElement(IXMLElement elem, HashMap<AttributeKey, Object> a) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> element."");\n"
2554,read,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,129,148,8,/**\n   * Reads a &lt;document-styles&gt; element from the specified\n   * input stream.\n   *\n   *\n   * @param in A input stream with a &lt;document&gt; root element\n   * or with a &lt;document-styles&gt; root element.\n   */,20,"  public void read(InputStream in) throws IOException {\n    IXMLParser parser;\n    try {\n      parser = XMLParserFactory.createDefaultXMLParser();\n    } catch (Exception ex) {\n      InternalError e = new InternalError(""Unable to instantiate NanoXML Parser"");\n      e.initCause(ex);\n      throw e;\n    }\n    IXMLReader reader = new StdXMLReader(in);\n    parser.setReader(reader);\n    IXMLElement document;\n    try {\n      document = (IXMLElement) parser.parse();\n    } catch (XMLException ex) {\n      IOException e = new IOException(ex.getMessage());\n      e.initCause(ex);\n      throw e;\n    }\n    read(document);\n"
2555,toLength,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,627,652,9,"/**\n   * Returns a value as a length.\n   *\n   * &lt;define name=""length""&gt;\n   * &lt;data type=""string""&gt;\n   * &lt;param name=""pattern""&gt;-?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)((cm)|(mm)|(in)|\n   * (pt)|(pc)|(px))&lt;/param&gt;\n   *\n   */",24,"  private double toLength(String str) throws IOException {\n    double scaleFactor = 1d;\n    if (str == null || str.length() == 0) {\n      return 0d;\n    }\n    if (str.endsWith(""cm"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 35.43307;\n    } else if (str.endsWith(""mm"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 3.543307;\n    } else if (str.endsWith(""in"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 90;\n    } else if (str.endsWith(""pt"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 1.25;\n    } else if (str.endsWith(""pc"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 15;\n    } else if (str.endsWith(""px"")) {\n      str = str.substring(0, str.length() - 2);\n    }\n    return Double.parseDouble(str) * scaleFactor;\n"
2557,readDocumentContentElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,240,257,6,/**\n   * Reads a &lt;document-content&gt; element from the specified\n   * XML element.\n   *\n   * @param elem A &lt;document-content&gt; element.\n   */,17,"  private void readDocumentContentElement(IXMLElement elem) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader <"" + elem.getName() + "" ...>"");\n    }\n    for (IXMLElement child : elem.getChildren()) {\n      String ns = child.getNamespace();\n      String name = child.getName();\n      if (name.equals(""automatic-styles"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n        readAutomaticStylesElement(child);\n      } else if (name.equals(""master-styles"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n        readStylesElement(child);\n      } else if (name.equals(""styles"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n        readStylesElement(child);\n      }\n    }\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader </"" + elem.getName() + "">"");\n"
2558,readDefaultStyleElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,197,227,18,"/**\n   * Reads a &lt;default-style&gt; element from the specified\n   * XML element.\n   * <p>\n   * A default style specifies default formatting properties for a certain\n   * style family. These defaults are used if a formatting property is neither\n   * specified by an automatic nor a common style. Default styles exist for\n   * all style families that are represented by the &lt;style:style&gt;\n   * element specified in section 14.1.\n   * Default styles are represented by the &lt;style:default-style&gt;\n   * element. The only attribute supported by this element is style:family.\n   * Its meaning equals the one of the same attribute for the\n   * &lt;style:style&gt; element, and the same properties child elements are\n   * supported depending on the style family.\n   *\n   * @param elem A &lt;default-style&gt; element.\n   * @param styles Style attributes to be filled in by this method.\n   */",30,"  private void readDefaultStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {\n    String styleName = elem.getAttribute(""family"", STYLE_NAMESPACE, null);\n    String family = elem.getAttribute(""family"", STYLE_NAMESPACE, null);\n    String parentStyleName = elem.getAttribute(""parent-style-name"", STYLE_NAMESPACE, null);\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader <default-style family="" + styleName + "" ...>...</>"");\n    }\n    if (styleName != null) {\n      Style a = styles.get(styleName);\n      if (a == null) {\n        a = new Style();\n        a.name = styleName;\n        a.family = family;\n        a.parentName = parentStyleName;\n        styles.put(styleName, a);\n      }\n      for (IXMLElement child : elem.getChildren()) {\n        String ns = child.getNamespace();\n        String name = child.getName();\n        if (name.equals(""drawing-page-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readDrawingPagePropertiesElement(child, a);\n        } else if (name.equals(""graphic-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readGraphicPropertiesElement(child, a);\n        } else if (name.equals(""paragraph-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readParagraphPropertiesElement(child, a);\n        } else if (name.equals(""text-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readTextPropertiesElement(child, a);\n        } else {\n          if (DEBUG) {\n            System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> child "" + child);\n"
2559,readStylesChildren,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,453,478,8,"/**\n   * Reads the children of a styles element.\n   *\n   *\n   * @param elem A &lt;styles&gt;, &lt;automatic-styles&gt;,\n   * &lt;document-styles&gt; or a &lt;master-styles&gt; element.\n   * @param styles Styles to be filled in by this method.\n   */",26,"  private void readStylesChildren(IXMLElement elem,\n      HashMap<String, Style> styles) throws IOException {\n    for (IXMLElement child : elem.getChildren()) {\n      String ns = child.getNamespace();\n      String name = child.getName();\n      if (name.equals(""default-style"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n        readDefaultStyleElement(child, styles);\n      } else if (name.equals(""layer-set"") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {\n        readLayerSetElement(child, styles);\n      } else if (name.equals(""list-style"") && (ns == null || ns.equals(TEXT_NAMESPACE))) {\n        readListStyleElement(child, styles);\n      } else if (name.equals(""marker"") && (ns == null || ns.equals(DRAWING_NAMESPACE))) {\n        readMarkerElement(child, styles);\n      } else if (name.equals(""master-page"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n        readMasterPageElement(child, styles);\n      } else if (name.equals(""page-layout"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n        readPageLayoutElement(child, styles);\n        //} else if (name.equals(""paragraph-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n        //  readParagraphPropertiesElement(child, styles);\n      } else if (name.equals(""style"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n        readStyleElement(child, styles);\n        //} else if (name.equals(""text-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n        //  readTextPropertiesElement(child, styles);\n      } else {\n        if (DEBUG) {\n          System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> child: "" + child);\n"
2560,readAutomaticStylesElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,493,494,9,/**\n   * Reads a &lt;automatic-styles&gt; element from the specified\n   * XML element.\n   * <p>\n   * The automatic-styles element contains automatic styles.\n   *\n   *\n   * @param elem A &lt;automatic-styles&gt; element.\n   */,2,"  private void readAutomaticStylesElement(IXMLElement elem) throws IOException {\n    readStylesChildren(elem, automaticStyles);\n"
2561,readDocumentStylesElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,272,292,11,"/**\n   * Reads a &lt;document-styles&gt; element from the specified\n   * XML element.\n   * <p>\n   * The document-styles element contains all named styles of\n   * a document, along with the automatic styles needed for the named\n   * styles.\n   *\n   *\n   * @param elem A &lt;document-styles&gt; element.\n   */",21,"  private void readDocumentStylesElement(IXMLElement elem) throws IOException {\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader <"" + elem.getName() + "" ...>"");\n    }\n    for (IXMLElement child : elem.getChildren()) {\n      String ns = child.getNamespace();\n      String name = child.getName();\n      if (name.equals(""styles"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n        readStylesElement(child);\n      } else if (name.equals(""automatic-styles"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n        readAutomaticStylesElement(child);\n      } else if (name.equals(""master-styles"") && (ns == null || ns.equals(OFFICE_NAMESPACE))) {\n        readMasterStylesElement(child);\n      } else {\n        if (DEBUG) {\n          System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> child "" + child);\n        }\n      }\n    }\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader </"" + elem.getName() + "">"");\n"
2562,readStyleElement,ODGStylesReader,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/odg/io/ODGStylesReader.java,384,425,11,"/**\n   * Reads a &lt;styles&gt; element from the specified\n   * XML element.\n   * <p>\n   * The &lt;style:style&gt; element can represent paragraph, text, and\n   * graphic styles.\n   *\n   *\n   * @param elem A &lt;style&gt; element.\n   * @param styles Style attributes to be filled in by this method.\n   */",39,"  private void readStyleElement(IXMLElement elem, HashMap<String, Style> styles) throws IOException {\n    // The style:name attribute identifies the name of the style. This attribute, combined with the\n// style:family attribute, uniquely identifies a style. The <office:styles>,\n// <office:automatic-styles> and <office:master-styles> elements each must not\n// contain two styles with the same family and the same name.\n// For automatic styles, a name is generated during document export. If the document is exported\n// several times, it cannot be assumed that the same name is generated each time.\n// In an XML document, the name of each style is a unique name that may be independent of the\n// language selected for an office applications user interface. Usually these names are the ones used\n// for the English version of the user interface.\n    String styleName = elem.getAttribute(""name"", STYLE_NAMESPACE, null);\n    String family = elem.getAttribute(""family"", STYLE_NAMESPACE, null);\n    String parentStyleName = elem.getAttribute(""parent-style-name"", STYLE_NAMESPACE, null);\n    if (DEBUG) {\n      System.out.println(""ODGStylesReader <style name="" + styleName + "" ...>...</>"");\n    }\n    if (styleName != null) {\n      Style a = styles.get(styleName);\n      if (a == null) {\n        a = new Style();\n        a.name = styleName;\n        a.family = family;\n        a.parentName = parentStyleName;\n        styles.put(styleName, a);\n      }\n      for (IXMLElement child : elem.getChildren()) {\n        String ns = child.getNamespace();\n        String name = child.getName();\n        if (name.equals(""drawing-page-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readDrawingPagePropertiesElement(child, a);\n        } else if (name.equals(""graphic-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readGraphicPropertiesElement(child, a);\n        } else if (name.equals(""paragraph-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readParagraphPropertiesElement(child, a);\n        } else if (name.equals(""text-properties"") && (ns == null || ns.equals(STYLE_NAMESPACE))) {\n          readTextPropertiesElement(child, a);\n        } else {\n          if (DEBUG) {\n            System.out.println(""ODGStylesReader unsupported <"" + elem.getName() + ""> child "" + child);\n"
2565,createToolBars,PertApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertApplicationModel.java,134,160,5,/**\n   * Creates toolbars for the application.\n   * This class always returns an empty list. Subclasses may return other\n   * values.\n   */,25,"  public java.util.List<JToolBar> createToolBars(Application a, View pr) {\n    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.pert.Labels"");\n    PertView p = (PertView) pr;\n    DrawingEditor editor;\n    if (p == null) {\n      editor = getSharedEditor();\n    } else {\n      editor = p.getEditor();\n    }\n    LinkedList<JToolBar> list = new LinkedList<JToolBar>();\n    JToolBar tb;\n    tb = new JToolBar();\n    addCreationButtonsTo(tb, editor);\n    tb.setName(drawLabels.getString(""window.drawToolBar.title""));\n    list.add(tb);\n    tb = new JToolBar();\n    ButtonFactory.addAttributesButtonsTo(tb, editor);\n    tb.setName(drawLabels.getString(""window.attributesToolBar.title""));\n    list.add(tb);\n    tb = new JToolBar();\n    ButtonFactory.addAlignmentButtonsTo(tb, editor);\n    tb.setName(drawLabels.getString(""window.alignmentToolBar.title""));\n    list.add(tb);\n    return list;\n"
2566,Matcher,Matcher,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java,74,87,8,/**\n   * Creates a new instance of Matcher\n   *\n   * @param document The document to be examined\n   * @param findString The string to be searched.\n   * @param matchCase Set to true for case sensitive search.\n   * @param matchType Sets the match type.\n   */,14,"  public Matcher(Document document, String findString, boolean matchCase, MatchType matchType) {\n    this.document = document;\n    this.findString = findString;\n    startIndex = 0;\n    \n    // Convert to chars for efficiency\n    if (matchCase) {\n      matchLowerCase = matchUpperCase = findString.toCharArray();\n    } else {\n      matchUpperCase = findString.toUpperCase().toCharArray();\n      matchLowerCase = findString.toLowerCase().toCharArray();\n    }\n    \n    this.matchType = matchType;\n"
2567,Matcher,Matcher,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java,62,63,7,/**\n   * Creates a new instance of Matcher which\n   * performs a case sensitive search.\n   *\n   * @param document The document to be examined\n   * @param findString The string to be searched.\n   */,2,"  public Matcher(Document document, String findString) {\n    this(document, findString, true, MatchType.CONTAINS);\n"
2568,findNext,Matcher,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java,117,119,9,"/**\n   * Resets this matcher and then attempts to find the next\n   * subsequence of the input sequence that matches the pattern,\n   * starting at the specified index.\n   *\n   * @param startIndex the index from which to start the search.\n   * @return the index of the first occurrence of the search string,\n   * starting at the specified offset, or -1 if no occurrence was found.\n   */",3,  public int findNext(int startIndex) {\n    this.startIndex = startIndex;\n    return findNext();\n
2569,findNext,Matcher,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java,134,193,13,"/**\n   * Attempts to find the next subsequence of the\n   * input sequence that matches the pattern.\n   * <p>\n   * This method starts at the beginning of\n   * the input sequence or, if a previous invocation\n   * of the method was successful and the matcher has not\n   * since been reset, at the first character not matched by\n   * the previous match.\n   *\n   * @return the index of the first occurrence of the search string,\n   * starting at the specified offset, or -1 if no occurrence was found.\n   */",60,"  public int findNext() {\n    // Don't match empty strings and don't match if we are at the end of the document.\n    if (findString.length() == 0 ||\n    document.getLength() - findString.length() < startIndex) {\n      return -1;\n    }\n    \n    try {\n      int nextMatch = 0; // index of next matching character\n      \n      // Iterate through all segments of the document starting from offset\n      Segment text = new Segment();\n      text.setPartialReturn(true);\n      int offset = startIndex;\n      int nleft = document.getLength() - startIndex;\n      while (nleft > 0) {\n        document.getText(offset, nleft, text);\n        \n        // Iterate through the characters in the current segment\n        char next = text.first();\n        for (text.first(); next != Segment.DONE; next = text.next()) {\n          \n          // Check if the current character matches with the next\n          // search character.\n          char current = text.current();\n          if (current == matchUpperCase[nextMatch] ||\n          current == matchLowerCase[nextMatch]) {\n            nextMatch++;\n            \n            // Did we match all search characters?\n            if (nextMatch == matchLowerCase.length) {\n              int foundIndex = text.getIndex() - text.getBeginIndex() + offset -\n              matchLowerCase.length + 1;\n              if (matchType == MatchType.CONTAINS) {\n                return foundIndex;\n                // break; <- never reached\n              } else if (matchType == MatchType.STARTS_WITH) {\n                if (! isWordChar(foundIndex - 1)) {\n                  return foundIndex;\n                }\n              } else if (matchType == MatchType.FULL_WORD) {\n                if (! isWordChar(foundIndex - 1) &&\n                ! isWordChar(foundIndex + matchLowerCase.length)) {\n                  return foundIndex;\n                }\n              }\n              nextMatch = 0;\n            }\n          } else {\n            nextMatch = 0;\n          }\n        }\n        \n        // Move forward to the next segment\n        nleft -= text.count;\n        offset += text.count;\n      }\n      return -1;\n    } catch (BadLocationException e) {\n      throw new IndexOutOfBoundsException();\n"
2570,findPrevious,Matcher,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java,205,207,9,"/**\n   * Resets this matcher and then attempts to find the previous\n   * subsequence of the input sequence that matches the pattern,\n   * starting at the specified index.\n   *\n   * @param startIndex the index from which to start the search.\n   * @return the index of the first occurrence of the search string,\n   * starting at the specified offset, or -1 if no occurrence was found.\n   */",3,  public int findPrevious(int startIndex) {\n    this.startIndex = startIndex;\n    return findPrevious();\n
2571,createPageable,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,125,126,3,/**\n   * Creates a Pageable object for printing this view.\n   */,2,  public Pageable createPageable() {\n    return new DrawingPageable(view.getDrawing());\n
2572,initActions,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,171,173,3,/**\n   * Initializes view specific actions.\n   */,3,"  private void initActions() {\n    getActionMap().put(UndoAction.ID, undo.getUndoAction());\n    getActionMap().put(RedoAction.ID, undo.getRedoAction());\n"
2573,findPrevious,Matcher,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java,222,276,13,"/**\n   * Attempts to find the previous subsequence of the\n   * input sequence that matches the pattern.\n   * <p>\n   * This method starts at the beginning of\n   * the input sequence or, if a previous invocation\n   * of the method was successful and the matcher has not\n   * since been reset, at the first character not matched by\n   * the previous match.\n   *\n   * @return the index of the first occurrence of the search string,\n   * starting at the specified offset, or -1 if no occurrence was found.\n   */",55,"  public int findPrevious() {\n    // Don\'t match empty strings and don\'t match if we are at the beginning of the document.\n    if (findString.length() == 0 ||\n    startIndex < findString.length() - 1) {\n      //System.out.println(""too close to start"");\n      return -1;\n    }\n    \n    try {\n      int nextMatch = matchLowerCase.length - 1; // index of next matching character\n      \n      // For simplicity, we request all text of the document in a single\n      // segment.\n      Segment text = new Segment();\n      text.setPartialReturn(false);\n      document.getText(0, startIndex + 1, text);\n      \n      // Iterate through the characters in the current segment\n      char previous = text.last();\n      //System.out.println(""previus isch ""+previous);\n      for (text.last(); previous != Segment.DONE; previous = text.previous()) {\n        \n        // Check if the current character matches with the next\n        // search character.\n        char current = text.current();\n        if (current == matchUpperCase[nextMatch] ||\n        current == matchLowerCase[nextMatch]) {\n          nextMatch--;\n          //System.out.println(""matched ""+nextMatch);\n          // Did we match all search characters?\n          if (nextMatch == -1) {\n            int foundIndex = text.getIndex() - text.getBeginIndex();\n            //System.out.println(""found index:""+foundIndex);\n            if (matchType == MatchType.CONTAINS) {\n              return foundIndex;\n            } else if (matchType == MatchType.STARTS_WITH) {\n              if (! isWordChar(foundIndex - 1)) {\n                return foundIndex;\n              }\n            } else if (matchType == MatchType.FULL_WORD) {\n              if (! isWordChar(foundIndex - 1) &&\n              ! isWordChar(foundIndex + matchLowerCase.length)) {\n                return foundIndex;\n              }\n            }\n            nextMatch = matchLowerCase.length - 1;\n          }\n        } else {\n          nextMatch = matchLowerCase.length - 1;\n        }\n      }\n      \n      return -1;\n    } catch (BadLocationException e) {\n      throw new IndexOutOfBoundsException();\n"
2574,clear,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,225,242,3,/**\n   * Clears the view.\n   */,17,  @Override\n  public void clear() {\n    final Drawing newDrawing = createDrawing();\n    try {\n      SwingUtilities.invokeAndWait(new Runnable() {\n        @Override\n        public void run() {\n          view.getDrawing().removeUndoableEditListener(undo);\n          view.setDrawing(newDrawing);\n          view.getDrawing().addUndoableEditListener(undo);\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InvocationTargetException ex) {\n      ex.printStackTrace();\n    } catch (InterruptedException ex) {\n      ex.printStackTrace();\n
2575,setStartIndex,Matcher,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/regex/Matcher.java,104,105,3,"/**\n   * Sets the start index for the findNext(), findPrevious() methods.\n   */",2,  public void setStartIndex(int newValue) {\n    startIndex = newValue;\n
2576,read,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,195,218,3,/**\n   * Reads the view from the specified uri.\n   */,23,"  @Override\n  public void read(URI f, URIChooser chooser) throws IOException {\n    try {\n      final Drawing drawing = createDrawing();\n      InputFormat inputFormat = drawing.getInputFormats().get(0);\n      inputFormat.read(new File(f), drawing, true);\n      SwingUtilities.invokeAndWait(new Runnable() {\n        @Override\n        public void run() {\n          view.getDrawing().removeUndoableEditListener(undo);\n          view.setDrawing(drawing);\n          view.getDrawing().addUndoableEditListener(undo);\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InterruptedException e) {\n      InternalError error = new InternalError();\n      e.initCause(e);\n      throw error;\n    } catch (InvocationTargetException e) {\n      InternalError error = new InternalError();\n      e.initCause(e);\n      throw error;\n"
2577,getLeftInset,NumberedParagraphView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/text/NumberedParagraphView.java,41,43,5,/**\n   * Gets the left inset.\n   *\n   * @return the inset >= 0\n   */,3,  protected short getLeftInset() {\n    short left = super.getLeftInset();\n    return (viewFactory.isLineNumbersVisible()) ? (short) (left + NUMBERS_WIDTH) : left;\n
2578,PertView,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,64,102,3,/**\n   * Creates a new view.\n   */,33,"  public PertView() {\n    initComponents();\n    JPanel zoomButtonPanel = new JPanel(new BorderLayout());\n    scrollPane.setLayout(new PlacardScrollPaneLayout());\n    scrollPane.setBorder(new EmptyBorder(0, 0, 0, 0));\n    setEditor(new DefaultDrawingEditor());\n    undo = new UndoRedoManager();\n    view.setDrawing(createDrawing());\n    view.getDrawing().addUndoableEditListener(undo);\n    initActions();\n    undo.addPropertyChangeListener(new PropertyChangeListener() {\n      @Override\n      public void propertyChange(PropertyChangeEvent evt) {\n        setHasUnsavedChanges(undo.hasSignificantEdits());\n      }\n    });\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    JPanel placardPanel = new JPanel(new BorderLayout());\n    javax.swing.AbstractButton pButton;\n    pButton = ButtonFactory.createZoomButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"", ""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"", new Insets(0, 0, 0, 0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    placardPanel.add(pButton, BorderLayout.WEST);\n    pButton = ButtonFactory.createToggleGridButton(view);\n    pButton.putClientProperty(""Quaqua.Button.style"", ""placard"");\n    pButton.putClientProperty(""Quaqua.Component.visualMargin"", new Insets(0, 0, 0, 0));\n    pButton.setFont(UIManager.getFont(""SmallSystemFont""));\n    labels.configureToolBarButton(pButton, ""view.toggleGrid.placard"");\n    placardPanel.add(pButton, BorderLayout.EAST);\n    scrollPane.add(placardPanel, JScrollPane.LOWER_LEFT_CORNER);\n    setGridVisible(preferences.getBoolean(""view.gridVisible"", false));\n    setScaleFactor(preferences.getDouble(""view.scaleFactor"", 1d));\n"
2579,write,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,185,189,3,/**\n   * Writes the view to the specified uri.\n   */,5,"  @Override\n  public void write(URI f, URIChooser chooser) throws IOException {\n    Drawing drawing = view.getDrawing();\n    OutputFormat outputFormat = drawing.getOutputFormats().get(0);\n    outputFormat.write(new File(f), drawing);\n"
2580,initComponents,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,257,268,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,8,"  private void initComponents() {\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n    scrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n"
2581,createDrawing,PertView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/pert/PertView.java,108,119,3,/**\n   * Creates a new Drawing for this view.\n   */,12,  protected Drawing createDrawing() {\n    DefaultDrawing drawing = new DefaultDrawing();\n    DOMStorableInputOutputFormat ioFormat =\n        new DOMStorableInputOutputFormat(new PertFactory());\n    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();\n    inputFormats.add(ioFormat);\n    drawing.setInputFormats(inputFormats);\n    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();\n    outputFormats.add(ioFormat);\n    outputFormats.add(new ImageOutputFormat());\n    drawing.setOutputFormats(outputFormats);\n    return drawing;\n
2582,getScaleFactor,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,130,131,3,/**\n   * Returns the scale factor of the number formatter.\n   */,2,  public double getScaleFactor() {\n    return scaleFactor;\n
2583,getMinimum,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,89,90,5,/**\n   * Returns the minimum permissible value.\n   *\n   * @return Minimum legal value that can be input\n   */,2,  public Comparable getMinimum() {\n    return min;\n
2584,setMinimum,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,77,81,9,"/**\n   * Sets the minimum permissible value. If the <code>valueClass</code> has\n   * not been specified, and <code>minimum</code> is non null, the\n   * <code>valueClass</code> will be set to that of the class of\n   * <code>minimum</code>.\n   *\n   * @param minimum Minimum legal value that can be input\n   * @see #setValueClass\n   */",5,  public void setMinimum(Comparable minimum) {\n    if (getValueClass() == null && minimum != null) {\n      setValueClass(minimum.getClass());\n    }\n    min = minimum;\n
2585,valueToString,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,175,215,8,/**\n   * Returns a String representation of the Object <code>value</code>.\n   * This invokes <code>format</code> on the current <code>Format</code>.\n   *\n   * @throws ParseException if there is an error in the conversion\n   * @param value Value to convert\n   * @return String representation of value\n   */,39,"  @Override\n  public String valueToString(Object value) throws ParseException {\n    if (value == null && allowsNullValue) {\n      return """";\n    }\n    if (value instanceof Double) {\n      double v = ((Double) value).doubleValue();\n      v *= scaleFactor;\n      String str = Double.toString(v);\n      if (!appendsDotZero && str.endsWith("".0"")) {\n        str = str.substring(0, str.length() - 2);\n      }\n      return str;\n    } else if (value instanceof Float) {\n      float v = ((Float) value).floatValue();\n      v = (float) (v * scaleFactor);\n      String str = Float.toString(v);\n      if (appendsDotZero && str.endsWith("".0"")) {\n        str = str.substring(0, str.length() - 2);\n      }\n      return str;\n    } else if (value instanceof Long) {\n      long v = ((Long) value).longValue();\n      v = (long) (v * scaleFactor);\n      return Long.toString(v);\n    } else if (value instanceof Integer) {\n      int v = ((Integer) value).intValue();\n      v = (int) (v * scaleFactor);\n      return Integer.toString(v);\n    } else if (value instanceof Byte) {\n      byte v = ((Byte) value).byteValue();\n      v = (byte) (v * scaleFactor);\n      return Byte.toString(v);\n    } else if (value instanceof Short) {\n      short v = ((Short) value).shortValue();\n      v = (short) (v * scaleFactor);\n      return Short.toString(v);\n    }\n    throw new ParseException(""Value is of unsupported class "" + value, 0);\n"
2586,setMaximum,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,102,106,9,"/**\n   * Sets the maximum permissible value. If the <code>valueClass</code> has\n   * not been specified, and <code>max</code> is non null, the\n   * <code>valueClass</code> will be set to that of the class of\n   * <code>max</code>.\n   *\n   * @param max Maximum legal value that can be input\n   * @see #setValueClass\n   */",5,  public void setMaximum(Comparable max) {\n    if (getValueClass() == null && max != null) {\n      setValueClass(max.getClass());\n    }\n    this.max = max;\n
2587,isValidValue,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,286,312,7,"/**\n   * Returns true if <code>value</code> is between the min/max.\n   *\n   * @param wantsCCE If false, and a ClassCastException is thrown in\n   *         comparing the values, the exception is consumed and\n   *         false is returned.\n   */",25,"  @SuppressWarnings(""unchecked"")\n  boolean isValidValue(Object value, boolean wantsCCE) {\n    Comparable min = getMinimum();\n    try {\n      if (min != null && min.compareTo(value) > 0) {\n        return false;\n      }\n    } catch (ClassCastException cce) {\n      if (wantsCCE) {\n        throw cce;\n      }\n      return false;\n    }\n    Comparable max = getMaximum();\n    try {\n      if (max != null && max.compareTo(value) < 0) {\n        return false;\n      }\n    } catch (ClassCastException cce) {\n      if (wantsCCE) {\n        throw cce;\n      }\n      return false;\n    }\n    return true;\n"
2588,getAllowsNullValue,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,146,147,3,/**\n   * Returns true if null values are allowed.\n   */,2,  public boolean getAllowsNullValue() {\n    return allowsNullValue;\n
2590,stringToValue,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,226,276,8,/**\n   * Returns the <code>Object</code> representation of the\n   * <code>String</code> <code>text</code>.\n   *\n   * @param text <code>String</code> to convert\n   * @return <code>Object</code> representation of text\n   * @throws ParseException if there is an error in the conversion\n   */,50,"  @Override\n  public Object stringToValue(String text) throws ParseException {\n    if ((text == null || text.length() == 0) && getAllowsNullValue()) {\n      return null;\n    }\n    Class valueClass = getValueClass();\n    Object value;\n    if (valueClass != null) {\n      try {\n        if (valueClass == Integer.class) {\n          int v = Integer.parseInt(text);\n          v = (int) (v / scaleFactor);\n          value = new Integer(v);\n        } else if (valueClass == Long.class) {\n          long v = Long.parseLong(text);\n          v = (long) (v / scaleFactor);\n          value = new Long(v);\n        } else if (valueClass == Float.class) {\n          float v = Float.parseFloat(text);\n          v = (float) (v / scaleFactor);\n          value = new Float(v);\n        } else if (valueClass == Double.class) {\n          double v = Double.parseDouble(text);\n          v = (double) (v / scaleFactor);\n          value = new Double(v);\n        } else if (valueClass == Byte.class) {\n          byte v = Byte.parseByte(text);\n          v = (byte) (v / scaleFactor);\n          value = new Byte(v);\n        } else if (valueClass == Short.class) {\n          short v = Short.parseShort(text);\n          v = (short) (v / scaleFactor);\n          value = new Short(v);\n        } else {\n          throw new ParseException(""Unsupported value class "" + valueClass, 0);\n        }\n      } catch (NumberFormatException e) {\n        throw new ParseException(e.getMessage(), 0);\n      }\n    } else {\n      throw new ParseException(""Unsupported value class "" + valueClass, 0);\n    }\n    try {\n      if (!isValidValue(value, true)) {\n        throw new ParseException(""Value not within min/max range"", 0);\n      }\n    } catch (ClassCastException cce) {\n      throw new ParseException(""Class cast exception comparing values: "" + cce, 0);\n    }\n    return value;\n"
2591,JavaNumberFormatter,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,58,65,3,/**\n   * Creates a NumberFormatter with the specified Format instance.\n   */,8,"  public JavaNumberFormatter(double min, double max, double scaleFactor, boolean allowsNullValue, boolean appendsDotZero) {\n    super();\n    setMinimum(min);\n    setMaximum(max);\n    setScaleFactor(scaleFactor);\n    setAllowsNullValue(allowsNullValue);\n    setAppendsDotZero(appendsDotZero);\n    setOverwriteMode(false);\n"
2592,createFormatterFactory,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,320,321,5,"/**\n   * Convenience method for creating a formatter factory with a\n   * {@code ScalableNumberFormatter} and a Java-style DecimalFormat.\n   * Doesn\'t allow null values and doesn\'t append "".0"" to double and float values.\n   */",2,"  public static AbstractFormatterFactory createFormatterFactory(double min, double max, double scaleFactor) {\n    return createFormatterFactory(min, max, scaleFactor, false, false);\n"
2593,setAppendsDotZero,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,156,157,6,"/**\n   * Specifies whether "".0"" is appended to double and float\n   * values. By default this is true.\n   *\n   * @param newValue\n   */",2,  public void setAppendsDotZero(boolean newValue) {\n    appendsDotZero = newValue;\n
2594,getMaximum,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,114,115,5,/**\n   * Returns the maximum permissible value.\n   *\n   * @return Maximum legal value that can be input\n   */,2,  public Comparable getMaximum() {\n    return max;\n
2595,JavaNumberFormatter,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,51,52,3,/**\n   * Creates a NumberFormatter with the specified Format instance.\n   */,2,"  public JavaNumberFormatter(double min, double max, double scaleFactor) {\n    this(min, max, scaleFactor, false, true);\n"
2596,setScaleFactor,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,123,124,5,/**\n   * Changes the scale factor of the number formatter.\n   *\n   * @param newValue\n   */,2,  public void setScaleFactor(double newValue) {\n    scaleFactor = newValue;\n
2597,getAppendsDotZero,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,163,164,3,/**\n   * Returns true if null values are allowed.\n   */,2,  public boolean getAppendsDotZero() {\n    return appendsDotZero;\n
2598,setAllowsNullValue,JavaNumberFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/JavaNumberFormatter.java,139,140,5,/**\n   * Allows/Disallows null values.\n   *\n   * @param newValue\n   */,2,  public void setAllowsNullValue(boolean newValue) {\n    allowsNullValue = newValue;\n
2599,write,LFWriter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java,63,76,5,/**\n   * Write a single character.\n   *\n   * @exception  IOException  If an I/O error occurs\n   */,14,  public void write(int c) throws IOException {\n    switch (c) {\n      case '\\r':\n        out.write(lineSeparator);\n        skipLF = true;\n        break;\n      case '\\n':\n        if (!skipLF) out.write(lineSeparator);\n        skipLF = false;\n        break;\n      default :\n        out.write(c);\n        skipLF = false;\n        break;\n
2600,write,LFWriter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java,89,113,9,/**\n   * Write a portion of an array of characters.\n   *\n   * @param  cbuf  Buffer of characters to be written\n   * @param  off   Offset from which to start reading characters\n   * @param  len   Number of characters to be written\n   *\n   * @exception  IOException  If an I/O error occurs\n   */,25,"  public void write(char cbuf[], int off, int len) throws IOException {\n    int end = off + len;\n    for (int i=off; i < end; i++) {\n      switch (cbuf[i]) {\n        case '\\r':\n          out.write(cbuf, off, i - off);\n          off = i + 1;\n          out.write(lineSeparator);\n          skipLF = true;\n          break;\n        case '\\n':\n          out.write(cbuf, off, i - off);\n          off = i + 1;\n          if (skipLF) {\n            skipLF = false;\n          } else {\n            out.write(lineSeparator);\n          }\n          break;\n        default :\n          skipLF = false;\n          break;\n      }\n    }\n    if (off < end) out.write(cbuf, off, end - off);\n"
2601,setLineSeparator,LFWriter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java,54,55,3,/**\n   * Sets the line separator for the println() methods.\n   */,2,  public void setLineSeparator(String lineSeparator) {\n    this.lineSeparator = lineSeparator;\n
2602,getLineSeparator,LFWriter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java,47,48,3,/**\n   * Gets the line separator of the println() methods.\n   */,2,  public String getLineSeparator() {\n    return lineSeparator;\n
2603,LFWriter,LFWriter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/teddy/io/LFWriter.java,39,41,3,/**\n   * Create a new line-numbering writer.\n   */,3,"  public LFWriter(Writer out) {\n    super(out);\n    lineSeparator = (String) System.getProperty(""line.separator"");\n"
2604,createFormatterFactory,FontFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java,166,167,5,/**\n   * Convenience method for creating a formatter factory with a\n   * {@code FontFormatter}.\n   * Uses the RGB_INTEGER format and disallows null values.\n   */,2,  public static AbstractFormatterFactory createFormatterFactory() {\n    return createFormatterFactory(false);\n
2605,getAllowsUnknownFont,FontFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java,92,93,3,"/**\n   * Returns true, if unknown font names are allowed.\n   */",2,  public boolean getAllowsUnknownFont() {\n    return allowsUnknownFont;\n
2606,clearGenericFontFamilies,FontFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java,97,98,1,/** Clears the generic font families map. */,2,  public void clearGenericFontFamilies() {\n    genericFontFamilies = null;\n
2607,getAllowsNullValue,FontFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java,77,78,3,"/**\n   * Returns true, if null value is allowed.\n   */",2,  public boolean getAllowsNullValue() {\n    return allowsNullValue;\n
2608,putGenericFontFamily,FontFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java,102,103,1,/** Adds a generic font family. */,2,"  public void putGenericFontFamily(String familyName, Font font) {\n    genericFontFamilies.put(familyName.toLowerCase(), font);\n"
2609,setAllowsNullValue,FontFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java,70,71,4,/**\n   * Sets whether a null value is allowed.\n   * @param newValue\n   */,2,  public void setAllowsNullValue(boolean newValue) {\n    allowsNullValue = newValue;\n
2610,setAllowsUnknownFont,FontFormatter,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/text/FontFormatter.java,85,86,4,/**\n   * Sets whether unknown font names are allowed.\n   * @param newValue\n   */,2,  public void setAllowsUnknownFont(boolean newValue) {\n    allowsUnknownFont = newValue;\n
2611,readSVGElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,507,588,3,"/**\n   * Reads an SVG ""svg"" element.\n   */",71,"  private Figure readSVGElement(IXMLElement elem)\n      throws IOException {\n    // Establish a new viewport\n    Viewport viewport = new Viewport();\n    String widthValue = readAttribute(elem, ""width"", ""100%"");\n    String heightValue = readAttribute(elem, ""height"", ""100%"");\n    viewport.width = toWidth(elem, widthValue);\n    viewport.height = toHeight(elem, heightValue);\n    if (readAttribute(elem, ""viewBox"", ""none"").equals(""none"")) {\n      viewport.viewBox.width = viewport.width;\n      viewport.viewBox.height = viewport.height;\n    } else {\n      String[] viewBoxValues = toWSOrCommaSeparatedArray(readAttribute(elem, ""viewBox"", ""none""));\n      viewport.viewBox.x = toNumber(elem, viewBoxValues[0]);\n      viewport.viewBox.y = toNumber(elem, viewBoxValues[1]);\n      viewport.viewBox.width = toNumber(elem, viewBoxValues[2]);\n      viewport.viewBox.height = toNumber(elem, viewBoxValues[3]);\n      // FIXME - Calculate percentages\n      if (widthValue.indexOf(\'%\') > 0) {\n        viewport.width = viewport.viewBox.width;\n      }\n      if (heightValue.indexOf(\'%\') > 0) {\n        viewport.height = viewport.viewBox.height;\n      }\n    }\n    if (viewportStack.size() == 1) {\n      // We always preserve the aspect ratio for to the topmost SVG element.\n      // This is not compliant, but looks much better.\n      viewport.isPreserveAspectRatio = true;\n    } else {\n      viewport.isPreserveAspectRatio = !readAttribute(elem, ""preserveAspectRatio"", ""none"").equals(""none"");\n    }\n    viewport.widthPercentFactor = viewport.viewBox.width / 100d;\n    viewport.heightPercentFactor = viewport.viewBox.height / 100d;\n    viewport.numberFactor = Math.min(\n        viewport.width / viewport.viewBox.width,\n        viewport.height / viewport.viewBox.height);\n    AffineTransform viewBoxTransform = new AffineTransform();\n    viewBoxTransform.translate(\n        -viewport.viewBox.x * viewport.width / viewport.viewBox.width,\n        -viewport.viewBox.y * viewport.height / viewport.viewBox.height);\n    if (viewport.isPreserveAspectRatio) {\n      double factor = Math.min(\n          viewport.width / viewport.viewBox.width,\n          viewport.height / viewport.viewBox.height);\n      viewBoxTransform.scale(factor, factor);\n    } else {\n      viewBoxTransform.scale(\n          viewport.width / viewport.viewBox.width,\n          viewport.height / viewport.viewBox.height);\n    }\n    viewportStack.push(viewport);\n    readViewportAttributes(elem, viewportStack.firstElement().attributes);\n\n    // Read the figures\n    for (IXMLElement node : elem.getChildren()) {\n      if (node instanceof IXMLElement) {\n        IXMLElement child = (IXMLElement) node;\n        Figure childFigure = readElement(child);\n        // skip invisible elements\n        if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") &&\n            !readAttribute(child, ""display"", ""inline"").equals(""none"")) {\n          if (childFigure != null) {\n            childFigure.transform(viewBoxTransform);\n            figures.add(childFigure);\n          }\n        }\n      }\n    }\n    viewportStack.pop();\n    return null;\n"
2612,toDouble,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,3215,3220,3,/**\n   * Reads a double attribute.\n   */,6,"  private double toDouble(IXMLElement elem, String value, double defaultValue, double min, double max) throws IOException {\n    try {\n      double d = Double.valueOf(value);\n      return Math.max(Math.min(d, max), min);\n    } catch (NumberFormatException e) {\n      return defaultValue;\n"
2613,readFontAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2968,3078,3,/* Reads font attributes as listed in\n   * http://www.w3.org/TR/SVGMobile12/feature.html#Font\n   */,104,"  private void readFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a)\n      throws IOException {\n    String value;\n    double doubleValue;\n    // \'font-family\'\n    // Value:    [[ <family-name> |\n    // <generic-family> ],]* [<family-name> |\n    // <generic-family>] | inherit\n    // Initial:    depends on user agent\n    // Applies to:    text content elements\n    // Inherited:    yes\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""font-family"", ""Dialog"");\n    String[] familyNames = toQuotedAndCommaSeparatedArray(value);\n    Font font = null;\n    // Try to find a font with exactly matching name\n    for (int i = 0; i < familyNames.length; i++) {\n      try {\n        font = (Font) fontFormatter.stringToValue(familyNames[i]);\n        break;\n      } catch (ParseException e) {\n      }\n    }\n    if (font == null) {\n      // Try to create a similar font using the first name in the list\n      if (familyNames.length > 0) {\n        fontFormatter.setAllowsUnknownFont(true);\n        try {\n          font = (Font) fontFormatter.stringToValue(familyNames[0]);\n        } catch (ParseException e) {\n        }\n        fontFormatter.setAllowsUnknownFont(false);\n      }\n    }\n    if (font == null) {\n      // Fallback to the system Dialog font\n      font = new Font(""Dialog"", Font.PLAIN, 12);\n    }\n    FONT_FACE.put(a, font);\n    // \'font-getChildCount\'\n    // Value:    <absolute-getChildCount> | <relative-getChildCount> |\n    // <length> | inherit\n    // Initial:    medium\n    // Applies to:    text content elements\n    // Inherited:    yes, the computed value is inherited\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     Absolute length\n    doubleValue = readInheritFontSizeAttribute(elem, ""font-size"", ""medium"");\n    FONT_SIZE.put(a, doubleValue);\n    // \'font-style\'\n    // Value:    normal | italic | oblique | inherit\n    // Initial:    normal\n    // Applies to:    text content elements\n    // Inherited:    yes\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""font-style"", ""normal"");\n    FONT_ITALIC.put(a, value.equals(""italic""));\n\n    //\'font-variant\'\n    //Value:    normal | small-caps | inherit\n    //Initial:    normal\n    //Applies to:    text content elements\n    //Inherited:    yes\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    no\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""font-variant"", ""normal"");\n    // if (DEBUG) System.out.println(""font-variant=""+value);\n    // \'font-weight\'\n    // Value:    normal | bold | bolder | lighter | 100 | 200 | 300\n    // | 400 | 500 | 600 | 700 | 800 | 900 | inherit\n    // Initial:    normal\n    // Applies to:    text content elements\n    // Inherited:    yes\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     one of the legal numeric values, non-numeric\n    // values shall be converted to numeric values according to the rules\n    // defined below.\n    value = readInheritAttribute(elem, ""font-weight"", ""normal"");\n    FONT_BOLD.put(a, value.equals(""bold"") || value.equals(""bolder"") ||\n        value.equals(""400"") || value.equals(""500"") || value.equals(""600"") ||\n        value.equals(""700"") || value.equals(""800"") || value.equals(""900""));\n    // Note: text-decoration is an SVG 1.1 feature\n    //\'text-decoration\'\n    //Value:    none | [ underline || overline || line-through || blink ] | inherit\n    //Initial:    none\n    //Applies to:    text content elements\n    //Inherited:    no (see prose)\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    value = readAttribute(elem, ""text-decoration"", ""none"");\n    FONT_UNDERLINE.put(a, value.equals(""underline""));\n"
2614,readCircleElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,626,640,3,"/**\n   * Reads an SVG ""circle"" element.\n   */",13,"  private Figure readCircleElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readShapeAttributes(elem, a);\n    double cx = toWidth(elem, readAttribute(elem, ""cx"", ""0""));\n    double cy = toHeight(elem, readAttribute(elem, ""cy"", ""0""));\n    double r = toWidth(elem, readAttribute(elem, ""r"", ""0""));\n    Figure figure = factory.createCircle(cx, cy, r, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2615,readPathElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,826,838,3,"/**\n   * Reads an SVG ""path"" element.\n   */",11,"  private Figure readPathElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readShapeAttributes(elem, a);\n    BezierPath[] beziers = toPath(elem, readAttribute(elem, ""d"", """"));\n    Figure figure = factory.createPath(beziers, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2616,toQuotedAndCommaSeparatedArray,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1348,1367,4,/**\n   * Returns a value as a String array.\n   * The values are separated by commas with optional quotes and white space.\n   */,19,"  public static String[] toQuotedAndCommaSeparatedArray(String str) throws IOException {\n    LinkedList<String> values = new LinkedList<String>();\n    StreamTokenizer tt = new StreamTokenizer(new StringReader(str));\n    tt.wordChars(\'a\', \'z\');\n    tt.wordChars(\'A\', \'Z\');\n    tt.wordChars(128 + 32, 255);\n    tt.whitespaceChars(0, \' \');\n    tt.quoteChar(\'""\');\n    tt.quoteChar(\'\\\'\');\n    while (tt.nextToken() != StreamTokenizer.TT_EOF) {\n      switch (tt.ttype) {\n        case StreamTokenizer.TT_WORD:\n        case \'""\':\n        case \'\\\'\':\n          values.add(tt.sval);\n          break;\n      }\n    }\n    return values.toArray(new String[values.size()]);\n"
2617,readTextFlowAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1953,1968,3,/* Reads text flow attributes as listed in\n   * http://www.w3.org/TR/SVGMobile12/feature.html#TextFlow\n   */,15,"  private void readTextFlowAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)\n      throws IOException {\n    Object value;\n    //\'line-increment\'\n    //Value:    auto | <number> | inherit\n    //Initial:    auto\n    //Applies to:    \'textArea\'\n    //Inherited:    yes\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""line-increment"", ""auto"");\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented line-increment="" + value);\n"
2618,readOpacityAttribute,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1875,1892,3,/* Reads object/group opacity as described in\n   * http://www.w3.org/TR/SVGMobile12/painting.html#groupOpacity\n   */,18,"  private void readOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> a)\n      throws IOException {\n    //\'opacity\'\n    //Value:    <opacity-value> | inherit\n    //Initial:    1\n    //Applies to:     \'image\' element\n    //Inherited:    no\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    //Computed value:     Specified value, except inherit\n    //<opacity-value>\n    //The uniform opacity setting must be applied across an entire object.\n    //Any values outside the range 0.0 (fully transparent) to 1.0\n    //(fully opaque) shall be clamped to this range.\n    //(See Clamping values which are restricted to a particular range.)\n    double value = toDouble(elem, readAttribute(elem, ""opacity"", ""1""), 1, 0, 1);\n    OPACITY.put(a, value);\n"
2619,toWidth,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1257,1260,7,"/**\n   * Returns a value as a width.\n   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#Animation"",\n --------------",4,"  private double toWidth(IXMLElement elem, String str) throws IOException {\n    // XXX - Compute xPercentFactor from viewport\n    return toLength(elem, str,\n        viewportStack.peek().widthPercentFactor);\n"
2620,readUseElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1095,1132,6,"/**\n   * Reads an SVG ""use"" element.\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#ExternalResourcesRequired"",\n --------------",35,"  @SuppressWarnings(""unchecked"")\n  private Figure readUseElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    HashMap<AttributeKey, Object> a2 = new HashMap<AttributeKey, Object>();\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a2);\n    readUseShapeAttributes(elem, a2);\n    readFontAttributes(elem, a2);\n    String href = readAttribute(elem, ""xlink:href"", null);\n    if (href != null && href.startsWith(""#"")) {\n      IXMLElement refElem = identifiedElements.get(href.substring(1));\n      if (refElem == null) {\n        if (DEBUG) {\n          System.out.println(""SVGInputFormat couldn\'t find href for <use> element:"" + href);\n        }\n      } else {\n        Object obj = readElement(refElem);\n        if (obj instanceof Figure) {\n          Figure figure = (Figure) ((Figure) obj).clone();\n          for (Map.Entry<AttributeKey, Object> entry : a2.entrySet()) {\n            figure.set(entry.getKey(), entry.getValue());\n          }\n          AffineTransform tx =\n              (TRANSFORM.get(a) == null) ? new AffineTransform() : TRANSFORM.get(a);\n          double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));\n          double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));\n          tx.translate(x, y);\n          figure.transform(tx);\n          return figure;\n        }\n      }\n    }\n    return null;\n"
2621,readDefsElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,421,426,3,"/**\n   * Reads an SVG ""defs"" element.\n   */",6,  private void readDefsElement(IXMLElement elem)\n      throws IOException {\n    for (IXMLElement node : elem.getChildren()) {\n      if (node instanceof IXMLElement) {\n        IXMLElement child = (IXMLElement) node;\n        Figure childFigure = readElement(child);\n
2622,readTransformAttribute,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1976,1981,3,/* Reads the transform attribute as specified in\n   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute\n   */,6,"  private void readTransformAttribute(IXMLElement elem, HashMap<AttributeKey, Object> a)\n      throws IOException {\n    String value;\n    value = readAttribute(elem, ""transform"", ""none"");\n    if (!value.equals(""none"")) {\n      TRANSFORM.put(a, toTransform(elem, value));\n"
2623,readPolylineElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,790,802,3,"/**\n   * Reads an SVG ""polyline"" element.\n   */",11,"  private Figure readPolylineElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readLineAttributes(elem, a);\n    Point2D.Double[] points = toPoints(elem, readAttribute(elem, ""points"", """"));\n    Figure figure = factory.createPolyline(points, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2624,readViewportAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2639,2683,2,/* Reads viewport attributes.\n   */,43,"  private void readViewportAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)\n      throws IOException {\n    Object value;\n    Double doubleValue;\n    // width of the viewport\n    value = readAttribute(elem, ""width"", null);\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat READ viewport w/h factors:"" + viewportStack.peek().widthPercentFactor + "","" + viewportStack.peek().heightPercentFactor);\n    }\n    if (value != null) {\n      doubleValue = toLength(elem, (String) value, viewportStack.peek().widthPercentFactor);\n      VIEWPORT_WIDTH.put(a, doubleValue);\n    }\n    // height of the viewport\n    value = readAttribute(elem, ""height"", null);\n    if (value != null) {\n      doubleValue = toLength(elem, (String) value, viewportStack.peek().heightPercentFactor);\n      VIEWPORT_HEIGHT.put(a, doubleValue);\n    }\n    //\'viewport-fill\'\n    //Value:   ""none"" | <color> | inherit\n    //Initial:   none\n    //Applies to:  viewport-creating elements\n    //Inherited:   no\n    //Percentages:   N/A\n    //Media:   visual\n    //Animatable:   yes\n    //Computed value:     ""none"" or specified <color> value, except inherit\n    value = toPaint(elem, readInheritColorAttribute(elem, ""viewport-fill"", ""none""));\n    if (value == null || (value instanceof Color)) {\n      VIEWPORT_FILL.put(a, (Color) value);\n    }\n    //\'viewport-fill-opacity\'\n    //Value:  <opacity-value> | inherit\n    //Initial:   1.0\n    //Applies to:  viewport-creating elements\n    //Inherited:   no\n    //Percentages:   N/A\n    //Media:   visual\n    //Animatable:   yes\n    //Computed value:     Specified value, except inherit\n    doubleValue = toDouble(elem, readAttribute(elem, ""viewport-fill-opacity"", ""1.0""));\n    VIEWPORT_FILL_OPACITY.put(a, doubleValue);\n"
2625,readTSpanElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,969,995,3,"/**\n   * Reads an SVG ""tspan"" element.\n   */",27,"  private void readTSpanElement(IXMLElement elem, DefaultStyledDocument doc)\n      throws IOException {\n    try {\n      if (elem.getContent() != null) {\n        doc.insertString(doc.getLength(), toText(elem, elem.getContent()), null);\n      } else {\n        for (IXMLElement node : elem.getChildren()) {\n          if (node instanceof IXMLElement) {\n            IXMLElement child = (IXMLElement) node;\n            if (node.getName() != null && node.getName().equals(""tspan"")) {\n              readTSpanElement((IXMLElement) node, doc);\n            } else {\n              if (DEBUG) {\n                System.out.println(""SVGInputFormat unknown text node "" + node.getName());\n              }\n            }\n          } else {\n            if (node.getName() == null) {\n              doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);\n            }\n          }\n        }\n      }\n    } catch (BadLocationException e) {\n      InternalError ex = new InternalError(e.getMessage());\n      ex.initCause(e);\n      throw ex;\n"
2626,readEllipseElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,646,661,3,"/**\n   * Reads an SVG ""ellipse"" element.\n   */",14,"  private Figure readEllipseElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readShapeAttributes(elem, a);\n    double cx = toWidth(elem, readAttribute(elem, ""cx"", ""0""));\n    double cy = toHeight(elem, readAttribute(elem, ""cy"", ""0""));\n    double rx = toWidth(elem, readAttribute(elem, ""rx"", ""0""));\n    double ry = toHeight(elem, readAttribute(elem, ""ry"", ""0""));\n    Figure figure = factory.createEllipse(cx, cy, rx, ry, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2627,readInheritFontSizeAttribute,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1199,1225,9,"/**\n   * Reads a font size attribute that is inherited.\n   * As specified by\n   * http://www.w3.org/TR/SVGMobile12/text.html#FontPropertiesUsedBySVG\n   * http://www.w3.org/TR/2006/CR-xsl11-20060220/#font-getChildCount\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#Listener"",\n --------------",26,"  private double readInheritFontSizeAttribute(IXMLElement elem, String attributeName, String defaultValue)\n      throws IOException {\n    String value = null;\n    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {\n      value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);\n    } else if (elem.hasAttribute(attributeName)) {\n      value = elem.getAttribute(attributeName, null);\n    } else if (elem.getParent() != null &&\n        (elem.getParent().getNamespace() == null ||\n        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {\n      return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);\n    } else {\n      value = defaultValue;\n    }\n    if (value.equals(""inherit"")) {\n      return readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);\n    } else if (SVG_ABSOLUTE_FONT_SIZES.containsKey(value)) {\n      return SVG_ABSOLUTE_FONT_SIZES.get(value);\n    } else if (SVG_RELATIVE_FONT_SIZES.containsKey(value)) {\n      return SVG_RELATIVE_FONT_SIZES.get(value) * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);\n    } else if (value.endsWith(""%"")) {\n      double factor = Double.valueOf(value.substring(0, value.length() - 1));\n      return factor * readInheritFontSizeAttribute(elem.getParent(), attributeName, defaultValue);\n    } else {\n      //return toScaledNumber(elem, value);\n      return toNumber(elem, value);\n"
2628,toPoints,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1374,1384,4,/**\n   * Returns a value as a Point2D.Double array.\n   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF\n   */,9,"  private Point2D.Double[] toPoints(IXMLElement elem, String str) throws IOException {\n    StringTokenizer tt = new StringTokenizer(str, "" ,"");\n    Point2D.Double[] points = new Point2D.Double[tt.countTokens() / 2];\n    for (int i = 0; i < points.length; i++) {\n      points[i] = new Point2D.Double(\n          toNumber(elem, tt.nextToken()),\n          toNumber(elem, tt.nextToken()));\n    }\n    return points;\n"
2629,SVGInputFormat,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,155,156,1,/** Creates a new instance. */,2,  public SVGInputFormat() {\n    this(new DefaultSVGFigureFactory());\n
2630,readInheritAttribute,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1138,1158,6,"/**\n   * Reads an attribute that is inherited.\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#Scripting"",\n --------------",21,"  private String readInheritAttribute(IXMLElement elem, String attributeName, String defaultValue) {\n    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {\n      String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);\n      if (value.equals(""inherit"")) {\n        return readInheritAttribute(elem.getParent(), attributeName, defaultValue);\n      } else {\n        return value;\n      }\n    } else if (elem.hasAttribute(attributeName)) {\n      String value = elem.getAttribute(attributeName);\n      if (value.equals(""inherit"")) {\n        return readInheritAttribute(elem.getParent(), attributeName, defaultValue);\n      } else {\n        return value;\n      }\n    } else if (elem.getParent() != null &&\n        (elem.getParent().getNamespace() == null ||\n        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {\n      return readInheritAttribute(elem.getParent(), attributeName, defaultValue);\n    } else {\n      return defaultValue;\n"
2631,toPath,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1394,1841,7,/**\n   * Returns a value as a BezierPath array.\n   * as specified in http://www.w3.org/TR/SVGMobile12/paths.html#PathDataBNF\n   *\n   * Also supports elliptical arc commands \'a\' and \'A\' as specified in\n   * http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands\n   */,416,"  private BezierPath[] toPath(IXMLElement elem, String str) throws IOException {\n    LinkedList<BezierPath> paths = new LinkedList<BezierPath>();\n    BezierPath path = null;\n    Point2D.Double p = new Point2D.Double();\n    Point2D.Double c1 = new Point2D.Double();\n    Point2D.Double c2 = new Point2D.Double();\n    StreamPosTokenizer tt;\n    if (toPathTokenizer == null) {\n      tt = new StreamPosTokenizer(new StringReader(str));\n      tt.resetSyntax();\n      tt.parseNumbers();\n      tt.parseExponents();\n      tt.parsePlusAsNumber();\n      tt.whitespaceChars(0, \' \');\n      tt.whitespaceChars(\',\', \',\');\n      toPathTokenizer = tt;\n    } else {\n      tt = toPathTokenizer;\n      tt.setReader(new StringReader(str));\n    }\n\n    char nextCommand = \'M\';\n    char command = \'M\';\n    Commands:\n    while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {\n      if (tt.ttype > 0) {\n        command = (char) tt.ttype;\n      } else {\n        command = nextCommand;\n        tt.pushBack();\n      }\n      BezierPath.Node node;\n      switch (command) {\n        case \'M\':\n          // absolute-moveto x y\n          if (path != null) {\n            paths.add(path);\n          }\n          path = new BezierPath();\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'M\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'M\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.moveTo(p.x, p.y);\n          nextCommand = \'L\';\n          break;\n        case \'m\':\n          // relative-moveto dx dy\n          if (path != null) {\n            paths.add(path);\n          }\n          path = new BezierPath();\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'m\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'m\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.moveTo(p.x, p.y);\n          nextCommand = \'l\';\n          break;\n        case \'Z\':\n        case \'z\':\n          // close path\n          p.x = path.get(0).x[0];\n          p.y = path.get(0).y[0];\n          // If the last point and the first point are the same, we\n          // can merge them\n          if (path.size() > 1) {\n            BezierPath.Node first = path.get(0);\n            BezierPath.Node last = path.get(path.size() - 1);\n            if (first.x[0] == last.x[0] &&\n                first.y[0] == last.y[0]) {\n              if ((last.mask & BezierPath.C1_MASK) != 0) {\n                first.mask |= BezierPath.C1_MASK;\n                first.x[1] = last.x[1];\n                first.y[1] = last.y[1];\n              }\n              path.remove(path.size() - 1);\n            }\n          }\n          path.setClosed(true);\n          break;\n        case \'L\':\n          // absolute-lineto x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'L\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'L\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'L\';\n          break;\n        case \'l\':\n          // relative-lineto dx dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'l\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'l\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'l\';\n          break;\n        case \'H\':\n          // absolute-horizontal-lineto x\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'H\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'H\';\n          break;\n        case \'h\':\n          // relative-horizontal-lineto dx\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'h\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'h\';\n          break;\n        case \'V\':\n          // absolute-vertical-lineto y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'V\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'V\';\n          break;\n        case \'v\':\n          // relative-vertical-lineto dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'v\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.lineTo(p.x, p.y);\n          nextCommand = \'v\';\n          break;\n        case \'C\':\n          // absolute-curveto x1 y1 x2 y2 x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x1 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y1 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x2 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y2 coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'C\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'C\';\n          break;\n        case \'c\':\n          // relative-curveto dx1 dy1 dx2 dy2 dx dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx1 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy1 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx2 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy2 coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'c\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'c\';\n          break;\n        case \'S\':\n          // absolute-shorthand-curveto x2 y2 x y\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x2 coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y2 coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'S\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'S\';\n          break;\n        case \'s\':\n          // relative-shorthand-curveto dx2 dy2 dx dy\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx2 coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy2 coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c2.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'s\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.curveTo(c1.x, c1.y, c2.x, c2.y, p.x, p.y);\n          nextCommand = \'s\';\n          break;\n        case \'Q\':\n          // absolute-quadto x1 y1 x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x1 coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y1 coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'Q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'Q\';\n          break;\n        case \'q\':\n          // relative-quadto dx1 dy1 dx dy\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx1 coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.x = p.x + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy1 coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          c1.y = p.y + tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'q\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'q\';\n          break;\n        case \'T\':\n          // absolute-shorthand-quadto x y\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'T\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'T\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'T\';\n          break;\n        case \'t\':\n          // relative-shorthand-quadto dx dy\n          node = path.get(path.size() - 1);\n          c1.x = node.x[0] * 2d - node.x[1];\n          c1.y = node.y[0] * 2d - node.y[1];\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dx coordinate missing for \'t\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""dy coordinate missing for \'t\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.quadTo(c1.x, c1.y, p.x, p.y);\n          nextCommand = \'s\';\n          break;\n\n        case \'A\': {\n          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""rx coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          // If rX or rY have negative signs, these are dropped;\n          // the absolute value is used instead.\n          double rx = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""ry coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double ry = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x-axis-rotation missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double xAxisRotation = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""large-arc-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean largeArcFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""sweep-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean sweepFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y = tt.nval;\n          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);\n          nextCommand = \'A\';\n          break;\n        }\n        case \'a\': {\n          // absolute-elliptical-arc rx ry x-axis-rotation large-arc-flag sweep-flag x y\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""rx coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          // If rX or rY have negative signs, these are dropped;\n          // the absolute value is used instead.\n          double rx = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""ry coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double ry = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x-axis-rotation missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          double xAxisRotation = tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""large-arc-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean largeArcFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""sweep-flag missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          boolean sweepFlag = tt.nval != 0;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""x coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.x += tt.nval;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""y coordinate missing for \'A\' at position "" + tt.getStartPosition() + "" in "" + str);\n          }\n          p.y += tt.nval;\n          path.arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y);\n          nextCommand = \'a\';\n          break;\n        }\n        default:\n          if (DEBUG) {\n            System.out.println(""SVGInputFormat.toPath aborting after illegal path command: "" + command + "" found in path "" + str);\n          }\n          break Commands;\n        //throw new IOException(""Illegal command: ""+command);\n      }\n    }\n    if (path != null) {\n      paths.add(path);\n    }\n    return paths.toArray(new BezierPath[paths.size()]);\n"
2632,readAttribute,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1233,1249,6,"/**\n   * Reads an attribute that is not inherited, unless its value is ""inherit"".\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#TimedAnimation"",\n --------------",17,"  private String readAttribute(IXMLElement elem, String attributeName, String defaultValue) {\n    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {\n      String value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);\n      if (value.equals(""inherit"")) {\n        return readAttribute(elem.getParent(), attributeName, defaultValue);\n      } else {\n        return value;\n      }\n    } else if (elem.hasAttribute(attributeName)) {\n      String value = elem.getAttribute(attributeName, null);\n      if (value.equals(""inherit"")) {\n        return readAttribute(elem.getParent(), attributeName, defaultValue);\n      } else {\n        return value;\n      }\n    } else {\n      return defaultValue;\n"
2633,readAElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,464,501,3,"/**\n   * Reads an SVG ""a"" element.\n   */",35,"  private Figure readAElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    CompositeFigure g = factory.createG(a);\n    String href = readAttribute(elem, ""xlink:href"", null);\n    if (href == null) {\n      href = readAttribute(elem, ""href"", null);\n    }\n    String target = readAttribute(elem, ""target"", null);\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat.readAElement href="" + href);\n    }\n    for (IXMLElement node : elem.getChildren()) {\n      if (node instanceof IXMLElement) {\n        IXMLElement child = (IXMLElement) node;\n        Figure childFigure = readElement(child);\n        // skip invisible elements\n        if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") &&\n            !readAttribute(child, ""display"", ""inline"").equals(""none"")) {\n          if (childFigure != null) {\n            g.basicAdd(childFigure);\n          }\n        }\n        if (childFigure != null) {\n          childFigure.set(LINK, href);\n          childFigure.set(LINK_TARGET, target);\n        } else {\n          if (DEBUG) {\n            System.out.println(""SVGInputFormat <a> has no child figure"");\n          }\n        }\n      }\n    }\n    return (g.getChildCount() == 1) ? g.getChild(0) : g;\n"
2634,toNumber,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1277,1278,4,/**\n   * Returns a value as a number.\n   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeNumber\n   */,2,"  private double toNumber(IXMLElement elem, String str) throws IOException {\n    return toLength(elem, str, viewportStack.peek().numberFactor);\n"
2635,readTextAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1898,1946,3,/* Reads text attributes as listed in\n   * http://www.w3.org/TR/SVGMobile12/feature.html#Text\n   */,46,"  private void readTextAttributes(IXMLElement elem, Map<AttributeKey, Object> a)\n      throws IOException {\n    Object value;\n    //\'text-anchor\'\n    //Value:    start | middle | end | inherit\n    //Initial:    start\n    //Applies to:    \'text\' IXMLElement\n    //Inherited:    yes\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""text-anchor"", ""start"");\n    if (SVG_TEXT_ANCHORS.get(value) != null) {\n      TEXT_ANCHOR.put(a, SVG_TEXT_ANCHORS.get(value));\n    }\n    //\'display-align\'\n    //Value:    auto | before | center | after | inherit\n    //Initial:    auto\n    //Applies to:    \'textArea\'\n    //Inherited:    yes\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""display-align"", ""auto"");\n    // XXX - Implement me properly\n    if (!value.equals(""auto"")) {\n      if (value.equals(""center"")) {\n        TEXT_ANCHOR.put(a, TextAnchor.MIDDLE);\n      } else if (value.equals(""before"")) {\n        TEXT_ANCHOR.put(a, TextAnchor.END);\n      }\n    }\n    //text-align\n    //Value:   start | end | center | inherit\n    //Initial:   start\n    //Applies to:   textArea elements\n    //Inherited:   yes\n    //Percentages:   N/A\n    //Media:   visual\n    //Animatable:   yes\n    value = readInheritAttribute(elem, ""text-align"", ""start"");\n    // XXX - Implement me properly\n    if (!value.equals(""start"")) {\n      TEXT_ALIGN.put(a, SVG_TEXT_ALIGNS.get(value));\n"
2636,toText,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,3233,3238,5,"/**\n   * Reads a text attribute.\n   * This method takes the ""xml:space"" attribute into account.\n   * http://www.w3.org/TR/SVGMobile12/text.html#WhiteSpace\n   */",6,"  private String toText(IXMLElement elem, String value) throws IOException {\n    String space = readInheritAttribute(elem, ""xml:space"", ""default"");\n    if (space.equals(""default"")) {\n      return value.trim().replaceAll(""\\\\s++"", "" "");\n    } else /*if (space.equals(""preserve""))*/ {\n      return value;\n"
2637,readUseShapeAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2224,2433,2,"/* Reads shape attributes for the SVG ""use"" element.\n   */",198,"  private void readUseShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)\n      throws IOException {\n    Object objectValue;\n    String value;\n    double doubleValue;\n    //\'color\'\n    // Value:    <color> | inherit\n    // Initial:     depends on user agent\n    // Applies to:    None. Indirectly affects other properties via currentColor\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified <color> value, except inherit\n    //\n    // value = readInheritAttribute(elem, ""color"", ""black"");\n    // if (DEBUG) System.out.println(""color=""+value);\n    //\'color-rendering\'\n    // Value:     auto | optimizeSpeed | optimizeQuality | inherit\n    // Initial:     auto\n    // Applies to:     container elements , graphics elements and \'animateColor\'\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    //\n    // value = readInheritAttribute(elem, ""color-rendering"", ""auto"");\n    // if (DEBUG) System.out.println(""color-rendering=""+value);\n    // \'fill\'\n    // Value:    <paint> | inherit (See Specifying paint)\n    // Initial:     black\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     ""none"", system paint, specified <color> value or absolute IRI\n    objectValue = readInheritColorAttribute(elem, ""fill"", null);\n    if (objectValue != null) {\n      objectValue = toPaint(elem, (String) objectValue);\n      if (objectValue instanceof Color) {\n        FILL_COLOR.put(a, (Color) objectValue);\n      } else if (objectValue instanceof Gradient) {\n        FILL_GRADIENT.put(a, (Gradient) objectValue);\n      } else if (objectValue == null) {\n        FILL_COLOR.put(a, null);\n      } else {\n        FILL_COLOR.put(a, null);\n        if (DEBUG) {\n          System.out.println(""SVGInputFormat not implemented  fill="" + objectValue);\n        }\n      }\n    }\n    //\'fill-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""fill-opacity"", null);\n    if (objectValue != null) {\n      FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));\n    }\n    // \'fill-rule\'\n    // Value:   nonzero | evenodd | inherit\n    // Initial:    nonzero\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""fill-rule"", null);\n    if (value != null) {\n      WINDING_RULE.put(a, SVG_FILL_RULES.get(value));\n    }\n    //\'stroke\'\n    //Value:    <paint> | inherit (See Specifying paint)\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     ""none"", system paint, specified <color> value\n    // or absolute IRI\n    objectValue = toPaint(elem, readInheritColorAttribute(elem, ""stroke"", null));\n    if (objectValue != null) {\n      if (objectValue instanceof Color) {\n        STROKE_COLOR.put(a, (Color) objectValue);\n      } else if (objectValue instanceof Gradient) {\n        STROKE_GRADIENT.put(a, (Gradient) objectValue);\n      }\n    }\n    //\'stroke-dasharray\'\n    //Value:     none | <dasharray> | inherit\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes (non-additive)\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-dasharray"", null);\n    if (value != null && !value.equals(""none"")) {\n      String[] values = toCommaSeparatedArray(value);\n      double[] dashes = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n        dashes[i] = toNumber(elem, values[i]);\n      }\n      STROKE_DASHES.put(a, dashes);\n    }\n    //\'stroke-dashoffset\'\n    //Value:    <length> | inherit\n    //Initial:     0\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""stroke-dashoffset"", null);\n    if (objectValue != null) {\n      doubleValue = toNumber(elem, (String) objectValue);\n      STROKE_DASH_PHASE.put(a, doubleValue);\n      IS_STROKE_DASH_FACTOR.put(a, false);\n    }\n    //\'stroke-linecap\'\n    //Value:     butt | round | square | inherit\n    //Initial:     butt\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-linecap"", null);\n    if (value != null) {\n      STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));\n    }\n    //\'stroke-linejoin\'\n    //Value:     miter | round | bevel | inherit\n    //Initial:     miter\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-linejoin"", null);\n    if (value != null) {\n      STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));\n    }\n    //\'stroke-miterlimit\'\n    //Value:     <miterlimit> | inherit\n    //Initial:     4\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""stroke-miterlimit"", null);\n    if (objectValue != null) {\n      doubleValue = toDouble(elem, (String) objectValue, 4d, 1d, Double.MAX_VALUE);\n      STROKE_MITER_LIMIT.put(a, doubleValue);\n      IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);\n    }\n    //\'stroke-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""stroke-opacity"", null);\n    if (objectValue != null) {\n      STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));\n    }\n    //\'stroke-width\'\n    //Value:    <length> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""stroke-width"", null);\n    if (objectValue != null) {\n      doubleValue = toNumber(elem, (String) objectValue);\n      STROKE_WIDTH.put(a, doubleValue);\n"
2638,toHeight,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1267,1270,7,"/**\n   * Returns a value as a height.\n   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#Audio"",\n --------------",4,"  private double toHeight(IXMLElement elem, String str) throws IOException {\n    // XXX - Compute yPercentFactor from viewport\n    return toLength(elem, str,\n        viewportStack.peek().heightPercentFactor);\n"
2639,flattenStyles,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,295,324,11,"/**\n   * Flattens all CSS styles.\n   * Styles defined in a ""style"" attribute and in CSS rules are converted\n   * into attributes with the same name.\n   */\n --------------\n/**\n     * Factor for number values in the user coordinate system.\n     * This is the smaller value of width / viewBox.width and height / viewBox.height.\n     */\n --------------",26,"  private void flattenStyles(IXMLElement elem)\n      throws IOException {\n    if (elem.getName() != null && elem.getName().equals(""style"") &&\n        readAttribute(elem, ""type"", """").equals(""text/css"") &&\n        elem.getContent() != null) {\n      CSSParser cssParser = new CSSParser();\n      cssParser.parse(elem.getContent(), styleManager);\n    } else {\n      if (elem.getNamespace() == null ||\n          elem.getNamespace().equals(SVG_NAMESPACE)) {\n        String style = readAttribute(elem, ""style"", null);\n        if (style != null) {\n          for (String styleProperty : style.split("";"")) {\n            String[] stylePropertyElements = styleProperty.split("":"");\n            if (stylePropertyElements.length == 2 &&\n                !elem.hasAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE)) {\n              //if (DEBUG) System.out.println(""flatten:""+Arrays.toString(stylePropertyElements));\n              elem.setAttribute(stylePropertyElements[0].trim(), SVG_NAMESPACE, stylePropertyElements[1].trim());\n            }\n          }\n        }\n        styleManager.applyStylesTo(elem);\n        for (IXMLElement node : elem.getChildren()) {\n          if (node instanceof IXMLElement) {\n            IXMLElement child = (IXMLElement) node;\n            flattenStyles(child);\n"
2640,toTransform,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,3246,3358,4,/* Converts an SVG transform attribute value into an AffineTransform\n   * as specified in\n   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute\n   */,104,"  public static AffineTransform toTransform(IXMLElement elem, String str) throws IOException {\n    AffineTransform t = new AffineTransform();\n    if (str != null && !str.equals(""none"")) {\n      StreamPosTokenizer tt = new StreamPosTokenizer(new StringReader(str));\n      tt.resetSyntax();\n      tt.wordChars(\'a\', \'z\');\n      tt.wordChars(\'A\', \'Z\');\n      tt.wordChars(128 + 32, 255);\n      tt.whitespaceChars(0, \' \');\n      tt.whitespaceChars(\',\', \',\');\n      tt.parseNumbers();\n      tt.parseExponents();\n      while (tt.nextToken() != StreamPosTokenizer.TT_EOF) {\n        if (tt.ttype != StreamPosTokenizer.TT_WORD) {\n          throw new IOException(""Illegal transform "" + str);\n        }\n        String type = tt.sval;\n        if (tt.nextToken() != \'(\') {\n          throw new IOException(""\'(\' not found in transform "" + str);\n        }\n        if (type.equals(""matrix"")) {\n          double[] m = new double[6];\n          for (int i = 0; i < 6; i++) {\n            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n              throw new IOException(""Matrix value "" + i + "" not found in transform "" + str + "" token:"" + tt.ttype + "" "" + tt.sval);\n            }\n            m[i] = tt.nval;\n          }\n          t.concatenate(new AffineTransform(m));\n        } else if (type.equals(""translate"")) {\n          double tx, ty;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""X-translation value not found in transform "" + str);\n          }\n          tx = tt.nval;\n          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {\n            ty = tt.nval;\n          } else {\n            tt.pushBack();\n            ty = 0;\n          }\n          t.translate(tx, ty);\n        } else if (type.equals(""scale"")) {\n          double sx, sy;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""X-scale value not found in transform "" + str);\n          }\n          sx = tt.nval;\n          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {\n            sy = tt.nval;\n          } else {\n            tt.pushBack();\n            sy = sx;\n          }\n          t.scale(sx, sy);\n        } else if (type.equals(""rotate"")) {\n          double angle, cx, cy;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""Angle value not found in transform "" + str);\n          }\n          angle = tt.nval;\n          if (tt.nextToken() == StreamPosTokenizer.TT_NUMBER) {\n            cx = tt.nval;\n            if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n              throw new IOException(""Y-center value not found in transform "" + str);\n            }\n            cy = tt.nval;\n          } else {\n            tt.pushBack();\n            cx = cy = 0;\n          }\n          t.rotate(angle * Math.PI / 180d, cx, cy);\n\n        } else if (type.equals(""skewX"")) {\n          double angle;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""Skew angle not found in transform "" + str);\n          }\n          angle = tt.nval;\n          t.concatenate(new AffineTransform(\n              1, 0, Math.tan(angle * Math.PI / 180), 1, 0, 0));\n        } else if (type.equals(""skewY"")) {\n          double angle;\n          if (tt.nextToken() != StreamPosTokenizer.TT_NUMBER) {\n            throw new IOException(""Skew angle not found in transform "" + str);\n          }\n          angle = tt.nval;\n          t.concatenate(new AffineTransform(\n              1, Math.tan(angle * Math.PI / 180), 0, 1, 0, 0));\n        } else if (type.equals(""ref"")) {\n          System.err.println(""SVGInputFormat warning: ignored ref(...) transform attribute in element "" + elem);\n          while (tt.nextToken() != \')\' && tt.ttype != StreamPosTokenizer.TT_EOF) {\n            // ignore tokens between brackets\n          }\n          tt.pushBack();\n        } else {\n          throw new IOException(""Unknown transform "" + type + "" in "" + str + "" in element "" + elem);\n        }\n        if (tt.nextToken() != \')\') {\n          throw new IOException(""\')\' not found in transform "" + str);\n        }\n      }\n    }\n    return t;\n"
2641,identifyElements,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1863,1868,4,"/**\n   * Puts all elments with an ""id"" or an ""xml:id"" attribute into the\n   * hashtable {@code identifiedElements}.\n   */",5,"  private void identifyElements(IXMLElement elem) {\n    identifiedElements.put(elem.getAttribute(""id""), elem);\n    identifiedElements.put(elem.getAttribute(""xml:id""), elem);\n    for (IXMLElement child : elem.getChildren()) {\n      identifyElements(child);\n"
2642,toCommaSeparatedArray,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1326,1327,4,/**\n   * Returns a value as a String array.\n   * The values are separated by commas with optional white space.\n   */,2,"  public static String[] toCommaSeparatedArray(String str) throws IOException {\n    return str.split(""\\\\s*,\\\\s*"");\n"
2643,read,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,176,277,14,"/**\n   * This is the main reading method.\n   *\n   * @param in The input stream.\n   * @param drawing The drawing to which this method adds figures.\n   * @param replace Whether attributes on the drawing object\n   * should by changed by this method. Set this to false, when reading individual\n   * images from the clipboard.\n   */\n --------------\n/**\n     * Factor for percent values relative to Viewport height.\n     */\n --------------",92,"  public void read(InputStream in, Drawing drawing, boolean replace) throws IOException {\n    long start = System.currentTimeMillis();\n    this.figures = new LinkedList<Figure>();\n    IXMLParser parser;\n    try {\n      parser = XMLParserFactory.createDefaultXMLParser();\n    } catch (Exception ex) {\n      InternalError e = new InternalError(""Unable to instantiate NanoXML Parser"");\n      e.initCause(ex);\n      throw e;\n    }\n    System.out.println(""SVGInputFormat parser created "" + (System.currentTimeMillis() - start));\n    IXMLReader reader = new StdXMLReader(in);\n    parser.setReader(reader);\n    System.out.println(""SVGInputFormat reader created "" + (System.currentTimeMillis() - start));\n    try {\n      document = (IXMLElement) parser.parse();\n    } catch (XMLException ex) {\n      IOException e = new IOException(ex.getMessage());\n      e.initCause(ex);\n      throw e;\n    }\n    System.out.println(""SVGInputFormat document created "" + (System.currentTimeMillis() - start));\n    // Search for the first \'svg\' element in the XML document\n    // in preorder sequence\n    IXMLElement svg = document;\n    Stack<Iterator<IXMLElement>> stack = new Stack<Iterator<IXMLElement>>();\n    LinkedList<IXMLElement> ll = new LinkedList<IXMLElement>();\n    ll.add(document);\n    stack.push(ll.iterator());\n    while (!stack.empty() && stack.peek().hasNext()) {\n      Iterator<IXMLElement> iter = stack.peek();\n      IXMLElement node = iter.next();\n      Iterator<IXMLElement> children = (node.getChildren() == null) ? null : node.getChildren().iterator();\n      if (!iter.hasNext()) {\n        stack.pop();\n      }\n      if (children != null && children.hasNext()) {\n        stack.push(children);\n      }\n      if (node.getName() != null &&\n          node.getName().equals(""svg"") &&\n          (node.getNamespace() == null ||\n          node.getNamespace().equals(SVG_NAMESPACE))) {\n        svg = node;\n        break;\n      }\n    }\n\n    if (svg.getName() == null ||\n        !svg.getName().equals(""svg"") ||\n        (svg.getNamespace() != null &&\n        !svg.getNamespace().equals(SVG_NAMESPACE))) {\n      throw new IOException(""\'svg\' element expected: "" + svg.getName());\n    }\n    //long end1 = System.currentTimeMillis();\n    // Flatten CSS Styles\n    initStorageContext(document);\n    flattenStyles(svg);\n    //long end2 = System.currentTimeMillis();\n    readElement(svg);\n    long end = System.currentTimeMillis();\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat elapsed:"" + (end - start));\n    }\n    /*if (DEBUG) System.out.println(""SVGInputFormat read:""+(end1-start));\n    if (DEBUG) System.out.println(""SVGInputFormat flatten:""+(end2-end1));\n    if (DEBUG) System.out.println(""SVGInputFormat build:""+(end-end2));\n     */\n    if (replace) {\n      drawing.removeAllChildren();\n    }\n    drawing.addAll(figures);\n\n    if (replace) {\n      Viewport viewport = viewportStack.firstElement();\n      drawing.set(VIEWPORT_FILL, VIEWPORT_FILL.get(viewport.attributes));\n      drawing.set(VIEWPORT_FILL_OPACITY, VIEWPORT_FILL_OPACITY.get(viewport.attributes));\n      drawing.set(VIEWPORT_HEIGHT, VIEWPORT_HEIGHT.get(viewport.attributes));\n      drawing.set(VIEWPORT_WIDTH, VIEWPORT_WIDTH.get(viewport.attributes));\n    }\n    // Get rid of all objects we don\'t need anymore to help garbage collector.\n    document.dispose();\n    identifiedElements.clear();\n    elementObjects.clear();\n    viewportStack.clear();\n    styleManager.clear();\n    document = null;\n    identifiedElements = null;\n    elementObjects = null;\n    viewportStack = null;\n    styleManager = null;\n"
2644,readInheritColorAttribute,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1167,1190,8,"/**\n   * Reads a color attribute that is inherited.\n   * This is similar to {@code readInheritAttribute}, but takes care of the\n   * ""currentColor"" magic attribute value.\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#Handler"",\n --------------",24,"  private String readInheritColorAttribute(IXMLElement elem, String attributeName, String defaultValue) {\n    String value = null;\n    if (elem.hasAttribute(attributeName, SVG_NAMESPACE)) {\n      value = elem.getAttribute(attributeName, SVG_NAMESPACE, null);\n      if (value.equals(""inherit"")) {\n        return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);\n      }\n    } else if (elem.hasAttribute(attributeName)) {\n      value = elem.getAttribute(attributeName);\n      if (value.equals(""inherit"")) {\n        return readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);\n      }\n    } else if (elem.getParent() != null &&\n        (elem.getParent().getNamespace() == null ||\n        elem.getParent().getNamespace().equals(SVG_NAMESPACE))) {\n      value = readInheritColorAttribute(elem.getParent(), attributeName, defaultValue);\n    } else {\n      value = defaultValue;\n    }\n    if (value != null && value.toLowerCase().equals(""currentcolor"") && !attributeName.equals(""color"")) {\n      // Lets do some magic stuff for ""currentColor"" attribute value\n      value = readInheritColorAttribute(elem, ""color"", ""defaultValue"");\n    }\n    return value;\n"
2645,readPolygonElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,808,820,3,"/**\n   * Reads an SVG ""polygon"" element.\n   */",11,"  private Figure readPolygonElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readShapeAttributes(elem, a);\n    Point2D.Double[] points = toPoints(elem, readAttribute(elem, ""points"", """"));\n    Figure figure = factory.createPolygon(points, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2646,readRectElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,594,620,3,"/**\n   * Reads an SVG ""rect"" element.\n   */",24,"  private Figure readRectElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readShapeAttributes(elem, a);\n    double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));\n    double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));\n    double w = toWidth(elem, readAttribute(elem, ""width"", ""0""));\n    double h = toHeight(elem, readAttribute(elem, ""height"", ""0""));\n    String rxValue = readAttribute(elem, ""rx"", ""none"");\n    String ryValue = readAttribute(elem, ""ry"", ""none"");\n    if (rxValue.equals(""none"")) {\n      rxValue = ryValue;\n    }\n    if (ryValue.equals(""none"")) {\n      ryValue = rxValue;\n    }\n    double rx = toNumber(elem, rxValue.equals(""none"") ? ""0"" : rxValue);\n    double ry = toNumber(elem, ryValue.equals(""none"") ? ""0"" : ryValue);\n    Figure figure = factory.createRect(x, y, w, h, rx, ry, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2647,toColor,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,3151,3201,4,/**\n   * Reads a color style attribute. This can be a Color or null.\n   * FIXME - Doesn\'t support url(...) colors yet.\n   */,50,"  private Color toColor(IXMLElement elem, String value) throws IOException {\n    String str = value;\n    if (str == null) {\n      return null;\n    }\n    str = str.trim().toLowerCase();\n    if (str.equals(""currentcolor"")) {\n      String currentColor = readInheritAttribute(elem, ""color"", ""black"");\n      if (currentColor == null || currentColor.trim().toLowerCase().equals(""currentColor"")) {\n        return null;\n      } else {\n        return toColor(elem, currentColor);\n      }\n    } else if (SVG_COLORS.containsKey(str)) {\n      return SVG_COLORS.get(str);\n    } else if (str.startsWith(""#"") && str.length() == 7) {\n      return new Color(Integer.decode(str));\n    } else if (str.startsWith(""#"") && str.length() == 4) {\n      // Three digits hex value\n      int th = Integer.decode(str);\n      return new Color(\n          (th & 0xf) | ((th & 0xf) << 4) |\n          ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |\n          ((th & 0xf00) << 8) | ((th & 0xf00) << 12));\n    } else if (str.startsWith(""rgb"")) {\n      try {\n        StringTokenizer tt = new StringTokenizer(str, ""() ,"");\n        tt.nextToken();\n        String r = tt.nextToken();\n        String g = tt.nextToken();\n        String b = tt.nextToken();\n        Color c = new Color(\n            r.endsWith(""%"") ? (int) (Integer.decode(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),\n            g.endsWith(""%"") ? (int) (Integer.decode(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),\n            b.endsWith(""%"") ? (int) (Integer.decode(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));\n        return c;\n      } catch (Exception e) {\n        if (DEBUG) {\n          System.out.println(""SVGInputFormat.toColor illegal RGB value "" + str);\n        }\n        return null;\n      }\n    } else if (str.startsWith(""url"")) {\n      // FIXME - Implement me\n      if (DEBUG) {\n        System.out.println(""SVGInputFormat.toColor not implemented for "" + str);\n      }\n      return null;\n    } else {\n      return null;\n"
2648,readSolidColorElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1987,2017,2,/* Reads solid color attributes.\n   */,28,"  private void readSolidColorElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    // \'solid-color\'\n    //Value:   currentColor | <color> | inherit\n    //Initial:   black\n    //Applies to:   \'solidColor\' elements\n    //Inherited:   no\n    //Percentages:   N/A\n    //Media:   visual\n    //Animatable:   yes\n    //Computed value:     Specified <color> value, except inherit\n    Color color = toColor(elem, readAttribute(elem, ""solid-color"", ""black""));\n    //\'solid-opacity\'\n    //Value:  <opacity-value> | inherit\n    //Initial:   1\n    //Applies to:   \'solidColor\' elements\n    //Inherited:   no\n    //Percentages:   N/A\n    //Media:   visual\n    //Animatable:   yes\n    //Computed value:     Specified value, except inherit\n    double opacity = toDouble(elem, readAttribute(elem, ""solid-opacity"", ""1""), 1, 0, 1);\n    if (opacity != 1) {\n      color = new Color(((int) (255 * opacity) << 24) | (0xffffff & color.getRGB()), true);\n    }\n    elementObjects.put(elem, color);\n"
2649,readGElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,434,458,3,"/**\n   * Reads an SVG ""g"" element.\n   */",24,"  private Figure readGElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readOpacityAttribute(elem, a);\n    CompositeFigure g = factory.createG(a);\n    for (IXMLElement node : elem.getChildren()) {\n      if (node instanceof IXMLElement) {\n        IXMLElement child = (IXMLElement) node;\n        Figure childFigure = readElement(child);\n        // skip invisible elements\n        if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") &&\n            !readAttribute(child, ""display"", ""inline"").equals(""none"")) {\n          if (childFigure != null) {\n            g.basicAdd(childFigure);\n          }\n        }\n      }\n    }\n    readTransformAttribute(elem, a);\n    if (TRANSFORM.get(a) != null) {\n      g.transform(TRANSFORM.get(a));\n    }\n    return g;\n"
2650,readShapeAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2024,2219,2,/** Reads shape attributes.\n   */,183,"  private void readShapeAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)\n      throws IOException {\n    Object objectValue;\n    String value;\n    double doubleValue;\n    //\'color\'\n    // Value:    <color> | inherit\n    // Initial:     depends on user agent\n    // Applies to:    None. Indirectly affects other properties via currentColor\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified <color> value, except inherit\n    //\n    // value = readInheritAttribute(elem, ""color"", ""black"");\n    // if (DEBUG) System.out.println(""color=""+value);\n    //\'color-rendering\'\n    // Value:     auto | optimizeSpeed | optimizeQuality | inherit\n    // Initial:     auto\n    // Applies to:     container elements , graphics elements and \'animateColor\'\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    //\n    // value = readInheritAttribute(elem, ""color-rendering"", ""auto"");\n    // if (DEBUG) System.out.println(""color-rendering=""+value);\n    // \'fill\'\n    // Value:    <paint> | inherit (See Specifying paint)\n    // Initial:     black\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     ""none"", system paint, specified <color> value or absolute IRI\n    objectValue = toPaint(elem, readInheritColorAttribute(elem, ""fill"", ""black""));\n    if (objectValue instanceof Color) {\n      FILL_COLOR.put(a, (Color) objectValue);\n    } else if (objectValue instanceof Gradient) {\n      FILL_GRADIENT.putClone(a, (Gradient) objectValue);\n    } else if (objectValue == null) {\n      FILL_COLOR.put(a, null);\n    } else {\n      FILL_COLOR.put(a, null);\n      if (DEBUG) {\n        System.out.println(""SVGInputFormat not implemented  fill="" + objectValue);\n      }\n    }\n    //\'fill-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""fill-opacity"", ""1"");\n    FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));\n    // \'fill-rule\'\n    // Value:   nonzero | evenodd | inherit\n    // Initial:    nonzero\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""fill-rule"", ""nonzero"");\n    WINDING_RULE.put(a, SVG_FILL_RULES.get(value));\n    //\'stroke\'\n    //Value:    <paint> | inherit (See Specifying paint)\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     ""none"", system paint, specified <color> value\n    // or absolute IRI\n    objectValue = toPaint(elem, readInheritColorAttribute(elem, ""stroke"", ""none""));\n    if (objectValue instanceof Color) {\n      STROKE_COLOR.put(a, (Color) objectValue);\n    } else if (objectValue instanceof Gradient) {\n      STROKE_GRADIENT.putClone(a, (Gradient) objectValue);\n    } else if (objectValue == null) {\n      STROKE_COLOR.put(a, null);\n    } else {\n      STROKE_COLOR.put(a, null);\n      if (DEBUG) {\n        System.out.println(""SVGInputFormat not implemented  stroke="" + objectValue);\n      }\n    }\n    //\'stroke-dasharray\'\n    //Value:     none | <dasharray> | inherit\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes (non-additive)\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-dasharray"", ""none"");\n    if (!value.equals(""none"")) {\n      String[] values = toWSOrCommaSeparatedArray(value);\n      double[] dashes = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n        dashes[i] = toNumber(elem, values[i]);\n      }\n      STROKE_DASHES.put(a, dashes);\n    }\n    //\'stroke-dashoffset\'\n    //Value:    <length> | inherit\n    //Initial:     0\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-dashoffset"", ""0""));\n    STROKE_DASH_PHASE.put(a, doubleValue);\n    IS_STROKE_DASH_FACTOR.put(a, false);\n    //\'stroke-linecap\'\n    //Value:     butt | round | square | inherit\n    //Initial:     butt\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-linecap"", ""butt"");\n    STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));\n\n    //\'stroke-linejoin\'\n    //Value:     miter | round | bevel | inherit\n    //Initial:     miter\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-linejoin"", ""miter"");\n    STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));\n    //\'stroke-miterlimit\'\n    //Value:     <miterlimit> | inherit\n    //Initial:     4\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    doubleValue = toDouble(elem, readInheritAttribute(elem, ""stroke-miterlimit"", ""4""), 4d, 1d, Double.MAX_VALUE);\n    STROKE_MITER_LIMIT.put(a, doubleValue);\n    IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);\n    //\'stroke-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""stroke-opacity"", ""1"");\n    STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));\n    //\'stroke-width\'\n    //Value:    <length> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-width"", ""1""));\n    STROKE_WIDTH.put(a, doubleValue);\n"
2651,toLength,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1285,1319,4,/**\n   * Returns a value as a length.\n   * http://www.w3.org/TR/SVGMobile12/types.html#DataTypeLength\n   */,33,"  private double toLength(IXMLElement elem, String str, double percentFactor) throws IOException {\n    double scaleFactor = 1d;\n    if (str == null || str.length() == 0 || str.equals(""none"")) {\n      return 0d;\n    }\n    if (str.endsWith(""%"")) {\n      str = str.substring(0, str.length() - 1);\n      scaleFactor = percentFactor;\n    } else if (str.endsWith(""px"")) {\n      str = str.substring(0, str.length() - 2);\n    } else if (str.endsWith(""pt"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 1.25;\n    } else if (str.endsWith(""pc"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 15;\n    } else if (str.endsWith(""mm"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 3.543307;\n    } else if (str.endsWith(""cm"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 35.43307;\n    } else if (str.endsWith(""in"")) {\n      str = str.substring(0, str.length() - 2);\n      scaleFactor = 90;\n    } else if (str.endsWith(""em"")) {\n      str = str.substring(0, str.length() - 2);\n      // XXX - This doesn\'t work\n      scaleFactor = toLength(elem, readAttribute(elem, ""font-size"", ""0""), percentFactor);\n    } else {\n      scaleFactor = 1d;\n    }\n    return Double.parseDouble(str) * scaleFactor;\n"
2652,toWSOrCommaSeparatedArray,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1335,1340,5,/**\n   * Returns a value as a String array.\n   * The values are separated by whitespace or by commas with optional white\n   * space.\n   */,6,"  public static String[] toWSOrCommaSeparatedArray(String str) throws IOException {\n    String[] result = str.split(""(\\\\s*,\\\\s*|\\\\s+)"");\n    if (result.length == 1 && result[0].equals("""")) {\n      return new String[0];\n    } else {\n      return result;\n"
2653,readLineAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2439,2634,2,/** Reads line and polyline attributes.\n   */,183,"  private void readLineAttributes(IXMLElement elem, HashMap<AttributeKey, Object> a)\n      throws IOException {\n    Object objectValue;\n    String value;\n    double doubleValue;\n    //\'color\'\n    // Value:    <color> | inherit\n    // Initial:     depends on user agent\n    // Applies to:    None. Indirectly affects other properties via currentColor\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified <color> value, except inherit\n    //\n    // value = readInheritAttribute(elem, ""color"", ""black"");\n    // if (DEBUG) System.out.println(""color=""+value);\n    //\'color-rendering\'\n    // Value:     auto | optimizeSpeed | optimizeQuality | inherit\n    // Initial:     auto\n    // Applies to:     container elements , graphics elements and \'animateColor\'\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    //\n    // value = readInheritAttribute(elem, ""color-rendering"", ""auto"");\n    // if (DEBUG) System.out.println(""color-rendering=""+value);\n    // \'fill\'\n    // Value:    <paint> | inherit (See Specifying paint)\n    // Initial:     black\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     ""none"", system paint, specified <color> value or absolute IRI\n    objectValue = toPaint(elem, readInheritColorAttribute(elem, ""fill"", ""none""));\n    if (objectValue instanceof Color) {\n      FILL_COLOR.put(a, (Color) objectValue);\n    } else if (objectValue instanceof Gradient) {\n      FILL_GRADIENT.putClone(a, (Gradient) objectValue);\n    } else if (objectValue == null) {\n      FILL_COLOR.put(a, null);\n    } else {\n      FILL_COLOR.put(a, null);\n      if (DEBUG) {\n        System.out.println(""SVGInputFormat not implemented  fill="" + objectValue);\n      }\n    }\n    //\'fill-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""fill-opacity"", ""1"");\n    FILL_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));\n    // \'fill-rule\'\n    // Value:   nonzero | evenodd | inherit\n    // Initial:    nonzero\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""fill-rule"", ""nonzero"");\n    WINDING_RULE.put(a, SVG_FILL_RULES.get(value));\n    //\'stroke\'\n    //Value:    <paint> | inherit (See Specifying paint)\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     ""none"", system paint, specified <color> value\n    // or absolute IRI\n    objectValue = toPaint(elem, readInheritColorAttribute(elem, ""stroke"", ""black""));\n    if (objectValue instanceof Color) {\n      STROKE_COLOR.put(a, (Color) objectValue);\n    } else if (objectValue instanceof Gradient) {\n      STROKE_GRADIENT.putClone(a, (Gradient) objectValue);\n    } else if (objectValue == null) {\n      STROKE_COLOR.put(a, null);\n    } else {\n      STROKE_COLOR.put(a, null);\n      if (DEBUG) {\n        System.out.println(""SVGInputFormat not implemented  stroke="" + objectValue);\n      }\n    }\n    //\'stroke-dasharray\'\n    //Value:     none | <dasharray> | inherit\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes (non-additive)\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-dasharray"", ""none"");\n    if (!value.equals(""none"")) {\n      String[] values = toWSOrCommaSeparatedArray(value);\n      double[] dashes = new double[values.length];\n      for (int i = 0; i < values.length; i++) {\n        dashes[i] = toNumber(elem, values[i]);\n      }\n      STROKE_DASHES.put(a, dashes);\n    }\n    //\'stroke-dashoffset\'\n    //Value:    <length> | inherit\n    //Initial:     0\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-dashoffset"", ""0""));\n    STROKE_DASH_PHASE.put(a, doubleValue);\n    IS_STROKE_DASH_FACTOR.put(a, false);\n    //\'stroke-linecap\'\n    //Value:     butt | round | square | inherit\n    //Initial:     butt\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-linecap"", ""butt"");\n    STROKE_CAP.put(a, SVG_STROKE_LINECAPS.get(value));\n\n    //\'stroke-linejoin\'\n    //Value:     miter | round | bevel | inherit\n    //Initial:     miter\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""stroke-linejoin"", ""miter"");\n    STROKE_JOIN.put(a, SVG_STROKE_LINEJOINS.get(value));\n    //\'stroke-miterlimit\'\n    //Value:     <miterlimit> | inherit\n    //Initial:     4\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    doubleValue = toDouble(elem, readInheritAttribute(elem, ""stroke-miterlimit"", ""4""), 4d, 1d, Double.MAX_VALUE);\n    STROKE_MITER_LIMIT.put(a, doubleValue);\n    IS_STROKE_MITER_LIMIT_FACTOR.put(a, false);\n    //\'stroke-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    objectValue = readInheritAttribute(elem, ""stroke-opacity"", ""1"");\n    STROKE_OPACITY.put(a, toDouble(elem, (String) objectValue, 1d, 0d, 1d));\n    //\'stroke-width\'\n    //Value:    <length> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    doubleValue = toNumber(elem, readInheritAttribute(elem, ""stroke-width"", ""1""));\n    STROKE_WIDTH.put(a, doubleValue);\n"
2654,readLinearGradientElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2805,2883,3,"/**\n   * Reads an SVG ""linearGradient"" element.\n   */",71,"  private void readLinearGradientElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    double x1 = toLength(elem, readAttribute(elem, ""x1"", ""0""), 0.01);\n    double y1 = toLength(elem, readAttribute(elem, ""y1"", ""0""), 0.01);\n    double x2 = toLength(elem, readAttribute(elem, ""x2"", ""1""), 0.01);\n    double y2 = toLength(elem, readAttribute(elem, ""y2"", ""0""), 0.01);\n    boolean isRelativeToFigureBounds = readAttribute(elem, ""gradientUnits"", ""objectBoundingBox"").equals(""objectBoundingBox"");\n    ArrayList<IXMLElement> stops = elem.getChildrenNamed(""stop"", SVG_NAMESPACE);\n    if (stops.size() == 0) {\n      stops = elem.getChildrenNamed(""stop"");\n    }\n    if (stops.size() == 0) {\n      // FIXME - Implement xlink support throughouth SVGInputFormat\n      String xlink = readAttribute(elem, ""xlink:href"", """");\n      if (xlink.startsWith(""#"") &&\n          identifiedElements.get(xlink.substring(1)) != null) {\n        stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"", SVG_NAMESPACE);\n        if (stops.size() == 0) {\n          stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"");\n        }\n      }\n    }\n    if (stops.size() == 0) {\n      if (DEBUG) {\n        System.out.println(""SVGInpuFormat: Warning no stops in linearGradient "" + elem);\n      }\n    }\n    double[] stopOffsets = new double[stops.size()];\n    Color[] stopColors = new Color[stops.size()];\n    double[] stopOpacities = new double[stops.size()];\n    for (int i = 0; i < stops.size(); i++) {\n      IXMLElement stopElem = stops.get(i);\n      String offsetStr = readAttribute(stopElem, ""offset"", ""0"");\n      if (offsetStr.endsWith(""%"")) {\n        stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;\n      } else {\n        stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);\n      }\n      // \'stop-color\'\n      // Value:    currentColor | <color> | inherit\n      // Initial:    black\n      // Applies to:     \'stop\' elements\n      // Inherited:    no\n      // Percentages:    N/A\n      // Media:    visual\n      // Animatable:    yes\n      // Computed value:     Specified <color> value, except i\n      stopColors[i] = toColor(stopElem, readAttribute(stopElem, ""stop-color"", ""black""));\n      if (stopColors[i] == null) {\n        stopColors[i] = new Color(0x0, true);\n        //throw new IOException(""stop color missing in ""+stopElem);\n      }\n      //\'stop-opacity\'\n      //Value:    <opacity-value> | inherit\n      //Initial:    1\n      //Applies to:     \'stop\' elements\n      //Inherited:    no\n      //Percentages:    N/A\n      //Media:    visual\n      //Animatable:    yes\n      //Computed value:     Specified value, except inherit\n      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, ""stop-opacity"", ""1""), 1, 0, 1);\n    }\n    AffineTransform tx = toTransform(elem, readAttribute(elem, ""gradientTransform"", ""none""));\n    Gradient gradient = factory.createLinearGradient(\n        x1, y1, x2, y2,\n        stopOffsets, stopColors, stopOpacities,\n        isRelativeToFigureBounds, tx);\n    elementObjects.put(elem, gradient);\n"
2655,toDouble,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,3208,3209,3,/**\n   * Reads a double attribute.\n   */,2,"  private double toDouble(IXMLElement elem, String value) throws IOException {\n    return toDouble(elem, value, 0, Double.MIN_VALUE, Double.MAX_VALUE);\n"
2656,readElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,336,415,5,"/**\n   * Reads an SVG element of any kind.\n   * @return Returns the Figure, if the SVG element represents a Figure.\n   * Returns null in all other cases.\n   */",79,"  private Figure readElement(IXMLElement elem)\n      throws IOException {\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat.readElement "" + elem.getName() + "" line:"" + elem.getLineNr());\n    }\n    Figure f = null;\n    if (elem.getNamespace() == null ||\n        elem.getNamespace().equals(SVG_NAMESPACE)) {\n      String name = elem.getName();\n      if (name == null) {\n        if (DEBUG) {\n          System.err.println(""SVGInputFormat warning: skipping nameless element at line "" + elem.getLineNr());\n        }\n      } else if (name.equals(""a"")) {\n        f = readAElement(elem);\n      } else if (name.equals(""circle"")) {\n        f = readCircleElement(elem);\n      } else if (name.equals(""defs"")) {\n        readDefsElement(elem);\n        f = null;\n      } else if (name.equals(""ellipse"")) {\n        f = readEllipseElement(elem);\n      } else if (name.equals(""g"")) {\n        f = readGElement(elem);\n      } else if (name.equals(""image"")) {\n        f = readImageElement(elem);\n      } else if (name.equals(""line"")) {\n        f = readLineElement(elem);\n      } else if (name.equals(""linearGradient"")) {\n        readLinearGradientElement(elem);\n        f = null;\n      } else if (name.equals(""path"")) {\n        f = readPathElement(elem);\n      } else if (name.equals(""polygon"")) {\n        f = readPolygonElement(elem);\n      } else if (name.equals(""polyline"")) {\n        f = readPolylineElement(elem);\n      } else if (name.equals(""radialGradient"")) {\n        readRadialGradientElement(elem);\n        f = null;\n      } else if (name.equals(""rect"")) {\n        f = readRectElement(elem);\n      } else if (name.equals(""solidColor"")) {\n        readSolidColorElement(elem);\n        f = null;\n      } else if (name.equals(""svg"")) {\n        f = readSVGElement(elem);\n        //f = readGElement(elem);\n      } else if (name.equals(""switch"")) {\n        f = readSwitchElement(elem);\n      } else if (name.equals(""text"")) {\n        f = readTextElement(elem);\n      } else if (name.equals(""textArea"")) {\n        f = readTextAreaElement(elem);\n      } else if (name.equals(""title"")) {\n        //FIXME - Implement reading of title element\n        //f = readTitleElement(elem);\n      } else if (name.equals(""use"")) {\n        f = readUseElement(elem);\n      } else if (name.equals(""style"")) {\n        // Nothing to do, style elements have been already\n        // processed in method flattenStyles\n      } else {\n        if (DEBUG) {\n          System.out.println(""SVGInputFormat not implemented for <"" + name + "">"");\n        }\n      }\n    }\n    if (f instanceof SVGFigure) {\n      if (((SVGFigure) f).isEmpty()) {\n        // if (DEBUG) System.out.println(""Empty figure ""+f);\n        return null;\n      }\n    } else if (f != null) {\n      if (DEBUG) {\n        System.out.println(""SVGInputFormat warning: not an SVGFigure "" + f);\n      }\n    }\n    return f;\n"
2657,toPaint,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,3085,3143,4,/**\n   * Reads a paint style attribute. This can be a Color or a Gradient or null.\n   * XXX - Doesn\'t support url(...) colors yet.\n   */,57,"  private Object toPaint(IXMLElement elem, String value) throws IOException {\n    String str = value;\n    if (str == null) {\n      return null;\n    }\n    str = str.trim().toLowerCase();\n    if (str.equals(""none"")) {\n      return null;\n    } else if (str.equals(""currentcolor"")) {\n      String currentColor = readInheritAttribute(elem, ""color"", ""black"");\n      if (currentColor == null || currentColor.trim().toLowerCase().equals(""currentColor"")) {\n        return null;\n      } else {\n        return toPaint(elem, currentColor);\n      }\n    } else if (SVG_COLORS.containsKey(str)) {\n      return SVG_COLORS.get(str);\n    } else if (str.startsWith(""#"") && str.length() == 7) {\n      return new Color(Integer.decode(str));\n    } else if (str.startsWith(""#"") && str.length() == 4) {\n      // Three digits hex value\n      int th = Integer.decode(str);\n      return new Color(\n          (th & 0xf) | ((th & 0xf) << 4) |\n          ((th & 0xf0) << 4) | ((th & 0xf0) << 8) |\n          ((th & 0xf00) << 8) | ((th & 0xf00) << 12));\n    } else if (str.startsWith(""rgb"")) {\n      try {\n        StringTokenizer tt = new StringTokenizer(str, ""() ,"");\n        tt.nextToken();\n        String r = tt.nextToken();\n        String g = tt.nextToken();\n        String b = tt.nextToken();\n        Color c = new Color(\n            r.endsWith(""%"") ? (int) (Double.parseDouble(r.substring(0, r.length() - 1)) * 2.55) : Integer.decode(r),\n            g.endsWith(""%"") ? (int) (Double.parseDouble(g.substring(0, g.length() - 1)) * 2.55) : Integer.decode(g),\n            b.endsWith(""%"") ? (int) (Double.parseDouble(b.substring(0, b.length() - 1)) * 2.55) : Integer.decode(b));\n        return c;\n      } catch (Exception e) {\n        /*if (DEBUG)*/ System.out.println(""SVGInputFormat.toPaint illegal RGB value "" + str);\n        e.printStackTrace();\n        return null;\n      }\n    } else if (str.startsWith(""url("")) {\n      String href = value.substring(4, value.length() - 1);\n      if (identifiedElements.containsKey(href.substring(1)) &&\n          elementObjects.containsKey(identifiedElements.get(href.substring(1)))) {\n        Object obj = elementObjects.get(identifiedElements.get(href.substring(1)));\n        return obj;\n      }\n      // XXX - Implement me\n      if (DEBUG) {\n        System.out.println(""SVGInputFormat.toPaint not implemented for "" + href);\n      }\n      return null;\n    } else {\n      return null;\n"
2658,readLineElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,757,784,3,"/**\n   * Reads an SVG ""line"" element.\n   */",25,"  private Figure readLineElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readLineAttributes(elem, a);\n    // Because \'line\' elements are single lines and thus are geometrically\n    // one-dimensional, they have no interior; thus, \'line\' elements are\n    // never filled (see the \'fill\' property).\n    if (FILL_COLOR.get(a) != null && STROKE_COLOR.get(a) == null) {\n      STROKE_COLOR.put(a, FILL_COLOR.get(a));\n    }\n    if (FILL_GRADIENT.get(a) != null && STROKE_GRADIENT.get(a) == null) {\n      STROKE_GRADIENT.put(a, FILL_GRADIENT.get(a));\n    }\n    FILL_COLOR.put(a, null);\n    FILL_GRADIENT.put(a, null);\n    double x1 = toNumber(elem, readAttribute(elem, ""x1"", ""0""));\n    double y1 = toNumber(elem, readAttribute(elem, ""y1"", ""0""));\n    double x2 = toNumber(elem, readAttribute(elem, ""x2"", ""0""));\n    double y2 = toNumber(elem, readAttribute(elem, ""y2"", ""0""));\n    Figure figure = factory.createLine(x1, y1, x2, y2, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2659,readTextElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,844,912,3,"/**\n   * Reads an SVG ""text"" element.\n   */",64,"  private Figure readTextElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readShapeAttributes(elem, a);\n    readFontAttributes(elem, a);\n    readTextAttributes(elem, a);\n    String[] xStr = toCommaSeparatedArray(readAttribute(elem, ""x"", ""0""));\n    String[] yStr = toCommaSeparatedArray(readAttribute(elem, ""y"", ""0""));\n    Point2D.Double[] coordinates = new Point2D.Double[Math.max(xStr.length, yStr.length)];\n    double lastX = 0;\n    double lastY = 0;\n    for (int i = 0; i < coordinates.length; i++) {\n      if (xStr.length > i) {\n        try {\n          lastX = toNumber(elem, xStr[i]);\n        } catch (NumberFormatException ex) {\n        }\n      }\n      if (yStr.length > i) {\n        try {\n          lastY = toNumber(elem, yStr[i]);\n        } catch (NumberFormatException ex) {\n        }\n      }\n      coordinates[i] = new Point2D.Double(lastX, lastY);\n    }\n\n    String[] rotateStr = toCommaSeparatedArray(readAttribute(elem, ""rotate"", """"));\n    double[] rotate = new double[rotateStr.length];\n    for (int i = 0; i < rotateStr.length; i++) {\n      try {\n        rotate[i] = toDouble(elem, rotateStr[i]);\n      } catch (NumberFormatException ex) {\n        rotate[i] = 0;\n      }\n    }\n    DefaultStyledDocument doc = new DefaultStyledDocument();\n    try {\n      if (elem.getContent() != null) {\n        doc.insertString(0, toText(elem, elem.getContent()), null);\n      } else {\n        for (IXMLElement node : elem.getChildren()) {\n          if (node.getName() == null) {\n            doc.insertString(0, toText(elem, node.getContent()), null);\n          } else if (node.getName().equals(""tspan"")) {\n            readTSpanElement((IXMLElement) node, doc);\n          } else {\n            if (DEBUG) {\n              System.out.println(""SVGInputFormat unsupported text node <"" + node.getName() + "">"");\n            }\n          }\n        }\n      }\n    } catch (BadLocationException e) {\n      InternalError ex = new InternalError(e.getMessage());\n      ex.initCause(e);\n      throw ex;\n    }\n    Figure figure = factory.createText(coordinates, rotate, doc, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2660,readGraphicsAttributes,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2689,2798,3,/* Reads graphics attributes as listed in\n   * http://www.w3.org/TR/SVGMobile12/feature.html#GraphicsAttribute\n   */,104,"  private void readGraphicsAttributes(IXMLElement elem, Figure f)\n      throws IOException {\n    Object value;\n    // \'display\'\n    // Value:     inline | block | list-item |\n    // run-in | compact | marker |\n    // table | inline-table | table-row-group | table-header-group |\n    // table-footer-group | table-row | table-column-group | table-column |\n    // table-cell | table-caption | none | inherit\n    // Initial:     inline\n    // Applies to:     \'svg\' , \'g\' , \'switch\' , \'a\' , \'foreignObject\' ,\n    // graphics elements (including the text content block elements) and text\n    // sub-elements (for example, \'tspan\' and \'a\' )\n    // Inherited:     no\n    // Percentages:     N/A\n    // Media:     all\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    value = readAttribute(elem, ""display"", ""inline"");\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented display="" + value);\n    }\n\n    //\'image-rendering\'\n    //Value:     auto | optimizeSpeed | optimizeQuality | inherit\n    //Initial:     auto\n    //Applies to:     images\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""image-rendering"", ""auto"");\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented image-rendering="" + value);\n    }\n    //\'pointer-events\'\n    //Value:    boundingBox | visiblePainted | visibleFill | visibleStroke | visible |\n    //painted | fill | stroke | all | none | inherit\n    //Initial:    visiblePainted\n    //Applies to:    graphics elements\n    //Inherited:    yes\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    //Computed value:    Specified value, except inherit\n    value = readInheritAttribute(elem, ""pointer-events"", ""visiblePainted"");\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented pointer-events="" + value);\n    }\n    // \'shape-rendering\'\n    //Value:     auto | optimizeSpeed | crispEdges |\n    //geometricPrecision | inherit\n    //Initial:     auto\n    //Applies to:     shapes\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""shape-rendering"", ""auto"");\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented shape-rendering="" + value);\n    }\n    //\'text-rendering\'\n    //Value:     auto | optimizeSpeed | optimizeLegibility |\n    //geometricPrecision | inherit\n    //Initial:     auto\n    //Applies to:    text content block elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""text-rendering"", ""auto"");\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented text-rendering="" + value);\n    }\n    //\'vector-effect\'\n    //Value:     non-scaling-stroke | none | inherit\n    //Initial:     none\n    //Applies to:     graphics elements\n    //Inherited:     no\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readAttribute(elem, ""vector-effect"", ""none"");\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented vector-effect="" + value);\n    }\n    //\'visibility\'\n    //Value:     visible | hidden | collapse | inherit\n    //Initial:     visible\n    //Applies to:     graphics elements (including the text content block\n    // elements) and text sub-elements (for example, \'tspan\' and \'a\' )\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    value = readInheritAttribute(elem, ""visibility"", null);\n    if (DEBUG) {\n      System.out.println(""SVGInputFormat not implemented visibility="" + value);\n"
2661,readRadialGradientElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,2889,2962,3,"/**\n   * Reads an SVG ""radialGradient"" element.\n   */",69,"  private void readRadialGradientElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    double cx = toLength(elem, readAttribute(elem, ""cx"", ""0.5""), 0.01);\n    double cy = toLength(elem, readAttribute(elem, ""cy"", ""0.5""), 0.01);\n    double fx = toLength(elem, readAttribute(elem, ""fx"", readAttribute(elem, ""cx"", ""0.5"")), 0.01);\n    double fy = toLength(elem, readAttribute(elem, ""fy"", readAttribute(elem, ""cy"", ""0.5"")), 0.01);\n    double r = toLength(elem, readAttribute(elem, ""r"", ""0.5""), 0.01);\n    boolean isRelativeToFigureBounds =\n        readAttribute(elem, ""gradientUnits"", ""objectBoundingBox"").equals(""objectBoundingBox"");\n    ArrayList<IXMLElement> stops = elem.getChildrenNamed(""stop"", SVG_NAMESPACE);\n    if (stops.size() == 0) {\n      stops = elem.getChildrenNamed(""stop"");\n    }\n    if (stops.size() == 0) {\n      // FIXME - Implement xlink support throughout SVGInputFormat\n      String xlink = readAttribute(elem, ""xlink:href"", """");\n      if (xlink.startsWith(""#"") &&\n          identifiedElements.get(xlink.substring(1)) != null) {\n        stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"", SVG_NAMESPACE);\n        if (stops.size() == 0) {\n          stops = identifiedElements.get(xlink.substring(1)).getChildrenNamed(""stop"");\n        }\n      }\n    }\n    double[] stopOffsets = new double[stops.size()];\n    Color[] stopColors = new Color[stops.size()];\n    double[] stopOpacities = new double[stops.size()];\n    for (int i = 0; i < stops.size(); i++) {\n      IXMLElement stopElem = stops.get(i);\n      String offsetStr = readAttribute(stopElem, ""offset"", ""0"");\n      if (offsetStr.endsWith(""%"")) {\n        stopOffsets[i] = toDouble(stopElem, offsetStr.substring(0, offsetStr.length() - 1), 0, 0, 100) / 100d;\n      } else {\n        stopOffsets[i] = toDouble(stopElem, offsetStr, 0, 0, 1);\n      }\n      // \'stop-color\'\n      // Value:    currentColor | <color> | inherit\n      // Initial:    black\n      // Applies to:     \'stop\' elements\n      // Inherited:    no\n      // Percentages:    N/A\n      // Media:    visual\n      // Animatable:    yes\n      // Computed value:     Specified <color> value, except i\n      stopColors[i] = toColor(stopElem, readAttribute(stopElem, ""stop-color"", ""black""));\n      if (stopColors[i] == null) {\n        stopColors[i] = new Color(0x0, true);\n        //throw new IOException(""stop color missing in ""+stopElem);\n      }\n      //\'stop-opacity\'\n      //Value:    <opacity-value> | inherit\n      //Initial:    1\n      //Applies to:     \'stop\' elements\n      //Inherited:    no\n      //Percentages:    N/A\n      //Media:    visual\n      //Animatable:    yes\n      //Computed value:     Specified value, except inherit\n      stopOpacities[i] = toDouble(stopElem, readAttribute(stopElem, ""stop-opacity"", ""1""), 1, 0, 1);\n    }\n    AffineTransform tx = toTransform(elem, readAttribute(elem, ""gradientTransform"", ""none""));\n    Gradient gradient = factory.createRadialGradient(\n        cx, cy, fx, fy, r,\n        stopOffsets, stopColors, stopOpacities,\n        isRelativeToFigureBounds,\n        tx);\n    elementObjects.put(elem, gradient);\n"
2662,readTextAreaElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,918,963,3,"/**\n   * Reads an SVG ""textArea"" element.\n   */",42,"  private Figure readTextAreaElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    readShapeAttributes(elem, a);\n    readFontAttributes(elem, a);\n    readTextAttributes(elem, a);\n    readTextFlowAttributes(elem, a);\n    double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));\n    double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));\n// XXX - Handle ""auto"" width and height\n    double w = toWidth(elem, readAttribute(elem, ""width"", ""0""));\n    double h = toHeight(elem, readAttribute(elem, ""height"", ""0""));\n    DefaultStyledDocument doc = new DefaultStyledDocument();\n    try {\n      if (elem.getContent() != null) {\n        doc.insertString(0, toText(elem, elem.getContent()), null);\n      } else {\n        for (IXMLElement node : elem.getChildren()) {\n          if (node.getName() == null) {\n            doc.insertString(doc.getLength(), toText(elem, node.getContent()), null);\n          } else if (node.getName().equals(""tbreak"")) {\n            doc.insertString(doc.getLength(), ""\\n"", null);\n          } else if (node.getName().equals(""tspan"")) {\n            readTSpanElement((IXMLElement) node, doc);\n          } else {\n            if (DEBUG) {\n              System.out.println(""SVGInputFormat unknown  text node "" + node.getName());\n            }\n          }\n        }\n      }\n    } catch (BadLocationException e) {\n      InternalError ex = new InternalError(e.getMessage());\n      ex.initCause(e);\n      throw ex;\n    }\n    Figure figure = factory.createTextArea(x, y, w, h, doc, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2663,readSwitchElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,1041,1089,7,"/**\n   * Evaluates an SVG ""switch"" element.\n   *\n   */\n --------------\n//""http://www.w3.org/Graphics/SVG/feature/1.2/#XlinkAttribute"",\n --------------",46,"  private Figure readSwitchElement(IXMLElement elem)\n      throws IOException {\n    for (IXMLElement node : elem.getChildren()) {\n      if (node instanceof IXMLElement) {\n        IXMLElement child = (IXMLElement) node;\n        String[] requiredFeatures = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredFeatures"", """"));\n        String[] requiredExtensions = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredExtensions"", """"));\n        String[] systemLanguage = toWSOrCommaSeparatedArray(readAttribute(child, ""systemLanguage"", """"));\n        String[] requiredFormats = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredFormats"", """"));\n        String[] requiredFonts = toWSOrCommaSeparatedArray(readAttribute(child, ""requiredFonts"", """"));\n        boolean isMatch;\n        isMatch = supportedFeatures.containsAll(Arrays.asList(requiredFeatures)) &&\n            requiredExtensions.length == 0 &&\n            requiredFormats.length == 0 &&\n            requiredFonts.length == 0;\n        if (isMatch && systemLanguage.length > 0) {\n          isMatch = false;\n          Locale locale = LocaleUtil.getDefault();\n          for (String lng : systemLanguage) {\n            int p = lng.indexOf(\'-\');\n            if (p == -1) {\n              if (locale.getLanguage().equals(lng)) {\n                isMatch = true;\n                break;\n              }\n            } else {\n              if (locale.getLanguage().equals(lng.substring(0, p)) &&\n                  locale.getCountry().toLowerCase().equals(lng.substring(p + 1))) {\n                isMatch = true;\n                break;\n              }\n            }\n          }\n        }\n        if (isMatch) {\n          Figure figure = readElement(child);\n          if (readAttribute(child, ""visibility"", ""visible"").equals(""visible"") &&\n              !readAttribute(child, ""display"", ""inline"").equals(""none"")) {\n            return figure;\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n    return null;\n"
2664,readImageElement,SVGInputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGInputFormat.java,667,751,3,"/**\n   * Reads an SVG ""image"" element.\n   */",80,"  private Figure readImageElement(IXMLElement elem)\n      throws IOException {\n    HashMap<AttributeKey, Object> a = new HashMap<AttributeKey, Object>();\n    readCoreAttributes(elem, a);\n    readTransformAttribute(elem, a);\n    readOpacityAttribute(elem, a);\n    double x = toNumber(elem, readAttribute(elem, ""x"", ""0""));\n    double y = toNumber(elem, readAttribute(elem, ""y"", ""0""));\n    double w = toWidth(elem, readAttribute(elem, ""width"", ""0""));\n    double h = toHeight(elem, readAttribute(elem, ""height"", ""0""));\n    String href = readAttribute(elem, ""xlink:href"", null);\n    if (href == null) {\n      href = readAttribute(elem, ""href"", null);\n    }\n    byte[] imageData = null;\n    if (href != null) {\n      if (href.startsWith(""data:"")) {\n        int semicolonPos = href.indexOf(\';\');\n        if (semicolonPos != -1) {\n          if (href.indexOf("";base64,"") == semicolonPos) {\n            imageData = Base64.decode(href.substring(semicolonPos + 8));\n          } else {\n            throw new IOException(""Unsupported encoding in data href in image element:"" + href);\n          }\n        } else {\n          throw new IOException(""Unsupported data href in image element:"" + href);\n        }\n      } else {\n        URL imageUrl = new URL(url, href);\n        // Check whether the imageURL is an SVG image.\n        // Load it as a group.\n        if (imageUrl.getFile().endsWith(""svg"")) {\n          SVGInputFormat svgImage = new SVGInputFormat(factory);\n          Drawing svgDrawing = new DefaultDrawing();\n          svgImage.read(imageUrl, svgDrawing, true);\n          CompositeFigure svgImageGroup = factory.createG(a);\n          for (Figure f : svgDrawing.getChildren()) {\n            svgImageGroup.add(f);\n          }\n          svgImageGroup.setBounds(new Point2D.Double(x, y), new Point2D.Double(x + w, y + h));\n          return svgImageGroup;\n        }\n        // Read the image data from the URL into a byte array\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        byte[] buf = new byte[512];\n        int len = 0;\n        try {\n          InputStream in = imageUrl.openStream();\n          try {\n            while ((len = in.read(buf)) > 0) {\n              bout.write(buf, 0, len);\n            }\n            imageData = bout.toByteArray();\n          } finally {\n            in.close();\n          }\n        } catch (FileNotFoundException e) {\n          // Use empty image\n        }\n      }\n    }\n    // Create a buffered image from the image data\n    BufferedImage bufferedImage = null;\n    if (imageData != null) {\n      try {\n        bufferedImage = ImageIO.read(new ByteArrayInputStream(imageData));\n      } catch (IIOException e) {\n        System.err.println(""SVGInputFormat warning: skipped unsupported image format."");\n        e.printStackTrace();\n      }\n    }\n    // Delete the image data in case of failure\n    if (bufferedImage == null) {\n      imageData = null;\n      //if (DEBUG) System.out.println(""FAILED:""+imageUrl);\n    }\n    // Create a figure from the image data and the buffered image.\n    Figure figure = factory.createImage(x, y, w, h, imageData, bufferedImage, a);\n    elementObjects.put(elem, figure);\n    return figure;\n"
2666,write,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,1311,1338,3,/**\n   * All other write methods delegate their work to here.\n   */,22,"  public void write(OutputStream out, Drawing drawing, java.util.List<Figure> figures) throws IOException {\n    document = new XMLElement(""svg"", SVG_NAMESPACE);\n    document.setAttribute(""xmlns:xlink"", ""http://www.w3.org/1999/xlink"");\n    document.setAttribute(""version"", ""1.2"");\n    document.setAttribute(""baseProfile"", ""tiny"");\n    writeViewportAttributes(document, drawing.getAttributes());\n    initStorageContext(document);\n    defs = new XMLElement(""defs"");\n    document.addChild(defs);\n    for (Figure f : figures) {\n      writeElement(document, f);\n    }\n    // Write XML prolog\n    PrintWriter writer = new PrintWriter(\n        new OutputStreamWriter(out, ""UTF-8""));\n    writer.println(""<?xml version=\\""1.0\\"" encoding=\\""UTF-8\\""?>"");\n    // Write XML content\n    XMLWriter xmlWriter = new XMLWriter(writer);\n    xmlWriter.write(document, isPrettyPrint);\n    // Flush writer\n    writer.flush();\n    document.dispose();\n"
2667,toNumber,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,1169,1174,3,/**\n   * Returns a double array as a number attribute value.\n   */,6,"  public static String toNumber(double number) {\n    String str = (isFloatPrecision) ? Float.toString((float) number) : Double.toString(number);\n    if (str.endsWith("".0"")) {\n      str = str.substring(0, str.length() - 2);\n    }\n    return str;\n"
2668,writeTransformAttribute,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,846,850,4,/* Writes the transform attribute as specified in\n   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute\n   *\n   */,5,"  protected void writeTransformAttribute(IXMLElement elem, Map<AttributeKey, Object> a)\n      throws IOException {\n    AffineTransform t = TRANSFORM.get(a);\n    if (t != null) {\n      writeAttribute(elem, ""transform"", toTransform(t), ""none"");\n"
2669,writeFontAttributes,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,857,934,3,/* Writes font attributes as listed in\n   * http://www.w3.org/TR/SVGMobile12/feature.html#Font\n   */,72,"  private void writeFontAttributes(IXMLElement elem, Map<AttributeKey, Object> a)\n      throws IOException {\n    String value;\n    double doubleValue;\n    // \'font-family\'\n    // Value:    [[ <family-name> |\n    // <generic-family> ],]* [<family-name> |\n    // <generic-family>] | inherit\n    // Initial:    depends on user agent\n    // Applies to:    text content elements\n    // Inherited:    yes\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""font-family"", FONT_FACE.get(a).getFontName(), ""Dialog"");\n    // \'font-getChildCount\'\n    // Value:    <absolute-getChildCount> | <relative-getChildCount> |\n    // <length> | inherit\n    // Initial:    medium\n    // Applies to:    text content elements\n    // Inherited:    yes, the computed value is inherited\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     Absolute length\n    writeAttribute(elem, ""font-size"", FONT_SIZE.get(a), 0d);\n    // \'font-style\'\n    // Value:    normal | italic | oblique | inherit\n    // Initial:    normal\n    // Applies to:    text content elements\n    // Inherited:    yes\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""font-style"", (FONT_ITALIC.get(a)) ? ""italic"" : ""normal"", ""normal"");\n\n    //\'font-variant\'\n    //Value:    normal | small-caps | inherit\n    //Initial:    normal\n    //Applies to:    text content elements\n    //Inherited:    yes\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    no\n    //Computed value:     Specified value, except inherit\n    // XXX - Implement me\n    writeAttribute(elem, ""font-variant"", ""normal"", ""normal"");\n    // \'font-weight\'\n    // Value:    normal | bold | bolder | lighter | 100 | 200 | 300\n    // | 400 | 500 | 600 | 700 | 800 | 900 | inherit\n    // Initial:    normal\n    // Applies to:    text content elements\n    // Inherited:    yes\n    // Percentages:    N/A\n    // Media:    visual\n    // Animatable:    yes\n    // Computed value:     one of the legal numeric values, non-numeric\n    // values shall be converted to numeric values according to the rules\n    // defined below.\n    writeAttribute(elem, ""font-weight"", (FONT_BOLD.get(a)) ? ""bold"" : ""normal"", ""normal"");\n    // Note: text-decoration is an SVG 1.1 feature\n    //\'text-decoration\'\n    //Value:    none | [ underline || overline || line-through || blink ] | inherit\n    //Initial:    none\n    //Applies to:    text content elements\n    //Inherited:    no (see prose)\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    writeAttribute(elem, ""text-decoration"", (FONT_UNDERLINE.get(a)) ? ""underline"" : ""none"", ""none"");\n"
2671,writeOpacityAttribute,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,823,839,2,/* Writes the opacity attribute.\n   */,17,"  protected void writeOpacityAttribute(IXMLElement elem, Map<AttributeKey, Object> m)\n      throws IOException {\n    //\'opacity\'\n    //Value:    <opacity-value> | inherit\n    //Initial:    1\n    //Applies to:     \'image\' element\n    //Inherited:    no\n    //Percentages:    N/A\n    //Media:    visual\n    //Animatable:    yes\n    //Computed value:     Specified value, except inherit\n    //<opacity-value>\n    //The uniform opacity setting must be applied across an entire object.\n    //Any values outside the range 0.0 (fully transparent) to 1.0\n    //(fully opaque) shall be clamped to this range.\n    //(See Clamping values which are restricted to a particular range.)\n    writeAttribute(elem, ""opacity"", OPACITY.get(m), 1d);\n"
2672,writeShapeAttributes,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,581,818,2,/* Writes shape attributes.\n   */,225,"  protected void writeShapeAttributes(IXMLElement elem, Map<AttributeKey, Object> m)\n      throws IOException {\n    Color color;\n    String value;\n    int intValue;\n    //\'color\'\n    // Value:    <color> | inherit\n    // Initial:     depends on user agent\n    // Applies to:    None. Indirectly affects other properties via currentColor\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified <color> value, except inherit\n    //\n    // Nothing to do: Attribute \'color\' is not needed.\n    //\'color-rendering\'\n    // Value:     auto | optimizeSpeed | optimizeQuality | inherit\n    // Initial:     auto\n    // Applies to:     container elements , graphics elements and \'animateColor\'\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    //\n    // Nothing to do: Attribute \'color-rendering\' is not needed.\n    // \'fill\'\n    // Value:    <paint> | inherit (See Specifying paint)\n    // Initial:     black\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     ""none"", system paint, specified <color> value or absolute IRI\n    Gradient gradient = FILL_GRADIENT.get(m);\n    if (gradient != null) {\n      String id;\n      if (gradientToIDMap.containsKey(gradient)) {\n        id = gradientToIDMap.get(gradient);\n      } else {\n        IXMLElement gradientElem;\n        if (gradient instanceof LinearGradient) {\n          LinearGradient lg = (LinearGradient) gradient;\n          gradientElem = createLinearGradient(document,\n              lg.getX1(), lg.getY1(),\n              lg.getX2(), lg.getY2(),\n              lg.getStopOffsets(),\n              lg.getStopColors(),\n              lg.getStopOpacities(),\n              lg.isRelativeToFigureBounds(),\n              lg.getTransform());\n        } else /*if (gradient instanceof RadialGradient)*/ {\n          RadialGradient rg = (RadialGradient) gradient;\n          gradientElem = createRadialGradient(document,\n              rg.getCX(), rg.getCY(),\n              rg.getFX(), rg.getFY(),\n              rg.getR(),\n              rg.getStopOffsets(),\n              rg.getStopColors(),\n              rg.getStopOpacities(),\n              rg.isRelativeToFigureBounds(),\n              rg.getTransform());\n        }\n        id = getId(gradientElem);\n        gradientElem.setAttribute(""id"", ""xml"", id);\n        defs.addChild(gradientElem);\n        gradientToIDMap.put(gradient, id);\n      }\n      writeAttribute(elem, ""fill"", ""url(#"" + id + "")"", ""#000"");\n    } else {\n      writeAttribute(elem, ""fill"", toColor(FILL_COLOR.get(m)), ""#000"");\n    }\n\n    //\'fill-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""fill-opacity"", FILL_OPACITY.get(m), 1d);\n    // \'fill-rule\'\n    // Value:   nonzero | evenodd | inherit\n    // Initial:    nonzero\n    // Applies to:     shapes and text content elements\n    // Inherited:     yes\n    // Percentages:     N/A\n    // Media:     visual\n    // Animatable:     yes\n    // Computed value:     Specified value, except inherit\n    if (WINDING_RULE.get(m) != WindingRule.NON_ZERO) {\n      writeAttribute(elem, ""fill-rule"", ""evenodd"", ""nonzero"");\n    }\n    //\'stroke\'\n    //Value:    <paint> | inherit (See Specifying paint)\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     ""none"", system paint, specified <color> value\n    // or absolute IRI\n    gradient = STROKE_GRADIENT.get(m);\n    if (gradient != null) {\n      String id;\n      if (gradientToIDMap.containsKey(gradient)) {\n        id = gradientToIDMap.get(gradient);\n      } else {\n        IXMLElement gradientElem;\n        if (gradient instanceof LinearGradient) {\n          LinearGradient lg = (LinearGradient) gradient;\n          gradientElem = createLinearGradient(document,\n              lg.getX1(), lg.getY1(),\n              lg.getX2(), lg.getY2(),\n              lg.getStopOffsets(),\n              lg.getStopColors(),\n              lg.getStopOpacities(),\n              lg.isRelativeToFigureBounds(),\n              lg.getTransform());\n        } else /*if (gradient instanceof RadialGradient)*/ {\n          RadialGradient rg = (RadialGradient) gradient;\n          gradientElem = createRadialGradient(document,\n              rg.getCX(), rg.getCY(),\n              rg.getFX(), rg.getFY(),\n              rg.getR(),\n              rg.getStopOffsets(),\n              rg.getStopColors(),\n              rg.getStopOpacities(),\n              rg.isRelativeToFigureBounds(),\n              rg.getTransform());\n        }\n        id = getId(gradientElem);\n        gradientElem.setAttribute(""id"", ""xml"", id);\n        defs.addChild(gradientElem);\n        gradientToIDMap.put(gradient, id);\n      }\n      writeAttribute(elem, ""stroke"", ""url(#"" + id + "")"", ""none"");\n    } else {\n      writeAttribute(elem, ""stroke"", toColor(STROKE_COLOR.get(m)), ""none"");\n    }\n    //\'stroke-dasharray\'\n    //Value:     none | <dasharray> | inherit\n    //Initial:     none\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes (non-additive)\n    //Computed value:     Specified value, except inherit\n    double[] dashes = STROKE_DASHES.get(m);\n    if (dashes != null) {\n      StringBuilder buf = new StringBuilder();\n      for (int i = 0; i < dashes.length; i++) {\n        if (i != 0) {\n          buf.append(\',\');\n        }\n        buf.append(toNumber(dashes[i]));\n      }\n      writeAttribute(elem, ""stroke-dasharray"", buf.toString(), null);\n    }\n    //\'stroke-dashoffset\'\n    //Value:    <length> | inherit\n    //Initial:     0\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""stroke-dashoffset"", STROKE_DASH_PHASE.get(m), 0d);\n    //\'stroke-linecap\'\n    //Value:     butt | round | square | inherit\n    //Initial:     butt\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""stroke-linecap"", strokeLinecapMap.get(STROKE_CAP.get(m)), ""butt"");\n    //\'stroke-linejoin\'\n    //Value:     miter | round | bevel | inherit\n    //Initial:     miter\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""stroke-linejoin"", strokeLinejoinMap.get(STROKE_JOIN.get(m)), ""miter"");\n    //\'stroke-miterlimit\'\n    //Value:     <miterlimit> | inherit\n    //Initial:     4\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""stroke-miterlimit"", STROKE_MITER_LIMIT.get(m), 4d);\n    //\'stroke-opacity\'\n    //Value:     <opacity-value> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""stroke-opacity"", STROKE_OPACITY.get(m), 1d);\n    //\'stroke-width\'\n    //Value:    <length> | inherit\n    //Initial:     1\n    //Applies to:     shapes and text content elements\n    //Inherited:     yes\n    //Percentages:     N/A\n    //Media:     visual\n    //Animatable:     yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""stroke-width"", STROKE_WIDTH.get(m), 1d);\n"
2673,writeViewportAttributes,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,939,970,2,/* Writes viewport attributes.\n   */,30,"  private void writeViewportAttributes(IXMLElement elem, Map<AttributeKey, Object> a)\n      throws IOException {\n    Object value;\n    Double doubleValue;\n    if (VIEWPORT_WIDTH.get(a) != null && VIEWPORT_HEIGHT.get(a) != null) {\n      // width of the viewport\n      writeAttribute(elem, ""width"", toNumber(VIEWPORT_WIDTH.get(a)), null);\n      // height of the viewport\n      writeAttribute(elem, ""height"", toNumber(VIEWPORT_HEIGHT.get(a)), null);\n    }\n    //\'viewport-fill\'\n    //Value:   ""none"" | <color> | inherit\n    //Initial:   none\n    //Applies to:  viewport-creating elements\n    //Inherited:   no\n    //Percentages:   N/A\n    //Media:   visual\n    //Animatable:   yes\n    //Computed value:     ""none"" or specified <color> value, except inherit\n    writeAttribute(elem, ""viewport-fill"", toColor(VIEWPORT_FILL.get(a)), ""none"");\n    //\'viewport-fill-opacity\'\n    //Value:  <opacity-value> | inherit\n    //Initial:   1.0\n    //Applies to:  viewport-creating elements\n    //Inherited:   no\n    //Percentages:   N/A\n    //Media:   visual\n    //Animatable:   yes\n    //Computed value:     Specified value, except inherit\n    writeAttribute(elem, ""viewport-fill-opacity"", VIEWPORT_FILL_OPACITY.get(a), 1.0);\n"
2674,toTransform,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,1197,1270,3,/* Converts an AffineTransform into an SVG transform attribute value as specified in\n   * http://www.w3.org/TR/SVGMobile12/coords.html#TransformAttribute\n   */,73,"  public static String toTransform(AffineTransform t) throws IOException {\n    StringBuilder buf = new StringBuilder();\n    switch (t.getType()) {\n      case AffineTransform.TYPE_IDENTITY:\n        buf.append(""none"");\n        break;\n      case AffineTransform.TYPE_TRANSLATION:\n        // translate(<tx> [<ty>]), specifies a translation by tx and ty.\n        // If <ty> is not provided, it is assumed to be zero.\n        buf.append(""translate("");\n        buf.append(toNumber(t.getTranslateX()));\n        if (t.getTranslateY() != 0d) {\n          buf.append(\' \');\n          buf.append(toNumber(t.getTranslateY()));\n        }\n        buf.append(\')\');\n        break;\n      /*\n      case AffineTransform.TYPE_GENERAL_ROTATION :\n      case AffineTransform.TYPE_QUADRANT_ROTATION :\n      case AffineTransform.TYPE_MASK_ROTATION :\n      // rotate(<rotate-angle> [<cx> <cy>]), specifies a rotation by\n      // <rotate-angle> degrees about a given point.\n      // If optional parameters <cx> and <cy> are not supplied, the\n      // rotate is about the origin of the current user coordinate\n      // system. The operation corresponds to the matrix\n      // [cos(a) sin(a) -sin(a) cos(a) 0 0].\n      // If optional parameters <cx> and <cy> are supplied, the rotate\n      // is about the point (<cx>, <cy>). The operation represents the\n      // equivalent of the following specification:\n      // translate(<cx>, <cy>) rotate(<rotate-angle>)\n      // translate(-<cx>, -<cy>).\n      buf.append(""rotate("");\n      buf.append(toNumber(t.getScaleX()));\n      buf.append(\')\');\n      break;*/\n      case AffineTransform.TYPE_UNIFORM_SCALE:\n        // scale(<sx> [<sy>]), specifies a scale operation by sx\n        // and sy. If <sy> is not provided, it is assumed to be equal\n        // to <sx>.\n        buf.append(""scale("");\n        buf.append(toNumber(t.getScaleX()));\n        buf.append(\')\');\n        break;\n      case AffineTransform.TYPE_GENERAL_SCALE:\n      case AffineTransform.TYPE_MASK_SCALE:\n        // scale(<sx> [<sy>]), specifies a scale operation by sx\n        // and sy. If <sy> is not provided, it is assumed to be equal\n        // to <sx>.\n        buf.append(""scale("");\n        buf.append(toNumber(t.getScaleX()));\n        buf.append(\' \');\n        buf.append(toNumber(t.getScaleY()));\n        buf.append(\')\');\n        break;\n      default:\n        // matrix(<a> <b> <c> <d> <e> <f>), specifies a transformation\n        // in the form of a transformation matrix of six values.\n        // matrix(a,b,c,d,e,f) is equivalent to applying the\n        // transformation matrix [a b c d e f].\n        buf.append(""matrix("");\n        double[] matrix = new double[6];\n        t.getMatrix(matrix);\n        for (int i = 0; i < matrix.length; i++) {\n          if (i != 0) {\n            buf.append(\' \');\n          }\n          buf.append(toNumber(matrix[i]));\n        }\n        buf.append(\')\');\n        break;\n    }\n    return buf.toString();\n"
2675,toPath,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,997,1163,3,/** Returns a value as a SVG Path attribute.\n   * as specified in http://www.w3.org/TR/SVGMobile12/paths.html#PathDataBNF\n   */,162,"  public static String toPath(BezierPath[] paths) {\n    StringBuilder buf = new StringBuilder();\n    for (int j = 0; j < paths.length; j++) {\n      BezierPath path = paths[j];\n      if (path.size() == 0) {\n        // nothing to do\n      } else if (path.size() == 1) {\n        BezierPath.Node current = path.get(0);\n        buf.append(""M "");\n        buf.append(toNumber(current.x[0]));\n        buf.append(\' \');\n        buf.append(toNumber(current.y[0]));\n        //buf.append("" L "");\n        buf.append(toNumber(current.x[0]));\n        buf.append(\' \');\n        buf.append(toNumber(current.y[0] + 1));\n      } else {\n        BezierPath.Node previous;\n        BezierPath.Node current;\n        previous = current = path.get(0);\n        buf.append(""M "");\n        buf.append(toNumber(current.x[0]));\n        buf.append(\' \');\n        buf.append(toNumber(current.y[0]));\n        char nextCommand = \'L\';\n        for (int i = 1, n = path.size(); i < n; i++) {\n          previous = current;\n          current = path.get(i);\n          if ((previous.mask & BezierPath.C2_MASK) == 0) {\n            if ((current.mask & BezierPath.C1_MASK) == 0) {\n              if (nextCommand != \'L\') {\n                buf.append("" L "");\n                nextCommand = \'L\';\n              } else {\n                buf.append(\' \');\n              }\n              buf.append(toNumber(current.x[0]));\n              buf.append(\' \');\n              buf.append(toNumber(current.y[0]));\n            } else {\n              if (nextCommand != \'Q\') {\n                buf.append("" Q "");\n                nextCommand = \'Q\';\n              } else {\n                buf.append(\' \');\n              }\n              buf.append(toNumber(current.x[1]));\n              buf.append(\' \');\n              buf.append(toNumber(current.y[1]));\n              buf.append(\' \');\n              buf.append(toNumber(current.x[0]));\n              buf.append(\' \');\n              buf.append(toNumber(current.y[0]));\n            }\n          } else {\n            if ((current.mask & BezierPath.C1_MASK) == 0) {\n              if (nextCommand != \'Q\') {\n                buf.append("" Q "");\n                nextCommand = \'Q\';\n              } else {\n                buf.append(\' \');\n              }\n              buf.append(toNumber(previous.x[2]));\n              buf.append(\' \');\n              buf.append(toNumber(previous.y[2]));\n              buf.append(\' \');\n              buf.append(toNumber(current.x[0]));\n              buf.append(\' \');\n              buf.append(toNumber(current.y[0]));\n            } else {\n              if (nextCommand != \'C\') {\n                buf.append("" C "");\n                nextCommand = \'C\';\n              } else {\n                buf.append(\' \');\n              }\n              buf.append(toNumber(previous.x[2]));\n              buf.append(\' \');\n              buf.append(toNumber(previous.y[2]));\n              buf.append(\' \');\n              buf.append(toNumber(current.x[1]));\n              buf.append(\' \');\n              buf.append(toNumber(current.y[1]));\n              buf.append(\' \');\n              buf.append(toNumber(current.x[0]));\n              buf.append(\' \');\n              buf.append(toNumber(current.y[0]));\n            }\n          }\n        }\n        if (path.isClosed()) {\n          if (path.size() > 1) {\n            previous = path.get(path.size() - 1);\n            current = path.get(0);\n            if ((previous.mask & BezierPath.C2_MASK) == 0) {\n              if ((current.mask & BezierPath.C1_MASK) == 0) {\n                if (nextCommand != \'L\') {\n                  buf.append("" L "");\n                  nextCommand = \'L\';\n                } else {\n                  buf.append(\' \');\n                }\n                buf.append(toNumber(current.x[0]));\n                buf.append(\' \');\n                buf.append(toNumber(current.y[0]));\n              } else {\n                if (nextCommand != \'Q\') {\n                  buf.append("" Q "");\n                  nextCommand = \'Q\';\n                } else {\n                  buf.append(\' \');\n                }\n                buf.append(toNumber(current.x[1]));\n                buf.append(\' \');\n                buf.append(toNumber(current.y[1]));\n                buf.append(\' \');\n                buf.append(toNumber(current.x[0]));\n                buf.append(\' \');\n                buf.append(toNumber(current.y[0]));\n              }\n            } else {\n              if ((current.mask & BezierPath.C1_MASK) == 0) {\n                if (nextCommand != \'Q\') {\n                  buf.append("" Q "");\n                  nextCommand = \'Q\';\n                } else {\n                  buf.append(\' \');\n                }\n                buf.append(toNumber(previous.x[2]));\n                buf.append(\' \');\n                buf.append(toNumber(previous.y[2]));\n                buf.append(\' \');\n                buf.append(toNumber(current.x[0]));\n                buf.append(\' \');\n                buf.append(toNumber(current.y[0]));\n              } else {\n                if (nextCommand != \'C\') {\n                  buf.append("" C "");\n                  nextCommand = \'C\';\n                } else {\n                  buf.append(\' \');\n                }\n                buf.append(toNumber(previous.x[2]));\n                buf.append(\' \');\n                buf.append(toNumber(previous.y[2]));\n                buf.append(\' \');\n                buf.append(toNumber(current.x[1]));\n                buf.append(\' \');\n                buf.append(toNumber(current.y[1]));\n                buf.append(\' \');\n                buf.append(toNumber(current.x[0]));\n                buf.append(\' \');\n                buf.append(toNumber(current.y[0]));\n              }\n            }\n          }\n          buf.append("" Z"");\n          nextCommand = \'\\0\';\n        }\n      }\n    }\n    return buf.toString();\n"
2676,toPoints,SVGOutputFormat,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/io/SVGOutputFormat.java,1181,1191,4,/**\n   * Returns a Point2D.Double array as a Points attribute value.\n   * as specified in http://www.w3.org/TR/SVGMobile12/shapes.html#PointsBNF\n   */,11,"  public static String toPoints(Point2D.Double[] points) throws IOException {\n    StringBuilder buf = new StringBuilder();\n    for (int i = 0; i < points.length; i++) {\n      if (i != 0) {\n        buf.append("", "");\n      }\n      buf.append(toNumber(points[i].x));\n      buf.append(\',\');\n      buf.append(toNumber(points[i].y));\n    }\n    return buf.toString();\n"
2677,ViewToolBar,ViewToolBar,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/gui/ViewToolBar.java,45,48,1,/** Creates new instance. */,4,"  public ViewToolBar() {\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    setName(labels.getString(getID() + "".toolbar""));\n    setDisclosureStateCount(3);\n"
2678,getTransferData,XMLTransferable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java,57,61,11,/**\n   * Returns an object which represents the data to be transferred.  The class\n   * of the object returned is defined by the representation class of the flavor.\n   *\n   * @param flavor the requested flavor for the data\n   * @see DataFlavor#getRepresentationClass\n   * @exception IOException        if the data is no longer available\n   *       in the requested flavor.\n   * @exception UnsupportedFlavorException if the requested data flavor is\n   *       not supported.\n   */,5,"  public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {\n    if (this.flavor.equals(flavor)) {\n      return new ByteArrayInputStream(data);\n    } else {\n      throw new UnsupportedFlavorException(flavor);\n"
2679,getTransferDataFlavors,XMLTransferable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java,71,72,6,/**\n   * Returns an array of DataFlavor objects indicating the flavors the data\n   * can be provided in.  The array should be ordered according to preference\n   * for providing the data (from most richly descriptive to least descriptive).\n   * @return an array of data flavors in which this data can be transferred\n   */,2,  public DataFlavor[] getTransferDataFlavors() {\n    return new DataFlavor[] {flavor};\n
2680,XMLTransferable,XMLTransferable,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/xml/XMLTransferable.java,31,33,1,/** Creates new XMLTransferable */,3,"  public XMLTransferable(byte[] data, String mimeType, String humanPresentableName) {\n    this.data = data;\n    this.flavor = new DataFlavor(mimeType, humanPresentableName);\n"
2683,PathTool,PathTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/PathTool.java,47,48,1,/** Creates a new instance. */,2,"  public PathTool(SVGPathFigure pathPrototype, SVGBezierFigure bezierPrototype) {\n    this(pathPrototype, bezierPrototype, null);\n"
2684,createDrawing,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,268,277,3,/**\n   * Creates the drawing.\n   */,10,"  protected Drawing createDrawing() {\n    DefaultDrawing drawing = new DefaultDrawing();\n    drawing.addInputFormat(new SVGZInputFormat());\n    drawing.addInputFormat(new ImageInputFormat(new SVGImageFigure()));\n    drawing.addOutputFormat(new SVGOutputFormat());\n    drawing.addOutputFormat(new SVGZOutputFormat());\n    drawing.addOutputFormat(new ImageOutputFormat());\n    drawing.addOutputFormat(new ImageOutputFormat(""JPG"", ""Joint Photographics Experts Group (JPEG)"", ""jpg"", BufferedImage.TYPE_INT_RGB));\n    drawing.addOutputFormat(new ImageOutputFormat(""BMP"", ""Windows Bitmap (BMP)"", ""bmp"", BufferedImage.TYPE_BYTE_INDEXED));\n    return drawing;\n"
2685,init,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,104,206,7,/**\n   * Displays a progress indicator and then invokes <code>loadDrawing</code>\n   * on a worker thread. Displays the drawing panel when done successfully.\n   * Displays an error message when done unsuccessfully.\n   *\n   * @see #loadDrawing\n   */,92,"  @Override\n  public final void init() {\n    // set the language of the applet\n    if (getParameter(""Locale"") != null) {\n      Locale.setDefault(new Locale(getParameter(""Locale"")));\n    }\n\n    final ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    // Set look and feel\n    // -----------------\n    try {\n      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Throwable e) {\n      // Do nothing.\n      // If we can\'t set the desired look and feel, UIManager does\n      // automaticaly the right thing for us.\n    }\n    // Set our own popup factory, because the one that comes with Mac OS X\n    // creates translucent popups which is not useful for color selection\n    // using pop menus.\n    try {\n      PopupFactory.setSharedInstance(new PopupFactory());\n    } catch (Throwable e) {\n      // If we can\'t set the popup factory, we have to use what is there.\n    }\n    // Display a progress indicator while we are loading the drawing\n    // ----------------------------------------------------------\n    Container c = getContentPane();\n    final ProgressIndicator progress = new ProgressIndicator(\n        getName(), labels.getString(""progressInitializing""));\n    c.add(progress);\n    progress.revalidate();\n    // Load the drawing using a worker thread\n    // --------------------------------------\n    new Worker() {\n      protected Object construct() throws Exception {\n        Thread t = new Thread() {\n          @Override\n          public void run() {\n            drawingComponent = createDrawingComponent();\n          }\n        };\n        t.start();\n        progress.setNote(labels.getString(""progressLoading""));\n        Object drawing = loadDrawing(progress);\n        progress.setNote(labels.getString(""progressOpeningEditor""));\n        progress.setIndeterminate(true);\n        t.join();\n        return drawing;\n      }\n      protected void done(Object result) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        c.add(drawingComponent.getComponent());\n        initComponents();\n        if (result != null) {\n          if (result instanceof Drawing) {\n            setDrawing((Drawing) result);\n          } else if (result instanceof Throwable) {\n            setDrawing(createDrawing());\n            getDrawing().add(new SVGTextFigure(result.toString()));\n            ((Throwable) result).printStackTrace();\n          }\n        }\n        drawingComponent.revalidate();\n      }\n      protected void failed(Throwable result) {\n        Container c = getContentPane();\n        c.setLayout(new BorderLayout());\n        c.removeAll();\n        Throwable error = (Throwable) result;\n        error.printStackTrace();\n        String message = (error.getMessage() == null) ? error.toString() : error.getMessage();\n        MessagePanel mp = new MessagePanel(\n            UIManager.getIcon(""OptionPane.errorIcon""),\n            labels.getFormatted(""messageLoadFailed"", htmlencode(getParameter(""DrawingURL"")), htmlencode(message)));\n        c.add(mp);\n        mp.addActionListener(new ActionListener() {\n          public void actionPerformed(ActionEvent evt) {\n            if (evt.getActionCommand().equals(""close"")) {\n              close();\n            }\n          }\n        });\n        mp.revalidate();\n      }\n      protected void finished() {\n        long end = System.currentTimeMillis();\n        System.out.println(""AbstractDrawingApplet startup latency:"" + (end - start));\n      }\n    }.start();\n"
2686,getParameter,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,75,80,4,/**\n   * Same as <code>Applet.getParameter()</code> but doesn't throw a\n   * NullPointerException when used without an Applet context.\n   */,6,  @Override\n  public String getParameter(String name) {\n    try {\n      return super.getParameter(name);\n    } catch (NullPointerException e) {\n      return null;\n
2687,htmlencode,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,402,432,5,"/**\n   * Escapes all \'<\', \'>\' and \'&\' characters in a string.\n   * @param str A String.\n   * @return HTMlEncoded String.\n   */",24,"  private static String htmlencode(String str) {\n    if (str == null) {\n      return """";\n    } else {\n      StringBuilder buf = new StringBuilder();\n      for (char ch : str.toCharArray()) {\n        switch (ch) {\n          case \'<\':\n            buf.append(""&lt;"");\n            break;\n          case \'>\':\n            buf.append(""&gt;"");\n            break;\n          case \'&\':\n            buf.append(""&amp;"");\n            break;\n          default:\n            buf.append(ch);\n            break;\n        }\n\n\n      }\n      return buf.toString();\n"
2688,setDrawing,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,212,213,3,/**\n   * Sets the drawing on the drawing panel.\n   */,2,  private void setDrawing(Drawing d) {\n    drawingComponent.setDrawing(d);\n
2689,getParameter,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,88,93,4,/**\n   * Same as <code>Applet.getParameter()</code> but doesn't throw a\n   * NullPointerException when used without an Applet context.\n   */,6,"  public String getParameter(String name, String defaultValue) {\n    try {\n      String value = super.getParameter(name);\n      return (value == null) ? defaultValue : value;\n    } catch (NullPointerException e) {\n      return defaultValue;\n"
2690,getDrawing,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,219,220,3,/**\n   * Gets the drawing from the drawing panel.\n   */,2,  private Drawing getDrawing() {\n    return drawingComponent.getDrawing();\n
2691,getAppletInfo,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,253,259,3,/**\n   * Returns information about the applet.\n   */,7,"  @Override\n  public String getAppletInfo() {\n    return getName() +\n        ""\\nVersion "" + getVersion() +\n        ""\\n\\nCopyright 1996-2010 (c) by the original authors of JHotDraw and all its contributors"" +\n        ""\\nThis software is licensed under LGPL or"" +\n        ""\\nCreative Commons 2.5 BY"";\n"
2692,loadDrawing,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,310,370,8,/**\n   * Loads the drawing.\n   * By convention this method is invoked on a worker thread.\n   *\n   * @param progress A ProgressIndicator to inform the user about the progress\n   * of the operation.\n   * @return The Drawing that was loaded.\n   */,58,"  protected Drawing loadDrawing(ProgressIndicator progress) throws IOException {\n    Drawing drawing = createDrawing();\n    if (getParameter(""datafile"") != null) {\n      ByteArrayOutputStream buf = new ByteArrayOutputStream();\n      URL url = new URL(getDocumentBase(), getParameter(""datafile""));\n      URLConnection uc = url.openConnection();\n      // Disable caching. This ensures that we always request the\n      // newest version of the drawing from the server.\n      // (Note: The server still needs to set the proper HTTP caching\n      // properties to prevent proxies from caching the drawing).\n      if (uc instanceof HttpURLConnection) {\n        ((HttpURLConnection) uc).setUseCaches(false);\n      }\n      // Read the data into a buffer\n      int contentLength = uc.getContentLength();\n      InputStream in = uc.getInputStream();\n      try {\n        if (contentLength != -1) {\n          in = new BoundedRangeInputStream(in);\n          ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);\n          progress.setProgressModel((BoundedRangeModel) in);\n          progress.setIndeterminate(false);\n        }\n        BufferedInputStream bin = new BufferedInputStream(in);\n        bin.mark(512);\n        // Read the data using all supported input formats\n        // until we succeed\n        final ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n        IOException formatException = null;\n        for (InputFormat format : drawing.getInputFormats()) {\n          try {\n            bin.reset();\n          } catch (IOException e) {\n            uc = url.openConnection();\n            in = uc.getInputStream();\n            in = new BoundedRangeInputStream(in);\n            ((BoundedRangeInputStream) in).setMaximum(contentLength + 1);\n            progress.setProgressModel((BoundedRangeModel) in);\n            bin = new BufferedInputStream(in);\n            bin.mark(512);\n          }\n          try {\n            bin.reset();\n            format.read(bin, drawing, true);\n            formatException = null;\n            break;\n          } catch (IOException e) {\n            formatException = e;\n          }\n        }\n        if (formatException != null) {\n          throw formatException;\n        }\n      } finally {\n        in.close();\n      }\n    }\n    return drawing;\n"
2693,createDrawingComponent,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,283,288,3,/**\n   * Creates the drawing component.\n   */,5,  protected SVGDrawingPanel createDrawingComponent() {\n    SVGDrawingPanel p = new SVGDrawingPanel();\n    DefaultDrawingEditor editor = new DefaultDrawingEditor();\n    p.setEditor(new DefaultDrawingEditor());\n    return p;\n
2694,getVersion,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,226,247,3,/**\n   * Gets the version of the applet.\n   */,22,"  public String getVersion() {\n    if (version == null) {\n      BufferedReader r = null;\n      try {\n        InputStream resource = SVGApplet.class.getResourceAsStream(""version.txt"");\n        r = new BufferedReader(new InputStreamReader(resource, ""UTF-8""));\n        version = r.readLine();\n      } catch (IOException e) {\n        version = ""unknown"";\n      } catch (NullPointerException e) {\n        version = ""unknown"";\n      } finally {\n        if (r != null) {\n          try {\n            r.close();\n          } catch (IOException e) {\n            // suppress\n          }\n        }\n      }\n    }\n    return version;\n"
2695,close,SVGApplet,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplet.java,377,391,4,/**\n   * Closes the applet. This method can be implemented by invoking\n   * <code>getAppletContext().showDocument(...)</code>.\n   */,14,"  protected void close() {\n    AppletContext appletContext;\n    try {\n      appletContext = getAppletContext();\n    } catch (Throwable e) {\n      appletContext = null;\n    }\n    if (appletContext == null) {\n      System.exit(0);\n    } else {\n      try {\n        appletContext.showDocument(new URL(getDocumentBase(), getParameter(""PageURL"")));\n      } catch (MalformedURLException ex) {\n        ex.printStackTrace();\n"
2697,SVGCreateFromFileTool,SVGCreateFromFileTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGCreateFromFileTool.java,62,65,1,/** Creates a new instance. */,4,"  public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype, Map<AttributeKey, Object> attributes) {\n    super(imagePrototype, attributes);\n    this.groupPrototype = groupPrototype;\n    this.imagePrototype = imagePrototype;\n"
2698,SVGCreateFromFileTool,SVGCreateFromFileTool,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGCreateFromFileTool.java,55,58,1,/** Creates a new instance. */,4,"  public SVGCreateFromFileTool(ImageHolderFigure imagePrototype, CompositeFigure groupPrototype) {\n    super(imagePrototype);\n    this.groupPrototype = groupPrototype;\n    this.imagePrototype = imagePrototype;\n"
2699,SVGApplicationModel,SVGApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplicationModel.java,56,57,1,/** Creates a new instance. */,2,"  public SVGApplicationModel() {\n    gridConstrainer = new GridConstrainer(12, 12);\n"
2700,createToolBars,SVGApplicationModel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGApplicationModel.java,175,178,7,/**\n   * Overriden to create no toolbars.\n   * \n   * @param app\n   * @param p\n   * @return An empty list.\n   */,4,"  @Override\n  public List<JToolBar> createToolBars(Application app, View p) {\n    LinkedList<JToolBar> list = new LinkedList<JToolBar>();\n    return list;\n"
2702,main,Main,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/Main.java,28,49,1,/** Creates a new instance. */,21,"  public static void main(String[] args) {\n    // Debug resource bundle\n    ResourceBundleUtil.setVerbose(true);\n    Application app;\n    String os = System.getProperty(""os.name"").toLowerCase();\n    if (os.startsWith(""mac"")) {\n      app = new OSXApplication();\n    } else if (os.startsWith(""win"")) {\n      //  app = new DefaultMDIApplication();\n      app = new SDIApplication();\n    } else {\n      app = new SDIApplication();\n    }\n    SVGApplicationModel model = new SVGApplicationModel();\n    model.setName(""JHotDraw SVG"");\n    model.setVersion(Main.class.getPackage().getImplementationVersion());\n    model.setCopyright(""Copyright 2006-2010 (c) by the authors of JHotDraw.\\n"" +\n        ""This software is licensed under LGPL and Creative Commons 3.0 Attribution."");\n    model.setViewClassName(""org.jhotdraw.samples.svg.SVGView"");\n    app.setModel(model);\n    app.launch(args);\n"
2703,ConvexHullOutlineHandle,ConvexHullOutlineHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java,55,88,5,/**\n   * Creates a bounds outline handle for resizing or transforming a component.\n   * \n   * @param owner\n   */,34,"  public ConvexHullOutlineHandle(SVGPathFigure owner, boolean isTransformHandle, boolean isHoverHandle) {\n    super(owner);\n    if (isTransformHandle) {\n      if (isHoverHandle) {\n        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_HOVER;\n        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_HOVER;\n        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_HOVER;\n        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_HOVER;\n      } else {\n        stroke1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1;\n        strokeColor1Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1;\n        stroke2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2;\n        strokeColor2Enabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2;\n      }\n      stroke1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_1_DISABLED;\n      strokeColor1Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_1_DISABLED;\n      stroke2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_STROKE_2_DISABLED;\n      strokeColor2Disabled = HandleAttributeKeys.TRANSFORM_BOUNDS_COLOR_2_DISABLED;\n    } else {\n      if (isHoverHandle) {\n        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_HOVER;\n        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_HOVER;\n        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_HOVER;\n        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_HOVER;\n      } else {\n        stroke1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1;\n        strokeColor1Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1;\n        stroke2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2;\n        strokeColor2Enabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2;\n      }\n      stroke1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_1_DISABLED;\n      strokeColor1Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_1_DISABLED;\n      stroke2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_STROKE_2_DISABLED;\n      strokeColor2Disabled = HandleAttributeKeys.RESIZE_BOUNDS_COLOR_2_DISABLED;\n"
2704,ConvexHullOutlineHandle,ConvexHullOutlineHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java,46,47,5,/**\n   * Creates a bounds outline handle for resizing a component.\n   * \n   * @param owner\n   */,2,"  public ConvexHullOutlineHandle(SVGPathFigure owner) {\n    this(owner, false, false);\n"
2705,ConvexHullOutlineHandle,ConvexHullOutlineHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/ConvexHullOutlineHandle.java,97,111,5,/**\n   * Creates a bounds outline handle for resizing or transforming a component.\n   *\n   * @param owner\n   */,15,"  public ConvexHullOutlineHandle(SVGPathFigure owner, //\n      AttributeKey<Stroke> stroke1Enabled, AttributeKey<Color> strokeColor1Enabled,//\n      AttributeKey<Stroke> stroke2Enabled, AttributeKey<Color> strokeColor2Enabled,//\n      AttributeKey<Stroke> stroke1Disabled, AttributeKey<Color> strokeColor1Disabled,//\n      AttributeKey<Stroke> stroke2Disabled, AttributeKey<Color> strokeColor2Disabled\n      ) {\n    super(owner);\n    this.stroke1Enabled = stroke1Enabled;\n    this.strokeColor1Enabled = strokeColor1Enabled;\n    this.stroke2Enabled = stroke2Enabled;\n    this.strokeColor2Enabled = strokeColor2Enabled;\n    this.stroke1Disabled = stroke1Disabled;\n    this.strokeColor1Disabled = strokeColor1Disabled;\n    this.stroke2Disabled = stroke2Disabled;\n    this.strokeColor2Disabled = strokeColor2Disabled;\n"
2706,LinkHandle,LinkHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/LinkHandle.java,34,35,1,/** Creates a new instance. */,2,  public LinkHandle(Figure owner) {\n    super(owner);\n
2707,draw,LinkHandle,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/LinkHandle.java,46,56,3,/**\n   * Draws this handle.\n   */,11,"  @Override public void draw(Graphics2D g) {\n    Figure o = getOwner();\n    if (o.get(LINK)!=null&&o.get(LINK).trim().length()>0) {\n      g.setColor((Color) getEditor().getHandleAttribute(HandleAttributeKeys.OVERFLOW_HANDLE_STROKE_COLOR));\n      Rectangle r = basicGetBounds();\n      g.drawLine(r.x+(r.width/2)-1, r.y, r.x, r.y);\n      g.drawLine(r.x, r.y, r.x, r.y+r.height-1);\n      g.drawLine(r.x, r.y+r.height-1, r.x+(r.width/2)-1, r.y+r.height-1);\n      g.drawLine(r.x+(r.width/3), r.y+r.height/2, r.x+r.width-1, r.y+r.height/2);\n      g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.25));\n      g.drawLine(r.x+r.width-1, r.y+r.height/2, (int)(r.x+r.width*.75-1), (int)(r.y+r.height*.75));\n"
2709,getDefaultEventIndex,SVGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java,150,151,7,"/**\n   * A bean may have a ""default"" event that is the event that will\n   * mostly commonly be used by human\'s when using the bean.\n   * @return Index of default event in the EventSetDescriptor array\n   *    returned by getEventSetDescriptors.\n   * <P>  Returns -1 if there is no default event.\n   */",2,  public int getDefaultEventIndex() {\n    return defaultEventIndex;\n
2712,getDefaultPropertyIndex,SVGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java,139,140,8,"/**\n   * A bean may have a ""default"" property that is the property that will\n   * mostly commonly be initially chosen for update by human\'s who are\n   * customizing the bean.\n   * @return  Index of default property in the PropertyDescriptor array\n   *     returned by getPropertyDescriptors.\n   * <P>  Returns -1 if there is no default property.\n   */",2,  public int getDefaultPropertyIndex() {\n    return defaultPropertyIndex;\n
2713,getEventSetDescriptors,SVGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java,116,117,7,/**\n   * Gets the bean's <code>EventSetDescriptor</code>s.\n   *\n   * @return  An array of EventSetDescriptors describing the kinds of\n   * events fired by this bean.  May return null if the information\n   * should be obtained by automatic analysis.\n   */,2,  public EventSetDescriptor[] getEventSetDescriptors() {\n    return getEdescriptor();\n
2714,getPropertyDescriptors,SVGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java,105,106,12,"/**\n   * Gets the bean\'s <code>PropertyDescriptor</code>s.\n   *\n   * @return An array of PropertyDescriptors describing the editable\n   * properties supported by this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   * <p>\n   * If a property is indexed, then its entry in the result array will\n   * belong to the IndexedPropertyDescriptor subclass of PropertyDescriptor.\n   * A client of getPropertyDescriptors can use ""instanceof"" to check\n   * if a given PropertyDescriptor is an IndexedPropertyDescriptor.\n   */",2,  public PropertyDescriptor[] getPropertyDescriptors() {\n    return getPdescriptor();\n
2715,getBeanDescriptor,SVGDrawingPanelBeanInfo,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanelBeanInfo.java,89,90,7,/**\n   * Gets the bean's <code>BeanDescriptor</code>s.\n   *\n   * @return BeanDescriptor describing the editable\n   * properties of this bean.  May return null if the\n   * information should be obtained by automatic analysis.\n   */,2,  public BeanDescriptor getBeanDescriptor() {\n    return getBdescriptor();\n
2717,ViewSourceAction,ViewSourceAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/action/ViewSourceAction.java,49,52,1,/** Creates a new instance. */,4,"  public ViewSourceAction(Application app, View view) {\n    super(app, view);\n    ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    labels.configureAction(this, ID);\n"
2718,read,SVGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java,329,360,8,"/**\n   * Reads a drawing from the specified file into the SVGDrawingPanel using\n   * the specified input format.\n   * <p>\n   * This method should be called from a worker thread.\n   * Calling it from the Event Dispatcher Thread will block the user\n   * interface, until the drawing is read.\n   */",29,"  public void read(File f, InputFormat format) throws IOException {\n    if (format == null) {\n      read(f);\n      return;\n    }\n    // Create a new drawing object\n    Drawing newDrawing = createDrawing();\n    if (newDrawing.getInputFormats().size() == 0) {\n      throw new InternalError(""Drawing object has no input formats."");\n    }\n    format.read(f, newDrawing);\n    final Drawing loadedDrawing = newDrawing;\n    Runnable r = new Runnable() {\n      public void run() {\n        // Set the drawing on the Event Dispatcher Thread\n        setDrawing(loadedDrawing);\n      }\n    };\n    if (SwingUtilities.isEventDispatchThread()) {\n      r.run();\n    } else {\n      try {\n        SwingUtilities.invokeAndWait(r);\n      } catch (InterruptedException ex) {\n        // suppress silently\n      } catch (InvocationTargetException ex) {\n        InternalError ie = new InternalError(""Error setting drawing."");\n        ie.initCause(ex);\n        throw ie;\n"
2719,write,SVGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java,372,415,7,"/**\n   * Writes the drawing from the SVGDrawingPanel into a file.\n   * <p>\n   * This method should be called from a worker thread.\n   * Calling it from the Event Dispatcher Thread will block the user\n   * interface, until the drawing is written.\n   */",38,"  public void write(File f) throws IOException {\n    // Defensively clone the drawing object, so that we are not\n    // affected by changes of the drawing while we write it into the file.\n    final Drawing[] helper = new Drawing[1];\n    Runnable r = new Runnable() {\n      public void run() {\n        helper[0] = (Drawing) getDrawing().clone();\n      }\n    };\n    if (SwingUtilities.isEventDispatchThread()) {\n      r.run();\n    } else {\n      try {\n        SwingUtilities.invokeAndWait(r);\n      } catch (InterruptedException ex) {\n        // suppress silently\n      } catch (InvocationTargetException ex) {\n        InternalError ie = new InternalError(""Error getting drawing."");\n        ie.initCause(ex);\n        throw ie;\n      }\n    }\n    Drawing saveDrawing = helper[0];\n    if (saveDrawing.getOutputFormats().size() == 0) {\n      throw new InternalError(""Drawing object has no output formats."");\n    }\n    // Try out all output formats until we find one which accepts the\n    // filename entered by the user.\n    for (OutputFormat format : saveDrawing.getOutputFormats()) {\n      if (format.getFileFilter().accept(f)) {\n        format.write(f, saveDrawing);\n        // We get here if writing was successful.\n        // We can return since we are done.\n        return;\n      }\n\n    }\n    throw new IOException(""No output format for "" + f.getName());\n"
2720,read,SVGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java,272,318,7,"/**\n   * Reads a drawing from the specified file into the SVGDrawingPanel.\n   * <p>\n   * This method should be called from a worker thread.\n   * Calling it from the Event Dispatcher Thread will block the user\n   * interface, until the drawing is read.\n   */",45,"  public void read(File f) throws IOException {\n    // Create a new drawing object\n    Drawing newDrawing = createDrawing();\n    if (newDrawing.getInputFormats().size() == 0) {\n      throw new InternalError(""Drawing object has no input formats."");\n    }\n    // Try out all input formats until we succeed\n    IOException firstIOException = null;\n    for (InputFormat format : newDrawing.getInputFormats()) {\n      try {\n        format.read(f, newDrawing);\n        final Drawing loadedDrawing = newDrawing;\n        Runnable r = new Runnable() {\n          public void run() {\n            // Set the drawing on the Event Dispatcher Thread\n            setDrawing(loadedDrawing);\n          }\n        };\n        if (SwingUtilities.isEventDispatchThread()) {\n          r.run();\n        } else {\n          try {\n            SwingUtilities.invokeAndWait(r);\n          } catch (InterruptedException ex) {\n            // suppress silently\n          } catch (InvocationTargetException ex) {\n            InternalError ie = new InternalError(""Error setting drawing."");\n            ie.initCause(ex);\n            throw ie;\n          }\n        }\n        // We get here if reading was successful.\n        // We can return since we are done.\n        return;\n        //\n      } catch (IOException e) {\n        // We get here if reading failed.\n        // We only preserve the exception of the first input format,\n        // because that\'s the one which is best suited for this drawing.\n        if (firstIOException == null) {\n          firstIOException = e;\n        }\n      }\n    }\n    throw firstIOException;\n"
2721,write,SVGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java,426,458,8,"/**\n   * Writes the drawing from the SVGDrawingPanel into a file using the\n   * specified output format.\n   * <p>\n   * This method should be called from a worker thread.\n   * Calling it from the Event Dispatcher Thread will block the user\n   * interface, until the drawing is written.\n   */",29,"  public void write(File f, OutputFormat format) throws IOException {\n    if (format == null) {\n      write(f);\n      return;\n    }\n    // Defensively clone the drawing object, so that we are not\n    // affected by changes of the drawing while we write it into the file.\n    final Drawing[] helper = new Drawing[1];\n    Runnable r = new Runnable() {\n      public void run() {\n        helper[0] = (Drawing) getDrawing().clone();\n      }\n    };\n    if (SwingUtilities.isEventDispatchThread()) {\n      r.run();\n    } else {\n      try {\n        SwingUtilities.invokeAndWait(r);\n      } catch (InterruptedException ex) {\n        // suppress silently\n      } catch (InvocationTargetException ex) {\n        InternalError ie = new InternalError(""Error getting drawing."");\n        ie.initCause(ex);\n        throw ie;\n      }\n    }\n    // Write drawing to file\n    Drawing saveDrawing = helper[0];\n    format.write(f, saveDrawing);\n"
2723,createDrawing,SVGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java,193,211,4,/**\n   * Creates a new Drawing object which can be used with this\n   * {@code SVGDrawingPanel}.\n   */,18,"  public Drawing createDrawing() {\n    Drawing drawing = new QuadTreeDrawing();\n    LinkedList<InputFormat> inputFormats = new LinkedList<InputFormat>();\n    inputFormats.add(new SVGZInputFormat());\n    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), ""PNG"", ""Portable Network Graphics (PNG)"", ""png"", ""image/png""));\n    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), ""JPG"", ""Joint Photographics Experts Group (JPEG)"", ""jpg"",""image/jpg""));\n    inputFormats.add(new ImageInputFormat(new SVGImageFigure(), ""GIF"", ""Graphics Interchange Format (GIF)"", ""gif"", ""image/gif""));\n    inputFormats.add(new TextInputFormat(new SVGTextFigure()));\n    drawing.setInputFormats(inputFormats);\n    LinkedList<OutputFormat> outputFormats = new LinkedList<OutputFormat>();\n    outputFormats.add(new SVGOutputFormat());\n    outputFormats.add(new SVGZOutputFormat());\n    outputFormats.add(new ImageOutputFormat());\n    outputFormats.add(new ImageOutputFormat(""JPG"", ""Joint Photographics Experts Group (JPEG)"", ""jpg"", BufferedImage.TYPE_INT_RGB));\n    outputFormats.add(new ImageOutputFormat(""BMP"", ""Windows Bitmap (BMP)"", ""bmp"", BufferedImage.TYPE_BYTE_INDEXED));\n    outputFormats.add(new ImageMapOutputFormat());\n    drawing.setOutputFormats(outputFormats);\n    return drawing;\n"
2724,initComponents,SVGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java,467,529,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,52,"  private void initComponents() {\n    java.awt.GridBagConstraints gridBagConstraints;\n    toolButtonGroup = new javax.swing.ButtonGroup();\n    scrollPane = new javax.swing.JScrollPane();\n    view = new org.jhotdraw.draw.DefaultDrawingView();\n    toolsPanel = new javax.swing.JPanel();\n    toolsScrollPane = new javax.swing.JScrollPane();\n    toolsPane = new javax.swing.JPanel();\n    creationToolBar = new org.jhotdraw.samples.svg.gui.ToolsToolBar();\n    actionToolBar = new org.jhotdraw.samples.svg.gui.ActionsToolBar();\n    fillToolBar = new org.jhotdraw.samples.svg.gui.FillToolBar();\n    strokeToolBar = new org.jhotdraw.samples.svg.gui.StrokeToolBar();\n    fontToolBar = new org.jhotdraw.samples.svg.gui.FontToolBar();\n    arrangeToolBar = new org.jhotdraw.samples.svg.gui.ArrangeToolBar();\n    alignToolBar = new org.jhotdraw.samples.svg.gui.AlignToolBar();\n    figureToolBar = new org.jhotdraw.samples.svg.gui.FigureToolBar();\n    linkToolBar = new org.jhotdraw.samples.svg.gui.LinkToolBar();\n    canvasToolBar = new org.jhotdraw.samples.svg.gui.CanvasToolBar();\n    viewToolBar = new org.jhotdraw.samples.svg.gui.ViewToolBar();\n    setBackground(new java.awt.Color(255, 255, 255));\n    setLayout(new java.awt.BorderLayout());\n    scrollPane.setBorder(null);\n    scrollPane.setViewportView(view);\n    add(scrollPane, java.awt.BorderLayout.CENTER);\n    toolsPanel.setBackground(new java.awt.Color(255, 255, 255));\n    toolsPanel.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));\n    toolsPanel.setOpaque(true);\n    toolsPanel.setLayout(new java.awt.GridBagLayout());\n    toolsScrollPane.setBorder(PaletteLookAndFeel.getInstance().getBorder(""Ribbon.border""));\n    toolsScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);\n    toolsScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);\n    toolsScrollPane.setMinimumSize(new java.awt.Dimension(0, 0));\n    toolsPane.setForeground(new java.awt.Color(153, 153, 153));\n    toolsPane.add(creationToolBar);\n    toolsPane.add(actionToolBar);\n    toolsPane.add(fillToolBar);\n    strokeToolBar.setMargin(new java.awt.Insets(0, 10, 0, 0));\n    toolsPane.add(strokeToolBar);\n    toolsPane.add(fontToolBar);\n    toolsPane.add(arrangeToolBar);\n    toolsPane.add(alignToolBar);\n    toolsPane.add(figureToolBar);\n    toolsPane.add(linkToolBar);\n    toolsPane.add(canvasToolBar);\n    toolsPane.add(viewToolBar);\n    toolsScrollPane.setViewportView(toolsPane);\n    gridBagConstraints = new java.awt.GridBagConstraints();\n    gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;\n    gridBagConstraints.weightx = 1.0;\n    gridBagConstraints.weighty = 1.0;\n    toolsPanel.add(toolsScrollPane, gridBagConstraints);\n    add(toolsPanel, java.awt.BorderLayout.SOUTH);\n"
2725,SVGDrawingPanel,SVGDrawingPanel,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGDrawingPanel.java,94,164,1,/** Creates new instance. */,59,"  public SVGDrawingPanel() {\n    labels = ResourceBundleUtil.getBundle(""org.jhotdraw.samples.svg.Labels"");\n    ResourceBundleUtil drawLabels = ResourceBundleUtil.getBundle(""org.jhotdraw.draw.Labels"");\n    try {\n      prefs = PreferencesUtil.userNodeForPackage(getClass());\n    } catch (SecurityException e) {\n      // prefs is null, because we are not permitted to read preferences\n    }\n    \n    initComponents();\n    toolsPane.setLayout(new ToolBarLayout());\n    toolsPane.setBackground(new Color(0xf0f0f0));\n    toolsPane.setOpaque(true);\n    viewToolBar.setView(view);\n    undoManager = new UndoRedoManager();\n    Drawing drawing = createDrawing();\n    view.setDrawing(drawing);\n    drawing.addUndoableEditListener(undoManager);\n    // Try to install the DnDDrawingViewTransferHandler\n    // Since this class only works on J2SE 6, we have to use reflection.\n    try {\n      view.setTransferHandler((TransferHandler) Class.forName(""org.jhotdraw.draw.DnDDrawingViewTransferHandler"").newInstance());\n    } catch (Exception e) {\n      // bail silently\n    }\n    // Sort the toolbars according to the user preferences\n    ArrayList<JToolBar> sortme = new ArrayList<JToolBar>();\n    for (Component c : toolsPane.getComponents()) {\n      if (c instanceof JToolBar) {\n        sortme.add((JToolBar) c);\n      }\n    }\n    Collections.sort(sortme, new Comparator<JToolBar>() {\n      public int compare(JToolBar tb1, JToolBar tb2) {\n        int i1 = prefs.getInt(""toolBarIndex."" + tb1.getName(), 0);\n        int i2 = prefs.getInt(""toolBarIndex."" + tb2.getName(), 0);\n        return i1 - i2;\n      }\n    });\n    toolsPane.removeAll();\n    for (JToolBar tb : sortme) {\n      toolsPane.add(tb);\n    }\n    toolsPane.addContainerListener(containerHandler = new ContainerListener() {\n      public void componentAdded(ContainerEvent e) {\n        int i = 0;\n        for (Component c : toolsPane.getComponents()) {\n          if (c instanceof JToolBar) {\n            JToolBar tb = (JToolBar) c;\n            prefs.putInt(""toolBarIndex."" + tb.getName(), i);\n            i++;\n          }\n        }\n      }\n      public void componentRemoved(ContainerEvent e) {\n      }\n    });\n\n    setEditor(new DefaultDrawingEditor());\n"
2726,CombineAction,CombineAction,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/action/CombineAction.java,45,46,1,/** Creates a new instance. */,2,"  public CombineAction(DrawingEditor editor) {\n    this(editor, new SVGPathFigure(true), true);\n"
2727,SVGBezierFigure,SVGBezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java,42,43,1,/** Creates a new instance. */,2,  public SVGBezierFigure() {\n    this(false);\n
2728,findSegment,SVGBezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java,157,168,5,/**\n   * Gets the segment of the polyline that is hit by\n   * the given Point2D.Double.\n   * @return the index of the segment or -1 if no segment was hit.\n   */,11,"  @Override\n  public int findSegment(Point2D.Double find, double tolerance) {\n    // Apply inverse of transform to point\n    if (get(TRANSFORM) != null) {\n      try {\n        find = (Point2D.Double) get(TRANSFORM).inverseTransform(find, new Point2D.Double());\n      } catch (NoninvertibleTransformException ex) {\n        System.err.println(""Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform."");\n      }\n    }\n    return getBezierPath().findSegment(find, tolerance);\n"
2729,joinSegments,SVGBezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java,180,197,9,"/**\n   * Joins two segments into one if the given Point2D.Double hits a node\n   * of the polyline.\n   * @return true if the two segments were joined.\n   *\n   * @param join a Point at a node on the bezier path\n   * @param tolerance a tolerance, tolerance should take into account\n   * the line width, plus 2 divided by the zoom factor. \n   */",16,"  @Override\n  public boolean joinSegments(Point2D.Double join, double tolerance) {\n    // Apply inverse of transform to point\n    if (get(TRANSFORM) != null) {\n      try {\n        join = (Point2D.Double) get(TRANSFORM).inverseTransform(join, new Point2D.Double());\n      } catch (NoninvertibleTransformException ex) {\n        System.err.println(""Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform."");\n      }\n    }\n    int i = getBezierPath().findSegment(join, tolerance);\n    if (i != -1 && i > 1) {\n      removeNode(i);\n      return true;\n    }\n    return false;\n"
2730,splitSegment,SVGBezierFigure,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/figures/SVGBezierFigure.java,208,224,8,"/**\n   * Splits the segment at the given Point2D.Double if a segment was hit.\n   * @return the index of the segment or -1 if no segment was hit.\n   *\n   * @param split a Point on (or near) a segment of the bezier path\n   * @param tolerance a tolerance, tolerance should take into account\n   * the line width, plus 2 divided by the zoom factor. \n   */",15,"  @Override\n  public int splitSegment(Point2D.Double split, double tolerance) {\n    // Apply inverse of transform to point\n    if (get(TRANSFORM) != null) {\n      try {\n        split = (Point2D.Double) get(TRANSFORM).inverseTransform(split, new Point2D.Double());\n      } catch (NoninvertibleTransformException ex) {\n        System.err.println(""Warning: SVGBezierFigure.findSegment. Figure has noninvertible Transform."");\n      }\n    }\n    int i = getBezierPath().findSegment(split, tolerance);\n    if (i != -1) {\n      addNode(i + 1, new BezierPath.Node(split));\n    }\n    return i + 1;\n"
2731,createDrawing,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,106,107,3,/**\n   * Creates a new Drawing for this View.\n   */,2,  protected Drawing createDrawing() {\n    return svgPanel.createDrawing();\n
2733,createPageable,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,113,114,3,/**\n   * Creates a Pageable object for printing the View.\n   */,2,  public Pageable createPageable() {\n    return new DrawingPageable(svgPanel.getDrawing());\n
2734,read,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,150,204,3,/**\n   * Reads the view from the specified uri.\n   */,52,"  public void read(final URI uri, URIChooser chooser) throws IOException {\n    try {\n      JFileURIChooser fc = (JFileURIChooser) chooser;\n      final Drawing drawing = createDrawing();\n      // We start with the selected uri format in the uri chooser,\n      // and then try out all formats we can import.\n      // We need to try out all formats, because the user may have\n      // chosen to load a uri without having used the uri chooser.\n      InputFormat selectedFormat = fileFilterInputFormatMap.get(fc.getFileFilter());\n      boolean success = false;\n      if (selectedFormat != null) {\n        try {\n          selectedFormat.read(new File(uri), drawing, true);\n          success = true;\n        } catch (Exception e) {\n          e.printStackTrace();\n          // try with the next input format\n        }\n      }\n      if (!success) {\n        for (InputFormat sfi : drawing.getInputFormats()) {\n          if (sfi != selectedFormat) {\n            try {\n              sfi.read(new File(uri), drawing, true);\n              success = true;\n              break;\n            } catch (Exception e) {\n              // try with the next input format\n            }\n          }\n        }\n      }\n      if (!success) {\n        ResourceBundleUtil labels = ResourceBundleUtil.getBundle(""org.jhotdraw.app.Labels"");\n        throw new IOException(labels.getFormatted(""file.open.unsupportedFileFormat.message"", URIUtil.getName(uri)));\n      }\n      SwingUtilities.invokeAndWait(new Runnable() {\n        public void run() {\n          Drawing oldDrawing = svgPanel.getDrawing();\n          svgPanel.setDrawing(drawing);\n          firePropertyChange(DRAWING_PROPERTY, oldDrawing, svgPanel.getDrawing());\n          undo.discardAllEdits();\n        }\n      });\n    } catch (InterruptedException e) {\n      InternalError error = new InternalError();\n      e.initCause(e);\n      throw error;\n    } catch (InvocationTargetException e) {\n      InternalError error = new InternalError();\n      error.initCause(e);\n      throw error;\n"
2735,init,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,70,87,3,/**\n   * Initializes the View.\n   */,14,"  @Override\n  public void init() {\n    super.init();\n    initComponents();\n    JPanel zoomButtonPanel = new JPanel(new BorderLayout());\n    undo = svgPanel.getUndoRedoManager();\n    Drawing oldDrawing = svgPanel.getDrawing();\n    svgPanel.setDrawing(createDrawing());\n    firePropertyChange(DRAWING_PROPERTY, oldDrawing, svgPanel.getDrawing());\n    svgPanel.getDrawing().addUndoableEditListener(undo);\n    initActions();\n    undo.addPropertyChangeListener(propertyHandler = new PropertyChangeListener() {\n      public void propertyChange(PropertyChangeEvent evt) {\n        setHasUnsavedChanges(undo.hasSignificantEdits());\n"
2736,initComponents,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,260,265,5,/** This method is called from within the constructor to\n   * initialize the form.\n   * WARNING: Do NOT modify this code. The content of this method is\n   * always regenerated by the Form Editor.\n   */,4,"  private void initComponents() {\n    svgPanel = new org.jhotdraw.samples.svg.SVGDrawingPanel();\n    setLayout(new java.awt.BorderLayout());\n    add(svgPanel, java.awt.BorderLayout.CENTER);\n"
2737,initActions,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,129,131,3,/**\n   * Initializes view specific actions.\n   */,3,"  private void initActions() {\n    getActionMap().put(UndoAction.ID, undo.getUndoAction());\n    getActionMap().put(RedoAction.ID, undo.getRedoAction());\n"
2738,clear,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,220,243,3,/**\n   * Clears the view.\n   */,23,"  public void clear() {\n    final Drawing newDrawing = createDrawing();\n    try {\n      Runnable r = new Runnable() {\n        public void run() {\n          Drawing oldDrawing = svgPanel.getDrawing();\n          svgPanel.setDrawing(newDrawing);\n          firePropertyChange(DRAWING_PROPERTY, oldDrawing, newDrawing);\n          if (oldDrawing != null) {\n            oldDrawing.removeAllChildren();\n          }\n          undo.discardAllEdits();\n        }\n      };\n      if (SwingUtilities.isEventDispatchThread()) {\n        r.run();\n      } else {\n        SwingUtilities.invokeAndWait(r);\n      }\n    } catch (InvocationTargetException ex) {\n      ex.printStackTrace();\n    } catch (InterruptedException ex) {\n      ex.printStackTrace();\n"
2739,write,SVGView,JHotDraw741,jhotdraw7/src/main/java/org/jhotdraw/samples/svg/SVGView.java,143,144,3,/**\n   * Writes the view to the specified uri.\n   */,2,"  public void write(URI uri, URIChooser chooser) throws IOException {\n    new SVGOutputFormat().write(new File(uri), svgPanel.getDrawing());\n"
